
firmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .legacy_isr_vector 00000008  0803fff8  0803fff8  0001fff8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000128e4  08080000  08080000  00020000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000074a8  08092900  08092900  00032900  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM          00000008  08099da8  08099da8  00039da8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .init_array   00000004  08099db0  08099db0  00039db0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .fini_array   00000004  08099db4  08099db4  00039db4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .data         000003dc  2000b000  08099db8  0003b000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00024118  2000b3e0  0809a194  0003b3e0  2**5
                  ALLOC
  9 ._user_heap_stack 00000500  2002f4f8  0809a194  0003f4f8  2**0
                  ALLOC
 10 .memory_sram_text 00000000  c007f800  c007f800  0003b3dc  2**0
                  CONTENTS
 11 ._lcd_framebuffer_background 00000000  c003fc00  c003fc00  0003b3dc  2**0
                  CONTENTS
 12 ._lcd_framebuffer_foreground 00000000  c0000000  c0000000  0003b3dc  2**0
                  CONTENTS
 13 .bss_vector   00000000  20001400  20001400  0003b3dc  2**0
                  CONTENTS
 14 ._legacy_sram 00000000  c007f800  c007f800  0003b3dc  2**0
                  CONTENTS
 15 ._dynamic_sram 00000000  c0300000  c0300000  0003b3dc  2**0
                  CONTENTS
 16 ._shared_data_area 00000000  20001600  20001600  0003b3dc  2**0
                  CONTENTS
 17 .ARM.attributes 00000030  00000000  00000000  0003b3dc  2**0
                  CONTENTS, READONLY
 18 .debug_info   00085ab1  00000000  00000000  0003b40c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 0000d7c0  00000000  00000000  000c0ebd  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_loc    0003f04c  00000000  00000000  000ce67d  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_aranges 00003178  00000000  00000000  0010d6d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 00007fe8  00000000  00000000  00110848  2**3
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_macro  0003b672  00000000  00000000  00118830  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_line   00044223  00000000  00000000  00153ea2  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    0011cbdb  00000000  00000000  001980c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .comment      0000007b  00000000  00000000  002b4ca0  2**0
                  CONTENTS, READONLY
 27 .debug_frame  0000b500  00000000  00000000  002b4d1c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08080000 <__do_global_dtors_aux>:
 8080000:	b510      	push	{r4, lr}
 8080002:	4c05      	ldr	r4, [pc, #20]	; (8080018 <__do_global_dtors_aux+0x18>)
 8080004:	7823      	ldrb	r3, [r4, #0]
 8080006:	b933      	cbnz	r3, 8080016 <__do_global_dtors_aux+0x16>
 8080008:	4b04      	ldr	r3, [pc, #16]	; (808001c <__do_global_dtors_aux+0x1c>)
 808000a:	b113      	cbz	r3, 8080012 <__do_global_dtors_aux+0x12>
 808000c:	4804      	ldr	r0, [pc, #16]	; (8080020 <__do_global_dtors_aux+0x20>)
 808000e:	f3af 8000 	nop.w
 8080012:	2301      	movs	r3, #1
 8080014:	7023      	strb	r3, [r4, #0]
 8080016:	bd10      	pop	{r4, pc}
 8080018:	2000b3e0 	.word	0x2000b3e0
 808001c:	00000000 	.word	0x00000000
 8080020:	080928cc 	.word	0x080928cc

08080024 <frame_dummy>:
 8080024:	b508      	push	{r3, lr}
 8080026:	4b03      	ldr	r3, [pc, #12]	; (8080034 <frame_dummy+0x10>)
 8080028:	b11b      	cbz	r3, 8080032 <frame_dummy+0xe>
 808002a:	4903      	ldr	r1, [pc, #12]	; (8080038 <frame_dummy+0x14>)
 808002c:	4803      	ldr	r0, [pc, #12]	; (808003c <frame_dummy+0x18>)
 808002e:	f3af 8000 	nop.w
 8080032:	bd08      	pop	{r3, pc}
 8080034:	00000000 	.word	0x00000000
 8080038:	2000b3e4 	.word	0x2000b3e4
 808003c:	080928cc 	.word	0x080928cc

08080040 <strlen>:
 8080040:	4603      	mov	r3, r0
 8080042:	f813 2b01 	ldrb.w	r2, [r3], #1
 8080046:	2a00      	cmp	r2, #0
 8080048:	d1fb      	bne.n	8080042 <strlen+0x2>
 808004a:	1a18      	subs	r0, r3, r0
 808004c:	3801      	subs	r0, #1
 808004e:	4770      	bx	lr

08080050 <memchr>:
 8080050:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8080054:	2a10      	cmp	r2, #16
 8080056:	db2b      	blt.n	80800b0 <memchr+0x60>
 8080058:	f010 0f07 	tst.w	r0, #7
 808005c:	d008      	beq.n	8080070 <memchr+0x20>
 808005e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8080062:	3a01      	subs	r2, #1
 8080064:	428b      	cmp	r3, r1
 8080066:	d02d      	beq.n	80800c4 <memchr+0x74>
 8080068:	f010 0f07 	tst.w	r0, #7
 808006c:	b342      	cbz	r2, 80800c0 <memchr+0x70>
 808006e:	d1f6      	bne.n	808005e <memchr+0xe>
 8080070:	b4f0      	push	{r4, r5, r6, r7}
 8080072:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8080076:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 808007a:	f022 0407 	bic.w	r4, r2, #7
 808007e:	f07f 0700 	mvns.w	r7, #0
 8080082:	2300      	movs	r3, #0
 8080084:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8080088:	3c08      	subs	r4, #8
 808008a:	ea85 0501 	eor.w	r5, r5, r1
 808008e:	ea86 0601 	eor.w	r6, r6, r1
 8080092:	fa85 f547 	uadd8	r5, r5, r7
 8080096:	faa3 f587 	sel	r5, r3, r7
 808009a:	fa86 f647 	uadd8	r6, r6, r7
 808009e:	faa5 f687 	sel	r6, r5, r7
 80800a2:	b98e      	cbnz	r6, 80800c8 <memchr+0x78>
 80800a4:	d1ee      	bne.n	8080084 <memchr+0x34>
 80800a6:	bcf0      	pop	{r4, r5, r6, r7}
 80800a8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80800ac:	f002 0207 	and.w	r2, r2, #7
 80800b0:	b132      	cbz	r2, 80800c0 <memchr+0x70>
 80800b2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80800b6:	3a01      	subs	r2, #1
 80800b8:	ea83 0301 	eor.w	r3, r3, r1
 80800bc:	b113      	cbz	r3, 80800c4 <memchr+0x74>
 80800be:	d1f8      	bne.n	80800b2 <memchr+0x62>
 80800c0:	2000      	movs	r0, #0
 80800c2:	4770      	bx	lr
 80800c4:	3801      	subs	r0, #1
 80800c6:	4770      	bx	lr
 80800c8:	2d00      	cmp	r5, #0
 80800ca:	bf06      	itte	eq
 80800cc:	4635      	moveq	r5, r6
 80800ce:	3803      	subeq	r0, #3
 80800d0:	3807      	subne	r0, #7
 80800d2:	f015 0f01 	tst.w	r5, #1
 80800d6:	d107      	bne.n	80800e8 <memchr+0x98>
 80800d8:	3001      	adds	r0, #1
 80800da:	f415 7f80 	tst.w	r5, #256	; 0x100
 80800de:	bf02      	ittt	eq
 80800e0:	3001      	addeq	r0, #1
 80800e2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80800e6:	3001      	addeq	r0, #1
 80800e8:	bcf0      	pop	{r4, r5, r6, r7}
 80800ea:	3801      	subs	r0, #1
 80800ec:	4770      	bx	lr
 80800ee:	bf00      	nop

080800f0 <__aeabi_ldivmod>:
 80800f0:	b97b      	cbnz	r3, 8080112 <__aeabi_ldivmod+0x22>
 80800f2:	b972      	cbnz	r2, 8080112 <__aeabi_ldivmod+0x22>
 80800f4:	2900      	cmp	r1, #0
 80800f6:	bfbe      	ittt	lt
 80800f8:	2000      	movlt	r0, #0
 80800fa:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 80800fe:	e006      	blt.n	808010e <__aeabi_ldivmod+0x1e>
 8080100:	bf08      	it	eq
 8080102:	2800      	cmpeq	r0, #0
 8080104:	bf1c      	itt	ne
 8080106:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 808010a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 808010e:	f000 b9bd 	b.w	808048c <__aeabi_idiv0>
 8080112:	f1ad 0c08 	sub.w	ip, sp, #8
 8080116:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 808011a:	2900      	cmp	r1, #0
 808011c:	db09      	blt.n	8080132 <__aeabi_ldivmod+0x42>
 808011e:	2b00      	cmp	r3, #0
 8080120:	db1a      	blt.n	8080158 <__aeabi_ldivmod+0x68>
 8080122:	f000 f84d 	bl	80801c0 <__udivmoddi4>
 8080126:	f8dd e004 	ldr.w	lr, [sp, #4]
 808012a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 808012e:	b004      	add	sp, #16
 8080130:	4770      	bx	lr
 8080132:	4240      	negs	r0, r0
 8080134:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8080138:	2b00      	cmp	r3, #0
 808013a:	db1b      	blt.n	8080174 <__aeabi_ldivmod+0x84>
 808013c:	f000 f840 	bl	80801c0 <__udivmoddi4>
 8080140:	f8dd e004 	ldr.w	lr, [sp, #4]
 8080144:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8080148:	b004      	add	sp, #16
 808014a:	4240      	negs	r0, r0
 808014c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8080150:	4252      	negs	r2, r2
 8080152:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8080156:	4770      	bx	lr
 8080158:	4252      	negs	r2, r2
 808015a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 808015e:	f000 f82f 	bl	80801c0 <__udivmoddi4>
 8080162:	f8dd e004 	ldr.w	lr, [sp, #4]
 8080166:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 808016a:	b004      	add	sp, #16
 808016c:	4240      	negs	r0, r0
 808016e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8080172:	4770      	bx	lr
 8080174:	4252      	negs	r2, r2
 8080176:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 808017a:	f000 f821 	bl	80801c0 <__udivmoddi4>
 808017e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8080182:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8080186:	b004      	add	sp, #16
 8080188:	4252      	negs	r2, r2
 808018a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 808018e:	4770      	bx	lr

08080190 <__aeabi_uldivmod>:
 8080190:	b953      	cbnz	r3, 80801a8 <__aeabi_uldivmod+0x18>
 8080192:	b94a      	cbnz	r2, 80801a8 <__aeabi_uldivmod+0x18>
 8080194:	2900      	cmp	r1, #0
 8080196:	bf08      	it	eq
 8080198:	2800      	cmpeq	r0, #0
 808019a:	bf1c      	itt	ne
 808019c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80801a0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80801a4:	f000 b972 	b.w	808048c <__aeabi_idiv0>
 80801a8:	f1ad 0c08 	sub.w	ip, sp, #8
 80801ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80801b0:	f000 f806 	bl	80801c0 <__udivmoddi4>
 80801b4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80801b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80801bc:	b004      	add	sp, #16
 80801be:	4770      	bx	lr

080801c0 <__udivmoddi4>:
 80801c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80801c4:	9e08      	ldr	r6, [sp, #32]
 80801c6:	4604      	mov	r4, r0
 80801c8:	4688      	mov	r8, r1
 80801ca:	2b00      	cmp	r3, #0
 80801cc:	d14b      	bne.n	8080266 <__udivmoddi4+0xa6>
 80801ce:	428a      	cmp	r2, r1
 80801d0:	4615      	mov	r5, r2
 80801d2:	d967      	bls.n	80802a4 <__udivmoddi4+0xe4>
 80801d4:	fab2 f282 	clz	r2, r2
 80801d8:	b14a      	cbz	r2, 80801ee <__udivmoddi4+0x2e>
 80801da:	f1c2 0720 	rsb	r7, r2, #32
 80801de:	fa01 f302 	lsl.w	r3, r1, r2
 80801e2:	fa20 f707 	lsr.w	r7, r0, r7
 80801e6:	4095      	lsls	r5, r2
 80801e8:	ea47 0803 	orr.w	r8, r7, r3
 80801ec:	4094      	lsls	r4, r2
 80801ee:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80801f2:	0c23      	lsrs	r3, r4, #16
 80801f4:	fbb8 f7fe 	udiv	r7, r8, lr
 80801f8:	fa1f fc85 	uxth.w	ip, r5
 80801fc:	fb0e 8817 	mls	r8, lr, r7, r8
 8080200:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8080204:	fb07 f10c 	mul.w	r1, r7, ip
 8080208:	4299      	cmp	r1, r3
 808020a:	d909      	bls.n	8080220 <__udivmoddi4+0x60>
 808020c:	18eb      	adds	r3, r5, r3
 808020e:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 8080212:	f080 811b 	bcs.w	808044c <__udivmoddi4+0x28c>
 8080216:	4299      	cmp	r1, r3
 8080218:	f240 8118 	bls.w	808044c <__udivmoddi4+0x28c>
 808021c:	3f02      	subs	r7, #2
 808021e:	442b      	add	r3, r5
 8080220:	1a5b      	subs	r3, r3, r1
 8080222:	b2a4      	uxth	r4, r4
 8080224:	fbb3 f0fe 	udiv	r0, r3, lr
 8080228:	fb0e 3310 	mls	r3, lr, r0, r3
 808022c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8080230:	fb00 fc0c 	mul.w	ip, r0, ip
 8080234:	45a4      	cmp	ip, r4
 8080236:	d909      	bls.n	808024c <__udivmoddi4+0x8c>
 8080238:	192c      	adds	r4, r5, r4
 808023a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 808023e:	f080 8107 	bcs.w	8080450 <__udivmoddi4+0x290>
 8080242:	45a4      	cmp	ip, r4
 8080244:	f240 8104 	bls.w	8080450 <__udivmoddi4+0x290>
 8080248:	3802      	subs	r0, #2
 808024a:	442c      	add	r4, r5
 808024c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8080250:	eba4 040c 	sub.w	r4, r4, ip
 8080254:	2700      	movs	r7, #0
 8080256:	b11e      	cbz	r6, 8080260 <__udivmoddi4+0xa0>
 8080258:	40d4      	lsrs	r4, r2
 808025a:	2300      	movs	r3, #0
 808025c:	e9c6 4300 	strd	r4, r3, [r6]
 8080260:	4639      	mov	r1, r7
 8080262:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8080266:	428b      	cmp	r3, r1
 8080268:	d909      	bls.n	808027e <__udivmoddi4+0xbe>
 808026a:	2e00      	cmp	r6, #0
 808026c:	f000 80eb 	beq.w	8080446 <__udivmoddi4+0x286>
 8080270:	2700      	movs	r7, #0
 8080272:	e9c6 0100 	strd	r0, r1, [r6]
 8080276:	4638      	mov	r0, r7
 8080278:	4639      	mov	r1, r7
 808027a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 808027e:	fab3 f783 	clz	r7, r3
 8080282:	2f00      	cmp	r7, #0
 8080284:	d147      	bne.n	8080316 <__udivmoddi4+0x156>
 8080286:	428b      	cmp	r3, r1
 8080288:	d302      	bcc.n	8080290 <__udivmoddi4+0xd0>
 808028a:	4282      	cmp	r2, r0
 808028c:	f200 80fa 	bhi.w	8080484 <__udivmoddi4+0x2c4>
 8080290:	1a84      	subs	r4, r0, r2
 8080292:	eb61 0303 	sbc.w	r3, r1, r3
 8080296:	2001      	movs	r0, #1
 8080298:	4698      	mov	r8, r3
 808029a:	2e00      	cmp	r6, #0
 808029c:	d0e0      	beq.n	8080260 <__udivmoddi4+0xa0>
 808029e:	e9c6 4800 	strd	r4, r8, [r6]
 80802a2:	e7dd      	b.n	8080260 <__udivmoddi4+0xa0>
 80802a4:	b902      	cbnz	r2, 80802a8 <__udivmoddi4+0xe8>
 80802a6:	deff      	udf	#255	; 0xff
 80802a8:	fab2 f282 	clz	r2, r2
 80802ac:	2a00      	cmp	r2, #0
 80802ae:	f040 808f 	bne.w	80803d0 <__udivmoddi4+0x210>
 80802b2:	1b49      	subs	r1, r1, r5
 80802b4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80802b8:	fa1f f885 	uxth.w	r8, r5
 80802bc:	2701      	movs	r7, #1
 80802be:	fbb1 fcfe 	udiv	ip, r1, lr
 80802c2:	0c23      	lsrs	r3, r4, #16
 80802c4:	fb0e 111c 	mls	r1, lr, ip, r1
 80802c8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80802cc:	fb08 f10c 	mul.w	r1, r8, ip
 80802d0:	4299      	cmp	r1, r3
 80802d2:	d907      	bls.n	80802e4 <__udivmoddi4+0x124>
 80802d4:	18eb      	adds	r3, r5, r3
 80802d6:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 80802da:	d202      	bcs.n	80802e2 <__udivmoddi4+0x122>
 80802dc:	4299      	cmp	r1, r3
 80802de:	f200 80cd 	bhi.w	808047c <__udivmoddi4+0x2bc>
 80802e2:	4684      	mov	ip, r0
 80802e4:	1a59      	subs	r1, r3, r1
 80802e6:	b2a3      	uxth	r3, r4
 80802e8:	fbb1 f0fe 	udiv	r0, r1, lr
 80802ec:	fb0e 1410 	mls	r4, lr, r0, r1
 80802f0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80802f4:	fb08 f800 	mul.w	r8, r8, r0
 80802f8:	45a0      	cmp	r8, r4
 80802fa:	d907      	bls.n	808030c <__udivmoddi4+0x14c>
 80802fc:	192c      	adds	r4, r5, r4
 80802fe:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8080302:	d202      	bcs.n	808030a <__udivmoddi4+0x14a>
 8080304:	45a0      	cmp	r8, r4
 8080306:	f200 80b6 	bhi.w	8080476 <__udivmoddi4+0x2b6>
 808030a:	4618      	mov	r0, r3
 808030c:	eba4 0408 	sub.w	r4, r4, r8
 8080310:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8080314:	e79f      	b.n	8080256 <__udivmoddi4+0x96>
 8080316:	f1c7 0c20 	rsb	ip, r7, #32
 808031a:	40bb      	lsls	r3, r7
 808031c:	fa22 fe0c 	lsr.w	lr, r2, ip
 8080320:	ea4e 0e03 	orr.w	lr, lr, r3
 8080324:	fa01 f407 	lsl.w	r4, r1, r7
 8080328:	fa20 f50c 	lsr.w	r5, r0, ip
 808032c:	fa21 f30c 	lsr.w	r3, r1, ip
 8080330:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8080334:	4325      	orrs	r5, r4
 8080336:	fbb3 f9f8 	udiv	r9, r3, r8
 808033a:	0c2c      	lsrs	r4, r5, #16
 808033c:	fb08 3319 	mls	r3, r8, r9, r3
 8080340:	fa1f fa8e 	uxth.w	sl, lr
 8080344:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8080348:	fb09 f40a 	mul.w	r4, r9, sl
 808034c:	429c      	cmp	r4, r3
 808034e:	fa02 f207 	lsl.w	r2, r2, r7
 8080352:	fa00 f107 	lsl.w	r1, r0, r7
 8080356:	d90b      	bls.n	8080370 <__udivmoddi4+0x1b0>
 8080358:	eb1e 0303 	adds.w	r3, lr, r3
 808035c:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8080360:	f080 8087 	bcs.w	8080472 <__udivmoddi4+0x2b2>
 8080364:	429c      	cmp	r4, r3
 8080366:	f240 8084 	bls.w	8080472 <__udivmoddi4+0x2b2>
 808036a:	f1a9 0902 	sub.w	r9, r9, #2
 808036e:	4473      	add	r3, lr
 8080370:	1b1b      	subs	r3, r3, r4
 8080372:	b2ad      	uxth	r5, r5
 8080374:	fbb3 f0f8 	udiv	r0, r3, r8
 8080378:	fb08 3310 	mls	r3, r8, r0, r3
 808037c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8080380:	fb00 fa0a 	mul.w	sl, r0, sl
 8080384:	45a2      	cmp	sl, r4
 8080386:	d908      	bls.n	808039a <__udivmoddi4+0x1da>
 8080388:	eb1e 0404 	adds.w	r4, lr, r4
 808038c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8080390:	d26b      	bcs.n	808046a <__udivmoddi4+0x2aa>
 8080392:	45a2      	cmp	sl, r4
 8080394:	d969      	bls.n	808046a <__udivmoddi4+0x2aa>
 8080396:	3802      	subs	r0, #2
 8080398:	4474      	add	r4, lr
 808039a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 808039e:	fba0 8902 	umull	r8, r9, r0, r2
 80803a2:	eba4 040a 	sub.w	r4, r4, sl
 80803a6:	454c      	cmp	r4, r9
 80803a8:	46c2      	mov	sl, r8
 80803aa:	464b      	mov	r3, r9
 80803ac:	d354      	bcc.n	8080458 <__udivmoddi4+0x298>
 80803ae:	d051      	beq.n	8080454 <__udivmoddi4+0x294>
 80803b0:	2e00      	cmp	r6, #0
 80803b2:	d069      	beq.n	8080488 <__udivmoddi4+0x2c8>
 80803b4:	ebb1 050a 	subs.w	r5, r1, sl
 80803b8:	eb64 0403 	sbc.w	r4, r4, r3
 80803bc:	fa04 fc0c 	lsl.w	ip, r4, ip
 80803c0:	40fd      	lsrs	r5, r7
 80803c2:	40fc      	lsrs	r4, r7
 80803c4:	ea4c 0505 	orr.w	r5, ip, r5
 80803c8:	e9c6 5400 	strd	r5, r4, [r6]
 80803cc:	2700      	movs	r7, #0
 80803ce:	e747      	b.n	8080260 <__udivmoddi4+0xa0>
 80803d0:	f1c2 0320 	rsb	r3, r2, #32
 80803d4:	fa20 f703 	lsr.w	r7, r0, r3
 80803d8:	4095      	lsls	r5, r2
 80803da:	fa01 f002 	lsl.w	r0, r1, r2
 80803de:	fa21 f303 	lsr.w	r3, r1, r3
 80803e2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80803e6:	4338      	orrs	r0, r7
 80803e8:	0c01      	lsrs	r1, r0, #16
 80803ea:	fbb3 f7fe 	udiv	r7, r3, lr
 80803ee:	fa1f f885 	uxth.w	r8, r5
 80803f2:	fb0e 3317 	mls	r3, lr, r7, r3
 80803f6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80803fa:	fb07 f308 	mul.w	r3, r7, r8
 80803fe:	428b      	cmp	r3, r1
 8080400:	fa04 f402 	lsl.w	r4, r4, r2
 8080404:	d907      	bls.n	8080416 <__udivmoddi4+0x256>
 8080406:	1869      	adds	r1, r5, r1
 8080408:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 808040c:	d22f      	bcs.n	808046e <__udivmoddi4+0x2ae>
 808040e:	428b      	cmp	r3, r1
 8080410:	d92d      	bls.n	808046e <__udivmoddi4+0x2ae>
 8080412:	3f02      	subs	r7, #2
 8080414:	4429      	add	r1, r5
 8080416:	1acb      	subs	r3, r1, r3
 8080418:	b281      	uxth	r1, r0
 808041a:	fbb3 f0fe 	udiv	r0, r3, lr
 808041e:	fb0e 3310 	mls	r3, lr, r0, r3
 8080422:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8080426:	fb00 f308 	mul.w	r3, r0, r8
 808042a:	428b      	cmp	r3, r1
 808042c:	d907      	bls.n	808043e <__udivmoddi4+0x27e>
 808042e:	1869      	adds	r1, r5, r1
 8080430:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8080434:	d217      	bcs.n	8080466 <__udivmoddi4+0x2a6>
 8080436:	428b      	cmp	r3, r1
 8080438:	d915      	bls.n	8080466 <__udivmoddi4+0x2a6>
 808043a:	3802      	subs	r0, #2
 808043c:	4429      	add	r1, r5
 808043e:	1ac9      	subs	r1, r1, r3
 8080440:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8080444:	e73b      	b.n	80802be <__udivmoddi4+0xfe>
 8080446:	4637      	mov	r7, r6
 8080448:	4630      	mov	r0, r6
 808044a:	e709      	b.n	8080260 <__udivmoddi4+0xa0>
 808044c:	4607      	mov	r7, r0
 808044e:	e6e7      	b.n	8080220 <__udivmoddi4+0x60>
 8080450:	4618      	mov	r0, r3
 8080452:	e6fb      	b.n	808024c <__udivmoddi4+0x8c>
 8080454:	4541      	cmp	r1, r8
 8080456:	d2ab      	bcs.n	80803b0 <__udivmoddi4+0x1f0>
 8080458:	ebb8 0a02 	subs.w	sl, r8, r2
 808045c:	eb69 020e 	sbc.w	r2, r9, lr
 8080460:	3801      	subs	r0, #1
 8080462:	4613      	mov	r3, r2
 8080464:	e7a4      	b.n	80803b0 <__udivmoddi4+0x1f0>
 8080466:	4660      	mov	r0, ip
 8080468:	e7e9      	b.n	808043e <__udivmoddi4+0x27e>
 808046a:	4618      	mov	r0, r3
 808046c:	e795      	b.n	808039a <__udivmoddi4+0x1da>
 808046e:	4667      	mov	r7, ip
 8080470:	e7d1      	b.n	8080416 <__udivmoddi4+0x256>
 8080472:	4681      	mov	r9, r0
 8080474:	e77c      	b.n	8080370 <__udivmoddi4+0x1b0>
 8080476:	3802      	subs	r0, #2
 8080478:	442c      	add	r4, r5
 808047a:	e747      	b.n	808030c <__udivmoddi4+0x14c>
 808047c:	f1ac 0c02 	sub.w	ip, ip, #2
 8080480:	442b      	add	r3, r5
 8080482:	e72f      	b.n	80802e4 <__udivmoddi4+0x124>
 8080484:	4638      	mov	r0, r7
 8080486:	e708      	b.n	808029a <__udivmoddi4+0xda>
 8080488:	4637      	mov	r7, r6
 808048a:	e6e9      	b.n	8080260 <__udivmoddi4+0xa0>

0808048c <__aeabi_idiv0>:
 808048c:	4770      	bx	lr
 808048e:	bf00      	nop

08080490 <read_register16>:
	params->oversampling_temperature = BMP280_STANDARD;
	params->oversampling_humidity = BMP280_STANDARD;
	params->standby = BMP280_STANDBY_250;
}

static bool read_register16(BMP280_HandleTypedef *dev, uint8_t addr, uint16_t *value) {
 8080490:	b5f0      	push	{r4, r5, r6, r7, lr}
 8080492:	4605      	mov	r5, r0
 8080494:	b085      	sub	sp, #20
		*value = (uint16_t) ((rx_buff[1] << 8) | rx_buff[0]);
		return true;
	} else
		return false;
#else
	uint8_t tx_buff[3]={addr | 0x80,0,0};
 8080496:	2400      	movs	r4, #0
	uint8_t rx_buff[3];
	uint8_t status;

	//HAL_GPIO_WritePin(dev->cs_gpio, dev->cs_pin, GPIO_PIN_RESET );
	BMP280_CS_ENABLE(dev);
 8080498:	6a80      	ldr	r0, [r0, #40]	; 0x28
	uint8_t tx_buff[3]={addr | 0x80,0,0};
 808049a:	f88d 1008 	strb.w	r1, [sp, #8]
static bool read_register16(BMP280_HandleTypedef *dev, uint8_t addr, uint16_t *value) {
 808049e:	4617      	mov	r7, r2
	BMP280_CS_ENABLE(dev);
 80804a0:	8da9      	ldrh	r1, [r5, #44]	; 0x2c
 80804a2:	4622      	mov	r2, r4
	uint8_t tx_buff[3]={addr | 0x80,0,0};
 80804a4:	f88d 4009 	strb.w	r4, [sp, #9]
 80804a8:	f88d 400a 	strb.w	r4, [sp, #10]
	BMP280_CS_ENABLE(dev);
 80804ac:	f005 fff8 	bl	80864a0 <HAL_GPIO_WritePin>

	status = HAL_SPI_TransmitReceive(dev->hspi, tx_buff, rx_buff, 3, 1000);
 80804b0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80804b4:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80804b6:	aa03      	add	r2, sp, #12
 80804b8:	2303      	movs	r3, #3
 80804ba:	9100      	str	r1, [sp, #0]
 80804bc:	a902      	add	r1, sp, #8
 80804be:	f009 fcff 	bl	8089ec0 <HAL_SPI_TransmitReceive>
 80804c2:	4606      	mov	r6, r0

	BMP280_CS_DISABLE(dev);
 80804c4:	8da9      	ldrh	r1, [r5, #44]	; 0x2c
 80804c6:	2201      	movs	r2, #1
 80804c8:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 80804ca:	f005 ffe9 	bl	80864a0 <HAL_GPIO_WritePin>

	if (status != HAL_OK) return false;
 80804ce:	b94e      	cbnz	r6, 80804e4 <read_register16+0x54>
	else
	{
		*value = (((uint16_t)rx_buff[2])<<8) + (uint16_t)rx_buff[1];
 80804d0:	f89d 200e 	ldrb.w	r2, [sp, #14]

		return true;
 80804d4:	2001      	movs	r0, #1
		*value = (((uint16_t)rx_buff[2])<<8) + (uint16_t)rx_buff[1];
 80804d6:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80804da:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80804de:	803b      	strh	r3, [r7, #0]
	}
#endif /* BMP280_SPI */

}
 80804e0:	b005      	add	sp, #20
 80804e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (status != HAL_OK) return false;
 80804e4:	4620      	mov	r0, r4
}
 80804e6:	b005      	add	sp, #20
 80804e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80804ea:	bf00      	nop

080804ec <read_data>:

static int read_data(BMP280_HandleTypedef *dev, uint8_t addr, uint8_t *value, uint8_t len) {
 80804ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80804f0:	461c      	mov	r4, r3
 80804f2:	4615      	mov	r5, r2
 80804f4:	b083      	sub	sp, #12
 80804f6:	4680      	mov	r8, r0
	if (HAL_I2C_Mem_Read(dev->i2c, tx_buff, addr, 1, value, len, 5000) == HAL_OK)
		return 0;
	else
		return 1;
#else
	uint8_t tx_buff[len+1];
 80804f8:	f104 0208 	add.w	r2, r4, #8
	uint8_t rx_buff[len+1];
	uint8_t status;
	uint8_t i;

	tx_buff[0]=addr | 0x80;
	for (i=1; i<len+1; i++)
 80804fc:	2301      	movs	r3, #1
static int read_data(BMP280_HandleTypedef *dev, uint8_t addr, uint8_t *value, uint8_t len) {
 80804fe:	af02      	add	r7, sp, #8
	uint8_t tx_buff[len+1];
 8080500:	f402 72fc 	and.w	r2, r2, #504	; 0x1f8
	{
		tx_buff[i]=0;
 8080504:	2000      	movs	r0, #0
	uint8_t tx_buff[len+1];
 8080506:	ebad 0d02 	sub.w	sp, sp, r2
 808050a:	46e9      	mov	r9, sp
	uint8_t rx_buff[len+1];
 808050c:	ebad 0d02 	sub.w	sp, sp, r2
	tx_buff[0]=addr | 0x80;
 8080510:	f809 1f08 	strb.w	r1, [r9, #8]!
	uint8_t rx_buff[len+1];
 8080514:	ae02      	add	r6, sp, #8
 8080516:	464a      	mov	r2, r9
	for (i=1; i<len+1; i++)
 8080518:	3301      	adds	r3, #1
		tx_buff[i]=0;
 808051a:	f802 0f01 	strb.w	r0, [r2, #1]!
	for (i=1; i<len+1; i++)
 808051e:	b2db      	uxtb	r3, r3
 8080520:	429c      	cmp	r4, r3
 8080522:	d2f9      	bcs.n	8080518 <read_data+0x2c>
	}

	BMP280_CS_ENABLE(dev);
 8080524:	2200      	movs	r2, #0
 8080526:	f8b8 102c 	ldrh.w	r1, [r8, #44]	; 0x2c
 808052a:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
 808052e:	f005 ffb7 	bl	80864a0 <HAL_GPIO_WritePin>

	status = HAL_SPI_TransmitReceive(dev->hspi, tx_buff, rx_buff, len+1, 1000);
 8080532:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8080536:	4649      	mov	r1, r9
 8080538:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
 808053c:	1c63      	adds	r3, r4, #1
 808053e:	9200      	str	r2, [sp, #0]
 8080540:	4632      	mov	r2, r6
 8080542:	f009 fcbd 	bl	8089ec0 <HAL_SPI_TransmitReceive>
 8080546:	4681      	mov	r9, r0

	BMP280_CS_DISABLE(dev);
 8080548:	2201      	movs	r2, #1
 808054a:	f8b8 102c 	ldrh.w	r1, [r8, #44]	; 0x2c
 808054e:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
 8080552:	f005 ffa5 	bl	80864a0 <HAL_GPIO_WritePin>

	if (status != HAL_OK) return false;
 8080556:	f1b9 0f00 	cmp.w	r9, #0
 808055a:	d10f      	bne.n	808057c <read_data+0x90>
 808055c:	3c01      	subs	r4, #1
 808055e:	1c72      	adds	r2, r6, #1
 8080560:	1e6b      	subs	r3, r5, #1
 8080562:	fa55 f484 	uxtab	r4, r5, r4
	else
	{
		for (i=1; i<len+1; i++)
		{
			value[i-1]=rx_buff[i];
 8080566:	f812 1b01 	ldrb.w	r1, [r2], #1
 808056a:	f803 1f01 	strb.w	r1, [r3, #1]!
		for (i=1; i<len+1; i++)
 808056e:	429c      	cmp	r4, r3
 8080570:	d1f9      	bne.n	8080566 <read_data+0x7a>
		}

		return true;
 8080572:	2001      	movs	r0, #1
	}
#endif /* BMP280_SPI */

}
 8080574:	3704      	adds	r7, #4
 8080576:	46bd      	mov	sp, r7
 8080578:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (status != HAL_OK) return false;
 808057c:	2000      	movs	r0, #0
}
 808057e:	3704      	adds	r7, #4
 8080580:	46bd      	mov	sp, r7
 8080582:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8080586:	bf00      	nop

08080588 <write_register8>:

static int write_register8(BMP280_HandleTypedef *dev, uint8_t addr, uint8_t value) {
 8080588:	b530      	push	{r4, r5, lr}
 808058a:	b083      	sub	sp, #12
 808058c:	4604      	mov	r4, r0
	if (HAL_I2C_Mem_Write(dev->i2c, tx_buff, addr, 1, &value, 1, 10000) == HAL_OK)
		return false;
	else
		return true;
#else
	uint8_t tx_buff[2]={addr & 0x7F,value};
 808058e:	f001 037f 	and.w	r3, r1, #127	; 0x7f
	uint8_t status;

	BMP280_CS_ENABLE(dev);
 8080592:	8d81      	ldrh	r1, [r0, #44]	; 0x2c
	uint8_t tx_buff[2]={addr & 0x7F,value};
 8080594:	f88d 2005 	strb.w	r2, [sp, #5]
	BMP280_CS_ENABLE(dev);
 8080598:	2200      	movs	r2, #0
 808059a:	6a80      	ldr	r0, [r0, #40]	; 0x28
	uint8_t tx_buff[2]={addr & 0x7F,value};
 808059c:	f88d 3004 	strb.w	r3, [sp, #4]
	BMP280_CS_ENABLE(dev);
 80805a0:	f005 ff7e 	bl	80864a0 <HAL_GPIO_WritePin>

	status = HAL_SPI_Transmit(dev->hspi, tx_buff, 2, 1000);
 80805a4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80805a8:	a901      	add	r1, sp, #4
 80805aa:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80805ac:	2202      	movs	r2, #2
 80805ae:	f009 fbc3 	bl	8089d38 <HAL_SPI_Transmit>
 80805b2:	4605      	mov	r5, r0

	BMP280_CS_DISABLE(dev);
 80805b4:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 80805b6:	2201      	movs	r2, #1
 80805b8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80805ba:	f005 ff71 	bl	80864a0 <HAL_GPIO_WritePin>

	if (status != HAL_OK) return false;
	else return true;
#endif /* BMP280_SPI */
}
 80805be:	fab5 f085 	clz	r0, r5
 80805c2:	0940      	lsrs	r0, r0, #5
 80805c4:	b003      	add	sp, #12
 80805c6:	bd30      	pop	{r4, r5, pc}

080805c8 <bmp280_init_default_params>:
	params->mode = BMP280_MODE_NORMAL;
 80805c8:	2303      	movs	r3, #3
	params->filter = BMP280_FILTER_OFF;
 80805ca:	2200      	movs	r2, #0
	params->mode = BMP280_MODE_NORMAL;
 80805cc:	7003      	strb	r3, [r0, #0]
	params->filter = BMP280_FILTER_OFF;
 80805ce:	7042      	strb	r2, [r0, #1]
	params->oversampling_pressure = BMP280_STANDARD;
 80805d0:	7083      	strb	r3, [r0, #2]
	params->oversampling_temperature = BMP280_STANDARD;
 80805d2:	70c3      	strb	r3, [r0, #3]
	params->oversampling_humidity = BMP280_STANDARD;
 80805d4:	7103      	strb	r3, [r0, #4]
	params->standby = BMP280_STANDBY_250;
 80805d6:	7143      	strb	r3, [r0, #5]
}
 80805d8:	4770      	bx	lr
 80805da:	bf00      	nop

080805dc <bmp280_init>:
	}

	return false;
}

bool bmp280_init(BMP280_HandleTypedef *dev, bmp280_params_t *params) {
 80805dc:	b5f0      	push	{r4, r5, r6, r7, lr}

		return false;
	}
#endif /*BMP280_SPI */

	if (read_data(dev, BMP280_REG_ID, &dev->id, 1)==false) {
 80805de:	2301      	movs	r3, #1
bool bmp280_init(BMP280_HandleTypedef *dev, bmp280_params_t *params) {
 80805e0:	b083      	sub	sp, #12
 80805e2:	460f      	mov	r7, r1
	if (read_data(dev, BMP280_REG_ID, &dev->id, 1)==false) {
 80805e4:	f100 0234 	add.w	r2, r0, #52	; 0x34
 80805e8:	21d0      	movs	r1, #208	; 0xd0
bool bmp280_init(BMP280_HandleTypedef *dev, bmp280_params_t *params) {
 80805ea:	4605      	mov	r5, r0
	if (read_data(dev, BMP280_REG_ID, &dev->id, 1)==false) {
 80805ec:	f7ff ff7e 	bl	80804ec <read_data>
 80805f0:	b140      	cbz	r0, 8080604 <bmp280_init+0x28>
		return false;
	}

	if (dev->id != BMP280_CHIP_ID && dev->id != BME280_CHIP_ID) {
 80805f2:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
 80805f6:	2858      	cmp	r0, #88	; 0x58
 80805f8:	bf18      	it	ne
 80805fa:	2860      	cmpne	r0, #96	; 0x60
 80805fc:	bf14      	ite	ne
 80805fe:	2401      	movne	r4, #1
 8080600:	2400      	moveq	r4, #0
 8080602:	d003      	beq.n	808060c <bmp280_init+0x30>
		return false;
 8080604:	2400      	movs	r4, #0
	if (write_register8(dev, BMP280_REG_CTRL, ctrl)==false) {
		return false;
	}

	return true;
}
 8080606:	4620      	mov	r0, r4
 8080608:	b003      	add	sp, #12
 808060a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (write_register8(dev, BMP280_REG_RESET, BMP280_RESET_VALUE)==false) {
 808060c:	22b6      	movs	r2, #182	; 0xb6
 808060e:	21e0      	movs	r1, #224	; 0xe0
 8080610:	4628      	mov	r0, r5
 8080612:	f7ff ffb9 	bl	8080588 <write_register8>
 8080616:	2800      	cmp	r0, #0
 8080618:	d0f4      	beq.n	8080604 <bmp280_init+0x28>
		uint8_t status=0;
 808061a:	4626      	mov	r6, r4
		if ((read_data(dev, BMP280_REG_STATUS, &status, 1)!=false)
 808061c:	2301      	movs	r3, #1
 808061e:	f10d 0206 	add.w	r2, sp, #6
 8080622:	21f3      	movs	r1, #243	; 0xf3
 8080624:	4628      	mov	r0, r5
		uint8_t status=0;
 8080626:	f88d 6006 	strb.w	r6, [sp, #6]
		if ((read_data(dev, BMP280_REG_STATUS, &status, 1)!=false)
 808062a:	f7ff ff5f 	bl	80804ec <read_data>
 808062e:	2800      	cmp	r0, #0
 8080630:	d0f4      	beq.n	808061c <bmp280_init+0x40>
				&& (status & 1) == 0)
 8080632:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8080636:	07db      	lsls	r3, r3, #31
 8080638:	d4f0      	bmi.n	808061c <bmp280_init+0x40>
	if (read_register16(dev, 0x88, &dev->dig_T1)
 808063a:	462a      	mov	r2, r5
 808063c:	2188      	movs	r1, #136	; 0x88
 808063e:	4628      	mov	r0, r5
 8080640:	f7ff ff26 	bl	8080490 <read_register16>
 8080644:	2800      	cmp	r0, #0
 8080646:	d0dd      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x8a, (uint16_t *) &dev->dig_T2)
 8080648:	1caa      	adds	r2, r5, #2
 808064a:	218a      	movs	r1, #138	; 0x8a
 808064c:	4628      	mov	r0, r5
 808064e:	f7ff ff1f 	bl	8080490 <read_register16>
 8080652:	2800      	cmp	r0, #0
 8080654:	d0d6      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x8c, (uint16_t *) &dev->dig_T3)
 8080656:	1d2a      	adds	r2, r5, #4
 8080658:	218c      	movs	r1, #140	; 0x8c
 808065a:	4628      	mov	r0, r5
 808065c:	f7ff ff18 	bl	8080490 <read_register16>
 8080660:	2800      	cmp	r0, #0
 8080662:	d0cf      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x8e, &dev->dig_P1)
 8080664:	1daa      	adds	r2, r5, #6
 8080666:	218e      	movs	r1, #142	; 0x8e
 8080668:	4628      	mov	r0, r5
 808066a:	f7ff ff11 	bl	8080490 <read_register16>
 808066e:	2800      	cmp	r0, #0
 8080670:	d0c8      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x90, (uint16_t *) &dev->dig_P2)
 8080672:	f105 0208 	add.w	r2, r5, #8
 8080676:	2190      	movs	r1, #144	; 0x90
 8080678:	4628      	mov	r0, r5
 808067a:	f7ff ff09 	bl	8080490 <read_register16>
 808067e:	2800      	cmp	r0, #0
 8080680:	d0c0      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x92, (uint16_t *) &dev->dig_P3)
 8080682:	f105 020a 	add.w	r2, r5, #10
 8080686:	2192      	movs	r1, #146	; 0x92
 8080688:	4628      	mov	r0, r5
 808068a:	f7ff ff01 	bl	8080490 <read_register16>
 808068e:	2800      	cmp	r0, #0
 8080690:	d0b8      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x94, (uint16_t *) &dev->dig_P4)
 8080692:	f105 020c 	add.w	r2, r5, #12
 8080696:	2194      	movs	r1, #148	; 0x94
 8080698:	4628      	mov	r0, r5
 808069a:	f7ff fef9 	bl	8080490 <read_register16>
 808069e:	2800      	cmp	r0, #0
 80806a0:	d0b0      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x96, (uint16_t *) &dev->dig_P5)
 80806a2:	f105 020e 	add.w	r2, r5, #14
 80806a6:	2196      	movs	r1, #150	; 0x96
 80806a8:	4628      	mov	r0, r5
 80806aa:	f7ff fef1 	bl	8080490 <read_register16>
 80806ae:	2800      	cmp	r0, #0
 80806b0:	d0a8      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x98, (uint16_t *) &dev->dig_P6)
 80806b2:	f105 0210 	add.w	r2, r5, #16
 80806b6:	2198      	movs	r1, #152	; 0x98
 80806b8:	4628      	mov	r0, r5
 80806ba:	f7ff fee9 	bl	8080490 <read_register16>
 80806be:	2800      	cmp	r0, #0
 80806c0:	d0a0      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x9a, (uint16_t *) &dev->dig_P7)
 80806c2:	f105 0212 	add.w	r2, r5, #18
 80806c6:	219a      	movs	r1, #154	; 0x9a
 80806c8:	4628      	mov	r0, r5
 80806ca:	f7ff fee1 	bl	8080490 <read_register16>
 80806ce:	2800      	cmp	r0, #0
 80806d0:	d098      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x9c, (uint16_t *) &dev->dig_P8)
 80806d2:	f105 0214 	add.w	r2, r5, #20
 80806d6:	219c      	movs	r1, #156	; 0x9c
 80806d8:	4628      	mov	r0, r5
 80806da:	f7ff fed9 	bl	8080490 <read_register16>
 80806de:	2800      	cmp	r0, #0
 80806e0:	d090      	beq.n	8080604 <bmp280_init+0x28>
			&& read_register16(dev, 0x9e,
 80806e2:	f105 0216 	add.w	r2, r5, #22
 80806e6:	219e      	movs	r1, #158	; 0x9e
 80806e8:	4628      	mov	r0, r5
 80806ea:	f7ff fed1 	bl	8080490 <read_register16>
 80806ee:	2800      	cmp	r0, #0
 80806f0:	d088      	beq.n	8080604 <bmp280_init+0x28>
	if (dev->id == BME280_CHIP_ID && !read_hum_calibration_data(dev)) {
 80806f2:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
 80806f6:	2b60      	cmp	r3, #96	; 0x60
 80806f8:	d026      	beq.n	8080748 <bmp280_init+0x16c>
	uint8_t config = (params->standby << 5) | (params->filter << 2);
 80806fa:	787a      	ldrb	r2, [r7, #1]
	if (write_register8(dev, BMP280_REG_CONFIG, config)==false) {
 80806fc:	21f5      	movs	r1, #245	; 0xf5
	uint8_t config = (params->standby << 5) | (params->filter << 2);
 80806fe:	797b      	ldrb	r3, [r7, #5]
	if (write_register8(dev, BMP280_REG_CONFIG, config)==false) {
 8080700:	4628      	mov	r0, r5
	uint8_t config = (params->standby << 5) | (params->filter << 2);
 8080702:	0092      	lsls	r2, r2, #2
 8080704:	ea42 1243 	orr.w	r2, r2, r3, lsl #5
	if (write_register8(dev, BMP280_REG_CONFIG, config)==false) {
 8080708:	f002 02fc 	and.w	r2, r2, #252	; 0xfc
 808070c:	f7ff ff3c 	bl	8080588 <write_register8>
 8080710:	2800      	cmp	r0, #0
 8080712:	f43f af77 	beq.w	8080604 <bmp280_init+0x28>
	if (params->mode == BMP280_MODE_FORCED) {
 8080716:	783b      	ldrb	r3, [r7, #0]
 8080718:	2b01      	cmp	r3, #1
 808071a:	d068      	beq.n	80807ee <bmp280_init+0x212>
 808071c:	b25b      	sxtb	r3, r3
													| (params->oversampling_pressure << 2) | (params->mode);
 808071e:	78ba      	ldrb	r2, [r7, #2]
	uint8_t ctrl = (params->oversampling_temperature << 5)
 8080720:	78f8      	ldrb	r0, [r7, #3]
													| (params->oversampling_pressure << 2) | (params->mode);
 8080722:	0092      	lsls	r2, r2, #2
	if (dev->id == BME280_CHIP_ID) {
 8080724:	f895 1034 	ldrb.w	r1, [r5, #52]	; 0x34
													| (params->oversampling_pressure << 2) | (params->mode);
 8080728:	ea42 1240 	orr.w	r2, r2, r0, lsl #5
	if (dev->id == BME280_CHIP_ID) {
 808072c:	2960      	cmp	r1, #96	; 0x60
													| (params->oversampling_pressure << 2) | (params->mode);
 808072e:	ea43 0302 	orr.w	r3, r3, r2
	uint8_t ctrl = (params->oversampling_temperature << 5)
 8080732:	b2dc      	uxtb	r4, r3
	if (dev->id == BME280_CHIP_ID) {
 8080734:	d053      	beq.n	80807de <bmp280_init+0x202>
	if (write_register8(dev, BMP280_REG_CTRL, ctrl)==false) {
 8080736:	4622      	mov	r2, r4
 8080738:	4628      	mov	r0, r5
 808073a:	21f4      	movs	r1, #244	; 0xf4
 808073c:	f7ff ff24 	bl	8080588 <write_register8>
 8080740:	1c04      	adds	r4, r0, #0
 8080742:	bf18      	it	ne
 8080744:	2401      	movne	r4, #1
 8080746:	e75e      	b.n	8080606 <bmp280_init+0x2a>
	uint16_t h4=0, h5=0;
 8080748:	2600      	movs	r6, #0
	if (!read_data(dev, 0xa1, &dev->dig_H1, 1)
 808074a:	2301      	movs	r3, #1
 808074c:	f105 0218 	add.w	r2, r5, #24
 8080750:	21a1      	movs	r1, #161	; 0xa1
 8080752:	4628      	mov	r0, r5
	uint16_t h4=0, h5=0;
 8080754:	f8ad 6004 	strh.w	r6, [sp, #4]
 8080758:	f8ad 6006 	strh.w	r6, [sp, #6]
	if (!read_data(dev, 0xa1, &dev->dig_H1, 1)
 808075c:	f7ff fec6 	bl	80804ec <read_data>
 8080760:	2800      	cmp	r0, #0
 8080762:	f47f af50 	bne.w	8080606 <bmp280_init+0x2a>
			&& read_register16(dev, 0xe1, (uint16_t *) &dev->dig_H2)
 8080766:	f105 021a 	add.w	r2, r5, #26
 808076a:	21e1      	movs	r1, #225	; 0xe1
 808076c:	4628      	mov	r0, r5
 808076e:	f7ff fe8f 	bl	8080490 <read_register16>
 8080772:	2800      	cmp	r0, #0
 8080774:	f43f af47 	beq.w	8080606 <bmp280_init+0x2a>
			&& !read_data(dev, 0xe3, &dev->dig_H3, 1)
 8080778:	2301      	movs	r3, #1
 808077a:	f105 021c 	add.w	r2, r5, #28
 808077e:	21e3      	movs	r1, #227	; 0xe3
 8080780:	4628      	mov	r0, r5
 8080782:	f7ff feb3 	bl	80804ec <read_data>
 8080786:	2800      	cmp	r0, #0
 8080788:	f47f af3d 	bne.w	8080606 <bmp280_init+0x2a>
			&& read_register16(dev, 0xe4, &h4)
 808078c:	aa01      	add	r2, sp, #4
 808078e:	21e4      	movs	r1, #228	; 0xe4
 8080790:	4628      	mov	r0, r5
 8080792:	f7ff fe7d 	bl	8080490 <read_register16>
 8080796:	2800      	cmp	r0, #0
 8080798:	f43f af35 	beq.w	8080606 <bmp280_init+0x2a>
			&& read_register16(dev, 0xe5, &h5)
 808079c:	f10d 0206 	add.w	r2, sp, #6
 80807a0:	21e5      	movs	r1, #229	; 0xe5
 80807a2:	4628      	mov	r0, r5
 80807a4:	f7ff fe74 	bl	8080490 <read_register16>
 80807a8:	2800      	cmp	r0, #0
 80807aa:	f43f af2c 	beq.w	8080606 <bmp280_init+0x2a>
			&& !read_data(dev, 0xe7, (uint8_t *) &dev->dig_H6, 1)) {
 80807ae:	2301      	movs	r3, #1
 80807b0:	f105 0222 	add.w	r2, r5, #34	; 0x22
 80807b4:	21e7      	movs	r1, #231	; 0xe7
 80807b6:	4628      	mov	r0, r5
 80807b8:	f7ff fe98 	bl	80804ec <read_data>
 80807bc:	2800      	cmp	r0, #0
 80807be:	f47f af22 	bne.w	8080606 <bmp280_init+0x2a>
		dev->dig_H4 = (h4 & 0x00ff) << 4 | (h4 & 0x0f00) >> 8;
 80807c2:	f8bd 2004 	ldrh.w	r2, [sp, #4]
		dev->dig_H5 = h5 >> 4;
 80807c6:	f8bd 1006 	ldrh.w	r1, [sp, #6]
		dev->dig_H4 = (h4 & 0x00ff) << 4 | (h4 & 0x0f00) >> 8;
 80807ca:	0113      	lsls	r3, r2, #4
 80807cc:	f3c2 2203 	ubfx	r2, r2, #8, #4
		dev->dig_H5 = h5 >> 4;
 80807d0:	0909      	lsrs	r1, r1, #4
		dev->dig_H4 = (h4 & 0x00ff) << 4 | (h4 & 0x0f00) >> 8;
 80807d2:	f403 637f 	and.w	r3, r3, #4080	; 0xff0
		dev->dig_H5 = h5 >> 4;
 80807d6:	8429      	strh	r1, [r5, #32]
		dev->dig_H4 = (h4 & 0x00ff) << 4 | (h4 & 0x0f00) >> 8;
 80807d8:	4313      	orrs	r3, r2
 80807da:	83eb      	strh	r3, [r5, #30]
 80807dc:	e78d      	b.n	80806fa <bmp280_init+0x11e>
		if (write_register8(dev, BMP280_REG_CTRL_HUM, ctrl_hum)==false) {
 80807de:	793a      	ldrb	r2, [r7, #4]
 80807e0:	21f2      	movs	r1, #242	; 0xf2
 80807e2:	4628      	mov	r0, r5
 80807e4:	f7ff fed0 	bl	8080588 <write_register8>
 80807e8:	2800      	cmp	r0, #0
 80807ea:	d1a4      	bne.n	8080736 <bmp280_init+0x15a>
 80807ec:	e70a      	b.n	8080604 <bmp280_init+0x28>
		params->mode = BMP280_MODE_SLEEP;  // initial mode for forced is sleep
 80807ee:	2200      	movs	r2, #0
 80807f0:	4613      	mov	r3, r2
 80807f2:	703a      	strb	r2, [r7, #0]
 80807f4:	e793      	b.n	808071e <bmp280_init+0x142>
 80807f6:	bf00      	nop

080807f8 <bmp280_is_measuring>:
		return false;
	}
	return true;
}

bool bmp280_is_measuring(BMP280_HandleTypedef *dev) {
 80807f8:	b510      	push	{r4, lr}
 80807fa:	b082      	sub	sp, #8
	uint8_t status=0;
 80807fc:	2400      	movs	r4, #0
	if (read_data(dev, BMP280_REG_STATUS, &status, 1)==false)
 80807fe:	2301      	movs	r3, #1
 8080800:	21f3      	movs	r1, #243	; 0xf3
	uint8_t status=0;
 8080802:	aa02      	add	r2, sp, #8
 8080804:	f802 4d01 	strb.w	r4, [r2, #-1]!
	if (read_data(dev, BMP280_REG_STATUS, &status, 1)==false)
 8080808:	f7ff fe70 	bl	80804ec <read_data>
 808080c:	b118      	cbz	r0, 8080816 <bmp280_is_measuring+0x1e>
		return false;
	if (status & (1 << 3)) {
 808080e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8080812:	f3c0 00c0 	ubfx	r0, r0, #3, #1
		return true;
	}
	return false;
}
 8080816:	b002      	add	sp, #8
 8080818:	bd10      	pop	{r4, pc}
 808081a:	bf00      	nop

0808081c <bmp280_read_raw>:
	v_x1_u32r = v_x1_u32r < 0 ? 0 : v_x1_u32r;
	v_x1_u32r = v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r;
	return v_x1_u32r >> 12;
}

bool bmp280_read_raw(BMP280_HandleTypedef *dev, int32_t *temperature, uint32_t *pressure,	uint32_t *humidity) {
 808081c:	b5f0      	push	{r4, r5, r6, r7, lr}
 808081e:	461d      	mov	r5, r3
	uint32_t adc_pressure;
	int32_t adc_temp;
	uint8_t data[8];

	// Only the BME280 supports reading the humidity.
	if (dev->id != BME280_CHIP_ID) {
 8080820:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
bool bmp280_read_raw(BMP280_HandleTypedef *dev, int32_t *temperature, uint32_t *pressure,	uint32_t *humidity) {
 8080824:	b083      	sub	sp, #12
 8080826:	4604      	mov	r4, r0
	if (dev->id != BME280_CHIP_ID) {
 8080828:	2b60      	cmp	r3, #96	; 0x60
bool bmp280_read_raw(BMP280_HandleTypedef *dev, int32_t *temperature, uint32_t *pressure,	uint32_t *humidity) {
 808082a:	460f      	mov	r7, r1
 808082c:	4616      	mov	r6, r2
	if (dev->id != BME280_CHIP_ID) {
 808082e:	d028      	beq.n	8080882 <bmp280_read_raw+0x66>
		if (humidity)
 8080830:	b38d      	cbz	r5, 8080896 <bmp280_read_raw+0x7a>
			*humidity = 0;
 8080832:	2200      	movs	r2, #0
 8080834:	2306      	movs	r3, #6
 8080836:	602a      	str	r2, [r5, #0]
	// Need to read in one sequence to ensure they match.
	size_t size = humidity ? 8 : 6;
	if (dev->id != BME280_CHIP_ID) size =6;
	else size=8;

	if (read_data(dev, 0xf7, data, size)==false) {
 8080838:	466a      	mov	r2, sp
 808083a:	21f7      	movs	r1, #247	; 0xf7
 808083c:	4620      	mov	r0, r4
 808083e:	f7ff fe55 	bl	80804ec <read_data>
 8080842:	b1e0      	cbz	r0, 808087e <bmp280_read_raw+0x62>
		return false;
	}

	adc_pressure = (((uint32_t)data[0]) << 12) | (((uint32_t)data[1]) << 4) | (((uint32_t)data[2]) >> 4);
	adc_temp = (((int32_t)data[3]) << 12) | (((int32_t)data[4]) << 4) | (((int32_t)data[5]) >> 4);
 8080844:	f89d 2004 	ldrb.w	r2, [sp, #4]
	adc_pressure = (((uint32_t)data[0]) << 12) | (((uint32_t)data[1]) << 4) | (((uint32_t)data[2]) >> 4);
 8080848:	f89d 3001 	ldrb.w	r3, [sp, #1]
	adc_temp = (((int32_t)data[3]) << 12) | (((int32_t)data[4]) << 4) | (((int32_t)data[5]) >> 4);
 808084c:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8080850:	0112      	lsls	r2, r2, #4
	adc_pressure = (((uint32_t)data[0]) << 12) | (((uint32_t)data[1]) << 4) | (((uint32_t)data[2]) >> 4);
 8080852:	f89d 1000 	ldrb.w	r1, [sp]
 8080856:	011b      	lsls	r3, r3, #4
	adc_temp = (((int32_t)data[3]) << 12) | (((int32_t)data[4]) << 4) | (((int32_t)data[5]) >> 4);
 8080858:	ea42 3200 	orr.w	r2, r2, r0, lsl #12
 808085c:	f89d 0005 	ldrb.w	r0, [sp, #5]
	adc_pressure = (((uint32_t)data[0]) << 12) | (((uint32_t)data[1]) << 4) | (((uint32_t)data[2]) >> 4);
 8080860:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
 8080864:	f89d 1002 	ldrb.w	r1, [sp, #2]
	adc_temp = (((int32_t)data[3]) << 12) | (((int32_t)data[4]) << 4) | (((int32_t)data[5]) >> 4);
 8080868:	ea42 1210 	orr.w	r2, r2, r0, lsr #4
	adc_pressure = (((uint32_t)data[0]) << 12) | (((uint32_t)data[1]) << 4) | (((uint32_t)data[2]) >> 4);
 808086c:	ea43 1311 	orr.w	r3, r3, r1, lsr #4

	*temperature = (int32_t)adc_temp;
 8080870:	603a      	str	r2, [r7, #0]
	*pressure = (uint32_t)adc_pressure;
 8080872:	6033      	str	r3, [r6, #0]

	if (dev->id == BME280_CHIP_ID) {
 8080874:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8080878:	2b60      	cmp	r3, #96	; 0x60
 808087a:	d004      	beq.n	8080886 <bmp280_read_raw+0x6a>
		uint32_t adc_humidity = (((uint32_t)data[6]) << 8) | ((uint32_t)data[7]);
		*humidity = (uint32_t)adc_humidity;
	}

	return true;
 808087c:	2001      	movs	r0, #1
}
 808087e:	b003      	add	sp, #12
 8080880:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8080882:	2308      	movs	r3, #8
 8080884:	e7d8      	b.n	8080838 <bmp280_read_raw+0x1c>
		*humidity = (uint32_t)adc_humidity;
 8080886:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	return true;
 808088a:	2001      	movs	r0, #1
		*humidity = (uint32_t)adc_humidity;
 808088c:	ba5b      	rev16	r3, r3
 808088e:	b29b      	uxth	r3, r3
 8080890:	602b      	str	r3, [r5, #0]
}
 8080892:	b003      	add	sp, #12
 8080894:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8080896:	2306      	movs	r3, #6
 8080898:	e7ce      	b.n	8080838 <bmp280_read_raw+0x1c>
 808089a:	bf00      	nop

0808089c <bmp280_read_fixed>:

bool bmp280_read_fixed(BMP280_HandleTypedef *dev, int32_t *temperature, uint32_t *pressure,	uint32_t *humidity) {
 808089c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80808a0:	b08f      	sub	sp, #60	; 0x3c
 80808a2:	460d      	mov	r5, r1
 80808a4:	4604      	mov	r4, r0
	int32_t adc_pressure;
	int32_t adc_temp;
	int32_t adc_humidity;
	int32_t fine_temp;

	if (bmp280_read_raw(dev,(int32_t*)&adc_temp, (uint32_t*)&adc_pressure, (uint32_t*)&adc_humidity)==false)
 80808a6:	a90c      	add	r1, sp, #48	; 0x30
bool bmp280_read_fixed(BMP280_HandleTypedef *dev, int32_t *temperature, uint32_t *pressure,	uint32_t *humidity) {
 80808a8:	e9cd 2307 	strd	r2, r3, [sp, #28]
	if (bmp280_read_raw(dev,(int32_t*)&adc_temp, (uint32_t*)&adc_pressure, (uint32_t*)&adc_humidity)==false)
 80808ac:	aa0b      	add	r2, sp, #44	; 0x2c
 80808ae:	ab0d      	add	r3, sp, #52	; 0x34
 80808b0:	f7ff ffb4 	bl	808081c <bmp280_read_raw>
 80808b4:	9006      	str	r0, [sp, #24]
 80808b6:	2800      	cmp	r0, #0
 80808b8:	f000 8133 	beq.w	8080b22 <bmp280_read_fixed+0x286>
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 80808bc:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
		return false;

	*temperature = compensate_temperature(dev, adc_temp, &fine_temp);
 80808c0:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
	var1 = ((((adc_temp >> 3) - ((int32_t) dev->dig_T1 << 1)))
 80808c4:	8823      	ldrh	r3, [r4, #0]
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 80808c6:	17ca      	asrs	r2, r1, #31
			* (int32_t) dev->dig_T2) >> 11;
 80808c8:	f9b4 0002 	ldrsh.w	r0, [r4, #2]
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 80808cc:	f9b4 600a 	ldrsh.w	r6, [r4, #10]
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 80808d0:	e9cd 1202 	strd	r1, r2, [sp, #8]
	var2 = (((((adc_temp >> 4) - (int32_t) dev->dig_T1)
 80808d4:	ebc3 122c 	rsb	r2, r3, ip, asr #4
			* (int32_t) dev->dig_T3) >> 14;
 80808d8:	f9b4 1004 	ldrsh.w	r1, [r4, #4]
	var1 = ((((adc_temp >> 3) - ((int32_t) dev->dig_T1 << 1)))
 80808dc:	005b      	lsls	r3, r3, #1
			* ((adc_temp >> 4) - (int32_t) dev->dig_T1)) >> 12)
 80808de:	fb02 f202 	mul.w	r2, r2, r2
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 80808e2:	17f7      	asrs	r7, r6, #31
	var1 = ((((adc_temp >> 3) - ((int32_t) dev->dig_T1 << 1)))
 80808e4:	ebc3 03ec 	rsb	r3, r3, ip, asr #3
			* ((adc_temp >> 4) - (int32_t) dev->dig_T1)) >> 12)
 80808e8:	1312      	asrs	r2, r2, #12
			* (int32_t) dev->dig_T2) >> 11;
 80808ea:	fb00 f303 	mul.w	r3, r0, r3
			* (int32_t) dev->dig_T3) >> 14;
 80808ee:	fb01 f202 	mul.w	r2, r1, r2
	var2 = (((((adc_temp >> 4) - (int32_t) dev->dig_T1)
 80808f2:	1392      	asrs	r2, r2, #14
	*fine_temp = var1 + var2;
 80808f4:	eb02 23e3 	add.w	r3, r2, r3, asr #11
	var1 = (int64_t) fine_temp - 128000;
 80808f8:	461a      	mov	r2, r3
 80808fa:	ea4f 7be3 	mov.w	fp, r3, asr #31
	*fine_temp = var1 + var2;
 80808fe:	9309      	str	r3, [sp, #36]	; 0x24
	return (*fine_temp * 5 + 128) >> 8;
 8080900:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	var1 = (int64_t) fine_temp - 128000;
 8080904:	f5b2 31fa 	subs.w	r1, r2, #128000	; 0x1f400
	return (*fine_temp * 5 + 128) >> 8;
 8080908:	f103 0380 	add.w	r3, r3, #128	; 0x80
	var1 = (int64_t) fine_temp - 128000;
 808090c:	f14b 32ff 	adc.w	r2, fp, #4294967295	; 0xffffffff
 8080910:	468a      	mov	sl, r1
	return (*fine_temp * 5 + 128) >> 8;
 8080912:	121b      	asrs	r3, r3, #8
	var1 = (int64_t) fine_temp - 128000;
 8080914:	4693      	mov	fp, r2
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 8080916:	460a      	mov	r2, r1
	*temperature = compensate_temperature(dev, adc_temp, &fine_temp);
 8080918:	602b      	str	r3, [r5, #0]
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 808091a:	4659      	mov	r1, fp
 808091c:	fb02 f201 	mul.w	r2, r2, r1
 8080920:	fbaa 010a 	umull	r0, r1, sl, sl
 8080924:	eb01 0342 	add.w	r3, r1, r2, lsl #1
 8080928:	e9cd 0100 	strd	r0, r1, [sp]
 808092c:	9301      	str	r3, [sp, #4]
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 808092e:	9b02      	ldr	r3, [sp, #8]
 8080930:	e9cd ab04 	strd	sl, fp, [sp, #16]
 8080934:	fb03 f50b 	mul.w	r5, r3, fp
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 8080938:	e9dd ab00 	ldrd	sl, fp, [sp]
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 808093c:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 8080940:	fb06 f10b 	mul.w	r1, r6, fp
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 8080944:	fb02 5503 	mla	r5, r2, r3, r5
 8080948:	9b02      	ldr	r3, [sp, #8]
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 808094a:	fb0a 1107 	mla	r1, sl, r7, r1
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 808094e:	fba3 2302 	umull	r2, r3, r3, r2
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 8080952:	fba6 670a 	umull	r6, r7, r6, sl
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 8080956:	442b      	add	r3, r5
 8080958:	ea4f 3b02 	mov.w	fp, r2, lsl #12
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 808095c:	440f      	add	r7, r1
 808095e:	ea4f 2816 	mov.w	r8, r6, lsr #8
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 8080962:	ea4f 3c03 	mov.w	ip, r3, lsl #12
	var1 = (((int64_t) 1 << 47) + var1) * ((int64_t) dev->dig_P1) >> 33;
 8080966:	88e6      	ldrh	r6, [r4, #6]
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 8080968:	ea48 6807 	orr.w	r8, r8, r7, lsl #24
													+ ((var1 * (int64_t) dev->dig_P2) << 12);
 808096c:	ea4c 5c12 	orr.w	ip, ip, r2, lsr #20
	var1 = ((var1 * var1 * (int64_t) dev->dig_P3) >> 8)
 8080970:	eb1b 0008 	adds.w	r0, fp, r8
 8080974:	ea4f 2927 	mov.w	r9, r7, asr #8
 8080978:	eb4c 0109 	adc.w	r1, ip, r9
	var1 = (((int64_t) 1 << 47) + var1) * ((int64_t) dev->dig_P1) >> 33;
 808097c:	f110 0b00 	adds.w	fp, r0, #0
 8080980:	f541 4c00 	adc.w	ip, r1, #32768	; 0x8000
 8080984:	fbab 8906 	umull	r8, r9, fp, r6
 8080988:	fb06 990c 	mla	r9, r6, ip, r9
 808098c:	ea4f 0269 	mov.w	r2, r9, asr #1
 8080990:	ea4f 73e9 	mov.w	r3, r9, asr #31
	if (var1 == 0) {
 8080994:	ea52 0103 	orrs.w	r1, r2, r3
 8080998:	f000 80c7 	beq.w	8080b2a <bmp280_read_fixed+0x28e>
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 808099c:	f9b4 000e 	ldrsh.w	r0, [r4, #14]
	p = 1048576 - adc_press;
 80809a0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809a2:	17c1      	asrs	r1, r0, #31
	p = 1048576 - adc_press;
 80809a4:	f5c5 1580 	rsb	r5, r5, #1048576	; 0x100000
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809a8:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80809ac:	465e      	mov	r6, fp
 80809ae:	fb00 f606 	mul.w	r6, r0, r6
 80809b2:	fb0a 6601 	mla	r6, sl, r1, r6
 80809b6:	fba0 010a 	umull	r0, r1, r0, sl
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 80809ba:	f9b4 a010 	ldrsh.w	sl, [r4, #16]
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809be:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80809c2:	4431      	add	r1, r6
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 80809c4:	ea4f 7bea 	mov.w	fp, sl, asr #31
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809c8:	9802      	ldr	r0, [sp, #8]
 80809ca:	ea4f 4941 	mov.w	r9, r1, lsl #17
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 80809ce:	e9dd 6700 	ldrd	r6, r7, [sp]
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809d2:	ea49 39d0 	orr.w	r9, r9, r0, lsr #15
	p = 1048576 - adc_press;
 80809d6:	4628      	mov	r0, r5
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 80809d8:	fb0a f107 	mul.w	r1, sl, r7
 80809dc:	fb06 1c0b 	mla	ip, r6, fp, r1
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809e0:	9902      	ldr	r1, [sp, #8]
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 80809e2:	fbaa ab06 	umull	sl, fp, sl, r6
	var2 = var2 + (((int64_t) dev->dig_P4) << 35);
 80809e6:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809ea:	ea4f 4841 	mov.w	r8, r1, lsl #17
	var2 = var2 + (((int64_t) dev->dig_P4) << 35);
 80809ee:	00f1      	lsls	r1, r6, #3
	var2 = var1 * var1 * (int64_t) dev->dig_P6;
 80809f0:	44e3      	add	fp, ip
	p = (((p << 31) - var2) * 3125) / var1;
 80809f2:	07ee      	lsls	r6, r5, #31
	var2 = var2 + (((int64_t) dev->dig_P4) << 35);
 80809f4:	9101      	str	r1, [sp, #4]
	p = 1048576 - adc_press;
 80809f6:	17e9      	asrs	r1, r5, #31
 80809f8:	e9cd 0102 	strd	r0, r1, [sp, #8]
	var2 = var2 + ((var1 * (int64_t) dev->dig_P5) << 17);
 80809fc:	eb18 000a 	adds.w	r0, r8, sl
 8080a00:	eb49 010b 	adc.w	r1, r9, fp
 8080a04:	4680      	mov	r8, r0
 8080a06:	4689      	mov	r9, r1
	var2 = var2 + (((int64_t) dev->dig_P4) << 35);
 8080a08:	2100      	movs	r1, #0
 8080a0a:	9100      	str	r1, [sp, #0]
	p = (((p << 31) - var2) * 3125) / var1;
 8080a0c:	9903      	ldr	r1, [sp, #12]
 8080a0e:	07cf      	lsls	r7, r1, #31
	var2 = var2 + (((int64_t) dev->dig_P4) << 35);
 8080a10:	e9dd 0100 	ldrd	r0, r1, [sp]
	p = (((p << 31) - var2) * 3125) / var1;
 8080a14:	ea47 0755 	orr.w	r7, r7, r5, lsr #1
	var2 = var2 + (((int64_t) dev->dig_P4) << 35);
 8080a18:	eb18 0800 	adds.w	r8, r8, r0
 8080a1c:	eb49 0901 	adc.w	r9, r9, r1
	p = (((p << 31) - var2) * 3125) / var1;
 8080a20:	ebb6 0608 	subs.w	r6, r6, r8
 8080a24:	46b0      	mov	r8, r6
 8080a26:	eb67 0709 	sbc.w	r7, r7, r9
 8080a2a:	19b6      	adds	r6, r6, r6
 8080a2c:	46b9      	mov	r9, r7
 8080a2e:	417f      	adcs	r7, r7
 8080a30:	eb16 0008 	adds.w	r0, r6, r8
 8080a34:	eb47 0109 	adc.w	r1, r7, r9
 8080a38:	ea4f 1a80 	mov.w	sl, r0, lsl #6
 8080a3c:	ea4f 1b81 	mov.w	fp, r1, lsl #6
 8080a40:	eb10 060a 	adds.w	r6, r0, sl
 8080a44:	ea4b 6b90 	orr.w	fp, fp, r0, lsr #26
 8080a48:	ea4f 0086 	mov.w	r0, r6, lsl #2
 8080a4c:	eb41 070b 	adc.w	r7, r1, fp
 8080a50:	eb10 0a08 	adds.w	sl, r0, r8
 8080a54:	ea4f 0187 	mov.w	r1, r7, lsl #2
 8080a58:	ea41 7196 	orr.w	r1, r1, r6, lsr #30
 8080a5c:	ea4f 068a 	mov.w	r6, sl, lsl #2
 8080a60:	eb41 0b09 	adc.w	fp, r1, r9
 8080a64:	eb16 0008 	adds.w	r0, r6, r8
 8080a68:	ea4f 058b 	mov.w	r5, fp, lsl #2
 8080a6c:	ea45 759a 	orr.w	r5, r5, sl, lsr #30
 8080a70:	eb45 0109 	adc.w	r1, r5, r9
 8080a74:	f7ff fb3c 	bl	80800f0 <__aeabi_ldivmod>
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080a78:	f9b4 2016 	ldrsh.w	r2, [r4, #22]
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080a7c:	f9b4 8014 	ldrsh.w	r8, [r4, #20]
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080a80:	134d      	asrs	r5, r1, #13
 8080a82:	0b46      	lsrs	r6, r0, #13
	p = (((p << 31) - var2) * 3125) / var1;
 8080a84:	4682      	mov	sl, r0
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080a86:	fb02 f705 	mul.w	r7, r2, r5
 8080a8a:	17d3      	asrs	r3, r2, #31
 8080a8c:	ea46 46c1 	orr.w	r6, r6, r1, lsl #19
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080a90:	fb08 fc01 	mul.w	ip, r8, r1
 8080a94:	ea4f 79e8 	mov.w	r9, r8, asr #31
	p = (((p << 31) - var2) * 3125) / var1;
 8080a98:	468b      	mov	fp, r1
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080a9a:	fb06 7703 	mla	r7, r6, r3, r7
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080a9e:	fb00 c109 	mla	r1, r0, r9, ip
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080aa2:	2000      	movs	r0, #0
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080aa4:	fba8 890a 	umull	r8, r9, r8, sl
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080aa8:	fba2 2306 	umull	r2, r3, r2, r6
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080aac:	4449      	add	r1, r9
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080aae:	443b      	add	r3, r7
 8080ab0:	fb02 f505 	mul.w	r5, r2, r5
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080ab4:	e9cd 8902 	strd	r8, r9, [sp, #8]
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080ab8:	fb06 5503 	mla	r5, r6, r3, r5
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080abc:	9103      	str	r1, [sp, #12]
	var1 = ((int64_t) dev->dig_P9 * (p >> 13) * (p >> 13)) >> 25;
 8080abe:	2100      	movs	r1, #0
 8080ac0:	fba2 2306 	umull	r2, r3, r2, r6
 8080ac4:	e9cd 0100 	strd	r0, r1, [sp]
 8080ac8:	0e51      	lsrs	r1, r2, #25
 8080aca:	442b      	add	r3, r5
 8080acc:	9100      	str	r1, [sp, #0]
 8080ace:	9900      	ldr	r1, [sp, #0]
 8080ad0:	ea41 11c3 	orr.w	r1, r1, r3, lsl #7
 8080ad4:	165b      	asrs	r3, r3, #25
 8080ad6:	9100      	str	r1, [sp, #0]
 8080ad8:	9301      	str	r3, [sp, #4]
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080ada:	e9dd 5602 	ldrd	r5, r6, [sp, #8]
	p = ((p + var1 + var2) >> 8) + ((int64_t) dev->dig_P7 << 4);
 8080ade:	e9dd 0100 	ldrd	r0, r1, [sp]
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080ae2:	ea4f 48d5 	mov.w	r8, r5, lsr #19
	p = ((p + var1 + var2) >> 8) + ((int64_t) dev->dig_P7 << 4);
 8080ae6:	eb10 000a 	adds.w	r0, r0, sl
	var2 = ((int64_t) dev->dig_P8 * p) >> 19;
 8080aea:	ea4f 49e6 	mov.w	r9, r6, asr #19
 8080aee:	ea48 3846 	orr.w	r8, r8, r6, lsl #13
	p = ((p + var1 + var2) >> 8) + ((int64_t) dev->dig_P7 << 4);
 8080af2:	f9b4 6012 	ldrsh.w	r6, [r4, #18]
 8080af6:	eb41 010b 	adc.w	r1, r1, fp
 8080afa:	eb10 0a08 	adds.w	sl, r0, r8
 8080afe:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8080b02:	eb41 0b09 	adc.w	fp, r1, r9
 8080b06:	ea4f 231a 	mov.w	r3, sl, lsr #8
 8080b0a:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
	return p;
 8080b0e:	441e      	add	r6, r3
	*pressure = compensate_pressure(dev, adc_pressure, fine_temp);
 8080b10:	9b07      	ldr	r3, [sp, #28]
 8080b12:	601e      	str	r6, [r3, #0]

	// Only the BME280 supports reading the humidity.
	if (dev->id != BME280_CHIP_ID) {
 8080b14:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8080b18:	2b60      	cmp	r3, #96	; 0x60
 8080b1a:	d00d      	beq.n	8080b38 <bmp280_read_fixed+0x29c>
		*humidity = 0;
 8080b1c:	2300      	movs	r3, #0
 8080b1e:	9a08      	ldr	r2, [sp, #32]
 8080b20:	6013      	str	r3, [r2, #0]
	{
		*humidity = compensate_humidity(dev, adc_humidity, fine_temp);
	}

	return true;
}
 8080b22:	9806      	ldr	r0, [sp, #24]
 8080b24:	b00f      	add	sp, #60	; 0x3c
 8080b26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	*pressure = compensate_pressure(dev, adc_pressure, fine_temp);
 8080b2a:	9b07      	ldr	r3, [sp, #28]
		return 0;  // avoid exception caused by division by zero
 8080b2c:	2600      	movs	r6, #0
	*pressure = compensate_pressure(dev, adc_pressure, fine_temp);
 8080b2e:	601e      	str	r6, [r3, #0]
	if (dev->id != BME280_CHIP_ID) {
 8080b30:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8080b34:	2b60      	cmp	r3, #96	; 0x60
 8080b36:	d1f1      	bne.n	8080b1c <bmp280_read_fixed+0x280>
	v_x1_u32r = fine_temp - (int32_t) 76800;
 8080b38:	9b09      	ldr	r3, [sp, #36]	; 0x24
													* (((((((v_x1_u32r * (int32_t) dev->dig_H6) >> 10)
 8080b3a:	f994 2022 	ldrsb.w	r2, [r4, #34]	; 0x22
	v_x1_u32r = fine_temp - (int32_t) 76800;
 8080b3e:	f5a3 3596 	sub.w	r5, r3, #76800	; 0x12c00
															* (((v_x1_u32r * (int32_t) dev->dig_H3) >> 11)
 8080b42:	7f23      	ldrb	r3, [r4, #28]
	v_x1_u32r = ((((adc_hum << 14) - ((int32_t) dev->dig_H4 << 20)
 8080b44:	f9b4 101e 	ldrsh.w	r1, [r4, #30]
															* (((v_x1_u32r * (int32_t) dev->dig_H3) >> 11)
 8080b48:	fb05 f303 	mul.w	r3, r5, r3
	v_x1_u32r = ((((adc_hum << 14) - ((int32_t) dev->dig_H4 << 20)
 8080b4c:	980d      	ldr	r0, [sp, #52]	; 0x34
													* (((((((v_x1_u32r * (int32_t) dev->dig_H6) >> 10)
 8080b4e:	fb05 f202 	mul.w	r2, r5, r2
	v_x1_u32r = ((((adc_hum << 14) - ((int32_t) dev->dig_H4 << 20)
 8080b52:	0509      	lsls	r1, r1, #20
															* (((v_x1_u32r * (int32_t) dev->dig_H3) >> 11)
 8080b54:	12db      	asrs	r3, r3, #11
													* (((((((v_x1_u32r * (int32_t) dev->dig_H6) >> 10)
 8080b56:	1292      	asrs	r2, r2, #10
																	+ (int32_t) 32768)) >> 10) + (int32_t) 2097152)
 8080b58:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
	v_x1_u32r = ((((adc_hum << 14) - ((int32_t) dev->dig_H4 << 20)
 8080b5c:	ebc1 3080 	rsb	r0, r1, r0, lsl #14
			- ((int32_t) dev->dig_H5 * v_x1_u32r)) + (int32_t) 16384) >> 15)
 8080b60:	f9b4 1020 	ldrsh.w	r1, [r4, #32]
															* (((v_x1_u32r * (int32_t) dev->dig_H3) >> 11)
 8080b64:	fb02 f203 	mul.w	r2, r2, r3
															* (int32_t) dev->dig_H2 + 8192) >> 14);
 8080b68:	f9b4 301a 	ldrsh.w	r3, [r4, #26]
			- ((int32_t) dev->dig_H5 * v_x1_u32r)) + (int32_t) 16384) >> 15)
 8080b6c:	fb05 0111 	mls	r1, r5, r1, r0
					* (int32_t) dev->dig_H1) >> 4);
 8080b70:	7e20      	ldrb	r0, [r4, #24]
																	+ (int32_t) 32768)) >> 10) + (int32_t) 2097152)
 8080b72:	1292      	asrs	r2, r2, #10
			- ((int32_t) dev->dig_H5 * v_x1_u32r)) + (int32_t) 16384) >> 15)
 8080b74:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
																	+ (int32_t) 32768)) >> 10) + (int32_t) 2097152)
 8080b78:	f502 1200 	add.w	r2, r2, #2097152	; 0x200000
															* (int32_t) dev->dig_H2 + 8192) >> 14);
 8080b7c:	fb03 f302 	mul.w	r3, r3, r2
			- ((int32_t) dev->dig_H5 * v_x1_u32r)) + (int32_t) 16384) >> 15)
 8080b80:	13ca      	asrs	r2, r1, #15
															* (int32_t) dev->dig_H2 + 8192) >> 14);
 8080b82:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8080b86:	139b      	asrs	r3, r3, #14
	v_x1_u32r = ((((adc_hum << 14) - ((int32_t) dev->dig_H4 << 20)
 8080b88:	fb03 f302 	mul.w	r3, r3, r2
			- (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7)
 8080b8c:	13da      	asrs	r2, r3, #15
 8080b8e:	fb02 f202 	mul.w	r2, r2, r2
 8080b92:	11d2      	asrs	r2, r2, #7
					* (int32_t) dev->dig_H1) >> 4);
 8080b94:	fb00 f202 	mul.w	r2, r0, r2
}
 8080b98:	9806      	ldr	r0, [sp, #24]
	v_x1_u32r = v_x1_u32r
 8080b9a:	eba3 1322 	sub.w	r3, r3, r2, asr #4
		*humidity = compensate_humidity(dev, adc_humidity, fine_temp);
 8080b9e:	9a08      	ldr	r2, [sp, #32]
	v_x1_u32r = v_x1_u32r < 0 ? 0 : v_x1_u32r;
 8080ba0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
	v_x1_u32r = v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r;
 8080ba4:	f1b3 5fc8 	cmp.w	r3, #419430400	; 0x19000000
 8080ba8:	bfa8      	it	ge
 8080baa:	f04f 53c8 	movge.w	r3, #419430400	; 0x19000000
	return v_x1_u32r >> 12;
 8080bae:	131b      	asrs	r3, r3, #12
		*humidity = compensate_humidity(dev, adc_humidity, fine_temp);
 8080bb0:	6013      	str	r3, [r2, #0]
}
 8080bb2:	b00f      	add	sp, #60	; 0x3c
 8080bb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08080bb8 <bmp280_read_float>:

bool bmp280_read_float(BMP280_HandleTypedef *dev, float *temperature, float *pressure,
		float *humidity) {
 8080bb8:	b570      	push	{r4, r5, r6, lr}
 8080bba:	460c      	mov	r4, r1
 8080bbc:	b084      	sub	sp, #16
 8080bbe:	4615      	mov	r5, r2
	int32_t fixed_temperature;
	uint32_t fixed_pressure;
	uint32_t fixed_humidity;
	if (bmp280_read_fixed(dev, &fixed_temperature, &fixed_pressure,
 8080bc0:	b30b      	cbz	r3, 8080c06 <bmp280_read_float+0x4e>
 8080bc2:	461e      	mov	r6, r3
 8080bc4:	aa02      	add	r2, sp, #8
 8080bc6:	ab03      	add	r3, sp, #12
 8080bc8:	a901      	add	r1, sp, #4
 8080bca:	f7ff fe67 	bl	808089c <bmp280_read_fixed>
 8080bce:	b1f8      	cbz	r0, 8080c10 <bmp280_read_float+0x58>
			humidity ? &fixed_humidity : NULL)) {
		*temperature = (float) fixed_temperature / 100;
 8080bd0:	2300      	movs	r3, #0
 8080bd2:	eddd 7a01 	vldr	s15, [sp, #4]
		*pressure = (float) fixed_pressure / 256;
 8080bd6:	ed9d 7a02 	vldr	s14, [sp, #8]
		*temperature = (float) fixed_temperature / 100;
 8080bda:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
 8080bde:	eef8 6ae7 	vcvt.f32.s32	s13, s15
		*pressure = (float) fixed_pressure / 256;
 8080be2:	eebb 7acc 	vcvt.f32.u32	s14, s14, #8
		*temperature = (float) fixed_temperature / 100;
 8080be6:	ee07 3a90 	vmov	s15, r3
 8080bea:	ee86 6aa7 	vdiv.f32	s12, s13, s15
		if (humidity)
			*humidity = (float) fixed_humidity / 1024;
 8080bee:	eddd 7a03 	vldr	s15, [sp, #12]
 8080bf2:	eefb 7acb 	vcvt.f32.u32	s15, s15, #10
		*temperature = (float) fixed_temperature / 100;
 8080bf6:	ed84 6a00 	vstr	s12, [r4]
		*pressure = (float) fixed_pressure / 256;
 8080bfa:	ed85 7a00 	vstr	s14, [r5]
			*humidity = (float) fixed_humidity / 1024;
 8080bfe:	edc6 7a00 	vstr	s15, [r6]
		return true;
	}

	return false;
}
 8080c02:	b004      	add	sp, #16
 8080c04:	bd70      	pop	{r4, r5, r6, pc}
	if (bmp280_read_fixed(dev, &fixed_temperature, &fixed_pressure,
 8080c06:	aa02      	add	r2, sp, #8
 8080c08:	a901      	add	r1, sp, #4
 8080c0a:	f7ff fe47 	bl	808089c <bmp280_read_fixed>
 8080c0e:	b910      	cbnz	r0, 8080c16 <bmp280_read_float+0x5e>
	return false;
 8080c10:	2000      	movs	r0, #0
}
 8080c12:	b004      	add	sp, #16
 8080c14:	bd70      	pop	{r4, r5, r6, pc}
		*temperature = (float) fixed_temperature / 100;
 8080c16:	2300      	movs	r3, #0
 8080c18:	eddd 7a01 	vldr	s15, [sp, #4]
		*pressure = (float) fixed_pressure / 256;
 8080c1c:	ed9d 7a02 	vldr	s14, [sp, #8]
		*temperature = (float) fixed_temperature / 100;
 8080c20:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
 8080c24:	eef8 6ae7 	vcvt.f32.s32	s13, s15
		*pressure = (float) fixed_pressure / 256;
 8080c28:	eebb 7acc 	vcvt.f32.u32	s14, s14, #8
		*temperature = (float) fixed_temperature / 100;
 8080c2c:	ee07 3a90 	vmov	s15, r3
 8080c30:	ee86 6aa7 	vdiv.f32	s12, s13, s15
 8080c34:	ed84 6a00 	vstr	s12, [r4]
		*pressure = (float) fixed_pressure / 256;
 8080c38:	ed85 7a00 	vstr	s14, [r5]
}
 8080c3c:	b004      	add	sp, #16
 8080c3e:	bd70      	pop	{r4, r5, r6, pc}

08080c40 <ft5336_Reset>:
  */
void ft5336_Reset(uint16_t DeviceAddr)
{
  /* Do nothing */
  /* No software reset sequence available in FT5336 IC */
}
 8080c40:	4770      	bx	lr
 8080c42:	bf00      	nop

08080c44 <ft5336_TS_ITStatus>:
  */
uint8_t ft5336_TS_ITStatus(uint16_t DeviceAddr)
{
  /* Always return 0 as feature not applicable to FT5336 */
  return 0;
}
 8080c44:	2000      	movs	r0, #0
 8080c46:	4770      	bx	lr

08080c48 <ft5336_Init>:
{
 8080c48:	b510      	push	{r4, lr}
  * @param  None.
  * @retval : I2C initialization status.
  */
static uint8_t ft5336_Get_I2C_InitializedStatus(void)
{
  return(ft5336_handle.i2cInitialized);
 8080c4a:	f24b 4400 	movw	r4, #46080	; 0xb400
  TS_IO_Delay(200);
 8080c4e:	20c8      	movs	r0, #200	; 0xc8
 8080c50:	f001 fb50 	bl	80822f4 <TS_IO_Delay>
  return(ft5336_handle.i2cInitialized);
 8080c54:	f2c2 0400 	movt	r4, #8192	; 0x2000
  * @param  None.
  * @retval : None.
  */
static void ft5336_I2C_InitializeIfRequired(void)
{
  if(ft5336_Get_I2C_InitializedStatus() == FT5336_I2C_NOT_INITIALIZED)
 8080c58:	7823      	ldrb	r3, [r4, #0]
 8080c5a:	b103      	cbz	r3, 8080c5e <ft5336_Init+0x16>
}
 8080c5c:	bd10      	pop	{r4, pc}
  {
    /* Initialize TS IO BUS layer (I2C) */
    TS_IO_Init();
 8080c5e:	f001 fb1d 	bl	808229c <TS_IO_Init>

    /* Set state to initialized */
    ft5336_handle.i2cInitialized = FT5336_I2C_INITIALIZED;
 8080c62:	2301      	movs	r3, #1
 8080c64:	7023      	strb	r3, [r4, #0]
}
 8080c66:	bd10      	pop	{r4, pc}

08080c68 <ft5336_ReadID>:
{
 8080c68:	b530      	push	{r4, r5, lr}
  return(ft5336_handle.i2cInitialized);
 8080c6a:	f24b 4400 	movw	r4, #46080	; 0xb400
  volatile uint8_t ucReadId = 0;
 8080c6e:	2300      	movs	r3, #0
{
 8080c70:	b083      	sub	sp, #12
 8080c72:	4605      	mov	r5, r0
  return(ft5336_handle.i2cInitialized);
 8080c74:	f2c2 0400 	movt	r4, #8192	; 0x2000
  volatile uint8_t ucReadId = 0;
 8080c78:	f88d 3007 	strb.w	r3, [sp, #7]
  if(ft5336_Get_I2C_InitializedStatus() == FT5336_I2C_NOT_INITIALIZED)
 8080c7c:	7823      	ldrb	r3, [r4, #0]
 8080c7e:	b1ab      	cbz	r3, 8080cac <ft5336_ReadID+0x44>
 8080c80:	b2ed      	uxtb	r5, r5
{
 8080c82:	2400      	movs	r4, #0
 8080c84:	e001      	b.n	8080c8a <ft5336_ReadID+0x22>
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8080c86:	2b51      	cmp	r3, #81	; 0x51
 8080c88:	d00c      	beq.n	8080ca4 <ft5336_ReadID+0x3c>
 8080c8a:	3401      	adds	r4, #1
    ucReadId = TS_IO_Read(DeviceAddr, FT5336_CHIP_ID_REG);
 8080c8c:	21a8      	movs	r1, #168	; 0xa8
 8080c8e:	4628      	mov	r0, r5
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8080c90:	b2e4      	uxtb	r4, r4
    ucReadId = TS_IO_Read(DeviceAddr, FT5336_CHIP_ID_REG);
 8080c92:	f001 fb19 	bl	80822c8 <TS_IO_Read>
 8080c96:	f88d 0007 	strb.w	r0, [sp, #7]
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8080c9a:	2c02      	cmp	r4, #2
    if(ucReadId == FT5336_ID_VALUE)
 8080c9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080ca0:	b2db      	uxtb	r3, r3
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 8080ca2:	d9f0      	bls.n	8080c86 <ft5336_ReadID+0x1e>
  return (ucReadId);
 8080ca4:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8080ca8:	b003      	add	sp, #12
 8080caa:	bd30      	pop	{r4, r5, pc}
    TS_IO_Init();
 8080cac:	f001 faf6 	bl	808229c <TS_IO_Init>
    ft5336_handle.i2cInitialized = FT5336_I2C_INITIALIZED;
 8080cb0:	2301      	movs	r3, #1
 8080cb2:	7023      	strb	r3, [r4, #0]
 8080cb4:	e7e4      	b.n	8080c80 <ft5336_ReadID+0x18>
 8080cb6:	bf00      	nop

08080cb8 <ft5336_TS_DetectTouch>:
{
 8080cb8:	b510      	push	{r4, lr}
  volatile uint8_t nbTouch = 0;
 8080cba:	2400      	movs	r4, #0
{
 8080cbc:	b082      	sub	sp, #8
  nbTouch = TS_IO_Read(DeviceAddr, FT5336_TD_STAT_REG);
 8080cbe:	b2c0      	uxtb	r0, r0
 8080cc0:	2102      	movs	r1, #2
  volatile uint8_t nbTouch = 0;
 8080cc2:	f88d 4007 	strb.w	r4, [sp, #7]
  nbTouch = TS_IO_Read(DeviceAddr, FT5336_TD_STAT_REG);
 8080cc6:	f001 faff 	bl	80822c8 <TS_IO_Read>
 8080cca:	f88d 0007 	strb.w	r0, [sp, #7]
  nbTouch &= FT5336_TD_STAT_MASK;
 8080cce:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080cd2:	f003 030f 	and.w	r3, r3, #15
 8080cd6:	f88d 3007 	strb.w	r3, [sp, #7]
  if(nbTouch > FT5336_MAX_DETECTABLE_TOUCH)
 8080cda:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080cde:	2b05      	cmp	r3, #5
 8080ce0:	d901      	bls.n	8080ce6 <ft5336_TS_DetectTouch+0x2e>
    nbTouch = 0;
 8080ce2:	f88d 4007 	strb.w	r4, [sp, #7]
  ft5336_handle.currActiveTouchNb = nbTouch;
 8080ce6:	f24b 4300 	movw	r3, #46080	; 0xb400
 8080cea:	f89d 1007 	ldrb.w	r1, [sp, #7]
  ft5336_handle.currActiveTouchIdx = 0;
 8080cee:	2200      	movs	r2, #0
  return(nbTouch);
 8080cf0:	f89d 0007 	ldrb.w	r0, [sp, #7]
  ft5336_handle.currActiveTouchNb = nbTouch;
 8080cf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8080cf8:	7059      	strb	r1, [r3, #1]
  ft5336_handle.currActiveTouchIdx = 0;
 8080cfa:	709a      	strb	r2, [r3, #2]
}
 8080cfc:	b002      	add	sp, #8
 8080cfe:	bd10      	pop	{r4, pc}

08080d00 <ft5336_TS_GetXY>:
{
 8080d00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8080d04:	f24b 4400 	movw	r4, #46080	; 0xb400
{
 8080d08:	b083      	sub	sp, #12
  volatile uint8_t ucReadData = 0;
 8080d0a:	f04f 0800 	mov.w	r8, #0
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8080d0e:	f2c2 0400 	movt	r4, #8192	; 0x2000
  volatile uint8_t ucReadData = 0;
 8080d12:	f88d 8007 	strb.w	r8, [sp, #7]
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8080d16:	78a3      	ldrb	r3, [r4, #2]
 8080d18:	7865      	ldrb	r5, [r4, #1]
 8080d1a:	429d      	cmp	r5, r3
 8080d1c:	d955      	bls.n	8080dca <ft5336_TS_GetXY+0xca>
 8080d1e:	2b09      	cmp	r3, #9
 8080d20:	d856      	bhi.n	8080dd0 <ft5336_TS_GetXY+0xd0>
 8080d22:	f642 1618 	movw	r6, #10520	; 0x2918
 8080d26:	f642 1c24 	movw	ip, #10532	; 0x2924
 8080d2a:	f642 1730 	movw	r7, #10544	; 0x2930
 8080d2e:	f642 153c 	movw	r5, #10556	; 0x293c
 8080d32:	f6c0 0609 	movt	r6, #2057	; 0x809
 8080d36:	f6c0 0c09 	movt	ip, #2057	; 0x809
 8080d3a:	f6c0 0709 	movt	r7, #2057	; 0x809
 8080d3e:	f6c0 0509 	movt	r5, #2057	; 0x809
 8080d42:	5cf6      	ldrb	r6, [r6, r3]
 8080d44:	f81c b003 	ldrb.w	fp, [ip, r3]
 8080d48:	f817 a003 	ldrb.w	sl, [r7, r3]
 8080d4c:	f815 8003 	ldrb.w	r8, [r5, r3]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXLow);
 8080d50:	b2c5      	uxtb	r5, r0
 8080d52:	4689      	mov	r9, r1
 8080d54:	4631      	mov	r1, r6
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8080d56:	f24b 36fc 	movw	r6, #46076	; 0xb3fc
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXLow);
 8080d5a:	4628      	mov	r0, r5
 8080d5c:	4617      	mov	r7, r2
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8080d5e:	f2c2 0600 	movt	r6, #8192	; 0x2000
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXLow);
 8080d62:	f001 fab1 	bl	80822c8 <TS_IO_Read>
 8080d66:	f88d 0007 	strb.w	r0, [sp, #7]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8080d6a:	4659      	mov	r1, fp
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8080d6c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8080d70:	4628      	mov	r0, r5
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8080d72:	8033      	strh	r3, [r6, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8080d74:	f001 faa8 	bl	80822c8 <TS_IO_Read>
 8080d78:	4603      	mov	r3, r0
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8080d7a:	8832      	ldrh	r2, [r6, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 8080d7c:	4651      	mov	r1, sl
 8080d7e:	4628      	mov	r0, r5
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8080d80:	f88d 3007 	strb.w	r3, [sp, #7]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8080d84:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080d88:	021b      	lsls	r3, r3, #8
 8080d8a:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8080d8e:	4313      	orrs	r3, r2
    *X = coord;
 8080d90:	f8a9 3000 	strh.w	r3, [r9]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8080d94:	8033      	strh	r3, [r6, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 8080d96:	f001 fa97 	bl	80822c8 <TS_IO_Read>
 8080d9a:	4603      	mov	r3, r0
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYHigh);
 8080d9c:	4641      	mov	r1, r8
 8080d9e:	4628      	mov	r0, r5
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 8080da0:	f88d 3007 	strb.w	r3, [sp, #7]
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 8080da4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080da8:	8033      	strh	r3, [r6, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYHigh);
 8080daa:	f001 fa8d 	bl	80822c8 <TS_IO_Read>
 8080dae:	f88d 0007 	strb.w	r0, [sp, #7]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8080db2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080db6:	8831      	ldrh	r1, [r6, #0]
 8080db8:	021b      	lsls	r3, r3, #8
    ft5336_handle.currActiveTouchIdx++; /* next call will work on next touch */
 8080dba:	78a2      	ldrb	r2, [r4, #2]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8080dbc:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    ft5336_handle.currActiveTouchIdx++; /* next call will work on next touch */
 8080dc0:	3201      	adds	r2, #1
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8080dc2:	430b      	orrs	r3, r1
    ft5336_handle.currActiveTouchIdx++; /* next call will work on next touch */
 8080dc4:	70a2      	strb	r2, [r4, #2]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 8080dc6:	8033      	strh	r3, [r6, #0]
    *Y = coord;
 8080dc8:	803b      	strh	r3, [r7, #0]
}
 8080dca:	b003      	add	sp, #12
 8080dcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 8080dd0:	46c2      	mov	sl, r8
 8080dd2:	46c3      	mov	fp, r8
 8080dd4:	4646      	mov	r6, r8
 8080dd6:	e7bb      	b.n	8080d50 <ft5336_TS_GetXY+0x50>

08080dd8 <ft5336_TS_EnableIT>:
   TS_IO_Write(DeviceAddr, FT5336_GMODE_REG, regValue);
 8080dd8:	b2c0      	uxtb	r0, r0
 8080dda:	2201      	movs	r2, #1
 8080ddc:	21a4      	movs	r1, #164	; 0xa4
 8080dde:	f001 ba5f 	b.w	80822a0 <TS_IO_Write>
 8080de2:	bf00      	nop

08080de4 <ft5336_TS_Start>:
  TS_IO_Write(DeviceAddr, FT5336_GMODE_REG, regValue);
 8080de4:	b2c0      	uxtb	r0, r0
 8080de6:	2200      	movs	r2, #0
 8080de8:	21a4      	movs	r1, #164	; 0xa4
 8080dea:	f001 ba59 	b.w	80822a0 <TS_IO_Write>
 8080dee:	bf00      	nop

08080df0 <ft5336_TS_DisableIT>:
 8080df0:	f7ff bff8 	b.w	8080de4 <ft5336_TS_Start>

08080df4 <ft5336_TS_ClearIT>:
 8080df4:	4770      	bx	lr
 8080df6:	bf00      	nop

08080df8 <ft5336_TS_GetGestureID>:
{
 8080df8:	b510      	push	{r4, lr}
  volatile uint8_t ucReadData = 0;
 8080dfa:	2300      	movs	r3, #0
{
 8080dfc:	b082      	sub	sp, #8
 8080dfe:	460c      	mov	r4, r1
  ucReadData = TS_IO_Read(DeviceAddr, FT5336_GEST_ID_REG);
 8080e00:	b2c0      	uxtb	r0, r0
 8080e02:	2101      	movs	r1, #1
  volatile uint8_t ucReadData = 0;
 8080e04:	f88d 3007 	strb.w	r3, [sp, #7]
  ucReadData = TS_IO_Read(DeviceAddr, FT5336_GEST_ID_REG);
 8080e08:	f001 fa5e 	bl	80822c8 <TS_IO_Read>
 8080e0c:	f88d 0007 	strb.w	r0, [sp, #7]
  * pGestureId = ucReadData;
 8080e10:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080e14:	6023      	str	r3, [r4, #0]
}
 8080e16:	b002      	add	sp, #8
 8080e18:	bd10      	pop	{r4, pc}
 8080e1a:	bf00      	nop

08080e1c <ft5336_TS_GetTouchInfo>:
{
 8080e1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 8080e20:	f24b 4400 	movw	r4, #46080	; 0xb400
{
 8080e24:	b082      	sub	sp, #8
  volatile uint8_t ucReadData = 0;
 8080e26:	2500      	movs	r5, #0
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 8080e28:	f2c2 0400 	movt	r4, #8192	; 0x2000
  volatile uint8_t ucReadData = 0;
 8080e2c:	f88d 5007 	strb.w	r5, [sp, #7]
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 8080e30:	7864      	ldrb	r4, [r4, #1]
 8080e32:	428c      	cmp	r4, r1
 8080e34:	d937      	bls.n	8080ea6 <ft5336_TS_GetTouchInfo+0x8a>
 8080e36:	2909      	cmp	r1, #9
 8080e38:	d838      	bhi.n	8080eac <ft5336_TS_GetTouchInfo+0x90>
 8080e3a:	f642 1648 	movw	r6, #10568	; 0x2948
 8080e3e:	f642 1554 	movw	r5, #10580	; 0x2954
 8080e42:	f642 1460 	movw	r4, #10592	; 0x2960
 8080e46:	f6c0 0509 	movt	r5, #2057	; 0x809
 8080e4a:	f6c0 0609 	movt	r6, #2057	; 0x809
 8080e4e:	f6c0 0409 	movt	r4, #2057	; 0x809
 8080e52:	f815 8001 	ldrb.w	r8, [r5, r1]
 8080e56:	f816 c001 	ldrb.w	ip, [r6, r1]
 8080e5a:	5c65      	ldrb	r5, [r4, r1]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8080e5c:	b2c4      	uxtb	r4, r0
 8080e5e:	4661      	mov	r1, ip
 8080e60:	461e      	mov	r6, r3
 8080e62:	4617      	mov	r7, r2
 8080e64:	4620      	mov	r0, r4
 8080e66:	f001 fa2f 	bl	80822c8 <TS_IO_Read>
 8080e6a:	4603      	mov	r3, r0
    * pEvent = (ucReadData & FT5336_TOUCH_EVT_FLAG_MASK) >> FT5336_TOUCH_EVT_FLAG_SHIFT;
 8080e6c:	9a08      	ldr	r2, [sp, #32]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 8080e6e:	4641      	mov	r1, r8
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 8080e70:	f88d 3007 	strb.w	r3, [sp, #7]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 8080e74:	4620      	mov	r0, r4
    * pEvent = (ucReadData & FT5336_TOUCH_EVT_FLAG_MASK) >> FT5336_TOUCH_EVT_FLAG_SHIFT;
 8080e76:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080e7a:	099b      	lsrs	r3, r3, #6
 8080e7c:	6013      	str	r3, [r2, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 8080e7e:	f001 fa23 	bl	80822c8 <TS_IO_Read>
 8080e82:	4603      	mov	r3, r0
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPMisc);
 8080e84:	4629      	mov	r1, r5
 8080e86:	4620      	mov	r0, r4
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 8080e88:	f88d 3007 	strb.w	r3, [sp, #7]
    * pWeight = (ucReadData & FT5336_TOUCH_WEIGHT_MASK) >> FT5336_TOUCH_WEIGHT_SHIFT;
 8080e8c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8080e90:	603b      	str	r3, [r7, #0]
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPMisc);
 8080e92:	f001 fa19 	bl	80822c8 <TS_IO_Read>
 8080e96:	f88d 0007 	strb.w	r0, [sp, #7]
    * pArea = (ucReadData & FT5336_TOUCH_AREA_MASK) >> FT5336_TOUCH_AREA_SHIFT;
 8080e9a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8080e9e:	0912      	lsrs	r2, r2, #4
 8080ea0:	f002 0204 	and.w	r2, r2, #4
 8080ea4:	6032      	str	r2, [r6, #0]
}
 8080ea6:	b002      	add	sp, #8
 8080ea8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(touchIdx < ft5336_handle.currActiveTouchNb)
 8080eac:	46a8      	mov	r8, r5
 8080eae:	46ac      	mov	ip, r5
 8080eb0:	e7d4      	b.n	8080e5c <ft5336_TS_GetTouchInfo+0x40>
 8080eb2:	bf00      	nop

08080eb4 <lis2mdl_from_lsb_to_mgauss>:
  * @{
  *
  */
float_t lis2mdl_from_lsb_to_mgauss(int16_t lsb)
{
  return ((float_t)lsb * 1.5f);
 8080eb4:	ee07 0a90 	vmov	s15, r0
 8080eb8:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 8080ebc:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
}
 8080ec0:	ee20 0a27 	vmul.f32	s0, s0, s15
 8080ec4:	4770      	bx	lr
 8080ec6:	bf00      	nop

08080ec8 <lis2mdl_from_lsb_to_celsius>:

float_t lis2mdl_from_lsb_to_celsius(int16_t lsb)
{
  return (((float_t)lsb / 8.0f) + 25.0f);
 8080ec8:	ee07 0a90 	vmov	s15, r0
 8080ecc:	eeb3 0a09 	vmov.f32	s0, #57	; 0x41c80000  25.0
 8080ed0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8080ed4:	eef4 7a00 	vmov.f32	s15, #64	; 0x3e000000  0.125
}
 8080ed8:	eea7 0a27 	vfma.f32	s0, s14, s15
 8080edc:	4770      	bx	lr
 8080ede:	bf00      	nop

08080ee0 <lis2mdl_operating_mode_set>:
  * @param  val    change the values of md in reg CFG_REG_A
  * @retval        interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_operating_mode_set(lis2mdl_ctx_t *ctx, lis2mdl_md_t val)
{
 8080ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8080ee2:	b083      	sub	sp, #12
 8080ee4:	4604      	mov	r4, r0
 8080ee6:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8080ee8:	6845      	ldr	r5, [r0, #4]
 8080eea:	2301      	movs	r3, #1
 8080eec:	aa01      	add	r2, sp, #4
 8080eee:	6880      	ldr	r0, [r0, #8]
 8080ef0:	2160      	movs	r1, #96	; 0x60
 8080ef2:	47a8      	blx	r5
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 8080ef4:	b958      	cbnz	r0, 8080f0e <lis2mdl_operating_mode_set+0x2e>
    reg.md = (uint8_t)val;
 8080ef6:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080efa:	aa01      	add	r2, sp, #4
 8080efc:	6827      	ldr	r7, [r4, #0]
 8080efe:	2301      	movs	r3, #1
    reg.md = (uint8_t)val;
 8080f00:	f366 0501 	bfi	r5, r6, #0, #2
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f04:	68a0      	ldr	r0, [r4, #8]
 8080f06:	2160      	movs	r1, #96	; 0x60
    reg.md = (uint8_t)val;
 8080f08:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f0c:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 8080f0e:	b003      	add	sp, #12
 8080f10:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8080f12:	bf00      	nop

08080f14 <lis2mdl_data_rate_set>:
  * @param  val   change the values of odr in reg CFG_REG_A
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_data_rate_set(lis2mdl_ctx_t *ctx, lis2mdl_odr_t val)
{
 8080f14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8080f16:	b083      	sub	sp, #12
 8080f18:	4604      	mov	r4, r0
 8080f1a:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8080f1c:	6845      	ldr	r5, [r0, #4]
 8080f1e:	2301      	movs	r3, #1
 8080f20:	aa01      	add	r2, sp, #4
 8080f22:	6880      	ldr	r0, [r0, #8]
 8080f24:	2160      	movs	r1, #96	; 0x60
 8080f26:	47a8      	blx	r5
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 8080f28:	b958      	cbnz	r0, 8080f42 <lis2mdl_data_rate_set+0x2e>
    reg.odr = (uint8_t)val;
 8080f2a:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f2e:	aa01      	add	r2, sp, #4
 8080f30:	6827      	ldr	r7, [r4, #0]
 8080f32:	2301      	movs	r3, #1
    reg.odr = (uint8_t)val;
 8080f34:	f366 0583 	bfi	r5, r6, #2, #2
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f38:	68a0      	ldr	r0, [r4, #8]
 8080f3a:	2160      	movs	r1, #96	; 0x60
    reg.odr = (uint8_t)val;
 8080f3c:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f40:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 8080f42:	b003      	add	sp, #12
 8080f44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8080f46:	bf00      	nop

08080f48 <lis2mdl_offset_temp_comp_set>:
  * @param  val   change the values of comp_temp_en in reg CFG_REG_A
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_offset_temp_comp_set(lis2mdl_ctx_t *ctx, uint8_t val)
{
 8080f48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8080f4a:	b083      	sub	sp, #12
 8080f4c:	4604      	mov	r4, r0
 8080f4e:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8080f50:	6845      	ldr	r5, [r0, #4]
 8080f52:	2301      	movs	r3, #1
 8080f54:	aa01      	add	r2, sp, #4
 8080f56:	6880      	ldr	r0, [r0, #8]
 8080f58:	2160      	movs	r1, #96	; 0x60
 8080f5a:	47a8      	blx	r5
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 8080f5c:	b958      	cbnz	r0, 8080f76 <lis2mdl_offset_temp_comp_set+0x2e>
    reg.comp_temp_en = val;
 8080f5e:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f62:	aa01      	add	r2, sp, #4
 8080f64:	6827      	ldr	r7, [r4, #0]
 8080f66:	2301      	movs	r3, #1
    reg.comp_temp_en = val;
 8080f68:	f366 15c7 	bfi	r5, r6, #7, #1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f6c:	68a0      	ldr	r0, [r4, #8]
 8080f6e:	2160      	movs	r1, #96	; 0x60
    reg.comp_temp_en = val;
 8080f70:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f74:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 8080f76:	b003      	add	sp, #12
 8080f78:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8080f7a:	bf00      	nop

08080f7c <lis2mdl_low_pass_bandwidth_set>:
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_low_pass_bandwidth_set(lis2mdl_ctx_t *ctx,
                                       lis2mdl_lpf_t val)
{
 8080f7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8080f7e:	b083      	sub	sp, #12
 8080f80:	4604      	mov	r4, r0
 8080f82:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8080f84:	6845      	ldr	r5, [r0, #4]
 8080f86:	2301      	movs	r3, #1
 8080f88:	aa01      	add	r2, sp, #4
 8080f8a:	6880      	ldr	r0, [r0, #8]
 8080f8c:	2161      	movs	r1, #97	; 0x61
 8080f8e:	47a8      	blx	r5
  lis2mdl_cfg_reg_b_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_B, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 8080f90:	b958      	cbnz	r0, 8080faa <lis2mdl_low_pass_bandwidth_set+0x2e>
    reg.lpf = (uint8_t)val;
 8080f92:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080f96:	aa01      	add	r2, sp, #4
 8080f98:	6827      	ldr	r7, [r4, #0]
 8080f9a:	2301      	movs	r3, #1
    reg.lpf = (uint8_t)val;
 8080f9c:	f366 0500 	bfi	r5, r6, #0, #1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080fa0:	68a0      	ldr	r0, [r4, #8]
 8080fa2:	2161      	movs	r1, #97	; 0x61
    reg.lpf = (uint8_t)val;
 8080fa4:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080fa8:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_B, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 8080faa:	b003      	add	sp, #12
 8080fac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8080fae:	bf00      	nop

08080fb0 <lis2mdl_set_rst_mode_set>:
  * @param  val   change the values of set_rst in reg CFG_REG_B
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_set_rst_mode_set(lis2mdl_ctx_t *ctx, lis2mdl_set_rst_t val)
{
 8080fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8080fb2:	b083      	sub	sp, #12
 8080fb4:	4604      	mov	r4, r0
 8080fb6:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8080fb8:	6845      	ldr	r5, [r0, #4]
 8080fba:	2301      	movs	r3, #1
 8080fbc:	aa01      	add	r2, sp, #4
 8080fbe:	6880      	ldr	r0, [r0, #8]
 8080fc0:	2161      	movs	r1, #97	; 0x61
 8080fc2:	47a8      	blx	r5
  lis2mdl_cfg_reg_b_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_B, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 8080fc4:	b958      	cbnz	r0, 8080fde <lis2mdl_set_rst_mode_set+0x2e>
    reg.set_rst = (uint8_t)val;
 8080fc6:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080fca:	aa01      	add	r2, sp, #4
 8080fcc:	6827      	ldr	r7, [r4, #0]
 8080fce:	2301      	movs	r3, #1
    reg.set_rst = (uint8_t)val;
 8080fd0:	f366 0542 	bfi	r5, r6, #1, #2
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080fd4:	68a0      	ldr	r0, [r4, #8]
 8080fd6:	2161      	movs	r1, #97	; 0x61
    reg.set_rst = (uint8_t)val;
 8080fd8:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080fdc:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_B, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 8080fde:	b003      	add	sp, #12
 8080fe0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8080fe2:	bf00      	nop

08080fe4 <lis2mdl_block_data_update_set>:
  * @param  val   change the values of bdu in reg CFG_REG_C
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_block_data_update_set(lis2mdl_ctx_t *ctx, uint8_t val)
{
 8080fe4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8080fe6:	b083      	sub	sp, #12
 8080fe8:	4604      	mov	r4, r0
 8080fea:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8080fec:	6845      	ldr	r5, [r0, #4]
 8080fee:	2301      	movs	r3, #1
 8080ff0:	aa01      	add	r2, sp, #4
 8080ff2:	6880      	ldr	r0, [r0, #8]
 8080ff4:	2162      	movs	r1, #98	; 0x62
 8080ff6:	47a8      	blx	r5
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 8080ff8:	b958      	cbnz	r0, 8081012 <lis2mdl_block_data_update_set+0x2e>
    reg.bdu = val;
 8080ffa:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8080ffe:	aa01      	add	r2, sp, #4
 8081000:	6827      	ldr	r7, [r4, #0]
 8081002:	2301      	movs	r3, #1
    reg.bdu = val;
 8081004:	f366 1504 	bfi	r5, r6, #4, #1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081008:	68a0      	ldr	r0, [r4, #8]
 808100a:	2162      	movs	r1, #98	; 0x62
    reg.bdu = val;
 808100c:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081010:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 8081012:	b003      	add	sp, #12
 8081014:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8081016:	bf00      	nop

08081018 <lis2mdl_mag_data_ready_get>:
  * @param  val   change the values of zyxda in reg STATUS_REG.(ptr)
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_mag_data_ready_get(lis2mdl_ctx_t *ctx, uint8_t *val)
{
 8081018:	b530      	push	{r4, r5, lr}
 808101a:	b083      	sub	sp, #12
 808101c:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 808101e:	6845      	ldr	r5, [r0, #4]
 8081020:	2301      	movs	r3, #1
 8081022:	aa01      	add	r2, sp, #4
 8081024:	2167      	movs	r1, #103	; 0x67
 8081026:	6880      	ldr	r0, [r0, #8]
 8081028:	47a8      	blx	r5
  lis2mdl_status_reg_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_STATUS_REG, (uint8_t*)&reg, 1);
  *val = reg.zyxda;
 808102a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 808102e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8081032:	7023      	strb	r3, [r4, #0]

  return ret;
}
 8081034:	b003      	add	sp, #12
 8081036:	bd30      	pop	{r4, r5, pc}

08081038 <lis2mdl_magnetic_raw_get>:
  * @param  buff  that stores data read
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_magnetic_raw_get(lis2mdl_ctx_t *ctx, uint8_t *buff)
{
 8081038:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 808103a:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 808103e:	460a      	mov	r2, r1
 8081040:	2306      	movs	r3, #6
 8081042:	46a4      	mov	ip, r4
 8081044:	2168      	movs	r1, #104	; 0x68
  int32_t ret;
  ret = lis2mdl_read_reg(ctx, LIS2MDL_OUTX_L_REG, buff, 6);
  return ret;
}
 8081046:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 808104a:	4760      	bx	ip

0808104c <lis2mdl_temperature_raw_get>:
  * @param  buff  that stores data read
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_temperature_raw_get(lis2mdl_ctx_t *ctx, uint8_t *buff)
{
 808104c:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 808104e:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 8081052:	460a      	mov	r2, r1
 8081054:	2302      	movs	r3, #2
 8081056:	46a4      	mov	ip, r4
 8081058:	216e      	movs	r1, #110	; 0x6e
  int32_t ret;
  ret = lis2mdl_read_reg(ctx, LIS2MDL_TEMP_OUT_L_REG, buff, 2);
  return ret;
}
 808105a:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 808105e:	4760      	bx	ip

08081060 <lis2mdl_device_id_get>:
  * @param  buff  that stores data read
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_device_id_get(lis2mdl_ctx_t *ctx, uint8_t *buff)
{
 8081060:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081062:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 8081066:	460a      	mov	r2, r1
 8081068:	2301      	movs	r3, #1
 808106a:	46a4      	mov	ip, r4
 808106c:	214f      	movs	r1, #79	; 0x4f
  int32_t ret;
  ret = lis2mdl_read_reg(ctx, LIS2MDL_WHO_AM_I, buff, 1);
  return ret;
}
 808106e:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081072:	4760      	bx	ip

08081074 <lis2mdl_reset_set>:
  * @param  val   change the values of soft_rst in reg CFG_REG_A
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_reset_set(lis2mdl_ctx_t *ctx, uint8_t val)
{
 8081074:	b5f0      	push	{r4, r5, r6, r7, lr}
 8081076:	b083      	sub	sp, #12
 8081078:	4604      	mov	r4, r0
 808107a:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 808107c:	6845      	ldr	r5, [r0, #4]
 808107e:	2301      	movs	r3, #1
 8081080:	aa01      	add	r2, sp, #4
 8081082:	6880      	ldr	r0, [r0, #8]
 8081084:	2160      	movs	r1, #96	; 0x60
 8081086:	47a8      	blx	r5
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 8081088:	b958      	cbnz	r0, 80810a2 <lis2mdl_reset_set+0x2e>
    reg.soft_rst = val;
 808108a:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 808108e:	aa01      	add	r2, sp, #4
 8081090:	6827      	ldr	r7, [r4, #0]
 8081092:	2301      	movs	r3, #1
    reg.soft_rst = val;
 8081094:	f366 1545 	bfi	r5, r6, #5, #1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081098:	68a0      	ldr	r0, [r4, #8]
 808109a:	2160      	movs	r1, #96	; 0x60
    reg.soft_rst = val;
 808109c:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80810a0:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 80810a2:	b003      	add	sp, #12
 80810a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80810a6:	bf00      	nop

080810a8 <lis2mdl_reset_get>:
  * @param  val   change the values of soft_rst in reg CFG_REG_A.(ptr)
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_reset_get(lis2mdl_ctx_t *ctx, uint8_t *val)
{
 80810a8:	b530      	push	{r4, r5, lr}
 80810aa:	b083      	sub	sp, #12
 80810ac:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80810ae:	6845      	ldr	r5, [r0, #4]
 80810b0:	2301      	movs	r3, #1
 80810b2:	aa01      	add	r2, sp, #4
 80810b4:	2160      	movs	r1, #96	; 0x60
 80810b6:	6880      	ldr	r0, [r0, #8]
 80810b8:	47a8      	blx	r5
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t*)&reg, 1);
  *val = reg.soft_rst;
 80810ba:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80810be:	f3c3 1340 	ubfx	r3, r3, #5, #1
 80810c2:	7023      	strb	r3, [r4, #0]

  return ret;
}
 80810c4:	b003      	add	sp, #12
 80810c6:	bd30      	pop	{r4, r5, pc}

080810c8 <lis2mdl_drdy_on_pin_set>:
  * @param  val   change the values of drdy_on_pin in reg CFG_REG_C
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_drdy_on_pin_set(lis2mdl_ctx_t *ctx, uint8_t val)
{
 80810c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80810ca:	b083      	sub	sp, #12
 80810cc:	4604      	mov	r4, r0
 80810ce:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80810d0:	6845      	ldr	r5, [r0, #4]
 80810d2:	2301      	movs	r3, #1
 80810d4:	aa01      	add	r2, sp, #4
 80810d6:	6880      	ldr	r0, [r0, #8]
 80810d8:	2162      	movs	r1, #98	; 0x62
 80810da:	47a8      	blx	r5
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t*)&reg, 1);
  
  if(ret == 0){
 80810dc:	b958      	cbnz	r0, 80810f6 <lis2mdl_drdy_on_pin_set+0x2e>
    reg.drdy_on_pin = val;
 80810de:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80810e2:	aa01      	add	r2, sp, #4
 80810e4:	6827      	ldr	r7, [r4, #0]
 80810e6:	2301      	movs	r3, #1
    reg.drdy_on_pin = val;
 80810e8:	f366 0500 	bfi	r5, r6, #0, #1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80810ec:	68a0      	ldr	r0, [r4, #8]
 80810ee:	2162      	movs	r1, #98	; 0x62
    reg.drdy_on_pin = val;
 80810f0:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80810f4:	47b8      	blx	r7
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t*)&reg, 1);
  }
  
  return ret;
}
 80810f6:	b003      	add	sp, #12
 80810f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80810fa:	bf00      	nop

080810fc <lsm6ds3_from_fs2g_to_mg>:
  *
  */

float_t lsm6ds3_from_fs2g_to_mg(int16_t lsb)
{
  return ((float_t)lsb * 61.0f / 1000.0f);
 80810fc:	2200      	movs	r2, #0
 80810fe:	ee07 0a90 	vmov	s15, r0
 8081102:	4613      	mov	r3, r2
 8081104:	f2c4 2274 	movt	r2, #17012	; 0x4274
 8081108:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 808110c:	ee00 2a10 	vmov	s0, r2
 8081110:	f2c4 437a 	movt	r3, #17530	; 0x447a
 8081114:	ee27 0a00 	vmul.f32	s0, s14, s0
 8081118:	ee07 3a90 	vmov	s15, r3
}
 808111c:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8081120:	4770      	bx	lr
 8081122:	bf00      	nop

08081124 <lsm6ds3_from_fs2000dps_to_mdps>:
  return ((float_t)lsb * 35.0f);
}

float_t lsm6ds3_from_fs2000dps_to_mdps(int16_t lsb)
{
  return ((float_t)lsb * 70.0f);
 8081124:	2300      	movs	r3, #0
 8081126:	ee07 0a90 	vmov	s15, r0
 808112a:	f2c4 238c 	movt	r3, #17036	; 0x428c
 808112e:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 8081132:	ee07 3a90 	vmov	s15, r3
}
 8081136:	ee20 0a27 	vmul.f32	s0, s0, s15
 808113a:	4770      	bx	lr

0808113c <lsm6ds3_from_lsb_to_celsius>:

float_t lsm6ds3_from_lsb_to_celsius(int16_t lsb)
{
  return ((float_t)lsb / 16.0f + 25.0f );
 808113c:	ee07 0a90 	vmov	s15, r0
 8081140:	f04f 5376 	mov.w	r3, #1031798784	; 0x3d800000
 8081144:	eeb3 0a09 	vmov.f32	s0, #57	; 0x41c80000  25.0
 8081148:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 808114c:	ee07 3a90 	vmov	s15, r3
}
 8081150:	eea7 0a27 	vfma.f32	s0, s14, s15
 8081154:	4770      	bx	lr
 8081156:	bf00      	nop

08081158 <lsm6ds3_xl_full_scale_set>:
  * @param  val      change the values of fs_xl in reg  LSM6DS3
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_xl_full_scale_set(lsm6ds3_ctx_t *ctx, lsm6ds3_xl_fs_t val)
{
 8081158:	b5f0      	push	{r4, r5, r6, r7, lr}
 808115a:	b083      	sub	sp, #12
 808115c:	4604      	mov	r4, r0
 808115e:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081160:	6845      	ldr	r5, [r0, #4]
 8081162:	2301      	movs	r3, #1
 8081164:	aa01      	add	r2, sp, #4
 8081166:	6880      	ldr	r0, [r0, #8]
 8081168:	2110      	movs	r1, #16
 808116a:	47a8      	blx	r5
  lsm6ds3_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  if(ret == 0){
 808116c:	b958      	cbnz	r0, 8081186 <lsm6ds3_xl_full_scale_set+0x2e>
    ctrl1_xl.fs_xl = (uint8_t)val;
 808116e:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081172:	aa01      	add	r2, sp, #4
 8081174:	6827      	ldr	r7, [r4, #0]
 8081176:	2301      	movs	r3, #1
    ctrl1_xl.fs_xl = (uint8_t)val;
 8081178:	f366 0583 	bfi	r5, r6, #2, #2
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 808117c:	68a0      	ldr	r0, [r4, #8]
 808117e:	2110      	movs	r1, #16
    ctrl1_xl.fs_xl = (uint8_t)val;
 8081180:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081184:	47b8      	blx	r7
    ret = lsm6ds3_write_reg(ctx, LSM6DS3_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  }
  return ret;
}
 8081186:	b003      	add	sp, #12
 8081188:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808118a:	bf00      	nop

0808118c <lsm6ds3_xl_data_rate_set>:
  * @param  val      change the values of odr_xl in reg  LSM6DS3
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_xl_data_rate_set(lsm6ds3_ctx_t *ctx, lsm6ds3_odr_xl_t val)
{
 808118c:	b5f0      	push	{r4, r5, r6, r7, lr}
 808118e:	b083      	sub	sp, #12
 8081190:	4604      	mov	r4, r0
 8081192:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081194:	6845      	ldr	r5, [r0, #4]
 8081196:	2301      	movs	r3, #1
 8081198:	aa01      	add	r2, sp, #4
 808119a:	6880      	ldr	r0, [r0, #8]
 808119c:	2110      	movs	r1, #16
 808119e:	47a8      	blx	r5
  lsm6ds3_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  if(ret == 0){
 80811a0:	b958      	cbnz	r0, 80811ba <lsm6ds3_xl_data_rate_set+0x2e>
    ctrl1_xl.odr_xl = (uint8_t)val;
 80811a2:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80811a6:	aa01      	add	r2, sp, #4
 80811a8:	6827      	ldr	r7, [r4, #0]
 80811aa:	2301      	movs	r3, #1
    ctrl1_xl.odr_xl = (uint8_t)val;
 80811ac:	f366 1507 	bfi	r5, r6, #4, #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80811b0:	68a0      	ldr	r0, [r4, #8]
 80811b2:	2110      	movs	r1, #16
    ctrl1_xl.odr_xl = (uint8_t)val;
 80811b4:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80811b8:	47b8      	blx	r7
    ret = lsm6ds3_write_reg(ctx, LSM6DS3_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  }
  return ret;
}
 80811ba:	b003      	add	sp, #12
 80811bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80811be:	bf00      	nop

080811c0 <lsm6ds3_gy_full_scale_set>:
  * @param  val      change the values of fs_g in reg  LSM6DS3
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_gy_full_scale_set(lsm6ds3_ctx_t *ctx, lsm6ds3_fs_g_t val)
{
 80811c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80811c2:	b083      	sub	sp, #12
 80811c4:	4604      	mov	r4, r0
 80811c6:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80811c8:	6845      	ldr	r5, [r0, #4]
 80811ca:	2301      	movs	r3, #1
 80811cc:	aa01      	add	r2, sp, #4
 80811ce:	6880      	ldr	r0, [r0, #8]
 80811d0:	2111      	movs	r1, #17
 80811d2:	47a8      	blx	r5
  lsm6ds3_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  if(ret == 0){
 80811d4:	b958      	cbnz	r0, 80811ee <lsm6ds3_gy_full_scale_set+0x2e>
    ctrl2_g.fs_g = (uint8_t)val;
 80811d6:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80811da:	aa01      	add	r2, sp, #4
 80811dc:	6827      	ldr	r7, [r4, #0]
 80811de:	2301      	movs	r3, #1
    ctrl2_g.fs_g = (uint8_t)val;
 80811e0:	f366 0543 	bfi	r5, r6, #1, #3
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80811e4:	68a0      	ldr	r0, [r4, #8]
 80811e6:	2111      	movs	r1, #17
    ctrl2_g.fs_g = (uint8_t)val;
 80811e8:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80811ec:	47b8      	blx	r7
    ret = lsm6ds3_write_reg(ctx, LSM6DS3_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  }
  return ret;
}
 80811ee:	b003      	add	sp, #12
 80811f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80811f2:	bf00      	nop

080811f4 <lsm6ds3_gy_data_rate_set>:
  * @param  val      change the values of odr_g in reg  LSM6DS3
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_gy_data_rate_set(lsm6ds3_ctx_t *ctx, lsm6ds3_odr_g_t val)
{
 80811f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80811f6:	b083      	sub	sp, #12
 80811f8:	4604      	mov	r4, r0
 80811fa:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80811fc:	6845      	ldr	r5, [r0, #4]
 80811fe:	2301      	movs	r3, #1
 8081200:	aa01      	add	r2, sp, #4
 8081202:	6880      	ldr	r0, [r0, #8]
 8081204:	2111      	movs	r1, #17
 8081206:	47a8      	blx	r5
  lsm6ds3_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  if(ret == 0){
 8081208:	b958      	cbnz	r0, 8081222 <lsm6ds3_gy_data_rate_set+0x2e>
    ctrl2_g.odr_g = (uint8_t)val;
 808120a:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 808120e:	aa01      	add	r2, sp, #4
 8081210:	6827      	ldr	r7, [r4, #0]
 8081212:	2301      	movs	r3, #1
    ctrl2_g.odr_g = (uint8_t)val;
 8081214:	f366 1507 	bfi	r5, r6, #4, #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081218:	68a0      	ldr	r0, [r4, #8]
 808121a:	2111      	movs	r1, #17
    ctrl2_g.odr_g = (uint8_t)val;
 808121c:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081220:	47b8      	blx	r7
    ret = lsm6ds3_write_reg(ctx, LSM6DS3_CTRL2_G, (uint8_t*)&ctrl2_g, 1);
  }
  return ret;
}
 8081222:	b003      	add	sp, #12
 8081224:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8081226:	bf00      	nop

08081228 <lsm6ds3_block_data_update_set>:
  * @param  val      change the values of bdu in reg CTRL3_C
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_block_data_update_set(lsm6ds3_ctx_t *ctx, uint8_t val)
{
 8081228:	b5f0      	push	{r4, r5, r6, r7, lr}
 808122a:	b083      	sub	sp, #12
 808122c:	4604      	mov	r4, r0
 808122e:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081230:	6845      	ldr	r5, [r0, #4]
 8081232:	2301      	movs	r3, #1
 8081234:	aa01      	add	r2, sp, #4
 8081236:	6880      	ldr	r0, [r0, #8]
 8081238:	2112      	movs	r1, #18
 808123a:	47a8      	blx	r5
  lsm6ds3_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  if(ret == 0){
 808123c:	b958      	cbnz	r0, 8081256 <lsm6ds3_block_data_update_set+0x2e>
    ctrl3_c.bdu = (uint8_t)val;
 808123e:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081242:	aa01      	add	r2, sp, #4
 8081244:	6827      	ldr	r7, [r4, #0]
 8081246:	2301      	movs	r3, #1
    ctrl3_c.bdu = (uint8_t)val;
 8081248:	f366 1586 	bfi	r5, r6, #6, #1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 808124c:	68a0      	ldr	r0, [r4, #8]
 808124e:	2112      	movs	r1, #18
    ctrl3_c.bdu = (uint8_t)val;
 8081250:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081254:	47b8      	blx	r7
    ret = lsm6ds3_write_reg(ctx, LSM6DS3_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  }
  return ret;
}
 8081256:	b003      	add	sp, #12
 8081258:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808125a:	bf00      	nop

0808125c <lsm6ds3_xl_flag_data_ready_get>:
  * @param  val      get the values of xlda in reg STATUS_REG
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_xl_flag_data_ready_get(lsm6ds3_ctx_t *ctx, uint8_t *val)
{
 808125c:	b530      	push	{r4, r5, lr}
 808125e:	b083      	sub	sp, #12
 8081260:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081262:	6845      	ldr	r5, [r0, #4]
 8081264:	2301      	movs	r3, #1
 8081266:	aa01      	add	r2, sp, #4
 8081268:	211e      	movs	r1, #30
 808126a:	6880      	ldr	r0, [r0, #8]
 808126c:	47a8      	blx	r5
  lsm6ds3_status_reg_t status_reg;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_STATUS_REG, (uint8_t*)&status_reg, 1);
  *val = (uint8_t)status_reg.xlda;
 808126e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8081272:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8081276:	7023      	strb	r3, [r4, #0]

  return ret;
}
 8081278:	b003      	add	sp, #12
 808127a:	bd30      	pop	{r4, r5, pc}

0808127c <lsm6ds3_gy_flag_data_ready_get>:
  * @param  val      get the values of gda in reg STATUS_REG
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_gy_flag_data_ready_get(lsm6ds3_ctx_t *ctx, uint8_t *val)
{
 808127c:	b530      	push	{r4, r5, lr}
 808127e:	b083      	sub	sp, #12
 8081280:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081282:	6845      	ldr	r5, [r0, #4]
 8081284:	2301      	movs	r3, #1
 8081286:	aa01      	add	r2, sp, #4
 8081288:	211e      	movs	r1, #30
 808128a:	6880      	ldr	r0, [r0, #8]
 808128c:	47a8      	blx	r5
  lsm6ds3_status_reg_t status_reg;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_STATUS_REG, (uint8_t*)&status_reg, 1);
  *val = (uint8_t)status_reg.gda;
 808128e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8081292:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8081296:	7023      	strb	r3, [r4, #0]

  return ret;
}
 8081298:	b003      	add	sp, #12
 808129a:	bd30      	pop	{r4, r5, pc}

0808129c <lsm6ds3_temp_flag_data_ready_get>:
  * @param  val      get the values of tda in reg STATUS_REG
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_temp_flag_data_ready_get(lsm6ds3_ctx_t *ctx, uint8_t *val)
{
 808129c:	b530      	push	{r4, r5, lr}
 808129e:	b083      	sub	sp, #12
 80812a0:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812a2:	6845      	ldr	r5, [r0, #4]
 80812a4:	2301      	movs	r3, #1
 80812a6:	aa01      	add	r2, sp, #4
 80812a8:	211e      	movs	r1, #30
 80812aa:	6880      	ldr	r0, [r0, #8]
 80812ac:	47a8      	blx	r5
  lsm6ds3_status_reg_t status_reg;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_STATUS_REG, (uint8_t*)&status_reg, 1);
  *val = (uint8_t)status_reg.tda;
 80812ae:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80812b2:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80812b6:	7023      	strb	r3, [r4, #0]

  return ret;
}
 80812b8:	b003      	add	sp, #12
 80812ba:	bd30      	pop	{r4, r5, pc}

080812bc <lsm6ds3_temperature_raw_get>:
  * @param  ctx         read / write interface definitions(ptr)
  * @param  buff        buffer that stores data read
  *
  */
int32_t lsm6ds3_temperature_raw_get(lsm6ds3_ctx_t *ctx, uint8_t *buff)
{
 80812bc:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812be:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 80812c2:	460a      	mov	r2, r1
 80812c4:	2302      	movs	r3, #2
 80812c6:	46a4      	mov	ip, r4
 80812c8:	2120      	movs	r1, #32
  int32_t ret;
  ret = lsm6ds3_read_reg(ctx, LSM6DS3_OUT_TEMP_L, buff, 2);
  return ret;
}
 80812ca:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812ce:	4760      	bx	ip

080812d0 <lsm6ds3_angular_rate_raw_get>:
  * @param  ctx         read / write interface definitions(ptr)
  * @param  buff        buffer that stores data read
  *
  */
int32_t lsm6ds3_angular_rate_raw_get(lsm6ds3_ctx_t *ctx, uint8_t *buff)
{
 80812d0:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812d2:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 80812d6:	460a      	mov	r2, r1
 80812d8:	2306      	movs	r3, #6
 80812da:	46a4      	mov	ip, r4
 80812dc:	2122      	movs	r1, #34	; 0x22
  int32_t ret;
  ret = lsm6ds3_read_reg(ctx, LSM6DS3_OUTX_L_G, buff, 6);
  return ret;
}
 80812de:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812e2:	4760      	bx	ip

080812e4 <lsm6ds3_acceleration_raw_get>:
  * @param  ctx         read / write interface definitions(ptr)
  * @param  buff        buffer that stores data read
  *
  */
int32_t lsm6ds3_acceleration_raw_get(lsm6ds3_ctx_t *ctx, uint8_t *buff)
{
 80812e4:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812e6:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 80812ea:	460a      	mov	r2, r1
 80812ec:	2306      	movs	r3, #6
 80812ee:	46a4      	mov	ip, r4
 80812f0:	2128      	movs	r1, #40	; 0x28
  int32_t ret;
  ret = lsm6ds3_read_reg(ctx, LSM6DS3_OUTX_L_XL, buff, 6);
  return ret;
}
 80812f2:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812f6:	4760      	bx	ip

080812f8 <lsm6ds3_device_id_get>:
  * @param  ctx         read / write interface definitions(ptr)
  * @param  buff        buffer that stores data read
  *
  */
int32_t lsm6ds3_device_id_get(lsm6ds3_ctx_t *ctx, uint8_t *buff)
{
 80812f8:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80812fa:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 80812fe:	460a      	mov	r2, r1
 8081300:	2301      	movs	r3, #1
 8081302:	46a4      	mov	ip, r4
 8081304:	210f      	movs	r1, #15
  int32_t ret;
  ret = lsm6ds3_read_reg(ctx, LSM6DS3_WHO_AM_I, buff, 1);
  return ret;
}
 8081306:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 808130a:	4760      	bx	ip

0808130c <lsm6ds3_reset_set>:
  * @param  val      change the values of sw_reset in reg CTRL3_C
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_reset_set(lsm6ds3_ctx_t *ctx, uint8_t val)
{
 808130c:	b5f0      	push	{r4, r5, r6, r7, lr}
 808130e:	b083      	sub	sp, #12
 8081310:	4604      	mov	r4, r0
 8081312:	460e      	mov	r6, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081314:	6845      	ldr	r5, [r0, #4]
 8081316:	2301      	movs	r3, #1
 8081318:	aa01      	add	r2, sp, #4
 808131a:	6880      	ldr	r0, [r0, #8]
 808131c:	2112      	movs	r1, #18
 808131e:	47a8      	blx	r5
  lsm6ds3_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  if(ret == 0){
 8081320:	b958      	cbnz	r0, 808133a <lsm6ds3_reset_set+0x2e>
    ctrl3_c.sw_reset = (uint8_t)val;
 8081322:	f89d 5004 	ldrb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081326:	aa01      	add	r2, sp, #4
 8081328:	6827      	ldr	r7, [r4, #0]
 808132a:	2301      	movs	r3, #1
    ctrl3_c.sw_reset = (uint8_t)val;
 808132c:	f366 0500 	bfi	r5, r6, #0, #1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081330:	68a0      	ldr	r0, [r4, #8]
 8081332:	2112      	movs	r1, #18
    ctrl3_c.sw_reset = (uint8_t)val;
 8081334:	f88d 5004 	strb.w	r5, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8081338:	47b8      	blx	r7
    ret = lsm6ds3_write_reg(ctx, LSM6DS3_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  }
  return ret;
}
 808133a:	b003      	add	sp, #12
 808133c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808133e:	bf00      	nop

08081340 <lsm6ds3_reset_get>:
  * @param  val      get the values of sw_reset in reg CTRL3_C
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6ds3_reset_get(lsm6ds3_ctx_t *ctx, uint8_t *val)
{
 8081340:	b530      	push	{r4, r5, lr}
 8081342:	b083      	sub	sp, #12
 8081344:	460c      	mov	r4, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8081346:	6845      	ldr	r5, [r0, #4]
 8081348:	2301      	movs	r3, #1
 808134a:	aa01      	add	r2, sp, #4
 808134c:	2112      	movs	r1, #18
 808134e:	6880      	ldr	r0, [r0, #8]
 8081350:	47a8      	blx	r5
  lsm6ds3_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = lsm6ds3_read_reg(ctx, LSM6DS3_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  *val = (uint8_t)ctrl3_c.sw_reset;
 8081352:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8081356:	f3c3 0300 	ubfx	r3, r3, #0, #1
 808135a:	7023      	strb	r3, [r4, #0]

  return ret;
}
 808135c:	b003      	add	sp, #12
 808135e:	bd30      	pop	{r4, r5, pc}

08081360 <wm8994_SetOutputMode>:
  */
uint32_t wm8994_SetOutputMode(uint16_t DeviceAddr, uint8_t Output)
{
  uint32_t counter = 0; 
  
  switch (Output) 
 8081360:	2901      	cmp	r1, #1
{
 8081362:	b510      	push	{r4, lr}
 8081364:	b2c4      	uxtb	r4, r0
  switch (Output) 
 8081366:	d021      	beq.n	80813ac <wm8994_SetOutputMode+0x4c>
 8081368:	2903      	cmp	r1, #3
 808136a:	d03f      	beq.n	80813ec <wm8994_SetOutputMode+0x8c>
  */
static uint8_t CODEC_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
{
  uint32_t result = 0;
  
 AUDIO_IO_Write(Addr, Reg, Value);
 808136c:	4620      	mov	r0, r4
 808136e:	f240 3203 	movw	r2, #771	; 0x303
 8081372:	2105      	movs	r1, #5
 8081374:	f000 ff64 	bl	8082240 <AUDIO_IO_Write>
 8081378:	4620      	mov	r0, r4
 808137a:	2201      	movs	r2, #1
 808137c:	f240 6101 	movw	r1, #1537	; 0x601
 8081380:	f000 ff5e 	bl	8082240 <AUDIO_IO_Write>
 8081384:	4620      	mov	r0, r4
 8081386:	2201      	movs	r2, #1
 8081388:	f240 6102 	movw	r1, #1538	; 0x602
 808138c:	f000 ff58 	bl	8082240 <AUDIO_IO_Write>
 8081390:	4620      	mov	r0, r4
 8081392:	2200      	movs	r2, #0
 8081394:	f240 6104 	movw	r1, #1540	; 0x604
 8081398:	f000 ff52 	bl	8082240 <AUDIO_IO_Write>
 808139c:	4620      	mov	r0, r4
 808139e:	2200      	movs	r2, #0
 80813a0:	f240 6105 	movw	r1, #1541	; 0x605
 80813a4:	f000 ff4c 	bl	8082240 <AUDIO_IO_Write>
}
 80813a8:	2000      	movs	r0, #0
 80813aa:	bd10      	pop	{r4, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 80813ac:	f640 420c 	movw	r2, #3084	; 0xc0c
 80813b0:	2105      	movs	r1, #5
 80813b2:	4620      	mov	r0, r4
 80813b4:	f000 ff44 	bl	8082240 <AUDIO_IO_Write>
 80813b8:	2200      	movs	r2, #0
 80813ba:	f240 6101 	movw	r1, #1537	; 0x601
 80813be:	4620      	mov	r0, r4
 80813c0:	f000 ff3e 	bl	8082240 <AUDIO_IO_Write>
 80813c4:	2200      	movs	r2, #0
 80813c6:	4620      	mov	r0, r4
 80813c8:	f240 6102 	movw	r1, #1538	; 0x602
 80813cc:	f000 ff38 	bl	8082240 <AUDIO_IO_Write>
 80813d0:	4620      	mov	r0, r4
 80813d2:	2202      	movs	r2, #2
 80813d4:	f240 6104 	movw	r1, #1540	; 0x604
 80813d8:	f000 ff32 	bl	8082240 <AUDIO_IO_Write>
 80813dc:	4620      	mov	r0, r4
 80813de:	2202      	movs	r2, #2
 80813e0:	f240 6105 	movw	r1, #1541	; 0x605
 80813e4:	f000 ff2c 	bl	8082240 <AUDIO_IO_Write>
}
 80813e8:	2000      	movs	r0, #0
 80813ea:	bd10      	pop	{r4, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 80813ec:	f640 720f 	movw	r2, #3855	; 0xf0f
 80813f0:	2105      	movs	r1, #5
 80813f2:	4620      	mov	r0, r4
 80813f4:	f000 ff24 	bl	8082240 <AUDIO_IO_Write>
 80813f8:	2201      	movs	r2, #1
 80813fa:	f240 6101 	movw	r1, #1537	; 0x601
 80813fe:	4620      	mov	r0, r4
 8081400:	f000 ff1e 	bl	8082240 <AUDIO_IO_Write>
 8081404:	2201      	movs	r2, #1
 8081406:	e7de      	b.n	80813c6 <wm8994_SetOutputMode+0x66>

08081408 <wm8994_SetFrequency>:
{
 8081408:	b508      	push	{r3, lr}
  switch (AudioFreq)
 808140a:	f245 6322 	movw	r3, #22050	; 0x5622
 808140e:	b2c0      	uxtb	r0, r0
 8081410:	4299      	cmp	r1, r3
 8081412:	d048      	beq.n	80814a6 <wm8994_SetFrequency+0x9e>
 8081414:	d913      	bls.n	808143e <wm8994_SetFrequency+0x36>
 8081416:	f64a 4344 	movw	r3, #44100	; 0xac44
 808141a:	4299      	cmp	r1, r3
 808141c:	d035      	beq.n	808148a <wm8994_SetFrequency+0x82>
 808141e:	f44f 43ee 	mov.w	r3, #30464	; 0x7700
 8081422:	f2c0 0301 	movt	r3, #1
 8081426:	4299      	cmp	r1, r3
 8081428:	d028      	beq.n	808147c <wm8994_SetFrequency+0x74>
 808142a:	f5b1 4ffa 	cmp.w	r1, #32000	; 0x7d00
 808142e:	d017      	beq.n	8081460 <wm8994_SetFrequency+0x58>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081430:	2283      	movs	r2, #131	; 0x83
 8081432:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081436:	f000 ff03 	bl	8082240 <AUDIO_IO_Write>
}
 808143a:	2000      	movs	r0, #0
 808143c:	bd08      	pop	{r3, pc}
  switch (AudioFreq)
 808143e:	f642 3311 	movw	r3, #11025	; 0x2b11
 8081442:	4299      	cmp	r1, r3
 8081444:	d028      	beq.n	8081498 <wm8994_SetFrequency+0x90>
 8081446:	f5b1 5f7a 	cmp.w	r1, #16000	; 0x3e80
 808144a:	d010      	beq.n	808146e <wm8994_SetFrequency+0x66>
 808144c:	f5b1 5ffa 	cmp.w	r1, #8000	; 0x1f40
 8081450:	d1ee      	bne.n	8081430 <wm8994_SetFrequency+0x28>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081452:	2203      	movs	r2, #3
 8081454:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081458:	f000 fef2 	bl	8082240 <AUDIO_IO_Write>
}
 808145c:	2000      	movs	r0, #0
 808145e:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 8081460:	2263      	movs	r2, #99	; 0x63
 8081462:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081466:	f000 feeb 	bl	8082240 <AUDIO_IO_Write>
}
 808146a:	2000      	movs	r0, #0
 808146c:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 808146e:	2233      	movs	r2, #51	; 0x33
 8081470:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081474:	f000 fee4 	bl	8082240 <AUDIO_IO_Write>
}
 8081478:	2000      	movs	r0, #0
 808147a:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 808147c:	22a3      	movs	r2, #163	; 0xa3
 808147e:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081482:	f000 fedd 	bl	8082240 <AUDIO_IO_Write>
}
 8081486:	2000      	movs	r0, #0
 8081488:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 808148a:	2273      	movs	r2, #115	; 0x73
 808148c:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081490:	f000 fed6 	bl	8082240 <AUDIO_IO_Write>
}
 8081494:	2000      	movs	r0, #0
 8081496:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 8081498:	2213      	movs	r2, #19
 808149a:	f44f 7104 	mov.w	r1, #528	; 0x210
 808149e:	f000 fecf 	bl	8082240 <AUDIO_IO_Write>
}
 80814a2:	2000      	movs	r0, #0
 80814a4:	bd08      	pop	{r3, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 80814a6:	2243      	movs	r2, #67	; 0x43
 80814a8:	f44f 7104 	mov.w	r1, #528	; 0x210
 80814ac:	f000 fec8 	bl	8082240 <AUDIO_IO_Write>
}
 80814b0:	2000      	movs	r0, #0
 80814b2:	bd08      	pop	{r3, pc}

080814b4 <wm8994_Reset>:
 AUDIO_IO_Write(Addr, Reg, Value);
 80814b4:	2200      	movs	r2, #0
 80814b6:	b2c0      	uxtb	r0, r0
{
 80814b8:	b508      	push	{r3, lr}
 AUDIO_IO_Write(Addr, Reg, Value);
 80814ba:	4611      	mov	r1, r2
 80814bc:	f000 fec0 	bl	8082240 <AUDIO_IO_Write>
  outputEnabled = 0;
 80814c0:	f24b 4108 	movw	r1, #46088	; 0xb408
  inputEnabled=0;
 80814c4:	f24b 4304 	movw	r3, #46084	; 0xb404
  outputEnabled = 0;
 80814c8:	2200      	movs	r2, #0
 80814ca:	f2c2 0100 	movt	r1, #8192	; 0x2000
  inputEnabled=0;
 80814ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 80814d2:	4610      	mov	r0, r2
  outputEnabled = 0;
 80814d4:	600a      	str	r2, [r1, #0]
  inputEnabled=0;
 80814d6:	601a      	str	r2, [r3, #0]
}
 80814d8:	bd08      	pop	{r3, pc}
 80814da:	bf00      	nop

080814dc <wm8994_DeInit>:
  AUDIO_IO_DeInit();
 80814dc:	f000 beae 	b.w	808223c <AUDIO_IO_DeInit>

080814e0 <wm8994_ReadID>:
{
 80814e0:	b510      	push	{r4, lr}
 80814e2:	4604      	mov	r4, r0
  AUDIO_IO_Init();
 80814e4:	f000 fea4 	bl	8082230 <AUDIO_IO_Init>
  return ((uint32_t)AUDIO_IO_Read(DeviceAddr, WM8994_CHIPID_ADDR));
 80814e8:	2100      	movs	r1, #0
 80814ea:	b2e0      	uxtb	r0, r4
 80814ec:	f000 febc 	bl	8082268 <AUDIO_IO_Read>
}
 80814f0:	bd10      	pop	{r4, pc}
 80814f2:	bf00      	nop

080814f4 <wm8994_SetMute.part.0>:
uint32_t wm8994_SetMute(uint16_t DeviceAddr, uint32_t Cmd)
 80814f4:	b510      	push	{r4, lr}
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 80814f6:	b2c4      	uxtb	r4, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 80814f8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80814fc:	f44f 6184 	mov.w	r1, #1056	; 0x420
 8081500:	4620      	mov	r0, r4
 8081502:	f000 fe9d 	bl	8082240 <AUDIO_IO_Write>
 8081506:	4620      	mov	r0, r4
 8081508:	f44f 7200 	mov.w	r2, #512	; 0x200
 808150c:	f240 4122 	movw	r1, #1058	; 0x422
}
 8081510:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 AUDIO_IO_Write(Addr, Reg, Value);
 8081514:	f000 be94 	b.w	8082240 <AUDIO_IO_Write>

08081518 <wm8994_SetMute>:
  if (outputEnabled != 0)
 8081518:	f24b 4308 	movw	r3, #46088	; 0xb408
 808151c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8081520:	681b      	ldr	r3, [r3, #0]
 8081522:	b18b      	cbz	r3, 8081548 <wm8994_SetMute+0x30>
    if(Cmd == AUDIO_MUTE_ON)
 8081524:	2901      	cmp	r1, #1
{
 8081526:	b510      	push	{r4, lr}
    if(Cmd == AUDIO_MUTE_ON)
 8081528:	d010      	beq.n	808154c <wm8994_SetMute+0x34>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0010);
 808152a:	b2c4      	uxtb	r4, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 808152c:	2210      	movs	r2, #16
 808152e:	f44f 6184 	mov.w	r1, #1056	; 0x420
 8081532:	4620      	mov	r0, r4
 8081534:	f000 fe84 	bl	8082240 <AUDIO_IO_Write>
 8081538:	4620      	mov	r0, r4
 808153a:	2210      	movs	r2, #16
 808153c:	f240 4122 	movw	r1, #1058	; 0x422
 8081540:	f000 fe7e 	bl	8082240 <AUDIO_IO_Write>
}
 8081544:	2000      	movs	r0, #0
 8081546:	bd10      	pop	{r4, pc}
 8081548:	2000      	movs	r0, #0
 808154a:	4770      	bx	lr
 808154c:	f7ff ffd2 	bl	80814f4 <wm8994_SetMute.part.0>
 8081550:	2000      	movs	r0, #0
 8081552:	bd10      	pop	{r4, pc}

08081554 <wm8994_Play>:
  counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
 8081554:	2100      	movs	r1, #0
 8081556:	f7ff bfdf 	b.w	8081518 <wm8994_SetMute>
 808155a:	bf00      	nop

0808155c <wm8994_Resume>:
  counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
 808155c:	2100      	movs	r1, #0
 808155e:	f7ff bfdb 	b.w	8081518 <wm8994_SetMute>
 8081562:	bf00      	nop

08081564 <wm8994_Pause>:
  if (outputEnabled != 0)
 8081564:	f24b 4308 	movw	r3, #46088	; 0xb408
 8081568:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808156c:	681b      	ldr	r3, [r3, #0]
{  
 808156e:	b510      	push	{r4, lr}
 8081570:	4604      	mov	r4, r0
  if (outputEnabled != 0)
 8081572:	b10b      	cbz	r3, 8081578 <wm8994_Pause+0x14>
 8081574:	f7ff ffbe 	bl	80814f4 <wm8994_SetMute.part.0>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081578:	b2e0      	uxtb	r0, r4
 808157a:	2201      	movs	r2, #1
 808157c:	2102      	movs	r1, #2
 808157e:	f000 fe5f 	bl	8082240 <AUDIO_IO_Write>
}
 8081582:	2000      	movs	r0, #0
 8081584:	bd10      	pop	{r4, pc}
 8081586:	bf00      	nop

08081588 <wm8994_SetVolume>:
{
 8081588:	f24b 4308 	movw	r3, #46088	; 0xb408
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
 808158c:	2964      	cmp	r1, #100	; 0x64
 808158e:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
 8081592:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8081596:	460c      	mov	r4, r1
 8081598:	4605      	mov	r5, r0
 808159a:	681e      	ldr	r6, [r3, #0]
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
 808159c:	d944      	bls.n	8081628 <wm8994_SetVolume+0xa0>
  if (outputEnabled != 0)
 808159e:	b1ee      	cbz	r6, 80815dc <wm8994_SetVolume+0x54>
      counter += CODEC_IO_Write(DeviceAddr, 0x1C, 0x3F | 0x140);
 80815a0:	b2ef      	uxtb	r7, r5
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
 80815a2:	2100      	movs	r1, #0
 80815a4:	4628      	mov	r0, r5
 80815a6:	f7ff ffb7 	bl	8081518 <wm8994_SetMute>
 AUDIO_IO_Write(Addr, Reg, Value);
 80815aa:	f240 127f 	movw	r2, #383	; 0x17f
 80815ae:	211c      	movs	r1, #28
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
 80815b0:	4606      	mov	r6, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 80815b2:	4638      	mov	r0, r7
 80815b4:	f000 fe44 	bl	8082240 <AUDIO_IO_Write>
 80815b8:	4638      	mov	r0, r7
 80815ba:	f240 127f 	movw	r2, #383	; 0x17f
 80815be:	211d      	movs	r1, #29
 80815c0:	f000 fe3e 	bl	8082240 <AUDIO_IO_Write>
 80815c4:	4638      	mov	r0, r7
 80815c6:	f240 127f 	movw	r2, #383	; 0x17f
 80815ca:	2126      	movs	r1, #38	; 0x26
 80815cc:	f000 fe38 	bl	8082240 <AUDIO_IO_Write>
 80815d0:	4638      	mov	r0, r7
 80815d2:	f240 127f 	movw	r2, #383	; 0x17f
 80815d6:	2127      	movs	r1, #39	; 0x27
 80815d8:	f000 fe32 	bl	8082240 <AUDIO_IO_Write>
  if (inputEnabled != 0)
 80815dc:	f24b 4304 	movw	r3, #46084	; 0xb404
 80815e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80815e4:	681b      	ldr	r3, [r3, #0]
 80815e6:	b1e3      	cbz	r3, 8081622 <wm8994_SetVolume+0x9a>
    convertedvol = VOLUME_IN_CONVERT(Volume);
 80815e8:	2c63      	cmp	r4, #99	; 0x63
 80815ea:	d936      	bls.n	808165a <wm8994_SetVolume+0xd2>
 80815ec:	f240 14ef 	movw	r4, #495	; 0x1ef
    counter += CODEC_IO_Write(DeviceAddr, 0x400, convertedvol | 0x100);
 80815f0:	b2ed      	uxtb	r5, r5
 AUDIO_IO_Write(Addr, Reg, Value);
 80815f2:	4622      	mov	r2, r4
 80815f4:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80815f8:	4628      	mov	r0, r5
 80815fa:	f000 fe21 	bl	8082240 <AUDIO_IO_Write>
 80815fe:	4622      	mov	r2, r4
 8081600:	4628      	mov	r0, r5
 8081602:	f240 4101 	movw	r1, #1025	; 0x401
 8081606:	f000 fe1b 	bl	8082240 <AUDIO_IO_Write>
 808160a:	4622      	mov	r2, r4
 808160c:	4628      	mov	r0, r5
 808160e:	f240 4104 	movw	r1, #1028	; 0x404
 8081612:	f000 fe15 	bl	8082240 <AUDIO_IO_Write>
 8081616:	4622      	mov	r2, r4
 8081618:	4628      	mov	r0, r5
 808161a:	f240 4105 	movw	r1, #1029	; 0x405
 808161e:	f000 fe0f 	bl	8082240 <AUDIO_IO_Write>
}
 8081622:	4630      	mov	r0, r6
 8081624:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (outputEnabled != 0)
 8081628:	2e00      	cmp	r6, #0
 808162a:	d0d7      	beq.n	80815dc <wm8994_SetVolume+0x54>
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
 808162c:	f248 521f 	movw	r2, #34079	; 0x851f
 8081630:	ebc1 1381 	rsb	r3, r1, r1, lsl #6
 8081634:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 8081638:	fba2 2303 	umull	r2, r3, r2, r3
 808163c:	095b      	lsrs	r3, r3, #5
    if(convertedvol > 0x3E)
 808163e:	2b3f      	cmp	r3, #63	; 0x3f
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
 8081640:	b2df      	uxtb	r7, r3
    if(convertedvol > 0x3E)
 8081642:	d0ad      	beq.n	80815a0 <wm8994_SetVolume+0x18>
    else if (Volume == 0)
 8081644:	b9b9      	cbnz	r1, 8081676 <wm8994_SetVolume+0xee>
 8081646:	f7ff ff55 	bl	80814f4 <wm8994_SetMute.part.0>
  if (inputEnabled != 0)
 808164a:	f24b 4304 	movw	r3, #46084	; 0xb404
 808164e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8081652:	681e      	ldr	r6, [r3, #0]
 8081654:	2e00      	cmp	r6, #0
 8081656:	d0e4      	beq.n	8081622 <wm8994_SetVolume+0x9a>
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_ON);
 8081658:	4626      	mov	r6, r4
    convertedvol = VOLUME_IN_CONVERT(Volume);
 808165a:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
 808165e:	f248 531f 	movw	r3, #34079	; 0x851f
 8081662:	0124      	lsls	r4, r4, #4
 8081664:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8081668:	fba3 3404 	umull	r3, r4, r3, r4
 808166c:	0964      	lsrs	r4, r4, #5
 808166e:	f444 7480 	orr.w	r4, r4, #256	; 0x100
 8081672:	b2a4      	uxth	r4, r4
 8081674:	e7bc      	b.n	80815f0 <wm8994_SetVolume+0x68>
      counter += CODEC_IO_Write(DeviceAddr, 0x1C, convertedvol | 0x140);
 8081676:	fa5f f880 	uxtb.w	r8, r0
 808167a:	f447 77a0 	orr.w	r7, r7, #320	; 0x140
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
 808167e:	2100      	movs	r1, #0
 8081680:	f7ff ff4a 	bl	8081518 <wm8994_SetMute>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081684:	463a      	mov	r2, r7
 8081686:	211c      	movs	r1, #28
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
 8081688:	4606      	mov	r6, r0
 AUDIO_IO_Write(Addr, Reg, Value);
 808168a:	4640      	mov	r0, r8
 808168c:	f000 fdd8 	bl	8082240 <AUDIO_IO_Write>
 8081690:	463a      	mov	r2, r7
 8081692:	4640      	mov	r0, r8
 8081694:	211d      	movs	r1, #29
 8081696:	f000 fdd3 	bl	8082240 <AUDIO_IO_Write>
 808169a:	463a      	mov	r2, r7
 808169c:	4640      	mov	r0, r8
 808169e:	2126      	movs	r1, #38	; 0x26
 80816a0:	f000 fdce 	bl	8082240 <AUDIO_IO_Write>
 80816a4:	463a      	mov	r2, r7
 80816a6:	4640      	mov	r0, r8
 80816a8:	2127      	movs	r1, #39	; 0x27
 80816aa:	f000 fdc9 	bl	8082240 <AUDIO_IO_Write>
  if (inputEnabled != 0)
 80816ae:	f24b 4304 	movw	r3, #46084	; 0xb404
 80816b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80816b6:	681b      	ldr	r3, [r3, #0]
 80816b8:	2b00      	cmp	r3, #0
 80816ba:	d195      	bne.n	80815e8 <wm8994_SetVolume+0x60>
 80816bc:	e7b1      	b.n	8081622 <wm8994_SetVolume+0x9a>
 80816be:	bf00      	nop

080816c0 <wm8994_Init>:
{
 80816c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  counter += CODEC_IO_Write(DeviceAddr, 0x102, 0x0003);
 80816c4:	b2c4      	uxtb	r4, r0
{
 80816c6:	461f      	mov	r7, r3
  uint16_t input_device = OutputInputDevice & 0xFF00;
 80816c8:	f401 467f 	and.w	r6, r1, #65280	; 0xff00
{
 80816cc:	4680      	mov	r8, r0
 80816ce:	4691      	mov	r9, r2
  uint16_t output_device = OutputInputDevice & 0xFF;
 80816d0:	b2cd      	uxtb	r5, r1
  AUDIO_IO_Init();
 80816d2:	f000 fdad 	bl	8082230 <AUDIO_IO_Init>
 AUDIO_IO_Write(Addr, Reg, Value);
 80816d6:	4620      	mov	r0, r4
 80816d8:	2203      	movs	r2, #3
 80816da:	f44f 7181 	mov.w	r1, #258	; 0x102
 80816de:	f000 fdaf 	bl	8082240 <AUDIO_IO_Write>
 80816e2:	4620      	mov	r0, r4
 80816e4:	2200      	movs	r2, #0
 80816e6:	f640 0117 	movw	r1, #2071	; 0x817
 80816ea:	f000 fda9 	bl	8082240 <AUDIO_IO_Write>
 80816ee:	4620      	mov	r0, r4
 80816f0:	2200      	movs	r2, #0
 80816f2:	f44f 7181 	mov.w	r1, #258	; 0x102
 80816f6:	f000 fda3 	bl	8082240 <AUDIO_IO_Write>
 80816fa:	4620      	mov	r0, r4
 80816fc:	226c      	movs	r2, #108	; 0x6c
 80816fe:	2139      	movs	r1, #57	; 0x39
 8081700:	f000 fd9e 	bl	8082240 <AUDIO_IO_Write>
  if (input_device > 0)
 8081704:	2e00      	cmp	r6, #0
 8081706:	f000 8104 	beq.w	8081912 <wm8994_Init+0x252>
 AUDIO_IO_Write(Addr, Reg, Value);
 808170a:	2213      	movs	r2, #19
 808170c:	2101      	movs	r1, #1
 808170e:	4620      	mov	r0, r4
 8081710:	f000 fd96 	bl	8082240 <AUDIO_IO_Write>
  AUDIO_IO_Delay(50);
 8081714:	2032      	movs	r0, #50	; 0x32
 8081716:	f000 fdbf 	bl	8082298 <AUDIO_IO_Delay>
    outputEnabled = 1;
 808171a:	f24b 4308 	movw	r3, #46088	; 0xb408
  if (output_device > 0)
 808171e:	2d00      	cmp	r5, #0
 8081720:	f000 8104 	beq.w	808192c <wm8994_Init+0x26c>
    outputEnabled = 1;
 8081724:	f04f 0a01 	mov.w	sl, #1
 8081728:	f2c2 0300 	movt	r3, #8192	; 0x2000
    switch (output_device)
 808172c:	2d02      	cmp	r5, #2
    outputEnabled = 1;
 808172e:	f8c3 a000 	str.w	sl, [r3]
    switch (output_device)
 8081732:	d005      	beq.n	8081740 <wm8994_Init+0x80>
 8081734:	2d03      	cmp	r5, #3
 8081736:	f000 82a3 	beq.w	8081c80 <wm8994_Init+0x5c0>
 808173a:	4555      	cmp	r5, sl
 808173c:	f000 8242 	beq.w	8081bc4 <wm8994_Init+0x504>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081740:	f240 3203 	movw	r2, #771	; 0x303
 8081744:	2105      	movs	r1, #5
 8081746:	4620      	mov	r0, r4
 8081748:	f000 fd7a 	bl	8082240 <AUDIO_IO_Write>
 808174c:	4652      	mov	r2, sl
 808174e:	f240 6101 	movw	r1, #1537	; 0x601
 8081752:	4620      	mov	r0, r4
 8081754:	f000 fd74 	bl	8082240 <AUDIO_IO_Write>
 8081758:	4652      	mov	r2, sl
 808175a:	f240 6102 	movw	r1, #1538	; 0x602
 808175e:	4620      	mov	r0, r4
 8081760:	f000 fd6e 	bl	8082240 <AUDIO_IO_Write>
 8081764:	2200      	movs	r2, #0
 8081766:	f240 6104 	movw	r1, #1540	; 0x604
 808176a:	4620      	mov	r0, r4
 808176c:	f000 fd68 	bl	8082240 <AUDIO_IO_Write>
 8081770:	2200      	movs	r2, #0
 8081772:	f240 6105 	movw	r1, #1541	; 0x605
 8081776:	4620      	mov	r0, r4
 8081778:	f000 fd62 	bl	8082240 <AUDIO_IO_Write>
    inputEnabled = 1;
 808177c:	f24b 4304 	movw	r3, #46084	; 0xb404
  if (input_device > 0)
 8081780:	2e00      	cmp	r6, #0
 8081782:	f000 80db 	beq.w	808193c <wm8994_Init+0x27c>
    inputEnabled = 1;
 8081786:	2201      	movs	r2, #1
 8081788:	f2c2 0300 	movt	r3, #8192	; 0x2000
    switch (input_device)
 808178c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    inputEnabled = 1;
 8081790:	601a      	str	r2, [r3, #0]
    switch (input_device)
 8081792:	f000 8295 	beq.w	8081cc0 <wm8994_Init+0x600>
 8081796:	f240 825e 	bls.w	8081c56 <wm8994_Init+0x596>
 808179a:	f5b6 7f40 	cmp.w	r6, #768	; 0x300
 808179e:	f000 81e4 	beq.w	8081b6a <wm8994_Init+0x4aa>
 80817a2:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 80817a6:	f040 82b2 	bne.w	8081d0e <wm8994_Init+0x64e>
 AUDIO_IO_Write(Addr, Reg, Value);
 80817aa:	f640 723c 	movw	r2, #3900	; 0xf3c
 80817ae:	2104      	movs	r1, #4
 80817b0:	4620      	mov	r0, r4
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000D);
 80817b2:	f04f 0a00 	mov.w	sl, #0
 AUDIO_IO_Write(Addr, Reg, Value);
 80817b6:	f000 fd43 	bl	8082240 <AUDIO_IO_Write>
 80817ba:	22db      	movs	r2, #219	; 0xdb
 80817bc:	f44f 618a 	mov.w	r1, #1104	; 0x450
 80817c0:	4620      	mov	r0, r4
 80817c2:	f000 fd3d 	bl	8082240 <AUDIO_IO_Write>
 80817c6:	22db      	movs	r2, #219	; 0xdb
 80817c8:	f44f 6188 	mov.w	r1, #1088	; 0x440
 80817cc:	4620      	mov	r0, r4
 80817ce:	f000 fd37 	bl	8082240 <AUDIO_IO_Write>
 80817d2:	f246 32a0 	movw	r2, #25504	; 0x63a0
 80817d6:	2102      	movs	r1, #2
 80817d8:	4620      	mov	r0, r4
 80817da:	f000 fd31 	bl	8082240 <AUDIO_IO_Write>
 80817de:	2202      	movs	r2, #2
 80817e0:	f240 6106 	movw	r1, #1542	; 0x606
 80817e4:	4620      	mov	r0, r4
 80817e6:	f000 fd2b 	bl	8082240 <AUDIO_IO_Write>
 80817ea:	2202      	movs	r2, #2
 80817ec:	f240 6107 	movw	r1, #1543	; 0x607
 80817f0:	4620      	mov	r0, r4
 80817f2:	f000 fd25 	bl	8082240 <AUDIO_IO_Write>
 80817f6:	2202      	movs	r2, #2
 80817f8:	f44f 61c1 	mov.w	r1, #1544	; 0x608
 80817fc:	4620      	mov	r0, r4
 80817fe:	f000 fd1f 	bl	8082240 <AUDIO_IO_Write>
 8081802:	2202      	movs	r2, #2
 8081804:	f240 6109 	movw	r1, #1545	; 0x609
 8081808:	4620      	mov	r0, r4
 808180a:	f000 fd19 	bl	8082240 <AUDIO_IO_Write>
 808180e:	220d      	movs	r2, #13
 8081810:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8081814:	4620      	mov	r0, r4
 8081816:	f000 fd13 	bl	8082240 <AUDIO_IO_Write>
  switch (AudioFreq)
 808181a:	f245 6322 	movw	r3, #22050	; 0x5622
 808181e:	429f      	cmp	r7, r3
 8081820:	f040 8095 	bne.w	808194e <wm8994_Init+0x28e>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081824:	2243      	movs	r2, #67	; 0x43
 8081826:	f44f 7104 	mov.w	r1, #528	; 0x210
 808182a:	4620      	mov	r0, r4
 808182c:	f000 fd08 	bl	8082240 <AUDIO_IO_Write>
  if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 8081830:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 8081834:	f040 80c1 	bne.w	80819ba <wm8994_Init+0x2fa>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081838:	f244 0218 	movw	r2, #16408	; 0x4018
 808183c:	f44f 7140 	mov.w	r1, #768	; 0x300
 8081840:	4620      	mov	r0, r4
 8081842:	f000 fcfd 	bl	8082240 <AUDIO_IO_Write>
 8081846:	2200      	movs	r2, #0
 8081848:	f240 3102 	movw	r1, #770	; 0x302
 808184c:	4620      	mov	r0, r4
 808184e:	f000 fcf7 	bl	8082240 <AUDIO_IO_Write>
 8081852:	220a      	movs	r2, #10
 8081854:	f44f 7102 	mov.w	r1, #520	; 0x208
 8081858:	4620      	mov	r0, r4
 808185a:	f000 fcf1 	bl	8082240 <AUDIO_IO_Write>
 808185e:	2201      	movs	r2, #1
 8081860:	f44f 7100 	mov.w	r1, #512	; 0x200
 8081864:	4620      	mov	r0, r4
 8081866:	f000 fceb 	bl	8082240 <AUDIO_IO_Write>
  if (output_device > 0)  /* Audio output selected */
 808186a:	2d00      	cmp	r5, #0
 808186c:	f000 815b 	beq.w	8081b26 <wm8994_Init+0x466>
    if (output_device == OUTPUT_DEVICE_HEADPHONE)
 8081870:	2d02      	cmp	r5, #2
 8081872:	f040 824f 	bne.w	8081d14 <wm8994_Init+0x654>
      if(ColdStartup)
 8081876:	f24b 0528 	movw	r5, #45096	; 0xb028
 AUDIO_IO_Write(Addr, Reg, Value);
 808187a:	f44f 7280 	mov.w	r2, #256	; 0x100
 808187e:	212d      	movs	r1, #45	; 0x2d
 8081880:	4620      	mov	r0, r4
      if(ColdStartup)
 8081882:	f2c2 0500 	movt	r5, #8192	; 0x2000
 AUDIO_IO_Write(Addr, Reg, Value);
 8081886:	f000 fcdb 	bl	8082240 <AUDIO_IO_Write>
 808188a:	f44f 7280 	mov.w	r2, #256	; 0x100
 808188e:	212e      	movs	r1, #46	; 0x2e
 8081890:	4620      	mov	r0, r4
 8081892:	f000 fcd5 	bl	8082240 <AUDIO_IO_Write>
      if(ColdStartup)
 8081896:	782b      	ldrb	r3, [r5, #0]
 8081898:	2b00      	cmp	r3, #0
 808189a:	f000 8258 	beq.w	8081d4e <wm8994_Init+0x68e>
 AUDIO_IO_Write(Addr, Reg, Value);
 808189e:	4620      	mov	r0, r4
 80818a0:	f44f 4201 	mov.w	r2, #33024	; 0x8100
 80818a4:	f44f 7188 	mov.w	r1, #272	; 0x110
 80818a8:	f000 fcca 	bl	8082240 <AUDIO_IO_Write>
        ColdStartup=0;
 80818ac:	2300      	movs	r3, #0
        AUDIO_IO_Delay(300);
 80818ae:	f44f 7096 	mov.w	r0, #300	; 0x12c
        ColdStartup=0;
 80818b2:	702b      	strb	r3, [r5, #0]
        AUDIO_IO_Delay(300);
 80818b4:	f000 fcf0 	bl	8082298 <AUDIO_IO_Delay>
 AUDIO_IO_Write(Addr, Reg, Value);
 80818b8:	2200      	movs	r2, #0
 80818ba:	f44f 6184 	mov.w	r1, #1056	; 0x420
 80818be:	4620      	mov	r0, r4
 80818c0:	f000 fcbe 	bl	8082240 <AUDIO_IO_Write>
 80818c4:	f44f 7240 	mov.w	r2, #768	; 0x300
 80818c8:	2103      	movs	r1, #3
 80818ca:	4620      	mov	r0, r4
 80818cc:	f000 fcb8 	bl	8082240 <AUDIO_IO_Write>
 80818d0:	2200      	movs	r2, #0
 80818d2:	2122      	movs	r1, #34	; 0x22
 80818d4:	4620      	mov	r0, r4
 80818d6:	f000 fcb3 	bl	8082240 <AUDIO_IO_Write>
 80818da:	2200      	movs	r2, #0
 80818dc:	2123      	movs	r1, #35	; 0x23
 80818de:	4620      	mov	r0, r4
 80818e0:	f000 fcae 	bl	8082240 <AUDIO_IO_Write>
 80818e4:	f44f 7240 	mov.w	r2, #768	; 0x300
 80818e8:	2136      	movs	r1, #54	; 0x36
 80818ea:	4620      	mov	r0, r4
 80818ec:	f000 fca8 	bl	8082240 <AUDIO_IO_Write>
 80818f0:	f243 0203 	movw	r2, #12291	; 0x3003
 80818f4:	2101      	movs	r1, #1
 80818f6:	4620      	mov	r0, r4
 80818f8:	f000 fca2 	bl	8082240 <AUDIO_IO_Write>
    if (input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 80818fc:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 8081900:	f040 8095 	bne.w	8081a2e <wm8994_Init+0x36e>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081904:	f240 2205 	movw	r2, #517	; 0x205
 8081908:	2151      	movs	r1, #81	; 0x51
 808190a:	4620      	mov	r0, r4
 808190c:	f000 fc98 	bl	8082240 <AUDIO_IO_Write>
 8081910:	e092      	b.n	8081a38 <wm8994_Init+0x378>
 8081912:	2203      	movs	r2, #3
 8081914:	2101      	movs	r1, #1
 8081916:	4620      	mov	r0, r4
 8081918:	f000 fc92 	bl	8082240 <AUDIO_IO_Write>
  AUDIO_IO_Delay(50);
 808191c:	2032      	movs	r0, #50	; 0x32
 808191e:	f000 fcbb 	bl	8082298 <AUDIO_IO_Delay>
    outputEnabled = 1;
 8081922:	f24b 4308 	movw	r3, #46088	; 0xb408
  if (output_device > 0)
 8081926:	2d00      	cmp	r5, #0
 8081928:	f47f aefc 	bne.w	8081724 <wm8994_Init+0x64>
    outputEnabled = 0;
 808192c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8081930:	601d      	str	r5, [r3, #0]
    inputEnabled = 1;
 8081932:	f24b 4304 	movw	r3, #46084	; 0xb404
  if (input_device > 0)
 8081936:	2e00      	cmp	r6, #0
 8081938:	f47f af25 	bne.w	8081786 <wm8994_Init+0xc6>
    inputEnabled = 0;
 808193c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8081940:	46b2      	mov	sl, r6
 8081942:	601e      	str	r6, [r3, #0]
  switch (AudioFreq)
 8081944:	f245 6322 	movw	r3, #22050	; 0x5622
 8081948:	429f      	cmp	r7, r3
 808194a:	f43f af6b 	beq.w	8081824 <wm8994_Init+0x164>
 808194e:	d917      	bls.n	8081980 <wm8994_Init+0x2c0>
 8081950:	f64a 4344 	movw	r3, #44100	; 0xac44
 8081954:	429f      	cmp	r7, r3
 8081956:	f000 81a5 	beq.w	8081ca4 <wm8994_Init+0x5e4>
 808195a:	f240 8186 	bls.w	8081c6a <wm8994_Init+0x5aa>
 808195e:	f64b 3380 	movw	r3, #48000	; 0xbb80
 8081962:	429f      	cmp	r7, r3
 8081964:	d01f      	beq.n	80819a6 <wm8994_Init+0x2e6>
 8081966:	f44f 43ee 	mov.w	r3, #30464	; 0x7700
 808196a:	f2c0 0301 	movt	r3, #1
 808196e:	429f      	cmp	r7, r3
 8081970:	d119      	bne.n	80819a6 <wm8994_Init+0x2e6>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081972:	22a3      	movs	r2, #163	; 0xa3
 8081974:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081978:	4620      	mov	r0, r4
 808197a:	f000 fc61 	bl	8082240 <AUDIO_IO_Write>
    break;
 808197e:	e018      	b.n	80819b2 <wm8994_Init+0x2f2>
  switch (AudioFreq)
 8081980:	f642 3311 	movw	r3, #11025	; 0x2b11
 8081984:	429f      	cmp	r7, r3
 8081986:	f000 8194 	beq.w	8081cb2 <wm8994_Init+0x5f2>
 808198a:	f5b7 5f7a 	cmp.w	r7, #16000	; 0x3e80
 808198e:	f000 80e5 	beq.w	8081b5c <wm8994_Init+0x49c>
 8081992:	f5b7 5ffa 	cmp.w	r7, #8000	; 0x1f40
 8081996:	d106      	bne.n	80819a6 <wm8994_Init+0x2e6>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081998:	2203      	movs	r2, #3
 808199a:	f44f 7104 	mov.w	r1, #528	; 0x210
 808199e:	4620      	mov	r0, r4
 80819a0:	f000 fc4e 	bl	8082240 <AUDIO_IO_Write>
    break;
 80819a4:	e005      	b.n	80819b2 <wm8994_Init+0x2f2>
 AUDIO_IO_Write(Addr, Reg, Value);
 80819a6:	2283      	movs	r2, #131	; 0x83
 80819a8:	f44f 7104 	mov.w	r1, #528	; 0x210
 80819ac:	4620      	mov	r0, r4
 80819ae:	f000 fc47 	bl	8082240 <AUDIO_IO_Write>
  if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 80819b2:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 80819b6:	f43f af3f 	beq.w	8081838 <wm8994_Init+0x178>
 AUDIO_IO_Write(Addr, Reg, Value);
 80819ba:	f244 0210 	movw	r2, #16400	; 0x4010
 80819be:	f44f 7140 	mov.w	r1, #768	; 0x300
 80819c2:	4620      	mov	r0, r4
 80819c4:	f000 fc3c 	bl	8082240 <AUDIO_IO_Write>
 80819c8:	2200      	movs	r2, #0
 80819ca:	f240 3102 	movw	r1, #770	; 0x302
 80819ce:	4620      	mov	r0, r4
 80819d0:	f000 fc36 	bl	8082240 <AUDIO_IO_Write>
 80819d4:	220a      	movs	r2, #10
 80819d6:	f44f 7102 	mov.w	r1, #520	; 0x208
 80819da:	4620      	mov	r0, r4
 80819dc:	f000 fc30 	bl	8082240 <AUDIO_IO_Write>
 80819e0:	2201      	movs	r2, #1
 80819e2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80819e6:	4620      	mov	r0, r4
 80819e8:	f000 fc2a 	bl	8082240 <AUDIO_IO_Write>
  if (output_device > 0)  /* Audio output selected */
 80819ec:	2d00      	cmp	r5, #0
 80819ee:	d07e      	beq.n	8081aee <wm8994_Init+0x42e>
    if (output_device == OUTPUT_DEVICE_HEADPHONE)
 80819f0:	2d02      	cmp	r5, #2
 80819f2:	f43f af40 	beq.w	8081876 <wm8994_Init+0x1b6>
 AUDIO_IO_Write(Addr, Reg, Value);
 80819f6:	f44f 7240 	mov.w	r2, #768	; 0x300
 80819fa:	2103      	movs	r1, #3
 80819fc:	4620      	mov	r0, r4
 80819fe:	f000 fc1f 	bl	8082240 <AUDIO_IO_Write>
 8081a02:	2200      	movs	r2, #0
 8081a04:	2122      	movs	r1, #34	; 0x22
 8081a06:	4620      	mov	r0, r4
 8081a08:	f000 fc1a 	bl	8082240 <AUDIO_IO_Write>
 8081a0c:	2200      	movs	r2, #0
 8081a0e:	2123      	movs	r1, #35	; 0x23
 8081a10:	4620      	mov	r0, r4
 8081a12:	f000 fc15 	bl	8082240 <AUDIO_IO_Write>
 8081a16:	f44f 7240 	mov.w	r2, #768	; 0x300
 8081a1a:	2136      	movs	r1, #54	; 0x36
 8081a1c:	4620      	mov	r0, r4
 8081a1e:	f000 fc0f 	bl	8082240 <AUDIO_IO_Write>
 8081a22:	f243 0203 	movw	r2, #12291	; 0x3003
 8081a26:	2101      	movs	r1, #1
 8081a28:	4620      	mov	r0, r4
 8081a2a:	f000 fc09 	bl	8082240 <AUDIO_IO_Write>
 8081a2e:	2205      	movs	r2, #5
 8081a30:	2151      	movs	r1, #81	; 0x51
 8081a32:	4620      	mov	r0, r4
 8081a34:	f000 fc04 	bl	8082240 <AUDIO_IO_Write>
 8081a38:	f243 3203 	movw	r2, #13059	; 0x3303
 8081a3c:	2101      	movs	r1, #1
 8081a3e:	4620      	mov	r0, r4
    power_mgnt_reg_1 |= 0x0303 | 0x3003;
 8081a40:	4615      	mov	r5, r2
 AUDIO_IO_Write(Addr, Reg, Value);
 8081a42:	f000 fbfd 	bl	8082240 <AUDIO_IO_Write>
 8081a46:	2222      	movs	r2, #34	; 0x22
 8081a48:	2160      	movs	r1, #96	; 0x60
 8081a4a:	4620      	mov	r0, r4
 8081a4c:	f000 fbf8 	bl	8082240 <AUDIO_IO_Write>
 8081a50:	f649 7225 	movw	r2, #40741	; 0x9f25
 8081a54:	214c      	movs	r1, #76	; 0x4c
 8081a56:	4620      	mov	r0, r4
 8081a58:	f000 fbf2 	bl	8082240 <AUDIO_IO_Write>
    AUDIO_IO_Delay(15);
 8081a5c:	200f      	movs	r0, #15
 8081a5e:	f000 fc1b 	bl	8082298 <AUDIO_IO_Delay>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081a62:	2201      	movs	r2, #1
 8081a64:	212d      	movs	r1, #45	; 0x2d
 8081a66:	4620      	mov	r0, r4
 8081a68:	f000 fbea 	bl	8082240 <AUDIO_IO_Write>
 8081a6c:	2201      	movs	r2, #1
 8081a6e:	212e      	movs	r1, #46	; 0x2e
 8081a70:	4620      	mov	r0, r4
 8081a72:	f000 fbe5 	bl	8082240 <AUDIO_IO_Write>
 8081a76:	f44f 724c 	mov.w	r2, #816	; 0x330
 8081a7a:	2103      	movs	r1, #3
 8081a7c:	4620      	mov	r0, r4
 8081a7e:	f000 fbdf 	bl	8082240 <AUDIO_IO_Write>
 8081a82:	2233      	movs	r2, #51	; 0x33
 8081a84:	2154      	movs	r1, #84	; 0x54
 8081a86:	4620      	mov	r0, r4
 8081a88:	f000 fbda 	bl	8082240 <AUDIO_IO_Write>
    AUDIO_IO_Delay(257);
 8081a8c:	f240 1001 	movw	r0, #257	; 0x101
 8081a90:	f000 fc02 	bl	8082298 <AUDIO_IO_Delay>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081a94:	22ee      	movs	r2, #238	; 0xee
 8081a96:	2160      	movs	r1, #96	; 0x60
 8081a98:	4620      	mov	r0, r4
 8081a9a:	f000 fbd1 	bl	8082240 <AUDIO_IO_Write>
 8081a9e:	22c0      	movs	r2, #192	; 0xc0
 8081aa0:	f44f 61c2 	mov.w	r1, #1552	; 0x610
 8081aa4:	4620      	mov	r0, r4
 8081aa6:	f000 fbcb 	bl	8082240 <AUDIO_IO_Write>
 8081aaa:	22c0      	movs	r2, #192	; 0xc0
 8081aac:	f240 6111 	movw	r1, #1553	; 0x611
 8081ab0:	4620      	mov	r0, r4
 8081ab2:	f000 fbc5 	bl	8082240 <AUDIO_IO_Write>
 8081ab6:	2210      	movs	r2, #16
 8081ab8:	f44f 6184 	mov.w	r1, #1056	; 0x420
 8081abc:	4620      	mov	r0, r4
 8081abe:	f000 fbbf 	bl	8082240 <AUDIO_IO_Write>
 8081ac2:	22c0      	movs	r2, #192	; 0xc0
 8081ac4:	f240 6112 	movw	r1, #1554	; 0x612
 8081ac8:	4620      	mov	r0, r4
 8081aca:	f000 fbb9 	bl	8082240 <AUDIO_IO_Write>
 8081ace:	22c0      	movs	r2, #192	; 0xc0
 8081ad0:	f240 6113 	movw	r1, #1555	; 0x613
 8081ad4:	4620      	mov	r0, r4
 8081ad6:	f000 fbb3 	bl	8082240 <AUDIO_IO_Write>
 8081ada:	f240 4122 	movw	r1, #1058	; 0x422
 8081ade:	4620      	mov	r0, r4
 8081ae0:	2210      	movs	r2, #16
 8081ae2:	f000 fbad 	bl	8082240 <AUDIO_IO_Write>
    wm8994_SetVolume(DeviceAddr, Volume);
 8081ae6:	4649      	mov	r1, r9
 8081ae8:	4640      	mov	r0, r8
 8081aea:	f7ff fd4d 	bl	8081588 <wm8994_SetVolume>
  if (input_device > 0) /* Audio input selected */
 8081aee:	b916      	cbnz	r6, 8081af6 <wm8994_Init+0x436>
}
 8081af0:	4650      	mov	r0, sl
 8081af2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((input_device == INPUT_DEVICE_DIGITAL_MICROPHONE_1) || (input_device == INPUT_DEVICE_DIGITAL_MICROPHONE_2))
 8081af6:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8081afa:	f000 8094 	beq.w	8081c26 <wm8994_Init+0x566>
 8081afe:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8081b02:	f000 8090 	beq.w	8081c26 <wm8994_Init+0x566>
    else if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 8081b06:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 8081b0a:	d00c      	beq.n	8081b26 <wm8994_Init+0x466>
    else if ((input_device == INPUT_DEVICE_INPUT_LINE_1) || (input_device == INPUT_DEVICE_INPUT_LINE_2))
 8081b0c:	f5b6 7f40 	cmp.w	r6, #768	; 0x300
 8081b10:	d077      	beq.n	8081c02 <wm8994_Init+0x542>
 8081b12:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 8081b16:	d074      	beq.n	8081c02 <wm8994_Init+0x542>
    wm8994_SetVolume(DeviceAddr, Volume);
 8081b18:	4649      	mov	r1, r9
 8081b1a:	4640      	mov	r0, r8
 8081b1c:	f7ff fd34 	bl	8081588 <wm8994_SetVolume>
}
 8081b20:	4650      	mov	r0, sl
 8081b22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 AUDIO_IO_Write(Addr, Reg, Value);
 8081b26:	f045 0213 	orr.w	r2, r5, #19
 8081b2a:	4620      	mov	r0, r4
 8081b2c:	2101      	movs	r1, #1
 8081b2e:	f000 fb87 	bl	8082240 <AUDIO_IO_Write>
 8081b32:	4620      	mov	r0, r4
 8081b34:	2202      	movs	r2, #2
 8081b36:	f44f 61c4 	mov.w	r1, #1568	; 0x620
 8081b3a:	f000 fb81 	bl	8082240 <AUDIO_IO_Write>
 8081b3e:	4620      	mov	r0, r4
 8081b40:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 8081b44:	f44f 6182 	mov.w	r1, #1040	; 0x410
 8081b48:	f000 fb7a 	bl	8082240 <AUDIO_IO_Write>
 8081b4c:	4620      	mov	r0, r4
 8081b4e:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 8081b52:	f240 4111 	movw	r1, #1041	; 0x411
 8081b56:	f000 fb73 	bl	8082240 <AUDIO_IO_Write>
 8081b5a:	e7dd      	b.n	8081b18 <wm8994_Init+0x458>
 8081b5c:	2233      	movs	r2, #51	; 0x33
 8081b5e:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081b62:	4620      	mov	r0, r4
 8081b64:	f000 fb6c 	bl	8082240 <AUDIO_IO_Write>
    break;
 8081b68:	e723      	b.n	80819b2 <wm8994_Init+0x2f2>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081b6a:	2211      	movs	r2, #17
 8081b6c:	2128      	movs	r1, #40	; 0x28
 8081b6e:	4620      	mov	r0, r4
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000D);
 8081b70:	f04f 0a00 	mov.w	sl, #0
 AUDIO_IO_Write(Addr, Reg, Value);
 8081b74:	f000 fb64 	bl	8082240 <AUDIO_IO_Write>
 8081b78:	2235      	movs	r2, #53	; 0x35
 8081b7a:	2129      	movs	r1, #41	; 0x29
 8081b7c:	4620      	mov	r0, r4
 8081b7e:	f000 fb5f 	bl	8082240 <AUDIO_IO_Write>
 8081b82:	2235      	movs	r2, #53	; 0x35
 8081b84:	212a      	movs	r1, #42	; 0x2a
 8081b86:	4620      	mov	r0, r4
 8081b88:	f000 fb5a 	bl	8082240 <AUDIO_IO_Write>
 8081b8c:	f240 3203 	movw	r2, #771	; 0x303
 8081b90:	2104      	movs	r1, #4
 8081b92:	4620      	mov	r0, r4
 8081b94:	f000 fb54 	bl	8082240 <AUDIO_IO_Write>
 8081b98:	22db      	movs	r2, #219	; 0xdb
 8081b9a:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8081b9e:	4620      	mov	r0, r4
 8081ba0:	f000 fb4e 	bl	8082240 <AUDIO_IO_Write>
 8081ba4:	f246 3250 	movw	r2, #25424	; 0x6350
 8081ba8:	2102      	movs	r1, #2
 8081baa:	4620      	mov	r0, r4
 8081bac:	f000 fb48 	bl	8082240 <AUDIO_IO_Write>
 8081bb0:	2202      	movs	r2, #2
 8081bb2:	f240 6106 	movw	r1, #1542	; 0x606
 8081bb6:	4620      	mov	r0, r4
 8081bb8:	f000 fb42 	bl	8082240 <AUDIO_IO_Write>
 8081bbc:	2202      	movs	r2, #2
 8081bbe:	f240 6107 	movw	r1, #1543	; 0x607
 8081bc2:	e621      	b.n	8081808 <wm8994_Init+0x148>
 8081bc4:	f640 420c 	movw	r2, #3084	; 0xc0c
 8081bc8:	2105      	movs	r1, #5
 8081bca:	4620      	mov	r0, r4
 8081bcc:	f000 fb38 	bl	8082240 <AUDIO_IO_Write>
 8081bd0:	2200      	movs	r2, #0
 8081bd2:	f240 6101 	movw	r1, #1537	; 0x601
 8081bd6:	4620      	mov	r0, r4
 8081bd8:	f000 fb32 	bl	8082240 <AUDIO_IO_Write>
 8081bdc:	2200      	movs	r2, #0
 8081bde:	4620      	mov	r0, r4
 8081be0:	f240 6102 	movw	r1, #1538	; 0x602
 8081be4:	f000 fb2c 	bl	8082240 <AUDIO_IO_Write>
 8081be8:	4620      	mov	r0, r4
 8081bea:	2202      	movs	r2, #2
 8081bec:	f240 6104 	movw	r1, #1540	; 0x604
 8081bf0:	f000 fb26 	bl	8082240 <AUDIO_IO_Write>
 8081bf4:	2202      	movs	r2, #2
 8081bf6:	f240 6105 	movw	r1, #1541	; 0x605
 8081bfa:	4620      	mov	r0, r4
 8081bfc:	f000 fb20 	bl	8082240 <AUDIO_IO_Write>
 8081c00:	e697      	b.n	8081932 <wm8994_Init+0x272>
 8081c02:	4620      	mov	r0, r4
 8081c04:	220b      	movs	r2, #11
 8081c06:	2118      	movs	r1, #24
 8081c08:	f000 fb1a 	bl	8082240 <AUDIO_IO_Write>
 8081c0c:	4620      	mov	r0, r4
 8081c0e:	220b      	movs	r2, #11
 8081c10:	211a      	movs	r1, #26
 8081c12:	f000 fb15 	bl	8082240 <AUDIO_IO_Write>
 8081c16:	4620      	mov	r0, r4
 8081c18:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 8081c1c:	f44f 6182 	mov.w	r1, #1040	; 0x410
 8081c20:	f000 fb0e 	bl	8082240 <AUDIO_IO_Write>
 8081c24:	e778      	b.n	8081b18 <wm8994_Init+0x458>
 8081c26:	f045 0213 	orr.w	r2, r5, #19
 8081c2a:	4620      	mov	r0, r4
 8081c2c:	2101      	movs	r1, #1
 8081c2e:	f000 fb07 	bl	8082240 <AUDIO_IO_Write>
 8081c32:	4620      	mov	r0, r4
 8081c34:	2202      	movs	r2, #2
 8081c36:	f44f 61c4 	mov.w	r1, #1568	; 0x620
 8081c3a:	f000 fb01 	bl	8082240 <AUDIO_IO_Write>
 8081c3e:	4620      	mov	r0, r4
 8081c40:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8081c44:	f240 4111 	movw	r1, #1041	; 0x411
 8081c48:	f000 fafa 	bl	8082240 <AUDIO_IO_Write>
    wm8994_SetVolume(DeviceAddr, Volume);
 8081c4c:	4649      	mov	r1, r9
 8081c4e:	4640      	mov	r0, r8
 8081c50:	f7ff fc9a 	bl	8081588 <wm8994_SetVolume>
 8081c54:	e764      	b.n	8081b20 <wm8994_Init+0x460>
    switch (input_device)
 8081c56:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8081c5a:	d158      	bne.n	8081d0e <wm8994_Init+0x64e>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081c5c:	f44f 7243 	mov.w	r2, #780	; 0x30c
 8081c60:	2104      	movs	r1, #4
 8081c62:	4620      	mov	r0, r4
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000D);
 8081c64:	f04f 0a00 	mov.w	sl, #0
 8081c68:	e794      	b.n	8081b94 <wm8994_Init+0x4d4>
  switch (AudioFreq)
 8081c6a:	f5b7 4ffa 	cmp.w	r7, #32000	; 0x7d00
 8081c6e:	f47f ae9a 	bne.w	80819a6 <wm8994_Init+0x2e6>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081c72:	2263      	movs	r2, #99	; 0x63
 8081c74:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081c78:	4620      	mov	r0, r4
 8081c7a:	f000 fae1 	bl	8082240 <AUDIO_IO_Write>
    break;
 8081c7e:	e698      	b.n	80819b2 <wm8994_Init+0x2f2>
      if (input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 8081c80:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 AUDIO_IO_Write(Addr, Reg, Value);
 8081c84:	f640 720f 	movw	r2, #3855	; 0xf0f
 8081c88:	f04f 0105 	mov.w	r1, #5
 8081c8c:	4620      	mov	r0, r4
      if (input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
 8081c8e:	d069      	beq.n	8081d64 <wm8994_Init+0x6a4>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081c90:	f000 fad6 	bl	8082240 <AUDIO_IO_Write>
 8081c94:	4652      	mov	r2, sl
 8081c96:	f240 6101 	movw	r1, #1537	; 0x601
 8081c9a:	4620      	mov	r0, r4
 8081c9c:	f000 fad0 	bl	8082240 <AUDIO_IO_Write>
 8081ca0:	4652      	mov	r2, sl
 8081ca2:	e79c      	b.n	8081bde <wm8994_Init+0x51e>
 8081ca4:	2273      	movs	r2, #115	; 0x73
 8081ca6:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081caa:	4620      	mov	r0, r4
 8081cac:	f000 fac8 	bl	8082240 <AUDIO_IO_Write>
    break; 
 8081cb0:	e67f      	b.n	80819b2 <wm8994_Init+0x2f2>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081cb2:	2213      	movs	r2, #19
 8081cb4:	f44f 7104 	mov.w	r1, #528	; 0x210
 8081cb8:	4620      	mov	r0, r4
 8081cba:	f000 fac1 	bl	8082240 <AUDIO_IO_Write>
    break;
 8081cbe:	e678      	b.n	80819b2 <wm8994_Init+0x2f2>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081cc0:	4620      	mov	r0, r4
 8081cc2:	f44f 6243 	mov.w	r2, #3120	; 0xc30
 8081cc6:	2104      	movs	r1, #4
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000E);
 8081cc8:	f04f 0a00 	mov.w	sl, #0
 AUDIO_IO_Write(Addr, Reg, Value);
 8081ccc:	f000 fab8 	bl	8082240 <AUDIO_IO_Write>
 8081cd0:	4620      	mov	r0, r4
 8081cd2:	22db      	movs	r2, #219	; 0xdb
 8081cd4:	f44f 618a 	mov.w	r1, #1104	; 0x450
 8081cd8:	f000 fab2 	bl	8082240 <AUDIO_IO_Write>
 8081cdc:	4620      	mov	r0, r4
 8081cde:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8081ce2:	2102      	movs	r1, #2
 8081ce4:	f000 faac 	bl	8082240 <AUDIO_IO_Write>
 8081ce8:	4620      	mov	r0, r4
 8081cea:	2202      	movs	r2, #2
 8081cec:	f44f 61c1 	mov.w	r1, #1544	; 0x608
 8081cf0:	f000 faa6 	bl	8082240 <AUDIO_IO_Write>
 8081cf4:	4620      	mov	r0, r4
 8081cf6:	2202      	movs	r2, #2
 8081cf8:	f240 6109 	movw	r1, #1545	; 0x609
 8081cfc:	f000 faa0 	bl	8082240 <AUDIO_IO_Write>
 8081d00:	220e      	movs	r2, #14
 8081d02:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8081d06:	4620      	mov	r0, r4
 8081d08:	f000 fa9a 	bl	8082240 <AUDIO_IO_Write>
      break;
 8081d0c:	e61a      	b.n	8081944 <wm8994_Init+0x284>
      counter++;
 8081d0e:	f04f 0a01 	mov.w	sl, #1
 8081d12:	e617      	b.n	8081944 <wm8994_Init+0x284>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081d14:	4620      	mov	r0, r4
 8081d16:	f44f 7240 	mov.w	r2, #768	; 0x300
 8081d1a:	2103      	movs	r1, #3
 8081d1c:	f000 fa90 	bl	8082240 <AUDIO_IO_Write>
 8081d20:	4620      	mov	r0, r4
 8081d22:	2200      	movs	r2, #0
 8081d24:	2122      	movs	r1, #34	; 0x22
 8081d26:	f000 fa8b 	bl	8082240 <AUDIO_IO_Write>
 8081d2a:	4620      	mov	r0, r4
 8081d2c:	2200      	movs	r2, #0
 8081d2e:	2123      	movs	r1, #35	; 0x23
 8081d30:	f000 fa86 	bl	8082240 <AUDIO_IO_Write>
 8081d34:	4620      	mov	r0, r4
 8081d36:	f44f 7240 	mov.w	r2, #768	; 0x300
 8081d3a:	2136      	movs	r1, #54	; 0x36
 8081d3c:	f000 fa80 	bl	8082240 <AUDIO_IO_Write>
 8081d40:	f243 0203 	movw	r2, #12291	; 0x3003
 8081d44:	2101      	movs	r1, #1
 8081d46:	4620      	mov	r0, r4
 8081d48:	f000 fa7a 	bl	8082240 <AUDIO_IO_Write>
 8081d4c:	e5da      	b.n	8081904 <wm8994_Init+0x244>
 8081d4e:	4620      	mov	r0, r4
 8081d50:	f248 1208 	movw	r2, #33032	; 0x8108
 8081d54:	f44f 7188 	mov.w	r1, #272	; 0x110
 8081d58:	f000 fa72 	bl	8082240 <AUDIO_IO_Write>
        AUDIO_IO_Delay(50);
 8081d5c:	2032      	movs	r0, #50	; 0x32
 8081d5e:	f000 fa9b 	bl	8082298 <AUDIO_IO_Delay>
 8081d62:	e5a9      	b.n	80818b8 <wm8994_Init+0x1f8>
 AUDIO_IO_Write(Addr, Reg, Value);
 8081d64:	f000 fa6c 	bl	8082240 <AUDIO_IO_Write>
 8081d68:	462a      	mov	r2, r5
 8081d6a:	f240 6101 	movw	r1, #1537	; 0x601
 8081d6e:	4620      	mov	r0, r4
 8081d70:	f000 fa66 	bl	8082240 <AUDIO_IO_Write>
 8081d74:	462a      	mov	r2, r5
 8081d76:	f240 6102 	movw	r1, #1538	; 0x602
 8081d7a:	4620      	mov	r0, r4
 8081d7c:	f000 fa60 	bl	8082240 <AUDIO_IO_Write>
 8081d80:	462a      	mov	r2, r5
 8081d82:	f240 6104 	movw	r1, #1540	; 0x604
 8081d86:	4620      	mov	r0, r4
 8081d88:	f000 fa5a 	bl	8082240 <AUDIO_IO_Write>
 8081d8c:	462a      	mov	r2, r5
 8081d8e:	f240 6105 	movw	r1, #1541	; 0x605
 8081d92:	4620      	mov	r0, r4
 8081d94:	f000 fa54 	bl	8082240 <AUDIO_IO_Write>
    inputEnabled = 1;
 8081d98:	f24b 4304 	movw	r3, #46084	; 0xb404
 8081d9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8081da0:	f8c3 a000 	str.w	sl, [r3]
 8081da4:	e501      	b.n	80817aa <wm8994_Init+0xea>
 8081da6:	bf00      	nop

08081da8 <wm8994_Stop>:
{
 8081da8:	b570      	push	{r4, r5, r6, lr}
  if (outputEnabled != 0)
 8081daa:	f24b 4408 	movw	r4, #46088	; 0xb408
 8081dae:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8081db2:	6822      	ldr	r2, [r4, #0]
 8081db4:	b90a      	cbnz	r2, 8081dba <wm8994_Stop+0x12>
}
 8081db6:	2000      	movs	r0, #0
 8081db8:	bd70      	pop	{r4, r5, r6, pc}
 8081dba:	460e      	mov	r6, r1
 8081dbc:	4605      	mov	r5, r0
 8081dbe:	f7ff fb99 	bl	80814f4 <wm8994_SetMute.part.0>
    if (CodecPdwnMode == CODEC_PDWN_SW)
 8081dc2:	2e02      	cmp	r6, #2
 8081dc4:	d0f7      	beq.n	8081db6 <wm8994_Stop+0xe>
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
 8081dc6:	b2ed      	uxtb	r5, r5
 AUDIO_IO_Write(Addr, Reg, Value);
 8081dc8:	f44f 7200 	mov.w	r2, #512	; 0x200
 8081dcc:	f44f 6184 	mov.w	r1, #1056	; 0x420
 8081dd0:	4628      	mov	r0, r5
 8081dd2:	f000 fa35 	bl	8082240 <AUDIO_IO_Write>
 8081dd6:	4628      	mov	r0, r5
 8081dd8:	f44f 7200 	mov.w	r2, #512	; 0x200
 8081ddc:	f240 4122 	movw	r1, #1058	; 0x422
 8081de0:	f000 fa2e 	bl	8082240 <AUDIO_IO_Write>
 8081de4:	4628      	mov	r0, r5
 8081de6:	2200      	movs	r2, #0
 8081de8:	212d      	movs	r1, #45	; 0x2d
 8081dea:	f000 fa29 	bl	8082240 <AUDIO_IO_Write>
 8081dee:	4628      	mov	r0, r5
 8081df0:	2200      	movs	r2, #0
 8081df2:	212e      	movs	r1, #46	; 0x2e
 8081df4:	f000 fa24 	bl	8082240 <AUDIO_IO_Write>
 8081df8:	4628      	mov	r0, r5
 8081dfa:	2200      	movs	r2, #0
 8081dfc:	2105      	movs	r1, #5
 8081dfe:	f000 fa1f 	bl	8082240 <AUDIO_IO_Write>
 8081e02:	2200      	movs	r2, #0
 8081e04:	4628      	mov	r0, r5
 8081e06:	4611      	mov	r1, r2
 8081e08:	f000 fa1a 	bl	8082240 <AUDIO_IO_Write>
      outputEnabled = 0;
 8081e0c:	2300      	movs	r3, #0
}
 8081e0e:	2000      	movs	r0, #0
      outputEnabled = 0;
 8081e10:	6023      	str	r3, [r4, #0]
}
 8081e12:	bd70      	pop	{r4, r5, r6, pc}

08081e14 <I2Cx_Init>:
 * @brief  Initializes I2C HAL.
 * @param  i2c_handler : I2C handler
 * @retval None
 */
static void I2Cx_Init(I2C_HandleTypeDef *i2c_handler)
{
 8081e14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8081e16:	b08b      	sub	sp, #44	; 0x2c
 8081e18:	4604      	mov	r4, r0
	if(HAL_I2C_GetState(i2c_handler) == HAL_I2C_STATE_RESET)
 8081e1a:	f004 fee3 	bl	8086be4 <HAL_I2C_GetState>
 8081e1e:	2800      	cmp	r0, #0
 8081e20:	d162      	bne.n	8081ee8 <I2Cx_Init+0xd4>
	{
		if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
 8081e22:	f24b 430c 	movw	r3, #46092	; 0xb40c
		DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e26:	f44f 5660 	mov.w	r6, #14336	; 0x3800
 8081e2a:	4605      	mov	r5, r0
			/* External, camera and Arduino connector  I2C configuration */
			i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
		}
		i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
		i2c_handler->Init.OwnAddress1      = 0;
		i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 8081e2c:	2701      	movs	r7, #1
		if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
 8081e2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
		i2c_handler->Init.OwnAddress1      = 0;
 8081e32:	60a0      	str	r0, [r4, #8]
		DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e34:	f2c4 0602 	movt	r6, #16386	; 0x4002
		i2c_handler->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
 8081e38:	6120      	str	r0, [r4, #16]
		if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
 8081e3a:	429c      	cmp	r4, r3
		i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
 8081e3c:	f242 7332 	movw	r3, #10034	; 0x2732
 8081e40:	f2c4 0391 	movt	r3, #16529	; 0x4091
		if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
 8081e44:	d052      	beq.n	8081eec <I2Cx_Init+0xd8>
		i2c_handler->Init.OwnAddress2      = 0;
 8081e46:	6160      	str	r0, [r4, #20]
			i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
 8081e48:	f44f 42a8 	mov.w	r2, #21504	; 0x5400
		i2c_handler->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
 8081e4c:	61e0      	str	r0, [r4, #28]
		gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
 8081e4e:	f44f 7180 	mov.w	r1, #256	; 0x100
		i2c_handler->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
 8081e52:	6220      	str	r0, [r4, #32]
			i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
 8081e54:	f2c4 0200 	movt	r2, #16384	; 0x4000
		i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 8081e58:	60e7      	str	r7, [r4, #12]
		gpio_init_structure.Speed = GPIO_SPEED_FAST;
 8081e5a:	2702      	movs	r7, #2
		i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
 8081e5c:	6063      	str	r3, [r4, #4]
		HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081e5e:	f44f 6080 	mov.w	r0, #1024	; 0x400
		DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e62:	6b33      	ldr	r3, [r6, #48]	; 0x30
			i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
 8081e64:	6022      	str	r2, [r4, #0]
		gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 8081e66:	2212      	movs	r2, #18
		DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e68:	f043 0302 	orr.w	r3, r3, #2
		HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081e6c:	f2c4 0002 	movt	r0, #16386	; 0x4002
		DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e70:	6333      	str	r3, [r6, #48]	; 0x30
 8081e72:	6b33      	ldr	r3, [r6, #48]	; 0x30
		gpio_init_structure.Pull = GPIO_NOPULL;
 8081e74:	9507      	str	r5, [sp, #28]
		DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e76:	403b      	ands	r3, r7
		gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 8081e78:	e9cd 1205 	strd	r1, r2, [sp, #20]
		gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
 8081e7c:	2204      	movs	r2, #4
		DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e7e:	9303      	str	r3, [sp, #12]
		HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081e80:	a905      	add	r1, sp, #20
		DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081e82:	9b03      	ldr	r3, [sp, #12]
		gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
 8081e84:	e9cd 7208 	strd	r7, r2, [sp, #32]
		HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081e88:	f004 f8ea 	bl	8086060 <HAL_GPIO_Init>
		HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081e8c:	f44f 6080 	mov.w	r0, #1024	; 0x400
		gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
 8081e90:	f44f 7300 	mov.w	r3, #512	; 0x200
		HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081e94:	a905      	add	r1, sp, #20
 8081e96:	f2c4 0002 	movt	r0, #16386	; 0x4002
		gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
 8081e9a:	9305      	str	r3, [sp, #20]
		HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081e9c:	f004 f8e0 	bl	8086060 <HAL_GPIO_Init>
		DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 8081ea0:	6c33      	ldr	r3, [r6, #64]	; 0x40
		HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 8081ea2:	462a      	mov	r2, r5
 8081ea4:	210f      	movs	r1, #15
 8081ea6:	201f      	movs	r0, #31
		DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 8081ea8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8081eac:	6433      	str	r3, [r6, #64]	; 0x40
 8081eae:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8081eb0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8081eb4:	9304      	str	r3, [sp, #16]
 8081eb6:	9b04      	ldr	r3, [sp, #16]
		DISCOVERY_EXT_I2Cx_FORCE_RESET();
 8081eb8:	6a33      	ldr	r3, [r6, #32]
 8081eba:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8081ebe:	6233      	str	r3, [r6, #32]
		DISCOVERY_EXT_I2Cx_RELEASE_RESET();
 8081ec0:	6a33      	ldr	r3, [r6, #32]
 8081ec2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8081ec6:	6233      	str	r3, [r6, #32]
		HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 8081ec8:	f003 fca2 	bl	8085810 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
 8081ecc:	201f      	movs	r0, #31
 8081ece:	f003 fcdb 	bl	8085888 <HAL_NVIC_EnableIRQ>
		HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x0F, 0);
 8081ed2:	2020      	movs	r0, #32
 8081ed4:	462a      	mov	r2, r5
 8081ed6:	210f      	movs	r1, #15
 8081ed8:	f003 fc9a 	bl	8085810 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
 8081edc:	2020      	movs	r0, #32
 8081ede:	f003 fcd3 	bl	8085888 <HAL_NVIC_EnableIRQ>

		/* Init the I2C */
		I2Cx_MspInit(i2c_handler);
		HAL_I2C_Init(i2c_handler);
 8081ee2:	4620      	mov	r0, r4
 8081ee4:	f004 fc3c 	bl	8086760 <HAL_I2C_Init>
	}
}
 8081ee8:	b00b      	add	sp, #44	; 0x2c
 8081eea:	bdf0      	pop	{r4, r5, r6, r7, pc}
		i2c_handler->Init.OwnAddress2      = 0;
 8081eec:	6160      	str	r0, [r4, #20]
		gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SCL_PIN;
 8081eee:	2180      	movs	r1, #128	; 0x80
		i2c_handler->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
 8081ef0:	61e0      	str	r0, [r4, #28]
			i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
 8081ef2:	f44f 42b8 	mov.w	r2, #23552	; 0x5c00
		i2c_handler->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
 8081ef6:	6220      	str	r0, [r4, #32]
		HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081ef8:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
		i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 8081efc:	60e7      	str	r7, [r4, #12]
			i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
 8081efe:	f2c4 0200 	movt	r2, #16384	; 0x4000
		i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
 8081f02:	6063      	str	r3, [r4, #4]
		gpio_init_structure.Speed = GPIO_SPEED_FAST;
 8081f04:	2702      	movs	r7, #2
		DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081f06:	6b33      	ldr	r3, [r6, #48]	; 0x30
		HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081f08:	f2c4 0002 	movt	r0, #16386	; 0x4002
			i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
 8081f0c:	6022      	str	r2, [r4, #0]
		gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 8081f0e:	2212      	movs	r2, #18
		DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081f10:	430b      	orrs	r3, r1
 8081f12:	6333      	str	r3, [r6, #48]	; 0x30
 8081f14:	6b33      	ldr	r3, [r6, #48]	; 0x30
		gpio_init_structure.Pull = GPIO_NOPULL;
 8081f16:	9507      	str	r5, [sp, #28]
		DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081f18:	400b      	ands	r3, r1
		gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 8081f1a:	e9cd 1205 	strd	r1, r2, [sp, #20]
		gpio_init_structure.Alternate = DISCOVERY_AUDIO_I2Cx_SCL_SDA_AF;
 8081f1e:	2204      	movs	r2, #4
		DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081f20:	9301      	str	r3, [sp, #4]
		HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081f22:	a905      	add	r1, sp, #20
		DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8081f24:	9b01      	ldr	r3, [sp, #4]
		gpio_init_structure.Alternate = DISCOVERY_AUDIO_I2Cx_SCL_SDA_AF;
 8081f26:	e9cd 7208 	strd	r7, r2, [sp, #32]
		HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081f2a:	f004 f899 	bl	8086060 <HAL_GPIO_Init>
		HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081f2e:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
		gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SDA_PIN;
 8081f32:	f44f 7380 	mov.w	r3, #256	; 0x100
		HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081f36:	a905      	add	r1, sp, #20
 8081f38:	f2c4 0002 	movt	r0, #16386	; 0x4002
		gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SDA_PIN;
 8081f3c:	9305      	str	r3, [sp, #20]
		HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8081f3e:	f004 f88f 	bl	8086060 <HAL_GPIO_Init>
		DISCOVERY_AUDIO_I2Cx_CLK_ENABLE();
 8081f42:	6c33      	ldr	r3, [r6, #64]	; 0x40
		HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_EV_IRQn, 0x0F, 0);
 8081f44:	462a      	mov	r2, r5
 8081f46:	210f      	movs	r1, #15
 8081f48:	2048      	movs	r0, #72	; 0x48
		DISCOVERY_AUDIO_I2Cx_CLK_ENABLE();
 8081f4a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8081f4e:	6433      	str	r3, [r6, #64]	; 0x40
 8081f50:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8081f52:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8081f56:	9302      	str	r3, [sp, #8]
 8081f58:	9b02      	ldr	r3, [sp, #8]
		DISCOVERY_AUDIO_I2Cx_FORCE_RESET();
 8081f5a:	6a33      	ldr	r3, [r6, #32]
 8081f5c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8081f60:	6233      	str	r3, [r6, #32]
		DISCOVERY_AUDIO_I2Cx_RELEASE_RESET();
 8081f62:	6a33      	ldr	r3, [r6, #32]
 8081f64:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8081f68:	6233      	str	r3, [r6, #32]
		HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_EV_IRQn, 0x0F, 0);
 8081f6a:	f003 fc51 	bl	8085810 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_EV_IRQn);
 8081f6e:	2048      	movs	r0, #72	; 0x48
 8081f70:	f003 fc8a 	bl	8085888 <HAL_NVIC_EnableIRQ>
		HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_ER_IRQn, 0x0F, 0);
 8081f74:	462a      	mov	r2, r5
 8081f76:	210f      	movs	r1, #15
 8081f78:	2049      	movs	r0, #73	; 0x49
 8081f7a:	f003 fc49 	bl	8085810 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_ER_IRQn);
 8081f7e:	2049      	movs	r0, #73	; 0x49
 8081f80:	f003 fc82 	bl	8085888 <HAL_NVIC_EnableIRQ>
 8081f84:	e7ad      	b.n	8081ee2 <I2Cx_Init+0xce>
 8081f86:	bf00      	nop

08081f88 <I2Cx_ReadMultiple>:
		uint8_t Addr,
		uint16_t Reg,
		uint16_t MemAddress,
		uint8_t *Buffer,
		uint16_t Length)
{
 8081f88:	b570      	push	{r4, r5, r6, lr}
 8081f8a:	b084      	sub	sp, #16
	HAL_StatusTypeDef status = HAL_OK;

	status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8081f8c:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
{
 8081f90:	f8bd 5024 	ldrh.w	r5, [sp, #36]	; 0x24
 8081f94:	9e08      	ldr	r6, [sp, #32]
	status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8081f96:	9402      	str	r4, [sp, #8]
 8081f98:	e9cd 6500 	strd	r6, r5, [sp]
{
 8081f9c:	4605      	mov	r5, r0
	status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8081f9e:	f004 fd35 	bl	8086a0c <HAL_I2C_Mem_Read>

	/* Check the communication status */
	if(status != HAL_OK)
 8081fa2:	4604      	mov	r4, r0
 8081fa4:	b128      	cbz	r0, 8081fb2 <I2Cx_ReadMultiple+0x2a>
 * @retval None
 */
static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
{
	/* De-initialize the I2C communication bus */
	HAL_I2C_DeInit(i2c_handler);
 8081fa6:	4628      	mov	r0, r5
 8081fa8:	f004 fc32 	bl	8086810 <HAL_I2C_DeInit>

	/* Re-Initialize the I2C communication bus */
	I2Cx_Init(i2c_handler);
 8081fac:	4628      	mov	r0, r5
 8081fae:	f7ff ff31 	bl	8081e14 <I2Cx_Init>
}
 8081fb2:	4620      	mov	r0, r4
 8081fb4:	b004      	add	sp, #16
 8081fb6:	bd70      	pop	{r4, r5, r6, pc}

08081fb8 <I2Cx_WriteMultiple>:
{
 8081fb8:	b570      	push	{r4, r5, r6, lr}
 8081fba:	b084      	sub	sp, #16
	status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8081fbc:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
{
 8081fc0:	f8bd 5024 	ldrh.w	r5, [sp, #36]	; 0x24
 8081fc4:	9e08      	ldr	r6, [sp, #32]
	status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8081fc6:	9402      	str	r4, [sp, #8]
 8081fc8:	e9cd 6500 	strd	r6, r5, [sp]
{
 8081fcc:	4605      	mov	r5, r0
	status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8081fce:	f004 fc39 	bl	8086844 <HAL_I2C_Mem_Write>
	if(status != HAL_OK)
 8081fd2:	4604      	mov	r4, r0
 8081fd4:	b128      	cbz	r0, 8081fe2 <I2Cx_WriteMultiple+0x2a>
	HAL_I2C_DeInit(i2c_handler);
 8081fd6:	4628      	mov	r0, r5
 8081fd8:	f004 fc1a 	bl	8086810 <HAL_I2C_DeInit>
	I2Cx_Init(i2c_handler);
 8081fdc:	4628      	mov	r0, r5
 8081fde:	f7ff ff19 	bl	8081e14 <I2Cx_Init>
}
 8081fe2:	4620      	mov	r0, r4
 8081fe4:	b004      	add	sp, #16
 8081fe6:	bd70      	pop	{r4, r5, r6, pc}

08081fe8 <BSP_LED_Init>:
	if (Led == LED1)
 8081fe8:	b100      	cbz	r0, 8081fec <BSP_LED_Init+0x4>
 8081fea:	4770      	bx	lr
		LED1_GPIO_CLK_ENABLE();
 8081fec:	f44f 5360 	mov.w	r3, #14336	; 0x3800
		gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
 8081ff0:	2101      	movs	r1, #1
		LED1_GPIO_CLK_ENABLE();
 8081ff2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8081ff6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8081ff8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
{
 8081ffc:	b570      	push	{r4, r5, r6, lr}
		LED1_GPIO_CLK_ENABLE();
 8081ffe:	631a      	str	r2, [r3, #48]	; 0x30
{
 8082000:	b086      	sub	sp, #24
		LED1_GPIO_CLK_ENABLE();
 8082002:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8082004:	4604      	mov	r4, r0
		HAL_GPIO_Init(gpio_led, &gpio_init_structure);
 8082006:	f44f 5000 	mov.w	r0, #8192	; 0x2000
		gpio_init_structure.Pin = GPIO_PIN[Led];
 808200a:	2502      	movs	r5, #2
		LED1_GPIO_CLK_ENABLE();
 808200c:	f403 7380 	and.w	r3, r3, #256	; 0x100
		gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 8082010:	2603      	movs	r6, #3
		HAL_GPIO_Init(gpio_led, &gpio_init_structure);
 8082012:	f2c4 0002 	movt	r0, #16386	; 0x4002
		gpio_init_structure.Pin = GPIO_PIN[Led];
 8082016:	9501      	str	r5, [sp, #4]
		LED1_GPIO_CLK_ENABLE();
 8082018:	9300      	str	r3, [sp, #0]
 808201a:	9b00      	ldr	r3, [sp, #0]
		gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 808201c:	9604      	str	r6, [sp, #16]
		gpio_init_structure.Pull = GPIO_PULLUP;
 808201e:	e9cd 1102 	strd	r1, r1, [sp, #8]
		HAL_GPIO_Init(gpio_led, &gpio_init_structure);
 8082022:	a901      	add	r1, sp, #4
 8082024:	f004 f81c 	bl	8086060 <HAL_GPIO_Init>
		HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
 8082028:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 808202c:	4622      	mov	r2, r4
 808202e:	4629      	mov	r1, r5
 8082030:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082034:	f004 fa34 	bl	80864a0 <HAL_GPIO_WritePin>
}
 8082038:	b006      	add	sp, #24
 808203a:	bd70      	pop	{r4, r5, r6, pc}

0808203c <BSP_PB_Init>:
	BUTTONx_GPIO_CLK_ENABLE(Button);
 808203c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8082040:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8082044:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8082046:	f442 7280 	orr.w	r2, r2, #256	; 0x100
{
 808204a:	b530      	push	{r4, r5, lr}
	BUTTONx_GPIO_CLK_ENABLE(Button);
 808204c:	631a      	str	r2, [r3, #48]	; 0x30
{
 808204e:	b089      	sub	sp, #36	; 0x24
	BUTTONx_GPIO_CLK_ENABLE(Button);
 8082050:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8082052:	4604      	mov	r4, r0
 8082054:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8082058:	bb70      	cbnz	r0, 80820b8 <BSP_PB_Init+0x7c>
 808205a:	9300      	str	r3, [sp, #0]
 808205c:	9b00      	ldr	r3, [sp, #0]
	if(ButtonMode == BUTTON_MODE_GPIO)
 808205e:	b389      	cbz	r1, 80820c4 <BSP_PB_Init+0x88>
	if(ButtonMode == BUTTON_MODE_EXTI)
 8082060:	2901      	cmp	r1, #1
 8082062:	d127      	bne.n	80820b4 <BSP_PB_Init+0x78>
		gpio_init_structure.Pin = BUTTON_PIN[Button];
 8082064:	f642 1374 	movw	r3, #10612	; 0x2974
		gpio_init_structure.Pull = GPIO_NOPULL;
 8082068:	2100      	movs	r1, #0
		gpio_init_structure.Speed = GPIO_SPEED_FAST;
 808206a:	2202      	movs	r2, #2
		gpio_init_structure.Pin = BUTTON_PIN[Button];
 808206c:	f6c0 0309 	movt	r3, #2057	; 0x809
 8082070:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
		gpio_init_structure.Speed = GPIO_SPEED_FAST;
 8082074:	e9cd 1205 	strd	r1, r2, [sp, #20]
		gpio_init_structure.Pin = BUTTON_PIN[Button];
 8082078:	9303      	str	r3, [sp, #12]
		if(Button != BUTTON_WAKEUP)
 808207a:	2c00      	cmp	r4, #0
 808207c:	d138      	bne.n	80820f0 <BSP_PB_Init+0xb4>
			gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
 808207e:	2300      	movs	r3, #0
 8082080:	f2c1 0311 	movt	r3, #4113	; 0x1011
 8082084:	9304      	str	r3, [sp, #16]
		HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8082086:	f24b 035c 	movw	r3, #45148	; 0xb05c
 808208a:	a903      	add	r1, sp, #12
 808208c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8082090:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8082094:	f003 ffe4 	bl	8086060 <HAL_GPIO_Init>
		HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
 8082098:	f642 136c 	movw	r3, #10604	; 0x296c
 808209c:	2200      	movs	r2, #0
 808209e:	210f      	movs	r1, #15
 80820a0:	f6c0 0309 	movt	r3, #2057	; 0x809
 80820a4:	f913 4014 	ldrsb.w	r4, [r3, r4, lsl #1]
 80820a8:	4620      	mov	r0, r4
 80820aa:	f003 fbb1 	bl	8085810 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 80820ae:	4620      	mov	r0, r4
 80820b0:	f003 fbea 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 80820b4:	b009      	add	sp, #36	; 0x24
 80820b6:	bd30      	pop	{r4, r5, pc}
	BUTTONx_GPIO_CLK_ENABLE(Button);
 80820b8:	2801      	cmp	r0, #1
 80820ba:	d01e      	beq.n	80820fa <BSP_PB_Init+0xbe>
 80820bc:	9302      	str	r3, [sp, #8]
 80820be:	9b02      	ldr	r3, [sp, #8]
	if(ButtonMode == BUTTON_MODE_GPIO)
 80820c0:	2900      	cmp	r1, #0
 80820c2:	d1cd      	bne.n	8082060 <BSP_PB_Init+0x24>
		gpio_init_structure.Pin = BUTTON_PIN[Button];
 80820c4:	f642 1274 	movw	r2, #10612	; 0x2974
		HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 80820c8:	f24b 035c 	movw	r3, #45148	; 0xb05c
		gpio_init_structure.Mode = GPIO_MODE_INPUT;
 80820cc:	9104      	str	r1, [sp, #16]
		gpio_init_structure.Speed = GPIO_SPEED_FAST;
 80820ce:	2502      	movs	r5, #2
		HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 80820d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
		gpio_init_structure.Pin = BUTTON_PIN[Button];
 80820d4:	f6c0 0209 	movt	r2, #2057	; 0x809
		gpio_init_structure.Pull = GPIO_NOPULL;
 80820d8:	9105      	str	r1, [sp, #20]
		HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 80820da:	a903      	add	r1, sp, #12
		gpio_init_structure.Pin = BUTTON_PIN[Button];
 80820dc:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
		HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 80820e0:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
		gpio_init_structure.Pin = BUTTON_PIN[Button];
 80820e4:	9203      	str	r2, [sp, #12]
		gpio_init_structure.Speed = GPIO_SPEED_FAST;
 80820e6:	9506      	str	r5, [sp, #24]
		HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 80820e8:	f003 ffba 	bl	8086060 <HAL_GPIO_Init>
}
 80820ec:	b009      	add	sp, #36	; 0x24
 80820ee:	bd30      	pop	{r4, r5, pc}
			gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 80820f0:	460b      	mov	r3, r1
 80820f2:	f2c1 0321 	movt	r3, #4129	; 0x1021
 80820f6:	9304      	str	r3, [sp, #16]
 80820f8:	e7c5      	b.n	8082086 <BSP_PB_Init+0x4a>
	BUTTONx_GPIO_CLK_ENABLE(Button);
 80820fa:	9301      	str	r3, [sp, #4]
 80820fc:	9b01      	ldr	r3, [sp, #4]
 80820fe:	e7ae      	b.n	808205e <BSP_PB_Init+0x22>

08082100 <BSP_PB_GetState>:
	if (Button >=256)
 8082100:	28ff      	cmp	r0, #255	; 0xff
{
 8082102:	b508      	push	{r3, lr}
	if (Button >=256)
 8082104:	d80e      	bhi.n	8082124 <BSP_PB_GetState+0x24>
		status= HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 8082106:	f642 1274 	movw	r2, #10612	; 0x2974
 808210a:	f24b 035c 	movw	r3, #45148	; 0xb05c
 808210e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8082112:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8082116:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
 808211a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 808211e:	f004 f9b9 	bl	8086494 <HAL_GPIO_ReadPin>
}
 8082122:	bd08      	pop	{r3, pc}
		status= BSP_KEYS_GetKey(Button-256);
 8082124:	b2c0      	uxtb	r0, r0
 8082126:	f000 ff69 	bl	8082ffc <BSP_KEYS_GetKey>
}
 808212a:	bd08      	pop	{r3, pc}

0808212c <BSP_COM_Init>:
	DISCOVERY_COMx_TX_GPIO_CLK_ENABLE(COM);
 808212c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8082130:	f2c4 0302 	movt	r3, #16386	; 0x4002
{
 8082134:	b5f0      	push	{r4, r5, r6, r7, lr}
	DISCOVERY_COMx_TX_GPIO_CLK_ENABLE(COM);
 8082136:	6b1a      	ldr	r2, [r3, #48]	; 0x30
{
 8082138:	b08d      	sub	sp, #52	; 0x34
 808213a:	460e      	mov	r6, r1
	DISCOVERY_COMx_TX_GPIO_CLK_ENABLE(COM);
 808213c:	4604      	mov	r4, r0
 808213e:	2800      	cmp	r0, #0
 8082140:	d15a      	bne.n	80821f8 <BSP_COM_Init+0xcc>
 8082142:	f042 0201 	orr.w	r2, r2, #1
 8082146:	631a      	str	r2, [r3, #48]	; 0x30
 8082148:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808214a:	f002 0201 	and.w	r2, r2, #1
 808214e:	9201      	str	r2, [sp, #4]
 8082150:	9a01      	ldr	r2, [sp, #4]
	DISCOVERY_COMx_RX_GPIO_CLK_ENABLE(COM);
 8082152:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8082154:	f042 0202 	orr.w	r2, r2, #2
 8082158:	631a      	str	r2, [r3, #48]	; 0x30
 808215a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808215c:	f002 0202 	and.w	r2, r2, #2
 8082160:	9203      	str	r2, [sp, #12]
 8082162:	9a03      	ldr	r2, [sp, #12]
	DISCOVERY_COMx_CLK_ENABLE(COM);
 8082164:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8082166:	f042 0210 	orr.w	r2, r2, #16
 808216a:	645a      	str	r2, [r3, #68]	; 0x44
 808216c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 808216e:	f003 0310 	and.w	r3, r3, #16
 8082172:	9305      	str	r3, [sp, #20]
 8082174:	9b05      	ldr	r3, [sp, #20]
	gpio_init_structure.Pin = COM_TX_PIN[COM];
 8082176:	f642 1188 	movw	r1, #10632	; 0x2988
	gpio_init_structure.Alternate = COM_TX_AF[COM];
 808217a:	f642 1284 	movw	r2, #10628	; 0x2984
	HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
 808217e:	f24b 0370 	movw	r3, #45168	; 0xb070
	gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 8082182:	2502      	movs	r5, #2
	gpio_init_structure.Pin = COM_TX_PIN[COM];
 8082184:	f6c0 0109 	movt	r1, #2057	; 0x809
	gpio_init_structure.Alternate = COM_TX_AF[COM];
 8082188:	f6c0 0209 	movt	r2, #2057	; 0x809
	HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
 808218c:	f2c2 0300 	movt	r3, #8192	; 0x2000
	gpio_init_structure.Pull = GPIO_PULLUP;
 8082190:	2701      	movs	r7, #1
	gpio_init_structure.Pin = COM_TX_PIN[COM];
 8082192:	f831 c014 	ldrh.w	ip, [r1, r4, lsl #1]
	HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
 8082196:	a907      	add	r1, sp, #28
	gpio_init_structure.Alternate = COM_TX_AF[COM];
 8082198:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
	HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
 808219c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
	gpio_init_structure.Pin = COM_TX_PIN[COM];
 80821a0:	f8cd c01c 	str.w	ip, [sp, #28]
	gpio_init_structure.Alternate = COM_TX_AF[COM];
 80821a4:	920b      	str	r2, [sp, #44]	; 0x2c
	gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 80821a6:	9508      	str	r5, [sp, #32]
	gpio_init_structure.Pull = GPIO_PULLUP;
 80821a8:	e9cd 7509 	strd	r7, r5, [sp, #36]	; 0x24
	HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
 80821ac:	f003 ff58 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Pin = COM_RX_PIN[COM];
 80821b0:	f642 1080 	movw	r0, #10624	; 0x2980
	gpio_init_structure.Alternate = COM_RX_AF[COM];
 80821b4:	f642 127c 	movw	r2, #10620	; 0x297c
	HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
 80821b8:	f24b 0368 	movw	r3, #45160	; 0xb068
	gpio_init_structure.Pin = COM_RX_PIN[COM];
 80821bc:	f6c0 0009 	movt	r0, #2057	; 0x809
	gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 80821c0:	9508      	str	r5, [sp, #32]
	gpio_init_structure.Alternate = COM_RX_AF[COM];
 80821c2:	f6c0 0209 	movt	r2, #2057	; 0x809
	HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
 80821c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
	gpio_init_structure.Pin = COM_RX_PIN[COM];
 80821ca:	f830 5014 	ldrh.w	r5, [r0, r4, lsl #1]
	HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
 80821ce:	a907      	add	r1, sp, #28
	gpio_init_structure.Alternate = COM_RX_AF[COM];
 80821d0:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
	HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
 80821d4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
	gpio_init_structure.Alternate = COM_RX_AF[COM];
 80821d8:	920b      	str	r2, [sp, #44]	; 0x2c
	gpio_init_structure.Pin = COM_RX_PIN[COM];
 80821da:	9507      	str	r5, [sp, #28]
	HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
 80821dc:	f003 ff40 	bl	8086060 <HAL_GPIO_Init>
	huart->Instance = COM_USART[COM];
 80821e0:	f24b 0378 	movw	r3, #45176	; 0xb078
	return HAL_UART_Init(huart);
 80821e4:	4630      	mov	r0, r6
	huart->Instance = COM_USART[COM];
 80821e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80821ea:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80821ee:	6033      	str	r3, [r6, #0]
	return HAL_UART_Init(huart);
 80821f0:	f008 ff72 	bl	808b0d8 <HAL_UART_Init>
}
 80821f4:	b00d      	add	sp, #52	; 0x34
 80821f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	DISCOVERY_COMx_TX_GPIO_CLK_ENABLE(COM);
 80821f8:	f042 0204 	orr.w	r2, r2, #4
 80821fc:	631a      	str	r2, [r3, #48]	; 0x30
 80821fe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8082200:	f002 0204 	and.w	r2, r2, #4
 8082204:	9202      	str	r2, [sp, #8]
 8082206:	9a02      	ldr	r2, [sp, #8]
	DISCOVERY_COMx_RX_GPIO_CLK_ENABLE(COM);
 8082208:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808220a:	f042 0204 	orr.w	r2, r2, #4
 808220e:	631a      	str	r2, [r3, #48]	; 0x30
 8082210:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8082212:	f002 0204 	and.w	r2, r2, #4
 8082216:	9204      	str	r2, [sp, #16]
 8082218:	9a04      	ldr	r2, [sp, #16]
	DISCOVERY_COMx_CLK_ENABLE(COM);
 808221a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 808221c:	f042 0220 	orr.w	r2, r2, #32
 8082220:	645a      	str	r2, [r3, #68]	; 0x44
 8082222:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8082224:	f003 0320 	and.w	r3, r3, #32
 8082228:	9306      	str	r3, [sp, #24]
 808222a:	9b06      	ldr	r3, [sp, #24]
 808222c:	e7a3      	b.n	8082176 <BSP_COM_Init+0x4a>
 808222e:	bf00      	nop

08082230 <AUDIO_IO_Init>:
 * @brief  Initializes Audio low level.
 * @retval None
 */
void AUDIO_IO_Init(void) 
{
	I2Cx_Init(&hI2cAudioHandler);
 8082230:	f24b 400c 	movw	r0, #46092	; 0xb40c
 8082234:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082238:	f7ff bdec 	b.w	8081e14 <I2Cx_Init>

0808223c <AUDIO_IO_DeInit>:
 * @brief  Deinitializes Audio low level.
 * @retval None
 */
void AUDIO_IO_DeInit(void)
{
}
 808223c:	4770      	bx	lr
 808223e:	bf00      	nop

08082240 <AUDIO_IO_Write>:
 * @param  Reg: Reg address
 * @param  Value: Data to be written
 * @retval None
 */
void AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
{
 8082240:	b530      	push	{r4, r5, lr}
 8082242:	b085      	sub	sp, #20
	uint16_t tmp = Value;

	Value = ((uint16_t)(tmp >> 8) & 0x00FF);

	Value |= ((uint16_t)(tmp << 8)& 0xFF00);
 8082244:	ba53      	rev16	r3, r2

	I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2);
 8082246:	2502      	movs	r5, #2
 8082248:	460a      	mov	r2, r1
	Value |= ((uint16_t)(tmp << 8)& 0xFF00);
 808224a:	ac04      	add	r4, sp, #16
	I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2);
 808224c:	4601      	mov	r1, r0
 808224e:	f24b 400c 	movw	r0, #46092	; 0xb40c
	Value |= ((uint16_t)(tmp << 8)& 0xFF00);
 8082252:	f824 3d02 	strh.w	r3, [r4, #-2]!
	I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2);
 8082256:	462b      	mov	r3, r5
 8082258:	9400      	str	r4, [sp, #0]
 808225a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808225e:	9501      	str	r5, [sp, #4]
 8082260:	f7ff feaa 	bl	8081fb8 <I2Cx_WriteMultiple>
}
 8082264:	b005      	add	sp, #20
 8082266:	bd30      	pop	{r4, r5, pc}

08082268 <AUDIO_IO_Read>:
 * @param  Addr: I2C address
 * @param  Reg: Reg address
 * @retval Data to be read
 */
uint16_t AUDIO_IO_Read(uint8_t Addr, uint16_t Reg)
{
 8082268:	b530      	push	{r4, r5, lr}
 808226a:	b085      	sub	sp, #20
	uint16_t read_value = 0, tmp = 0;

	I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2);
 808226c:	460a      	mov	r2, r1
 808226e:	2302      	movs	r3, #2
 8082270:	4601      	mov	r1, r0
	uint16_t read_value = 0, tmp = 0;
 8082272:	ac04      	add	r4, sp, #16
 8082274:	2500      	movs	r5, #0
	I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2);
 8082276:	f24b 400c 	movw	r0, #46092	; 0xb40c
	uint16_t read_value = 0, tmp = 0;
 808227a:	f824 5d02 	strh.w	r5, [r4, #-2]!
	I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2);
 808227e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082282:	e9cd 4300 	strd	r4, r3, [sp]
 8082286:	f7ff fe7f 	bl	8081f88 <I2Cx_ReadMultiple>
 808228a:	f8bd 000e 	ldrh.w	r0, [sp, #14]
 808228e:	ba40      	rev16	r0, r0
	tmp |= ((uint16_t)(read_value << 8)& 0xFF00);

	read_value = tmp;

	return read_value;
}
 8082290:	b280      	uxth	r0, r0
 8082292:	b005      	add	sp, #20
 8082294:	bd30      	pop	{r4, r5, pc}
 8082296:	bf00      	nop

08082298 <AUDIO_IO_Delay>:
 * @param  Delay: Delay in ms
 * @retval None
 */
void AUDIO_IO_Delay(uint32_t Delay)
{
	HAL_Delay(Delay);
 8082298:	f003 ba90 	b.w	80857bc <HAL_Delay>

0808229c <TS_IO_Init>:
 808229c:	f7ff bfc8 	b.w	8082230 <AUDIO_IO_Init>

080822a0 <TS_IO_Write>:
 * @param  Reg: Reg address
 * @param  Value: Data to be written
 * @retval None
 */
void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
 80822a0:	b510      	push	{r4, lr}
 80822a2:	b084      	sub	sp, #16
	I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
 80822a4:	2401      	movs	r4, #1
{
 80822a6:	ab04      	add	r3, sp, #16
 80822a8:	f803 2d01 	strb.w	r2, [r3, #-1]!
	I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
 80822ac:	460a      	mov	r2, r1
 80822ae:	4601      	mov	r1, r0
 80822b0:	f24b 400c 	movw	r0, #46092	; 0xb40c
 80822b4:	9300      	str	r3, [sp, #0]
 80822b6:	4623      	mov	r3, r4
 80822b8:	9401      	str	r4, [sp, #4]
 80822ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80822be:	f7ff fe7b 	bl	8081fb8 <I2Cx_WriteMultiple>
}
 80822c2:	b004      	add	sp, #16
 80822c4:	bd10      	pop	{r4, pc}
 80822c6:	bf00      	nop

080822c8 <TS_IO_Read>:
 * @param  Addr: I2C address
 * @param  Reg: Reg address
 * @retval Data to be read
 */
uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
{
 80822c8:	b530      	push	{r4, r5, lr}
 80822ca:	b085      	sub	sp, #20
	uint8_t read_value = 0;

	I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
 80822cc:	460a      	mov	r2, r1
 80822ce:	2301      	movs	r3, #1
 80822d0:	4601      	mov	r1, r0
	uint8_t read_value = 0;
 80822d2:	ac04      	add	r4, sp, #16
 80822d4:	2500      	movs	r5, #0
	I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
 80822d6:	f24b 400c 	movw	r0, #46092	; 0xb40c
	uint8_t read_value = 0;
 80822da:	f804 5d01 	strb.w	r5, [r4, #-1]!
	I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
 80822de:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80822e2:	e9cd 4300 	strd	r4, r3, [sp]
 80822e6:	f7ff fe4f 	bl	8081f88 <I2Cx_ReadMultiple>

	return read_value;
}
 80822ea:	f89d 000f 	ldrb.w	r0, [sp, #15]
 80822ee:	b005      	add	sp, #20
 80822f0:	bd30      	pop	{r4, r5, pc}
 80822f2:	bf00      	nop

080822f4 <TS_IO_Delay>:
 80822f4:	f003 ba62 	b.w	80857bc <HAL_Delay>

080822f8 <HAL_UART_RxCpltCallback>:
}

/**************************** COMx *****************************************/
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	if (huart->Instance == COM_USART[COM1])
 80822f8:	f24b 0378 	movw	r3, #45176	; 0xb078
 80822fc:	6802      	ldr	r2, [r0, #0]
 80822fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8082302:	681b      	ldr	r3, [r3, #0]
 8082304:	429a      	cmp	r2, r3
 8082306:	d000      	beq.n	808230a <HAL_UART_RxCpltCallback+0x12>
		BSP_STDIO_DataReceived	((char*)(huart->pRxBuffPtr-huart->RxXferSize), huart->RxXferSize);
}
 8082308:	4770      	bx	lr
		BSP_STDIO_DataReceived	((char*)(huart->pRxBuffPtr-huart->RxXferSize), huart->RxXferSize);
 808230a:	f8b0 1058 	ldrh.w	r1, [r0, #88]	; 0x58
 808230e:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8082310:	1a40      	subs	r0, r0, r1
 8082312:	f003 b84d 	b.w	80853b0 <BSP_STDIO_DataReceived>
 8082316:	bf00      	nop

08082318 <platform_read>:
 * @param  len       number of consecutive register to read
 *
 */
static int32_t platform_read(void *handle, uint8_t reg, uint8_t *bufp,
		uint16_t len)
{
 8082318:	b510      	push	{r4, lr}

	HAL_I2C_Mem_Read(handle, LSM6DS3_I2C_ADD_H, reg,
 808231a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
{
 808231e:	b084      	sub	sp, #16
	HAL_I2C_Mem_Read(handle, LSM6DS3_I2C_ADD_H, reg,
 8082320:	e9cd 2300 	strd	r2, r3, [sp]
 8082324:	9402      	str	r4, [sp, #8]
 8082326:	460a      	mov	r2, r1
 8082328:	2301      	movs	r3, #1
 808232a:	21d7      	movs	r1, #215	; 0xd7
 808232c:	f004 fb6e 	bl	8086a0c <HAL_I2C_Mem_Read>
			I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);


	return 0;
}
 8082330:	2000      	movs	r0, #0
 8082332:	b004      	add	sp, #16
 8082334:	bd10      	pop	{r4, pc}
 8082336:	bf00      	nop

08082338 <platform_write>:
{
 8082338:	b510      	push	{r4, lr}
	HAL_I2C_Mem_Write(handle, LSM6DS3_I2C_ADD_H, reg,
 808233a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
{
 808233e:	b084      	sub	sp, #16
	HAL_I2C_Mem_Write(handle, LSM6DS3_I2C_ADD_H, reg,
 8082340:	e9cd 2300 	strd	r2, r3, [sp]
 8082344:	9402      	str	r4, [sp, #8]
 8082346:	460a      	mov	r2, r1
 8082348:	2301      	movs	r3, #1
 808234a:	21d7      	movs	r1, #215	; 0xd7
 808234c:	f004 fa7a 	bl	8086844 <HAL_I2C_Mem_Write>
}
 8082350:	2000      	movs	r0, #0
 8082352:	b004      	add	sp, #16
 8082354:	bd10      	pop	{r4, pc}
 8082356:	bf00      	nop

08082358 <BSP_ACC_ReadRawValues.part.0>:
uint8_t BSP_ACC_ReadRawValues(axis3bit16_t *data_raw_acceleration)
 8082358:	b510      	push	{r4, lr}
 808235a:	4604      	mov	r4, r0
 808235c:	b082      	sub	sp, #8
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 808235e:	b672      	cpsid	i
		lsm6ds3_xl_flag_data_ready_get(&sensorCtx, &reg);
 8082360:	f24d 604c 	movw	r0, #54860	; 0xd64c
 8082364:	f10d 0107 	add.w	r1, sp, #7
 8082368:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808236c:	f7fe ff76 	bl	808125c <lsm6ds3_xl_flag_data_ready_get>
		if (reg)
 8082370:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8082374:	b91b      	cbnz	r3, 808237e <BSP_ACC_ReadRawValues.part.0+0x26>
  __ASM volatile ("cpsie i" : : : "memory");
 8082376:	b662      	cpsie	i
}
 8082378:	2000      	movs	r0, #0
 808237a:	b002      	add	sp, #8
 808237c:	bd10      	pop	{r4, pc}
			memset(data_raw_acceleration->u8bit, 0, 3 * sizeof(int16_t));
 808237e:	2300      	movs	r3, #0
			lsm6ds3_acceleration_raw_get(&sensorCtx, data_raw_acceleration->u8bit);
 8082380:	f24d 604c 	movw	r0, #54860	; 0xd64c
 8082384:	4621      	mov	r1, r4
			memset(data_raw_acceleration->u8bit, 0, 3 * sizeof(int16_t));
 8082386:	6023      	str	r3, [r4, #0]
			lsm6ds3_acceleration_raw_get(&sensorCtx, data_raw_acceleration->u8bit);
 8082388:	f2c2 0002 	movt	r0, #8194	; 0x2002
			memset(data_raw_acceleration->u8bit, 0, 3 * sizeof(int16_t));
 808238c:	80a3      	strh	r3, [r4, #4]
			lsm6ds3_acceleration_raw_get(&sensorCtx, data_raw_acceleration->u8bit);
 808238e:	f7fe ffa9 	bl	80812e4 <lsm6ds3_acceleration_raw_get>
 8082392:	b662      	cpsie	i
}
 8082394:	2000      	movs	r0, #0
 8082396:	b002      	add	sp, #8
 8082398:	bd10      	pop	{r4, pc}
 808239a:	bf00      	nop

0808239c <BSP_GYRO_ReadRawValues.part.1>:
uint8_t BSP_GYRO_ReadRawValues(axis3bit16_t *data_raw_angular_rate)
 808239c:	b510      	push	{r4, lr}
 808239e:	4604      	mov	r4, r0
 80823a0:	b082      	sub	sp, #8
  __ASM volatile ("cpsid i" : : : "memory");
 80823a2:	b672      	cpsid	i
		lsm6ds3_gy_flag_data_ready_get(&sensorCtx, &reg);
 80823a4:	f24d 604c 	movw	r0, #54860	; 0xd64c
 80823a8:	f10d 0107 	add.w	r1, sp, #7
 80823ac:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80823b0:	f7fe ff64 	bl	808127c <lsm6ds3_gy_flag_data_ready_get>
		if (reg)
 80823b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80823b8:	b91b      	cbnz	r3, 80823c2 <BSP_GYRO_ReadRawValues.part.1+0x26>
  __ASM volatile ("cpsie i" : : : "memory");
 80823ba:	b662      	cpsie	i
}
 80823bc:	2000      	movs	r0, #0
 80823be:	b002      	add	sp, #8
 80823c0:	bd10      	pop	{r4, pc}
			memset(data_raw_angular_rate->u8bit, 0, 3 * sizeof(int16_t));
 80823c2:	2300      	movs	r3, #0
			lsm6ds3_angular_rate_raw_get(&sensorCtx, data_raw_angular_rate->u8bit);
 80823c4:	f24d 604c 	movw	r0, #54860	; 0xd64c
 80823c8:	4621      	mov	r1, r4
			memset(data_raw_angular_rate->u8bit, 0, 3 * sizeof(int16_t));
 80823ca:	6023      	str	r3, [r4, #0]
			lsm6ds3_angular_rate_raw_get(&sensorCtx, data_raw_angular_rate->u8bit);
 80823cc:	f2c2 0002 	movt	r0, #8194	; 0x2002
			memset(data_raw_angular_rate->u8bit, 0, 3 * sizeof(int16_t));
 80823d0:	80a3      	strh	r3, [r4, #4]
			lsm6ds3_angular_rate_raw_get(&sensorCtx, data_raw_angular_rate->u8bit);
 80823d2:	f7fe ff7d 	bl	80812d0 <lsm6ds3_angular_rate_raw_get>
 80823d6:	b662      	cpsie	i
}
 80823d8:	2000      	movs	r0, #0
 80823da:	b002      	add	sp, #8
 80823dc:	bd10      	pop	{r4, pc}
 80823de:	bf00      	nop

080823e0 <BSP_ACC_ReadValues>:
	if (accSensorEnabled)
 80823e0:	f24b 43a4 	movw	r3, #46244	; 0xb4a4
 80823e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
 80823e8:	b530      	push	{r4, r5, lr}
	if (accSensorEnabled)
 80823ea:	781a      	ldrb	r2, [r3, #0]
{
 80823ec:	b083      	sub	sp, #12
	if (accSensorEnabled)
 80823ee:	b13a      	cbz	r2, 8082400 <BSP_ACC_ReadValues+0x20>
  __ASM volatile ("cpsid i" : : : "memory");
 80823f0:	b672      	cpsid	i
	if (accSensorEnabled)
 80823f2:	781b      	ldrb	r3, [r3, #0]
 80823f4:	b943      	cbnz	r3, 8082408 <BSP_ACC_ReadValues+0x28>
	} else status = ACC_ERROR;
 80823f6:	2401      	movs	r4, #1
  __ASM volatile ("cpsie i" : : : "memory");
 80823f8:	b662      	cpsie	i
}
 80823fa:	4620      	mov	r0, r4
 80823fc:	b003      	add	sp, #12
 80823fe:	bd30      	pop	{r4, r5, pc}
	} else status = ACC_ERROR;
 8082400:	2401      	movs	r4, #1
}
 8082402:	4620      	mov	r0, r4
 8082404:	b003      	add	sp, #12
 8082406:	bd30      	pop	{r4, r5, pc}
 8082408:	4605      	mov	r5, r0
 808240a:	4668      	mov	r0, sp
 808240c:	f7ff ffa4 	bl	8082358 <BSP_ACC_ReadRawValues.part.0>
		if (status == ACC_OK)
 8082410:	4604      	mov	r4, r0
 8082412:	2800      	cmp	r0, #0
 8082414:	d1f0      	bne.n	80823f8 <BSP_ACC_ReadValues+0x18>
					lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[0]);
 8082416:	f9bd 0000 	ldrsh.w	r0, [sp]
 808241a:	f7fe fe6f 	bl	80810fc <lsm6ds3_from_fs2g_to_mg>
					lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[1]);
 808241e:	f9bd 0002 	ldrsh.w	r0, [sp, #2]
			acceleration->x =
 8082422:	ed85 0a00 	vstr	s0, [r5]
					lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[1]);
 8082426:	f7fe fe69 	bl	80810fc <lsm6ds3_from_fs2g_to_mg>
					lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[2]);
 808242a:	f9bd 0004 	ldrsh.w	r0, [sp, #4]
			acceleration->y =
 808242e:	ed85 0a01 	vstr	s0, [r5, #4]
					lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[2]);
 8082432:	f7fe fe63 	bl	80810fc <lsm6ds3_from_fs2g_to_mg>
			acceleration->z =
 8082436:	ed85 0a02 	vstr	s0, [r5, #8]
 808243a:	e7dd      	b.n	80823f8 <BSP_ACC_ReadValues+0x18>

0808243c <BSP_GYRO_ReadValues>:
	if (accSensorEnabled)
 808243c:	f24b 43a4 	movw	r3, #46244	; 0xb4a4
 8082440:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
 8082444:	b530      	push	{r4, r5, lr}
	if (accSensorEnabled)
 8082446:	781a      	ldrb	r2, [r3, #0]
{
 8082448:	b083      	sub	sp, #12
	if (accSensorEnabled)
 808244a:	b13a      	cbz	r2, 808245c <BSP_GYRO_ReadValues+0x20>
  __ASM volatile ("cpsid i" : : : "memory");
 808244c:	b672      	cpsid	i
	if (accSensorEnabled)
 808244e:	781b      	ldrb	r3, [r3, #0]
 8082450:	b943      	cbnz	r3, 8082464 <BSP_GYRO_ReadValues+0x28>
	} else status = ACC_ERROR;
 8082452:	2401      	movs	r4, #1
  __ASM volatile ("cpsie i" : : : "memory");
 8082454:	b662      	cpsie	i
}
 8082456:	4620      	mov	r0, r4
 8082458:	b003      	add	sp, #12
 808245a:	bd30      	pop	{r4, r5, pc}
	} else status = ACC_ERROR;
 808245c:	2401      	movs	r4, #1
}
 808245e:	4620      	mov	r0, r4
 8082460:	b003      	add	sp, #12
 8082462:	bd30      	pop	{r4, r5, pc}
 8082464:	4605      	mov	r5, r0
 8082466:	4668      	mov	r0, sp
 8082468:	f7ff ff98 	bl	808239c <BSP_GYRO_ReadRawValues.part.1>
		if (status == ACC_OK)
 808246c:	4604      	mov	r4, r0
 808246e:	2800      	cmp	r0, #0
 8082470:	d1f0      	bne.n	8082454 <BSP_GYRO_ReadValues+0x18>
					lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[0]);
 8082472:	f9bd 0000 	ldrsh.w	r0, [sp]
 8082476:	f7fe fe55 	bl	8081124 <lsm6ds3_from_fs2000dps_to_mdps>
					lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[1]);
 808247a:	f9bd 0002 	ldrsh.w	r0, [sp, #2]
			angular_rate->x =
 808247e:	ed85 0a00 	vstr	s0, [r5]
					lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[1]);
 8082482:	f7fe fe4f 	bl	8081124 <lsm6ds3_from_fs2000dps_to_mdps>
					lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[2]);
 8082486:	f9bd 0004 	ldrsh.w	r0, [sp, #4]
			angular_rate->y =
 808248a:	ed85 0a01 	vstr	s0, [r5, #4]
					lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[2]);
 808248e:	f7fe fe49 	bl	8081124 <lsm6ds3_from_fs2000dps_to_mdps>
			angular_rate->z =
 8082492:	ed85 0a02 	vstr	s0, [r5, #8]
 8082496:	e7dd      	b.n	8082454 <BSP_GYRO_ReadValues+0x18>

08082498 <BSP_ACC_ReadTemperature>:
	if (accSensorEnabled)
 8082498:	f24b 43a4 	movw	r3, #46244	; 0xb4a4
 808249c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80824a0:	781b      	ldrb	r3, [r3, #0]
 80824a2:	b90b      	cbnz	r3, 80824a8 <BSP_ACC_ReadTemperature+0x10>
	} else status = ACC_ERROR;
 80824a4:	2001      	movs	r0, #1
}
 80824a6:	4770      	bx	lr
{
 80824a8:	b530      	push	{r4, r5, lr}
 80824aa:	4605      	mov	r5, r0
 80824ac:	b083      	sub	sp, #12
  __ASM volatile ("cpsid i" : : : "memory");
 80824ae:	b672      	cpsid	i
		lsm6ds3_temp_flag_data_ready_get(&sensorCtx, &reg);
 80824b0:	f24d 604c 	movw	r0, #54860	; 0xd64c
 80824b4:	f10d 0103 	add.w	r1, sp, #3
 80824b8:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80824bc:	f7fe feee 	bl	808129c <lsm6ds3_temp_flag_data_ready_get>
		if (reg)
 80824c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80824c4:	b91b      	cbnz	r3, 80824ce <BSP_ACC_ReadTemperature+0x36>
			status =  ACC_NO_DATA;
 80824c6:	2003      	movs	r0, #3
  __ASM volatile ("cpsie i" : : : "memory");
 80824c8:	b662      	cpsie	i
}
 80824ca:	b003      	add	sp, #12
 80824cc:	bd30      	pop	{r4, r5, pc}
			lsm6ds3_temperature_raw_get(&sensorCtx, data_raw_temperature.u8bit);
 80824ce:	f24d 604c 	movw	r0, #54860	; 0xd64c
			memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
 80824d2:	2400      	movs	r4, #0
			lsm6ds3_temperature_raw_get(&sensorCtx, data_raw_temperature.u8bit);
 80824d4:	a901      	add	r1, sp, #4
 80824d6:	f2c2 0002 	movt	r0, #8194	; 0x2002
			memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
 80824da:	f8ad 4004 	strh.w	r4, [sp, #4]
			lsm6ds3_temperature_raw_get(&sensorCtx, data_raw_temperature.u8bit);
 80824de:	f7fe feed 	bl	80812bc <lsm6ds3_temperature_raw_get>
			*temperature_degC = lsm6ds3_from_lsb_to_celsius(data_raw_temperature.i16bit);
 80824e2:	f9bd 0004 	ldrsh.w	r0, [sp, #4]
 80824e6:	f7fe fe29 	bl	808113c <lsm6ds3_from_lsb_to_celsius>
	uint8_t status= ACC_OK;
 80824ea:	4620      	mov	r0, r4
			*temperature_degC = lsm6ds3_from_lsb_to_celsius(data_raw_temperature.i16bit);
 80824ec:	ed85 0a00 	vstr	s0, [r5]
 80824f0:	b662      	cpsie	i
}
 80824f2:	b003      	add	sp, #12
 80824f4:	bd30      	pop	{r4, r5, pc}
 80824f6:	bf00      	nop

080824f8 <BSP_ACC_GYRO_MspInit>:
 *           - Peripheral's GPIO Configuration
 *           - NVIC configuration for QSPI interrupt
 * @retval None
 */
__weak void BSP_ACC_GYRO_MspInit(void)
{
 80824f8:	b570      	push	{r4, r5, r6, lr}
	GPIO_InitTypeDef gpio_init_structure;
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 80824fa:	f44f 5460 	mov.w	r4, #14336	; 0x3800
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
	gpio_init_structure.Mode = GPIO_MODE_AF_OD;
	gpio_init_structure.Pull = GPIO_PULLUP;
	gpio_init_structure.Speed = GPIO_SPEED_FAST;
	gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 80824fe:	f44f 6580 	mov.w	r5, #1024	; 0x400
{
 8082502:	b088      	sub	sp, #32
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
 8082504:	f44f 7680 	mov.w	r6, #256	; 0x100
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8082508:	f2c4 0402 	movt	r4, #16386	; 0x4002
	gpio_init_structure.Pull = GPIO_PULLUP;
 808250c:	2201      	movs	r2, #1
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 808250e:	f2c4 0502 	movt	r5, #16386	; 0x4002
	gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 8082512:	2012      	movs	r0, #18
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8082514:	6b23      	ldr	r3, [r4, #48]	; 0x30
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8082516:	a903      	add	r1, sp, #12
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8082518:	f043 0302 	orr.w	r3, r3, #2
 808251c:	6323      	str	r3, [r4, #48]	; 0x30
 808251e:	6b23      	ldr	r3, [r4, #48]	; 0x30
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
 8082520:	9603      	str	r6, [sp, #12]
	gpio_init_structure.Speed = GPIO_SPEED_FAST;
 8082522:	2602      	movs	r6, #2
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8082524:	f003 0302 	and.w	r3, r3, #2
	gpio_init_structure.Pull = GPIO_PULLUP;
 8082528:	9205      	str	r2, [sp, #20]
	gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
 808252a:	2204      	movs	r2, #4
	gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 808252c:	9004      	str	r0, [sp, #16]
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 808252e:	9301      	str	r3, [sp, #4]
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8082530:	4628      	mov	r0, r5
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8082532:	9b01      	ldr	r3, [sp, #4]
	gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
 8082534:	e9cd 6206 	strd	r6, r2, [sp, #24]
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8082538:	f003 fd92 	bl	8086060 <HAL_GPIO_Init>

	/* Configure I2C Rx as alternate function */
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
 808253c:	f44f 7300 	mov.w	r3, #512	; 0x200
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8082540:	4628      	mov	r0, r5
 8082542:	a903      	add	r1, sp, #12
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
 8082544:	9303      	str	r3, [sp, #12]
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8082546:	f003 fd8b 	bl	8086060 <HAL_GPIO_Init>
	//	HAL_NVIC_EnableIRQ(I2C1_  SPI2_IRQn);


	/*** Configure the I2C peripheral ***/
	/* Enable I2C clock */
	DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 808254a:	6c23      	ldr	r3, [r4, #64]	; 0x40

	/* Release the I2C peripheral clock reset */
	DISCOVERY_EXT_I2Cx_RELEASE_RESET();

	/* Enable and set I2Cx Interrupt to a lower priority */
	HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 808254c:	2200      	movs	r2, #0
 808254e:	210f      	movs	r1, #15
 8082550:	201f      	movs	r0, #31
	DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 8082552:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8082556:	6423      	str	r3, [r4, #64]	; 0x40
 8082558:	6c23      	ldr	r3, [r4, #64]	; 0x40
 808255a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 808255e:	9302      	str	r3, [sp, #8]
 8082560:	9b02      	ldr	r3, [sp, #8]
	DISCOVERY_EXT_I2Cx_FORCE_RESET();
 8082562:	6a23      	ldr	r3, [r4, #32]
 8082564:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8082568:	6223      	str	r3, [r4, #32]
	DISCOVERY_EXT_I2Cx_RELEASE_RESET();
 808256a:	6a23      	ldr	r3, [r4, #32]
 808256c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8082570:	6223      	str	r3, [r4, #32]
	HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 8082572:	f003 f94d 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
 8082576:	201f      	movs	r0, #31
 8082578:	f003 f986 	bl	8085888 <HAL_NVIC_EnableIRQ>

	/* Enable and set I2Cx Interrupt to a lower priority */
	HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x0F, 0);
 808257c:	2200      	movs	r2, #0
 808257e:	210f      	movs	r1, #15
 8082580:	2020      	movs	r0, #32
 8082582:	f003 f945 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
 8082586:	2020      	movs	r0, #32
 8082588:	f003 f97e 	bl	8085888 <HAL_NVIC_EnableIRQ>

	//	/* Enable and set EXTI9-5 Interrupt to the lowest priority */
	//	HAL_NVIC_SetPriority(ACC_GYRO_DRDY_EXTI_IRQn, 0xFF, 0);
	//	HAL_NVIC_EnableIRQ(ACC_GYRO_DRDY_EXTI_IRQn);
}
 808258c:	b008      	add	sp, #32
 808258e:	bd70      	pop	{r4, r5, r6, pc}

08082590 <BSP_ACC_GYRO_Init>:
{ 
 8082590:	b5f0      	push	{r4, r5, r6, r7, lr}
	I2CHandle.Instance = ACC_GYRO_I2Cx;
 8082592:	f24b 4458 	movw	r4, #46168	; 0xb458
 8082596:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
{ 
 808259a:	b083      	sub	sp, #12
	I2CHandle.Instance = ACC_GYRO_I2Cx;
 808259c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80825a0:	f2c4 0300 	movt	r3, #16384	; 0x4000
	if (HAL_I2C_DeInit(&I2CHandle) != HAL_OK)
 80825a4:	4620      	mov	r0, r4
	I2CHandle.Instance = ACC_GYRO_I2Cx;
 80825a6:	6023      	str	r3, [r4, #0]
	if (HAL_I2C_DeInit(&I2CHandle) != HAL_OK)
 80825a8:	f004 f932 	bl	8086810 <HAL_I2C_DeInit>
 80825ac:	b118      	cbz	r0, 80825b6 <BSP_ACC_GYRO_Init+0x26>
		return ACC_ERROR;
 80825ae:	2401      	movs	r4, #1
}
 80825b0:	4620      	mov	r0, r4
 80825b2:	b003      	add	sp, #12
 80825b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80825b6:	4605      	mov	r5, r0
	BSP_ACC_GYRO_MspInit();
 80825b8:	f7ff ff9e 	bl	80824f8 <BSP_ACC_GYRO_MspInit>
	I2CHandle.Init.Timing          = ACC_GYRO_I2C_TIMING;
 80825bc:	f242 7232 	movw	r2, #10034	; 0x2732
	I2CHandle.Init.OwnAddress1     = 0xFF;
 80825c0:	23ff      	movs	r3, #255	; 0xff
	I2CHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
 80825c2:	2601      	movs	r6, #1
	if (HAL_I2C_Init(&I2CHandle) != HAL_OK)
 80825c4:	4620      	mov	r0, r4
	I2CHandle.Init.Timing          = ACC_GYRO_I2C_TIMING;
 80825c6:	f2c4 0291 	movt	r2, #16529	; 0x4091
	I2CHandle.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80825ca:	6125      	str	r5, [r4, #16]
	I2CHandle.Init.OwnAddress2     = 0xFF;
 80825cc:	6163      	str	r3, [r4, #20]
	I2CHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
 80825ce:	60e6      	str	r6, [r4, #12]
	I2CHandle.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
 80825d0:	e9c4 5507 	strd	r5, r5, [r4, #28]
	I2CHandle.Init.OwnAddress1     = 0xFF;
 80825d4:	e9c4 2301 	strd	r2, r3, [r4, #4]
	if (HAL_I2C_Init(&I2CHandle) != HAL_OK)
 80825d8:	f004 f8c2 	bl	8086760 <HAL_I2C_Init>
 80825dc:	2800      	cmp	r0, #0
 80825de:	d1e6      	bne.n	80825ae <BSP_ACC_GYRO_Init+0x1e>
	HAL_I2CEx_ConfigAnalogFilter(&I2CHandle,I2C_ANALOGFILTER_ENABLE);
 80825e0:	4601      	mov	r1, r0
	sensorCtx.write_reg = platform_write;
 80825e2:	f24d 654c 	movw	r5, #54860	; 0xd64c
	HAL_I2CEx_ConfigAnalogFilter(&I2CHandle,I2C_ANALOGFILTER_ENABLE);
 80825e6:	4620      	mov	r0, r4
 80825e8:	f004 fb00 	bl	8086bec <HAL_I2CEx_ConfigAnalogFilter>
	sensorCtx.write_reg = platform_write;
 80825ec:	f242 3239 	movw	r2, #9017	; 0x2339
	sensorCtx.read_reg = platform_read;
 80825f0:	f242 3319 	movw	r3, #8985	; 0x2319
	sensorCtx.write_reg = platform_write;
 80825f4:	f2c2 0502 	movt	r5, #8194	; 0x2002
 80825f8:	f6c0 0208 	movt	r2, #2056	; 0x808
	lsm6ds3_device_id_get(&sensorCtx, &whoamI);
 80825fc:	f10d 0106 	add.w	r1, sp, #6
	sensorCtx.read_reg = platform_read;
 8082600:	f6c0 0308 	movt	r3, #2056	; 0x808
	lsm6ds3_device_id_get(&sensorCtx, &whoamI);
 8082604:	4628      	mov	r0, r5
	sensorCtx.handle = &I2CHandle;
 8082606:	60ac      	str	r4, [r5, #8]
	sensorCtx.read_reg = platform_read;
 8082608:	e9c5 2300 	strd	r2, r3, [r5]
	lsm6ds3_device_id_get(&sensorCtx, &whoamI);
 808260c:	f7fe fe74 	bl	80812f8 <lsm6ds3_device_id_get>
	if (whoamI != LSM6DS3_ID)
 8082610:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8082614:	2b69      	cmp	r3, #105	; 0x69
 8082616:	d1ca      	bne.n	80825ae <BSP_ACC_GYRO_Init+0x1e>
	lsm6ds3_reset_set(&sensorCtx, PROPERTY_ENABLE);
 8082618:	4631      	mov	r1, r6
 808261a:	4628      	mov	r0, r5
		lsm6ds3_reset_get(&sensorCtx, &rst);
 808261c:	462f      	mov	r7, r5
	lsm6ds3_reset_set(&sensorCtx, PROPERTY_ENABLE);
 808261e:	f7fe fe75 	bl	808130c <lsm6ds3_reset_set>
		lsm6ds3_reset_get(&sensorCtx, &rst);
 8082622:	f10d 0107 	add.w	r1, sp, #7
 8082626:	4638      	mov	r0, r7
 8082628:	f7fe fe8a 	bl	8081340 <lsm6ds3_reset_get>
	} while (rst);
 808262c:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8082630:	2c00      	cmp	r4, #0
 8082632:	d1f6      	bne.n	8082622 <BSP_ACC_GYRO_Init+0x92>
	lsm6ds3_block_data_update_set(&sensorCtx, PROPERTY_ENABLE);
 8082634:	f24d 604c 	movw	r0, #54860	; 0xd64c
 8082638:	2101      	movs	r1, #1
 808263a:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808263e:	f7fe fdf3 	bl	8081228 <lsm6ds3_block_data_update_set>
	lsm6ds3_xl_full_scale_set(&sensorCtx, LSM6DS3_4g);
 8082642:	f24d 604c 	movw	r0, #54860	; 0xd64c
 8082646:	2102      	movs	r1, #2
 8082648:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808264c:	f7fe fd84 	bl	8081158 <lsm6ds3_xl_full_scale_set>
	lsm6ds3_gy_full_scale_set(&sensorCtx, LSM6DS3_1000dps);
 8082650:	f24d 604c 	movw	r0, #54860	; 0xd64c
 8082654:	2104      	movs	r1, #4
 8082656:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808265a:	f7fe fdb1 	bl	80811c0 <lsm6ds3_gy_full_scale_set>
	lsm6ds3_xl_data_rate_set(&sensorCtx, LSM6DS3_XL_ODR_833Hz);
 808265e:	f24d 604c 	movw	r0, #54860	; 0xd64c
 8082662:	2107      	movs	r1, #7
 8082664:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8082668:	f7fe fd90 	bl	808118c <lsm6ds3_xl_data_rate_set>
	lsm6ds3_gy_data_rate_set(&sensorCtx, LSM6DS3_GY_ODR_833Hz);
 808266c:	f24d 604c 	movw	r0, #54860	; 0xd64c
 8082670:	2107      	movs	r1, #7
 8082672:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8082676:	f7fe fdbd 	bl	80811f4 <lsm6ds3_gy_data_rate_set>
	accSensorEnabled = 1;
 808267a:	f24b 43a4 	movw	r3, #46244	; 0xb4a4
 808267e:	2201      	movs	r2, #1
 8082680:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8082684:	701a      	strb	r2, [r3, #0]
	return ACC_OK;
 8082686:	e793      	b.n	80825b0 <BSP_ACC_GYRO_Init+0x20>

08082688 <SAIx_In_Init>:
  */
static void SAIx_In_Init(uint32_t SaiOutMode, uint32_t SlotActive, uint32_t AudioFreq)
{
  /* Initialize SAI2 block A in MASTER RX */
  /* Initialize the haudio_out_sai Instance parameter */
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082688:	f645 4304 	movw	r3, #23556	; 0x5c04
  haudio_out_sai.Init.Protocol = SAI_FREE_PROTOCOL;
  haudio_out_sai.Init.DataSize = SAI_DATASIZE_16;
  haudio_out_sai.Init.FirstBit = SAI_FIRSTBIT_MSB;
  haudio_out_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
  haudio_out_sai.Init.Synchro = SAI_ASYNCHRONOUS;
  haudio_out_sai.Init.OutputDrive = SAI_OUTPUTDRIVE_ENABLED;
 808268c:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082690:	f2c4 0301 	movt	r3, #16385	; 0x4001
{
 8082694:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082698:	681c      	ldr	r4, [r3, #0]
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 808269a:	f24b 552c 	movw	r5, #46380	; 0xb52c
  haudio_out_sai.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
 808269e:	2600      	movs	r6, #0
{
 80826a0:	b083      	sub	sp, #12
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 80826a2:	f2c2 0500 	movt	r5, #8192	; 0x2000
  __HAL_SAI_DISABLE(&haudio_out_sai);
 80826a6:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
  haudio_out_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 80826aa:	2701      	movs	r7, #1
  FS Definition: Start frame + Channel Side identification
  FS Polarity: FS active Low
  FS Offset: FS asserted one bit before the first bit of slot 0 */
  haudio_out_sai.FrameInit.FrameLength = 64;
  haudio_out_sai.FrameInit.ActiveFrameLength = 32;
  haudio_out_sai.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
 80826ac:	f44f 3980 	mov.w	r9, #65536	; 0x10000
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 80826b0:	602b      	str	r3, [r5, #0]
  haudio_out_sai.FrameInit.FrameLength = 64;
 80826b2:	f04f 0b40 	mov.w	fp, #64	; 0x40
  __HAL_SAI_DISABLE(&haudio_out_sai);
 80826b6:	601c      	str	r4, [r3, #0]
  haudio_out_sai.Init.DataSize = SAI_DATASIZE_16;
 80826b8:	2380      	movs	r3, #128	; 0x80
  haudio_out_sai.FrameInit.ActiveFrameLength = 32;
 80826ba:	f04f 0a20 	mov.w	sl, #32
  haudio_out_sai.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
  haudio_out_sai.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
 80826be:	f44f 2880 	mov.w	r8, #262144	; 0x40000
  haudio_out_sai.Init.DataSize = SAI_DATASIZE_16;
 80826c2:	636b      	str	r3, [r5, #52]	; 0x34
  Slot Size  : 16
  Slot Number: 4
  Slot Active: All slot actives */
  haudio_out_sai.SlotInit.FirstBitOffset = 0;
  haudio_out_sai.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
  haudio_out_sai.SlotInit.SlotNumber = 4;
 80826c4:	2304      	movs	r3, #4
  haudio_out_sai.Init.AudioMode = SaiOutMode;
 80826c6:	6068      	str	r0, [r5, #4]
  haudio_out_sai.SlotInit.SlotActive = SlotActive;

  HAL_SAI_Init(&haudio_out_sai);
 80826c8:	4628      	mov	r0, r5
  haudio_out_sai.Init.AudioFrequency = AudioFreq;
 80826ca:	61ea      	str	r2, [r5, #28]

  /* Initialize SAI2 block B in SLAVE RX synchronous from SAI2 block A */
  /* Initialize the haudio_in_sai Instance parameter */
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 80826cc:	f24b 44a8 	movw	r4, #46248	; 0xb4a8
  haudio_out_sai.Init.AudioFrequency = AudioFreq;
 80826d0:	9201      	str	r2, [sp, #4]
  haudio_out_sai.SlotInit.SlotActive = SlotActive;
 80826d2:	6629      	str	r1, [r5, #96]	; 0x60
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 80826d4:	f2c2 0400 	movt	r4, #8192	; 0x2000
  haudio_out_sai.SlotInit.SlotActive = SlotActive;
 80826d8:	9100      	str	r1, [sp, #0]
  haudio_out_sai.SlotInit.SlotNumber = 4;
 80826da:	65eb      	str	r3, [r5, #92]	; 0x5c
  haudio_out_sai.Init.Protocol = SAI_FREE_PROTOCOL;
 80826dc:	632e      	str	r6, [r5, #48]	; 0x30
  haudio_out_sai.Init.FirstBit = SAI_FIRSTBIT_MSB;
 80826de:	63ae      	str	r6, [r5, #56]	; 0x38
  haudio_out_sai.Init.Synchro = SAI_ASYNCHRONOUS;
 80826e0:	60ae      	str	r6, [r5, #8]
  haudio_out_sai.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 80826e2:	64ee      	str	r6, [r5, #76]	; 0x4c
  haudio_out_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 80826e4:	63ef      	str	r7, [r5, #60]	; 0x3c
  haudio_out_sai.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 80826e6:	61af      	str	r7, [r5, #24]
  haudio_out_sai.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
 80826e8:	f8c5 9048 	str.w	r9, [r5, #72]	; 0x48
  haudio_out_sai.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
 80826ec:	f8c5 8050 	str.w	r8, [r5, #80]	; 0x50
  haudio_out_sai.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
 80826f0:	e9c5 c604 	strd	ip, r6, [r5, #16]
  haudio_out_sai.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 80826f4:	e9c5 6615 	strd	r6, r6, [r5, #84]	; 0x54
  haudio_out_sai.FrameInit.ActiveFrameLength = 32;
 80826f8:	e9c5 ba10 	strd	fp, sl, [r5, #64]	; 0x40
  HAL_SAI_Init(&haudio_out_sai);
 80826fc:	f005 ffb2 	bl	8088664 <HAL_SAI_Init>
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082700:	f645 4324 	movw	r3, #23588	; 0x5c24
  __HAL_SAI_DISABLE(&haudio_in_sai);
  
  /* Configure SAI_Block_x
  LSBFirst: Disabled
  DataSize: 16 */
  haudio_in_sai.Init.AudioFrequency = AudioFreq;
 8082704:	9a01      	ldr	r2, [sp, #4]
  haudio_in_sai.Init.AudioMode = SAI_MODESLAVE_RX;
 8082706:	f04f 0e03 	mov.w	lr, #3
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 808270a:	f2c4 0301 	movt	r3, #16385	; 0x4001
  Slot Number: 4
  Slot Active: All slot active */
  haudio_in_sai.SlotInit.FirstBitOffset = 0;
  haudio_in_sai.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
  haudio_in_sai.SlotInit.SlotNumber = 4;
  haudio_in_sai.SlotInit.SlotActive = SlotActive;
 808270e:	9900      	ldr	r1, [sp, #0]

  HAL_SAI_Init(&haudio_in_sai);
 8082710:	4620      	mov	r0, r4
  __HAL_SAI_DISABLE(&haudio_in_sai);
 8082712:	f8d3 c000 	ldr.w	ip, [r3]
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082716:	6023      	str	r3, [r4, #0]
  __HAL_SAI_DISABLE(&haudio_in_sai);
 8082718:	f42c 3c80 	bic.w	ip, ip, #65536	; 0x10000
 808271c:	f8c3 c000 	str.w	ip, [r3]
  haudio_in_sai.Init.DataSize = SAI_DATASIZE_16;
 8082720:	2380      	movs	r3, #128	; 0x80
  haudio_in_sai.Init.AudioFrequency = AudioFreq;
 8082722:	61e2      	str	r2, [r4, #28]
  haudio_in_sai.SlotInit.SlotActive = SlotActive;
 8082724:	6621      	str	r1, [r4, #96]	; 0x60
  haudio_in_sai.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
 8082726:	6166      	str	r6, [r4, #20]
  haudio_in_sai.Init.Protocol = SAI_FREE_PROTOCOL;
 8082728:	6326      	str	r6, [r4, #48]	; 0x30
  haudio_in_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 808272a:	63e7      	str	r7, [r4, #60]	; 0x3c
  haudio_in_sai.Init.Synchro = SAI_SYNCHRONOUS;
 808272c:	60a7      	str	r7, [r4, #8]
  haudio_in_sai.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLED;
 808272e:	6126      	str	r6, [r4, #16]
  haudio_in_sai.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 8082730:	61a7      	str	r7, [r4, #24]
  haudio_in_sai.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 8082732:	65a6      	str	r6, [r4, #88]	; 0x58
  haudio_in_sai.Init.AudioMode = SAI_MODESLAVE_RX;
 8082734:	f8c4 e004 	str.w	lr, [r4, #4]
  haudio_in_sai.Init.FirstBit = SAI_FIRSTBIT_MSB;
 8082738:	e9c4 360d 	strd	r3, r6, [r4, #52]	; 0x34
  haudio_in_sai.SlotInit.SlotNumber = 4;
 808273c:	2304      	movs	r3, #4
  haudio_in_sai.FrameInit.ActiveFrameLength = 32;
 808273e:	e9c4 ba10 	strd	fp, sl, [r4, #64]	; 0x40
  haudio_in_sai.SlotInit.SlotNumber = 4;
 8082742:	65e3      	str	r3, [r4, #92]	; 0x5c
  haudio_in_sai.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 8082744:	e9c4 9612 	strd	r9, r6, [r4, #72]	; 0x48
  haudio_in_sai.SlotInit.FirstBitOffset = 0;
 8082748:	e9c4 8614 	strd	r8, r6, [r4, #80]	; 0x50
  HAL_SAI_Init(&haudio_in_sai);
 808274c:	f005 ff8a 	bl	8088664 <HAL_SAI_Init>

  /* Enable SAI peripheral to generate MCLK */
  __HAL_SAI_ENABLE(&haudio_out_sai);
 8082750:	6829      	ldr	r1, [r5, #0]

  /* Enable SAI peripheral */
  __HAL_SAI_ENABLE(&haudio_in_sai);
 8082752:	6822      	ldr	r2, [r4, #0]
  __HAL_SAI_ENABLE(&haudio_out_sai);
 8082754:	680b      	ldr	r3, [r1, #0]
 8082756:	ea43 0309 	orr.w	r3, r3, r9
 808275a:	600b      	str	r3, [r1, #0]
  __HAL_SAI_ENABLE(&haudio_in_sai);
 808275c:	6813      	ldr	r3, [r2, #0]
 808275e:	ea43 0309 	orr.w	r3, r3, r9
 8082762:	6013      	str	r3, [r2, #0]
}
 8082764:	b003      	add	sp, #12
 8082766:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 808276a:	bf00      	nop

0808276c <BSP_AUDIO_OUT_Play>:
{
 808276c:	b538      	push	{r3, r4, r5, lr}
  if(audio_drv->Play(AUDIO_I2C_ADDRESS, pBuffer, Size) != 0)
 808276e:	f24d 639c 	movw	r3, #54940	; 0xd69c
{
 8082772:	4605      	mov	r5, r0
 8082774:	460c      	mov	r4, r1
  if(audio_drv->Play(AUDIO_I2C_ADDRESS, pBuffer, Size) != 0)
 8082776:	2034      	movs	r0, #52	; 0x34
 8082778:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808277c:	4629      	mov	r1, r5
 808277e:	b2a2      	uxth	r2, r4
 8082780:	681b      	ldr	r3, [r3, #0]
 8082782:	68db      	ldr	r3, [r3, #12]
 8082784:	4798      	blx	r3
 8082786:	b978      	cbnz	r0, 80827a8 <BSP_AUDIO_OUT_Play+0x3c>
    HAL_SAI_Transmit_DMA(&haudio_out_sai, (uint8_t*) pBuffer, DMA_MAX(Size / AUDIODATA_SIZE));
 8082788:	f5b4 3f00 	cmp.w	r4, #131072	; 0x20000
 808278c:	f24b 502c 	movw	r0, #46380	; 0xb52c
 8082790:	4629      	mov	r1, r5
 8082792:	bf34      	ite	cc
 8082794:	f3c4 024f 	ubfxcc	r2, r4, #1, #16
 8082798:	f64f 72ff 	movwcs	r2, #65535	; 0xffff
 808279c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80827a0:	f006 f962 	bl	8088a68 <HAL_SAI_Transmit_DMA>
    return AUDIO_OK;
 80827a4:	2000      	movs	r0, #0
}
 80827a6:	bd38      	pop	{r3, r4, r5, pc}
    return AUDIO_ERROR;
 80827a8:	2001      	movs	r0, #1
}
 80827aa:	bd38      	pop	{r3, r4, r5, pc}

080827ac <BSP_AUDIO_OUT_Pause>:
  if(audio_drv->Pause(AUDIO_I2C_ADDRESS) != 0)
 80827ac:	f24d 639c 	movw	r3, #54940	; 0xd69c
 80827b0:	2034      	movs	r0, #52	; 0x34
 80827b2:	f2c2 0302 	movt	r3, #8194	; 0x2002
 80827b6:	681b      	ldr	r3, [r3, #0]
{    
 80827b8:	b510      	push	{r4, lr}
  if(audio_drv->Pause(AUDIO_I2C_ADDRESS) != 0)
 80827ba:	691b      	ldr	r3, [r3, #16]
 80827bc:	4798      	blx	r3
 80827be:	b108      	cbz	r0, 80827c4 <BSP_AUDIO_OUT_Pause+0x18>
    return AUDIO_ERROR;
 80827c0:	2001      	movs	r0, #1
}
 80827c2:	bd10      	pop	{r4, pc}
 80827c4:	4604      	mov	r4, r0
    HAL_SAI_DMAPause(&haudio_out_sai);
 80827c6:	f24b 502c 	movw	r0, #46380	; 0xb52c
 80827ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80827ce:	f006 f8b5 	bl	808893c <HAL_SAI_DMAPause>
    return AUDIO_OK;
 80827d2:	4620      	mov	r0, r4
}
 80827d4:	bd10      	pop	{r4, pc}
 80827d6:	bf00      	nop

080827d8 <BSP_AUDIO_OUT_Resume>:
  if(audio_drv->Resume(AUDIO_I2C_ADDRESS) != 0)
 80827d8:	f24d 639c 	movw	r3, #54940	; 0xd69c
 80827dc:	2034      	movs	r0, #52	; 0x34
 80827de:	f2c2 0302 	movt	r3, #8194	; 0x2002
 80827e2:	681b      	ldr	r3, [r3, #0]
{    
 80827e4:	b510      	push	{r4, lr}
  if(audio_drv->Resume(AUDIO_I2C_ADDRESS) != 0)
 80827e6:	695b      	ldr	r3, [r3, #20]
 80827e8:	4798      	blx	r3
 80827ea:	b108      	cbz	r0, 80827f0 <BSP_AUDIO_OUT_Resume+0x18>
    return AUDIO_ERROR;
 80827ec:	2001      	movs	r0, #1
}
 80827ee:	bd10      	pop	{r4, pc}
 80827f0:	4604      	mov	r4, r0
    HAL_SAI_DMAResume(&haudio_out_sai);
 80827f2:	f24b 502c 	movw	r0, #46380	; 0xb52c
 80827f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80827fa:	f006 f8b3 	bl	8088964 <HAL_SAI_DMAResume>
    return AUDIO_OK;
 80827fe:	4620      	mov	r0, r4
}
 8082800:	bd10      	pop	{r4, pc}
 8082802:	bf00      	nop

08082804 <BSP_AUDIO_OUT_Stop>:
{
 8082804:	b538      	push	{r3, r4, r5, lr}
 8082806:	4605      	mov	r5, r0
  HAL_SAI_DMAStop(&haudio_out_sai);
 8082808:	f24b 502c 	movw	r0, #46380	; 0xb52c
 808280c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082810:	f006 f8c2 	bl	8088998 <HAL_SAI_DMAStop>
  if(audio_drv->Stop(AUDIO_I2C_ADDRESS, Option) != 0)
 8082814:	f24d 639c 	movw	r3, #54940	; 0xd69c
 8082818:	4629      	mov	r1, r5
 808281a:	2034      	movs	r0, #52	; 0x34
 808281c:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8082820:	681b      	ldr	r3, [r3, #0]
 8082822:	699b      	ldr	r3, [r3, #24]
 8082824:	4798      	blx	r3
 8082826:	b918      	cbnz	r0, 8082830 <BSP_AUDIO_OUT_Stop+0x2c>
    if(Option == CODEC_PDWN_HW)
 8082828:	2d01      	cmp	r5, #1
 808282a:	4604      	mov	r4, r0
 808282c:	d002      	beq.n	8082834 <BSP_AUDIO_OUT_Stop+0x30>
}
 808282e:	bd38      	pop	{r3, r4, r5, pc}
    return AUDIO_ERROR;
 8082830:	2001      	movs	r0, #1
}
 8082832:	bd38      	pop	{r3, r4, r5, pc}
      HAL_Delay(1);
 8082834:	4628      	mov	r0, r5
 8082836:	f002 ffc1 	bl	80857bc <HAL_Delay>
    return AUDIO_OK;
 808283a:	4620      	mov	r0, r4
}
 808283c:	bd38      	pop	{r3, r4, r5, pc}
 808283e:	bf00      	nop

08082840 <BSP_AUDIO_OUT_SetVolume>:
{
 8082840:	b508      	push	{r3, lr}
  if(audio_drv->SetVolume(AUDIO_I2C_ADDRESS, Volume) != 0)
 8082842:	f24d 639c 	movw	r3, #54940	; 0xd69c
 8082846:	4601      	mov	r1, r0
 8082848:	2034      	movs	r0, #52	; 0x34
 808284a:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808284e:	681b      	ldr	r3, [r3, #0]
 8082850:	6a1b      	ldr	r3, [r3, #32]
 8082852:	4798      	blx	r3
}
 8082854:	3000      	adds	r0, #0
 8082856:	bf18      	it	ne
 8082858:	2001      	movne	r0, #1
 808285a:	bd08      	pop	{r3, pc}

0808285c <BSP_AUDIO_OUT_SetAudioFrameSlot>:
{ 
 808285c:	b510      	push	{r4, lr}
  __HAL_SAI_DISABLE(&haudio_out_sai);
 808285e:	f24b 542c 	movw	r4, #46380	; 0xb52c
 8082862:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8082866:	6822      	ldr	r2, [r4, #0]
 8082868:	6813      	ldr	r3, [r2, #0]
 808286a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 808286e:	6013      	str	r3, [r2, #0]
  haudio_out_sai.SlotInit.SlotActive = AudioFrameSlot;
 8082870:	6620      	str	r0, [r4, #96]	; 0x60
  HAL_SAI_Init(&haudio_out_sai);
 8082872:	4620      	mov	r0, r4
 8082874:	f005 fef6 	bl	8088664 <HAL_SAI_Init>
  __HAL_SAI_ENABLE(&haudio_out_sai);
 8082878:	6822      	ldr	r2, [r4, #0]
 808287a:	6813      	ldr	r3, [r2, #0]
 808287c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8082880:	6013      	str	r3, [r2, #0]
}
 8082882:	bd10      	pop	{r4, pc}

08082884 <HAL_SAI_TxCpltCallback>:
{
 8082884:	b508      	push	{r3, lr}
  BSP_AUDIO_OUT_TransferComplete_CallBack();
 8082886:	f00a f847 	bl	808c918 <BSP_AUDIO_OUT_TransferComplete_CallBack>
}
 808288a:	bd08      	pop	{r3, pc}

0808288c <HAL_SAI_TxHalfCpltCallback>:
{
 808288c:	b508      	push	{r3, lr}
  BSP_AUDIO_OUT_HalfTransfer_CallBack();
 808288e:	f00a f84d 	bl	808c92c <BSP_AUDIO_OUT_HalfTransfer_CallBack>
}
 8082892:	bd08      	pop	{r3, pc}

08082894 <BSP_AUDIO_OUT_MspInit>:
{ 
 8082894:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  AUDIO_OUT_SAIx_CLK_ENABLE();
 8082898:	f44f 5460 	mov.w	r4, #14336	; 0x3800
{ 
 808289c:	b08a      	sub	sp, #40	; 0x28
 808289e:	4682      	mov	sl, r0
  HAL_GPIO_Init(AUDIO_OUT_SAIx_FS_GPIO_PORT, &gpio_init_structure);
 80828a0:	f44f 5000 	mov.w	r0, #8192	; 0x2000
  AUDIO_OUT_SAIx_CLK_ENABLE();
 80828a4:	f2c4 0402 	movt	r4, #16386	; 0x4002
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_FS_PIN;
 80828a8:	2280      	movs	r2, #128	; 0x80
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 80828aa:	f04f 0802 	mov.w	r8, #2
  gpio_init_structure.Pull = GPIO_NOPULL;
 80828ae:	2500      	movs	r5, #0
  AUDIO_OUT_SAIx_CLK_ENABLE();
 80828b0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 80828b2:	2603      	movs	r6, #3
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_SD_MCLK_AF;
 80828b4:	270a      	movs	r7, #10
  HAL_GPIO_Init(AUDIO_OUT_SAIx_FS_GPIO_PORT, &gpio_init_structure);
 80828b6:	f2c4 0002 	movt	r0, #16386	; 0x4002
  AUDIO_OUT_SAIx_CLK_ENABLE();
 80828ba:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  HAL_GPIO_Init(AUDIO_OUT_SAIx_FS_GPIO_PORT, &gpio_init_structure);
 80828be:	a905      	add	r1, sp, #20
  gpio_init_structure.Pin =  AUDIO_OUT_SAIx_SD_PIN;
 80828c0:	f04f 0940 	mov.w	r9, #64	; 0x40
  AUDIO_OUT_SAIx_CLK_ENABLE();
 80828c4:	6463      	str	r3, [r4, #68]	; 0x44
 80828c6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80828c8:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80828cc:	9300      	str	r3, [sp, #0]
 80828ce:	9b00      	ldr	r3, [sp, #0]
  AUDIO_OUT_SAIx_MCLK_ENABLE();
 80828d0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80828d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80828d6:	6323      	str	r3, [r4, #48]	; 0x30
 80828d8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80828da:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80828de:	9301      	str	r3, [sp, #4]
 80828e0:	9b01      	ldr	r3, [sp, #4]
  AUDIO_OUT_SAIx_SCK_SD_ENABLE();
 80828e2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80828e4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80828e8:	6323      	str	r3, [r4, #48]	; 0x30
 80828ea:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80828ec:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80828f0:	9302      	str	r3, [sp, #8]
 80828f2:	9b02      	ldr	r3, [sp, #8]
  AUDIO_OUT_SAIx_FS_ENABLE();
 80828f4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80828f6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80828fa:	6323      	str	r3, [r4, #48]	; 0x30
 80828fc:	6b23      	ldr	r3, [r4, #48]	; 0x30
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_FS_PIN;
 80828fe:	9205      	str	r2, [sp, #20]
  AUDIO_OUT_SAIx_FS_ENABLE();
 8082900:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8082904:	9303      	str	r3, [sp, #12]
 8082906:	9b03      	ldr	r3, [sp, #12]
  gpio_init_structure.Pull = GPIO_NOPULL;
 8082908:	e9cd 8506 	strd	r8, r5, [sp, #24]
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_SD_MCLK_AF;
 808290c:	e9cd 6708 	strd	r6, r7, [sp, #32]
  HAL_GPIO_Init(AUDIO_OUT_SAIx_FS_GPIO_PORT, &gpio_init_structure);
 8082910:	f003 fba6 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
 8082914:	f44f 5000 	mov.w	r0, #8192	; 0x2000
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_SCK_PIN;
 8082918:	2320      	movs	r3, #32
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
 808291a:	a905      	add	r1, sp, #20
 808291c:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 8082920:	f8cd 8018 	str.w	r8, [sp, #24]
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_SCK_PIN;
 8082924:	9305      	str	r3, [sp, #20]
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_SCK_AF;
 8082926:	9709      	str	r7, [sp, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 8082928:	e9cd 5607 	strd	r5, r6, [sp, #28]
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
 808292c:	f003 fb98 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
 8082930:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8082934:	a905      	add	r1, sp, #20
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 8082936:	f8cd 8018 	str.w	r8, [sp, #24]
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
 808293a:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_SD_MCLK_AF;
 808293e:	9709      	str	r7, [sp, #36]	; 0x24
  gpio_init_structure.Pin =  AUDIO_OUT_SAIx_SD_PIN;
 8082940:	f8cd 9014 	str.w	r9, [sp, #20]
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 8082944:	e9cd 5607 	strd	r5, r6, [sp, #28]
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
 8082948:	f003 fb8a 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(AUDIO_OUT_SAIx_MCLK_GPIO_PORT, &gpio_init_structure);
 808294c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_MCLK_PIN;
 8082950:	2310      	movs	r3, #16
  HAL_GPIO_Init(AUDIO_OUT_SAIx_MCLK_GPIO_PORT, &gpio_init_structure);
 8082952:	a905      	add	r1, sp, #20
 8082954:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 8082958:	f8cd 8018 	str.w	r8, [sp, #24]
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_MCLK_PIN;
 808295c:	9305      	str	r3, [sp, #20]
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_SD_MCLK_AF;
 808295e:	9709      	str	r7, [sp, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 8082960:	e9cd 5607 	strd	r5, r6, [sp, #28]
  HAL_GPIO_Init(AUDIO_OUT_SAIx_MCLK_GPIO_PORT, &gpio_init_structure);
 8082964:	f003 fb7c 	bl	8086060 <HAL_GPIO_Init>
  AUDIO_OUT_SAIx_DMAx_CLK_ENABLE();
 8082968:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if(hsai->Instance == AUDIO_OUT_SAIx)
 808296a:	f645 4204 	movw	r2, #23556	; 0x5c04
 808296e:	f8da 1000 	ldr.w	r1, [sl]
  AUDIO_OUT_SAIx_DMAx_CLK_ENABLE();
 8082972:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  if(hsai->Instance == AUDIO_OUT_SAIx)
 8082976:	f2c4 0201 	movt	r2, #16385	; 0x4001
  AUDIO_OUT_SAIx_DMAx_CLK_ENABLE();
 808297a:	6323      	str	r3, [r4, #48]	; 0x30
 808297c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if(hsai->Instance == AUDIO_OUT_SAIx)
 808297e:	4291      	cmp	r1, r2
  AUDIO_OUT_SAIx_DMAx_CLK_ENABLE();
 8082980:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8082984:	9304      	str	r3, [sp, #16]
 8082986:	9b04      	ldr	r3, [sp, #16]
  if(hsai->Instance == AUDIO_OUT_SAIx)
 8082988:	d00a      	beq.n	80829a0 <BSP_AUDIO_OUT_MspInit+0x10c>
  HAL_NVIC_SetPriority(AUDIO_OUT_SAIx_DMAx_IRQ, AUDIO_OUT_IRQ_PREPRIO, 0);
 808298a:	2200      	movs	r2, #0
 808298c:	210e      	movs	r1, #14
 808298e:	203c      	movs	r0, #60	; 0x3c
 8082990:	f002 ff3e 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(AUDIO_OUT_SAIx_DMAx_IRQ); 
 8082994:	203c      	movs	r0, #60	; 0x3c
 8082996:	f002 ff77 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 808299a:	b00a      	add	sp, #40	; 0x28
 808299c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hdma_sai_tx.Init.Channel             = AUDIO_OUT_SAIx_DMAx_CHANNEL;
 80829a0:	f24b 6410 	movw	r4, #46608	; 0xb610
 80829a4:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
    hdma_sai_tx.Instance = AUDIO_OUT_SAIx_DMAx_STREAM;
 80829a8:	f246 4370 	movw	r3, #25712	; 0x6470
    hdma_sai_tx.Init.MemInc              = DMA_MINC_ENABLE;
 80829ac:	f44f 6780 	mov.w	r7, #1024	; 0x400
    hdma_sai_tx.Init.Channel             = AUDIO_OUT_SAIx_DMAx_CHANNEL;
 80829b0:	f2c2 0400 	movt	r4, #8192	; 0x2000
    hdma_sai_tx.Init.PeriphDataAlignment = AUDIO_OUT_SAIx_DMAx_PERIPH_DATA_SIZE;
 80829b4:	f44f 6000 	mov.w	r0, #2048	; 0x800
    hdma_sai_tx.Instance = AUDIO_OUT_SAIx_DMAx_STREAM;
 80829b8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_sai_tx.Init.Priority            = DMA_PRIORITY_HIGH;
 80829bc:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    hdma_sai_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
 80829c0:	60e5      	str	r5, [r4, #12]
    hdma_sai_tx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 80829c2:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai_tx.Init.MemDataAlignment    = AUDIO_OUT_SAIx_DMAx_MEM_DATA_SIZE;
 80829c4:	f44f 5600 	mov.w	r6, #8192	; 0x2000
    hdma_sai_tx.Init.Channel             = AUDIO_OUT_SAIx_DMAx_CHANNEL;
 80829c8:	6062      	str	r2, [r4, #4]
    hdma_sai_tx.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;         
 80829ca:	2204      	movs	r2, #4
    __HAL_LINKDMA(hsai, hdmatx, hdma_sai_tx);
 80829cc:	f8ca 406c 	str.w	r4, [sl, #108]	; 0x6c
    hdma_sai_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
 80829d0:	f8c4 9008 	str.w	r9, [r4, #8]
    __HAL_LINKDMA(hsai, hdmatx, hdma_sai_tx);
 80829d4:	f8c4 a038 	str.w	sl, [r4, #56]	; 0x38
    hdma_sai_tx.Instance = AUDIO_OUT_SAIx_DMAx_STREAM;
 80829d8:	6023      	str	r3, [r4, #0]
    hdma_sai_tx.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 80829da:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
    hdma_sai_tx.Init.Mode                = DMA_CIRCULAR;
 80829de:	f44f 7580 	mov.w	r5, #256	; 0x100
    hdma_sai_tx.Init.PeriphDataAlignment = AUDIO_OUT_SAIx_DMAx_PERIPH_DATA_SIZE;
 80829e2:	e9c4 7004 	strd	r7, r0, [r4, #16]
    HAL_DMA_DeInit(&hdma_sai_tx);
 80829e6:	4620      	mov	r0, r4
    hdma_sai_tx.Init.Mode                = DMA_CIRCULAR;
 80829e8:	e9c4 6506 	strd	r6, r5, [r4, #24]
    hdma_sai_tx.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;         
 80829ec:	e9c4 1208 	strd	r1, r2, [r4, #32]
    HAL_DMA_DeInit(&hdma_sai_tx);
 80829f0:	f003 f802 	bl	80859f8 <HAL_DMA_DeInit>
    HAL_DMA_Init(&hdma_sai_tx);      
 80829f4:	4620      	mov	r0, r4
 80829f6:	f002 ff61 	bl	80858bc <HAL_DMA_Init>
 80829fa:	e7c6      	b.n	808298a <BSP_AUDIO_OUT_MspInit+0xf6>

080829fc <BSP_AUDIO_OUT_MspDeInit>:
{
 80829fc:	b510      	push	{r4, lr}
 80829fe:	4604      	mov	r4, r0
    HAL_NVIC_DisableIRQ(AUDIO_OUT_SAIx_DMAx_IRQ);
 8082a00:	203c      	movs	r0, #60	; 0x3c
 8082a02:	f002 ff4d 	bl	80858a0 <HAL_NVIC_DisableIRQ>
    if(hsai->Instance == AUDIO_OUT_SAIx)
 8082a06:	f645 4204 	movw	r2, #23556	; 0x5c04
 8082a0a:	6823      	ldr	r3, [r4, #0]
 8082a0c:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8082a10:	4293      	cmp	r3, r2
 8082a12:	d028      	beq.n	8082a66 <BSP_AUDIO_OUT_MspDeInit+0x6a>
    __HAL_SAI_DISABLE(hsai);  
 8082a14:	681a      	ldr	r2, [r3, #0]
    HAL_GPIO_DeInit(AUDIO_OUT_SAIx_FS_GPIO_PORT, gpio_init_structure.Pin);
 8082a16:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8082a1a:	2180      	movs	r1, #128	; 0x80
    __HAL_SAI_DISABLE(hsai);  
 8082a1c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    HAL_GPIO_DeInit(AUDIO_OUT_SAIx_FS_GPIO_PORT, gpio_init_structure.Pin);
 8082a20:	f2c4 0002 	movt	r0, #16386	; 0x4002
    __HAL_SAI_DISABLE(hsai);  
 8082a24:	601a      	str	r2, [r3, #0]
    HAL_GPIO_DeInit(AUDIO_OUT_SAIx_FS_GPIO_PORT, gpio_init_structure.Pin);
 8082a26:	f003 fc51 	bl	80862cc <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, gpio_init_structure.Pin);
 8082a2a:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8082a2e:	2120      	movs	r1, #32
 8082a30:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082a34:	f003 fc4a 	bl	80862cc <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, gpio_init_structure.Pin);
 8082a38:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8082a3c:	2140      	movs	r1, #64	; 0x40
 8082a3e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082a42:	f003 fc43 	bl	80862cc <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(AUDIO_OUT_SAIx_MCLK_GPIO_PORT, gpio_init_structure.Pin);
 8082a46:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8082a4a:	2110      	movs	r1, #16
 8082a4c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082a50:	f003 fc3c 	bl	80862cc <HAL_GPIO_DeInit>
    AUDIO_OUT_SAIx_CLK_DISABLE();
 8082a54:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8082a58:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8082a5c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8082a5e:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8082a62:	645a      	str	r2, [r3, #68]	; 0x44
}
 8082a64:	bd10      	pop	{r4, pc}
      HAL_DMA_DeInit(hsai->hdmatx);
 8082a66:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8082a68:	f002 ffc6 	bl	80859f8 <HAL_DMA_DeInit>
 8082a6c:	6823      	ldr	r3, [r4, #0]
 8082a6e:	e7d1      	b.n	8082a14 <BSP_AUDIO_OUT_MspDeInit+0x18>

08082a70 <BSP_AUDIO_OUT_DeInit>:
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082a70:	f645 4304 	movw	r3, #23556	; 0x5c04
 8082a74:	f2c4 0301 	movt	r3, #16385	; 0x4001
{
 8082a78:	b510      	push	{r4, lr}
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082a7a:	681a      	ldr	r2, [r3, #0]
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082a7c:	f24b 542c 	movw	r4, #46380	; 0xb52c
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082a80:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082a84:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8082a88:	6023      	str	r3, [r4, #0]
  HAL_SAI_DeInit(&haudio_out_sai);
 8082a8a:	4620      	mov	r0, r4
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082a8c:	601a      	str	r2, [r3, #0]
  HAL_SAI_DeInit(&haudio_out_sai);
 8082a8e:	f005 ff19 	bl	80888c4 <HAL_SAI_DeInit>
  BSP_AUDIO_OUT_MspDeInit(&haudio_out_sai, NULL);
 8082a92:	4620      	mov	r0, r4
 8082a94:	2100      	movs	r1, #0
 8082a96:	f7ff ffb1 	bl	80829fc <BSP_AUDIO_OUT_MspDeInit>
}
 8082a9a:	bd10      	pop	{r4, pc}

08082a9c <BSP_AUDIO_OUT_ClockConfig>:
{ 
 8082a9c:	b530      	push	{r4, r5, lr}
 8082a9e:	b0a3      	sub	sp, #140	; 0x8c
 8082aa0:	460c      	mov	r4, r1
    rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 8082aa2:	f44f 1580 	mov.w	r5, #1048576	; 0x100000
  HAL_RCCEx_GetPeriphCLKConfig(&rcc_ex_clk_init_struct);
 8082aa6:	a801      	add	r0, sp, #4
 8082aa8:	f005 fc60 	bl	808836c <HAL_RCCEx_GetPeriphCLKConfig>
  if((AudioFreq == AUDIO_FREQUENCY_11K) || (AudioFreq == AUDIO_FREQUENCY_22K) || (AudioFreq == AUDIO_FREQUENCY_44K))
 8082aac:	f642 3211 	movw	r2, #11025	; 0x2b11
 8082ab0:	f245 6322 	movw	r3, #22050	; 0x5622
 8082ab4:	429c      	cmp	r4, r3
 8082ab6:	bf18      	it	ne
 8082ab8:	4294      	cmpne	r4, r2
 8082aba:	d00a      	beq.n	8082ad2 <BSP_AUDIO_OUT_ClockConfig+0x36>
 8082abc:	f64a 4344 	movw	r3, #44100	; 0xac44
 8082ac0:	429c      	cmp	r4, r3
 8082ac2:	d006      	beq.n	8082ad2 <BSP_AUDIO_OUT_ClockConfig+0x36>
    rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 8082ac4:	f44f 0480 	mov.w	r4, #4194304	; 0x400000
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = 344;
 8082ac8:	f44f 71ac 	mov.w	r1, #344	; 0x158
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 7;
 8082acc:	2207      	movs	r2, #7
    rcc_ex_clk_init_struct.PLLI2SDivQ = 1;
 8082ace:	2301      	movs	r3, #1
 8082ad0:	e005      	b.n	8082ade <BSP_AUDIO_OUT_ClockConfig+0x42>
    rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 8082ad2:	f44f 0480 	mov.w	r4, #4194304	; 0x400000
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = 429;
 8082ad6:	f240 11ad 	movw	r1, #429	; 0x1ad
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 2;
 8082ada:	2202      	movs	r2, #2
    rcc_ex_clk_init_struct.PLLI2SDivQ = 19;
 8082adc:	2313      	movs	r3, #19
    HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
 8082ade:	a801      	add	r0, sp, #4
    rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 8082ae0:	9501      	str	r5, [sp, #4]
    rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
 8082ae2:	9411      	str	r4, [sp, #68]	; 0x44
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = 344;
 8082ae4:	9102      	str	r1, [sp, #8]
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 7;
 8082ae6:	9204      	str	r2, [sp, #16]
    rcc_ex_clk_init_struct.PLLI2SDivQ = 1;
 8082ae8:	930a      	str	r3, [sp, #40]	; 0x28
    HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
 8082aea:	f005 f937 	bl	8087d5c <HAL_RCCEx_PeriphCLKConfig>
}
 8082aee:	b023      	add	sp, #140	; 0x8c
 8082af0:	bd30      	pop	{r4, r5, pc}
 8082af2:	bf00      	nop

08082af4 <BSP_AUDIO_OUT_Init>:
{ 
 8082af4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082af8:	f645 4504 	movw	r5, #23556	; 0x5c04
 8082afc:	f24b 542c 	movw	r4, #46380	; 0xb52c
{ 
 8082b00:	4617      	mov	r7, r2
 8082b02:	4680      	mov	r8, r0
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082b04:	f2c4 0501 	movt	r5, #16385	; 0x4001
 8082b08:	f2c2 0400 	movt	r4, #8192	; 0x2000
{ 
 8082b0c:	4689      	mov	r9, r1
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082b0e:	682b      	ldr	r3, [r5, #0]
  HAL_SAI_DeInit(&haudio_out_sai);
 8082b10:	4620      	mov	r0, r4
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082b12:	6025      	str	r5, [r4, #0]
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082b14:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8082b18:	602b      	str	r3, [r5, #0]
  HAL_SAI_DeInit(&haudio_out_sai);
 8082b1a:	f005 fed3 	bl	80888c4 <HAL_SAI_DeInit>
  BSP_AUDIO_OUT_ClockConfig(&haudio_out_sai, AudioFreq, NULL);
 8082b1e:	4620      	mov	r0, r4
 8082b20:	4639      	mov	r1, r7
 8082b22:	2200      	movs	r2, #0
 8082b24:	f7ff ffba 	bl	8082a9c <BSP_AUDIO_OUT_ClockConfig>
  if(HAL_SAI_GetState(&haudio_out_sai) == HAL_SAI_STATE_RESET)
 8082b28:	4620      	mov	r0, r4
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082b2a:	6025      	str	r5, [r4, #0]
  if(HAL_SAI_GetState(&haudio_out_sai) == HAL_SAI_STATE_RESET)
 8082b2c:	f006 f910 	bl	8088d50 <HAL_SAI_GetState>
 8082b30:	2800      	cmp	r0, #0
 8082b32:	d052      	beq.n	8082bda <BSP_AUDIO_OUT_Init+0xe6>
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082b34:	f645 4304 	movw	r3, #23556	; 0x5c04
  haudio_out_sai.Init.DataSize = SAI_DATASIZE_16;
 8082b38:	2680      	movs	r6, #128	; 0x80
  haudio_out_sai.Init.OutputDrive = SAI_OUTPUTDRIVE_ENABLED;
 8082b3a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  HAL_SAI_Init(&haudio_out_sai);
 8082b3e:	f24b 502c 	movw	r0, #46380	; 0xb52c
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082b42:	f2c4 0301 	movt	r3, #16385	; 0x4001
  haudio_out_sai.Init.AudioMode = SAI_MODEMASTER_TX;
 8082b46:	2500      	movs	r5, #0
  haudio_out_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 8082b48:	f04f 0a01 	mov.w	sl, #1
  HAL_SAI_Init(&haudio_out_sai);
 8082b4c:	f2c2 0000 	movt	r0, #8192	; 0x2000
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082b50:	681a      	ldr	r2, [r3, #0]
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082b52:	6023      	str	r3, [r4, #0]
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082b54:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8082b58:	601a      	str	r2, [r3, #0]
  haudio_out_sai.FrameInit.FrameLength = 64; 
 8082b5a:	2240      	movs	r2, #64	; 0x40
  haudio_out_sai.FrameInit.ActiveFrameLength = 32;
 8082b5c:	2320      	movs	r3, #32
  haudio_out_sai.Init.DataSize = SAI_DATASIZE_16;
 8082b5e:	6366      	str	r6, [r4, #52]	; 0x34
  haudio_out_sai.Init.OutputDrive = SAI_OUTPUTDRIVE_ENABLED;
 8082b60:	6121      	str	r1, [r4, #16]
  haudio_out_sai.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
 8082b62:	f44f 3680 	mov.w	r6, #65536	; 0x10000
  haudio_out_sai.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
 8082b66:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  haudio_out_sai.FrameInit.FrameLength = 64; 
 8082b6a:	6422      	str	r2, [r4, #64]	; 0x40
  haudio_out_sai.FrameInit.ActiveFrameLength = 32;
 8082b6c:	6463      	str	r3, [r4, #68]	; 0x44
  haudio_out_sai.SlotInit.SlotNumber = 4; 
 8082b6e:	2204      	movs	r2, #4
  haudio_out_sai.SlotInit.SlotActive = CODEC_AUDIOFRAME_SLOT_0123;
 8082b70:	230f      	movs	r3, #15
  haudio_out_sai.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
 8082b72:	64a6      	str	r6, [r4, #72]	; 0x48
  haudio_out_sai.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
 8082b74:	6521      	str	r1, [r4, #80]	; 0x50
  deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082b76:	f24b 062c 	movw	r6, #45100	; 0xb02c
  haudio_out_sai.SlotInit.SlotNumber = 4; 
 8082b7a:	65e2      	str	r2, [r4, #92]	; 0x5c
  haudio_out_sai.SlotInit.SlotActive = CODEC_AUDIOFRAME_SLOT_0123;
 8082b7c:	6623      	str	r3, [r4, #96]	; 0x60
  deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082b7e:	f2c2 0600 	movt	r6, #8192	; 0x2000
  haudio_out_sai.Init.AudioFrequency = AudioFreq;
 8082b82:	61e7      	str	r7, [r4, #28]
  haudio_out_sai.Init.AudioMode = SAI_MODEMASTER_TX;
 8082b84:	6065      	str	r5, [r4, #4]
  haudio_out_sai.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
 8082b86:	6165      	str	r5, [r4, #20]
  haudio_out_sai.Init.Protocol = SAI_FREE_PROTOCOL;
 8082b88:	6325      	str	r5, [r4, #48]	; 0x30
  haudio_out_sai.Init.FirstBit = SAI_FIRSTBIT_MSB;
 8082b8a:	63a5      	str	r5, [r4, #56]	; 0x38
  haudio_out_sai.Init.Synchro = SAI_ASYNCHRONOUS;
 8082b8c:	60a5      	str	r5, [r4, #8]
  haudio_out_sai.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 8082b8e:	64e5      	str	r5, [r4, #76]	; 0x4c
  haudio_out_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
 8082b90:	f8c4 a03c 	str.w	sl, [r4, #60]	; 0x3c
  haudio_out_sai.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 8082b94:	f8c4 a018 	str.w	sl, [r4, #24]
  haudio_out_sai.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 8082b98:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
  HAL_SAI_Init(&haudio_out_sai);
 8082b9c:	f005 fd62 	bl	8088664 <HAL_SAI_Init>
  __HAL_SAI_ENABLE(&haudio_out_sai);
 8082ba0:	6822      	ldr	r2, [r4, #0]
  deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082ba2:	68b1      	ldr	r1, [r6, #8]
 8082ba4:	2034      	movs	r0, #52	; 0x34
  __HAL_SAI_ENABLE(&haudio_out_sai);
 8082ba6:	6813      	ldr	r3, [r2, #0]
 8082ba8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8082bac:	6013      	str	r3, [r2, #0]
  deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082bae:	4788      	blx	r1
  if((deviceid) == WM8994_ID)
 8082bb0:	f648 1394 	movw	r3, #35220	; 0x8994
 8082bb4:	4298      	cmp	r0, r3
 8082bb6:	d115      	bne.n	8082be4 <BSP_AUDIO_OUT_Init+0xf0>
    audio_drv = &wm8994_drv; 
 8082bb8:	f24d 649c 	movw	r4, #54940	; 0xd69c
    wm8994_drv.Reset(AUDIO_I2C_ADDRESS);
 8082bbc:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8082bbe:	2034      	movs	r0, #52	; 0x34
    audio_drv = &wm8994_drv; 
 8082bc0:	f2c2 0402 	movt	r4, #8194	; 0x2002
    wm8994_drv.Reset(AUDIO_I2C_ADDRESS);
 8082bc4:	4798      	blx	r3
    audio_drv->Init(AUDIO_I2C_ADDRESS, OutputDevice, Volume, AudioFreq);
 8082bc6:	463b      	mov	r3, r7
 8082bc8:	464a      	mov	r2, r9
 8082bca:	4641      	mov	r1, r8
 8082bcc:	6837      	ldr	r7, [r6, #0]
    audio_drv = &wm8994_drv; 
 8082bce:	6026      	str	r6, [r4, #0]
    audio_drv->Init(AUDIO_I2C_ADDRESS, OutputDevice, Volume, AudioFreq);
 8082bd0:	2034      	movs	r0, #52	; 0x34
 8082bd2:	47b8      	blx	r7
    ret = AUDIO_OK;
 8082bd4:	4628      	mov	r0, r5
}
 8082bd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    BSP_AUDIO_OUT_MspInit(&haudio_out_sai, NULL);
 8082bda:	4601      	mov	r1, r0
 8082bdc:	4620      	mov	r0, r4
 8082bde:	f7ff fe59 	bl	8082894 <BSP_AUDIO_OUT_MspInit>
 8082be2:	e7a7      	b.n	8082b34 <BSP_AUDIO_OUT_Init+0x40>
    ret = AUDIO_ERROR;
 8082be4:	4650      	mov	r0, sl
}
 8082be6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8082bea:	bf00      	nop

08082bec <BSP_AUDIO_OUT_SetFrequency>:
{ 
 8082bec:	b538      	push	{r3, r4, r5, lr}
  BSP_AUDIO_OUT_ClockConfig(&haudio_out_sai, AudioFreq, NULL);
 8082bee:	f24b 542c 	movw	r4, #46380	; 0xb52c
 8082bf2:	4601      	mov	r1, r0
{ 
 8082bf4:	4605      	mov	r5, r0
  BSP_AUDIO_OUT_ClockConfig(&haudio_out_sai, AudioFreq, NULL);
 8082bf6:	2200      	movs	r2, #0
 8082bf8:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8082bfc:	4620      	mov	r0, r4
 8082bfe:	f7ff ff4d 	bl	8082a9c <BSP_AUDIO_OUT_ClockConfig>
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082c02:	6822      	ldr	r2, [r4, #0]
  HAL_SAI_Init(&haudio_out_sai);
 8082c04:	4620      	mov	r0, r4
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082c06:	6813      	ldr	r3, [r2, #0]
 8082c08:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8082c0c:	6013      	str	r3, [r2, #0]
  haudio_out_sai.Init.AudioFrequency = AudioFreq;
 8082c0e:	61e5      	str	r5, [r4, #28]
  HAL_SAI_Init(&haudio_out_sai);
 8082c10:	f005 fd28 	bl	8088664 <HAL_SAI_Init>
  __HAL_SAI_ENABLE(&haudio_out_sai);
 8082c14:	6822      	ldr	r2, [r4, #0]
 8082c16:	6813      	ldr	r3, [r2, #0]
 8082c18:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8082c1c:	6013      	str	r3, [r2, #0]
}
 8082c1e:	bd38      	pop	{r3, r4, r5, pc}

08082c20 <BSP_AUDIO_IN_Record>:
  HAL_SAI_Receive_DMA(&haudio_in_sai, (uint8_t*)pbuf, size);
 8082c20:	b28a      	uxth	r2, r1
 8082c22:	4601      	mov	r1, r0
 8082c24:	f24b 40a8 	movw	r0, #46248	; 0xb4a8
{
 8082c28:	b508      	push	{r3, lr}
  HAL_SAI_Receive_DMA(&haudio_in_sai, (uint8_t*)pbuf, size);
 8082c2a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082c2e:	f005 ff83 	bl	8088b38 <HAL_SAI_Receive_DMA>
}
 8082c32:	2000      	movs	r0, #0
 8082c34:	bd08      	pop	{r3, pc}
 8082c36:	bf00      	nop

08082c38 <BSP_AUDIO_IN_Stop>:
{
 8082c38:	b538      	push	{r3, r4, r5, lr}
 8082c3a:	4605      	mov	r5, r0
  HAL_SAI_DMAStop(&haudio_in_sai);
 8082c3c:	f24b 40a8 	movw	r0, #46248	; 0xb4a8
 8082c40:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082c44:	f005 fea8 	bl	8088998 <HAL_SAI_DMAStop>
  if(audio_drv->Stop(AUDIO_I2C_ADDRESS, Option) != 0)
 8082c48:	f24d 639c 	movw	r3, #54940	; 0xd69c
 8082c4c:	4629      	mov	r1, r5
 8082c4e:	2034      	movs	r0, #52	; 0x34
 8082c50:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8082c54:	681b      	ldr	r3, [r3, #0]
 8082c56:	699b      	ldr	r3, [r3, #24]
 8082c58:	4798      	blx	r3
 8082c5a:	b918      	cbnz	r0, 8082c64 <BSP_AUDIO_IN_Stop+0x2c>
    if(Option == CODEC_PDWN_HW)
 8082c5c:	2d01      	cmp	r5, #1
 8082c5e:	4604      	mov	r4, r0
 8082c60:	d002      	beq.n	8082c68 <BSP_AUDIO_IN_Stop+0x30>
}
 8082c62:	bd38      	pop	{r3, r4, r5, pc}
    return AUDIO_ERROR;
 8082c64:	2001      	movs	r0, #1
}
 8082c66:	bd38      	pop	{r3, r4, r5, pc}
      HAL_Delay(1);
 8082c68:	4628      	mov	r0, r5
 8082c6a:	f002 fda7 	bl	80857bc <HAL_Delay>
    return AUDIO_OK;
 8082c6e:	4620      	mov	r0, r4
}
 8082c70:	bd38      	pop	{r3, r4, r5, pc}
 8082c72:	bf00      	nop

08082c74 <HAL_SAI_RxCpltCallback>:
{
 8082c74:	b508      	push	{r3, lr}
  BSP_AUDIO_IN_TransferComplete_CallBack();
 8082c76:	f00c fe47 	bl	808f908 <BSP_AUDIO_IN_TransferComplete_CallBack>
}
 8082c7a:	bd08      	pop	{r3, pc}

08082c7c <HAL_SAI_RxHalfCpltCallback>:
{
 8082c7c:	b508      	push	{r3, lr}
  BSP_AUDIO_IN_HalfTransfer_CallBack();
 8082c7e:	f00c fe4b 	bl	808f918 <BSP_AUDIO_IN_HalfTransfer_CallBack>
}
 8082c82:	bd08      	pop	{r3, pc}

08082c84 <HAL_SAI_ErrorCallback>:
  audio_out_state = HAL_SAI_GetState(&haudio_out_sai);
 8082c84:	f24b 502c 	movw	r0, #46380	; 0xb52c
{
 8082c88:	b538      	push	{r3, r4, r5, lr}
  audio_out_state = HAL_SAI_GetState(&haudio_out_sai);
 8082c8a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082c8e:	f006 f85f 	bl	8088d50 <HAL_SAI_GetState>
 8082c92:	4605      	mov	r5, r0
  audio_in_state = HAL_SAI_GetState(&haudio_in_sai);
 8082c94:	f24b 40a8 	movw	r0, #46248	; 0xb4a8
  if ((audio_out_state == HAL_SAI_STATE_BUSY) || (audio_out_state == HAL_SAI_STATE_BUSY_TX))
 8082c98:	f005 05ef 	and.w	r5, r5, #239	; 0xef
  audio_in_state = HAL_SAI_GetState(&haudio_in_sai);
 8082c9c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082ca0:	f006 f856 	bl	8088d50 <HAL_SAI_GetState>
  if ((audio_out_state == HAL_SAI_STATE_BUSY) || (audio_out_state == HAL_SAI_STATE_BUSY_TX))
 8082ca4:	2d02      	cmp	r5, #2
  audio_in_state = HAL_SAI_GetState(&haudio_in_sai);
 8082ca6:	4604      	mov	r4, r0
  if ((audio_out_state == HAL_SAI_STATE_BUSY) || (audio_out_state == HAL_SAI_STATE_BUSY_TX))
 8082ca8:	d007      	beq.n	8082cba <HAL_SAI_ErrorCallback+0x36>
  if ((audio_in_state == HAL_SAI_STATE_BUSY) || (audio_in_state == HAL_SAI_STATE_BUSY_RX))
 8082caa:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 8082cae:	2c02      	cmp	r4, #2
 8082cb0:	d000      	beq.n	8082cb4 <HAL_SAI_ErrorCallback+0x30>
}
 8082cb2:	bd38      	pop	{r3, r4, r5, pc}
    BSP_AUDIO_IN_Error_CallBack();
 8082cb4:	f00c fe38 	bl	808f928 <BSP_AUDIO_IN_Error_CallBack>
}
 8082cb8:	bd38      	pop	{r3, r4, r5, pc}
    BSP_AUDIO_OUT_Error_CallBack();
 8082cba:	f00c fccf 	bl	808f65c <BSP_AUDIO_OUT_Error_CallBack>
 8082cbe:	e7f4      	b.n	8082caa <HAL_SAI_ErrorCallback+0x26>

08082cc0 <BSP_AUDIO_IN_MspInit>:
{
 8082cc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  AUDIO_IN_SAIx_CLK_ENABLE();
 8082cc4:	f44f 5460 	mov.w	r4, #14336	; 0x3800
{
 8082cc8:	b08a      	sub	sp, #40	; 0x28
 8082cca:	4606      	mov	r6, r0
  HAL_GPIO_Init(AUDIO_IN_SAIx_SD_GPIO_PORT, &gpio_init_structure);
 8082ccc:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
  AUDIO_IN_SAIx_CLK_ENABLE();
 8082cd0:	f2c4 0402 	movt	r4, #16386	; 0x4002
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 8082cd4:	f04f 0802 	mov.w	r8, #2
  gpio_init_structure.Alternate = AUDIO_IN_SAIx_SD_AF;
 8082cd8:	220a      	movs	r2, #10
  gpio_init_structure.Pull = GPIO_NOPULL;
 8082cda:	2500      	movs	r5, #0
  AUDIO_IN_SAIx_CLK_ENABLE();
 8082cdc:	6c63      	ldr	r3, [r4, #68]	; 0x44
  gpio_init_structure.Pin = AUDIO_IN_SAIx_SD_PIN;
 8082cde:	f44f 6780 	mov.w	r7, #1024	; 0x400
  HAL_GPIO_Init(AUDIO_IN_SAIx_SD_GPIO_PORT, &gpio_init_structure);
 8082ce2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082ce6:	a905      	add	r1, sp, #20
  AUDIO_IN_SAIx_CLK_ENABLE();
 8082ce8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8082cec:	6463      	str	r3, [r4, #68]	; 0x44
 8082cee:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8082cf0:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8082cf4:	9301      	str	r3, [sp, #4]
 8082cf6:	9b01      	ldr	r3, [sp, #4]
  AUDIO_IN_SAIx_SD_ENABLE();
 8082cf8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8082cfa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8082cfe:	6323      	str	r3, [r4, #48]	; 0x30
 8082d00:	6b23      	ldr	r3, [r4, #48]	; 0x30
  gpio_init_structure.Alternate = AUDIO_IN_SAIx_SD_AF;
 8082d02:	9209      	str	r2, [sp, #36]	; 0x24
  AUDIO_IN_SAIx_SD_ENABLE();
 8082d04:	f003 0340 	and.w	r3, r3, #64	; 0x40
  gpio_init_structure.Pin = AUDIO_IN_SAIx_SD_PIN;
 8082d08:	9705      	str	r7, [sp, #20]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 8082d0a:	f8cd 8018 	str.w	r8, [sp, #24]
  AUDIO_IN_SAIx_SD_ENABLE();
 8082d0e:	9302      	str	r3, [sp, #8]
 8082d10:	9b02      	ldr	r3, [sp, #8]
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
 8082d12:	f8cd 8020 	str.w	r8, [sp, #32]
  gpio_init_structure.Pull = GPIO_NOPULL;
 8082d16:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(AUDIO_IN_SAIx_SD_GPIO_PORT, &gpio_init_structure);
 8082d18:	f003 f9a2 	bl	8086060 <HAL_GPIO_Init>
  AUDIO_IN_INT_GPIO_ENABLE();
 8082d1c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  HAL_GPIO_Init(AUDIO_IN_INT_GPIO_PORT, &gpio_init_structure);
 8082d1e:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
  gpio_init_structure.Pin = AUDIO_IN_INT_GPIO_PIN;
 8082d22:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  HAL_GPIO_Init(AUDIO_IN_INT_GPIO_PORT, &gpio_init_structure);
 8082d26:	a905      	add	r1, sp, #20
  AUDIO_IN_INT_GPIO_ENABLE();
 8082d28:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  HAL_GPIO_Init(AUDIO_IN_INT_GPIO_PORT, &gpio_init_structure);
 8082d2c:	f2c4 0002 	movt	r0, #16386	; 0x4002
  AUDIO_IN_INT_GPIO_ENABLE();
 8082d30:	6323      	str	r3, [r4, #48]	; 0x30
 8082d32:	6b23      	ldr	r3, [r4, #48]	; 0x30
  gpio_init_structure.Pin = AUDIO_IN_INT_GPIO_PIN;
 8082d34:	9205      	str	r2, [sp, #20]
  AUDIO_IN_INT_GPIO_ENABLE();
 8082d36:	f003 0380 	and.w	r3, r3, #128	; 0x80
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
 8082d3a:	f8cd 8020 	str.w	r8, [sp, #32]
  AUDIO_IN_INT_GPIO_ENABLE();
 8082d3e:	9303      	str	r3, [sp, #12]
 8082d40:	9b03      	ldr	r3, [sp, #12]
  gpio_init_structure.Pull = GPIO_NOPULL;
 8082d42:	e9cd 5506 	strd	r5, r5, [sp, #24]
  HAL_GPIO_Init(AUDIO_IN_INT_GPIO_PORT, &gpio_init_structure);
 8082d46:	f003 f98b 	bl	8086060 <HAL_GPIO_Init>
  AUDIO_IN_SAIx_DMAx_CLK_ENABLE();
 8082d4a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if(hsai->Instance == AUDIO_IN_SAIx)
 8082d4c:	f645 4224 	movw	r2, #23588	; 0x5c24
 8082d50:	6831      	ldr	r1, [r6, #0]
  AUDIO_IN_SAIx_DMAx_CLK_ENABLE();
 8082d52:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  if(hsai->Instance == AUDIO_IN_SAIx)
 8082d56:	f2c4 0201 	movt	r2, #16385	; 0x4001
  AUDIO_IN_SAIx_DMAx_CLK_ENABLE();
 8082d5a:	6323      	str	r3, [r4, #48]	; 0x30
 8082d5c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if(hsai->Instance == AUDIO_IN_SAIx)
 8082d5e:	4291      	cmp	r1, r2
  AUDIO_IN_SAIx_DMAx_CLK_ENABLE();
 8082d60:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8082d64:	9304      	str	r3, [sp, #16]
 8082d66:	9b04      	ldr	r3, [sp, #16]
  if(hsai->Instance == AUDIO_IN_SAIx)
 8082d68:	d012      	beq.n	8082d90 <BSP_AUDIO_IN_MspInit+0xd0>
  HAL_NVIC_SetPriority(AUDIO_IN_SAIx_DMAx_IRQ, AUDIO_IN_IRQ_PREPRIO, 0);
 8082d6a:	2200      	movs	r2, #0
 8082d6c:	210f      	movs	r1, #15
 8082d6e:	2046      	movs	r0, #70	; 0x46
 8082d70:	f002 fd4e 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(AUDIO_IN_SAIx_DMAx_IRQ);
 8082d74:	2046      	movs	r0, #70	; 0x46
 8082d76:	f002 fd87 	bl	8085888 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(AUDIO_IN_INT_IRQ, AUDIO_IN_IRQ_PREPRIO, 0);
 8082d7a:	2200      	movs	r2, #0
 8082d7c:	210f      	movs	r1, #15
 8082d7e:	2028      	movs	r0, #40	; 0x28
 8082d80:	f002 fd46 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(AUDIO_IN_INT_IRQ);
 8082d84:	2028      	movs	r0, #40	; 0x28
 8082d86:	f002 fd7f 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 8082d8a:	b00a      	add	sp, #40	; 0x28
 8082d8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hdma_sai_rx.Init.Channel             = AUDIO_IN_SAIx_DMAx_CHANNEL;
 8082d90:	f24b 54b0 	movw	r4, #46512	; 0xb5b0
    hdma_sai_rx.Instance = AUDIO_IN_SAIx_DMAx_STREAM;
 8082d94:	f246 43b8 	movw	r3, #25784	; 0x64b8
    hdma_sai_rx.Init.PeriphDataAlignment = AUDIO_IN_SAIx_DMAx_PERIPH_DATA_SIZE;
 8082d98:	f44f 6000 	mov.w	r0, #2048	; 0x800
    hdma_sai_rx.Init.MemDataAlignment    = AUDIO_IN_SAIx_DMAx_MEM_DATA_SIZE;
 8082d9c:	f44f 5e00 	mov.w	lr, #8192	; 0x2000
    hdma_sai_rx.Init.Channel             = AUDIO_IN_SAIx_DMAx_CHANNEL;
 8082da0:	f2c2 0400 	movt	r4, #8192	; 0x2000
    hdma_sai_rx.Instance = AUDIO_IN_SAIx_DMAx_STREAM;
 8082da4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_sai_rx.Init.Mode                = DMA_CIRCULAR;
 8082da8:	f44f 7c80 	mov.w	ip, #256	; 0x100
    hdma_sai_rx.Init.Priority            = DMA_PRIORITY_HIGH;
 8082dac:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    hdma_sai_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8082db0:	2203      	movs	r2, #3
    hdma_sai_rx.Init.PeriphDataAlignment = AUDIO_IN_SAIx_DMAx_PERIPH_DATA_SIZE;
 8082db2:	6160      	str	r0, [r4, #20]
    __HAL_LINKDMA(hsai, hdmarx, hdma_sai_rx);
 8082db4:	6734      	str	r4, [r6, #112]	; 0x70
    HAL_DMA_DeInit(&hdma_sai_rx);
 8082db6:	4620      	mov	r0, r4
    hdma_sai_rx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
 8082db8:	6265      	str	r5, [r4, #36]	; 0x24
    __HAL_LINKDMA(hsai, hdmarx, hdma_sai_rx);
 8082dba:	63a6      	str	r6, [r4, #56]	; 0x38
    hdma_sai_rx.Init.Priority            = DMA_PRIORITY_HIGH;
 8082dbc:	6221      	str	r1, [r4, #32]
    hdma_sai_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8082dbe:	62a2      	str	r2, [r4, #40]	; 0x28
    hdma_sai_rx.Instance = AUDIO_IN_SAIx_DMAx_STREAM;
 8082dc0:	6023      	str	r3, [r4, #0]
    hdma_sai_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 8082dc2:	e9c4 5501 	strd	r5, r5, [r4, #4]
    hdma_sai_rx.Init.MemInc              = DMA_MINC_ENABLE;
 8082dc6:	e9c4 5703 	strd	r5, r7, [r4, #12]
    hdma_sai_rx.Init.PeriphBurst         = DMA_MBURST_SINGLE;
 8082dca:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
    hdma_sai_rx.Init.Mode                = DMA_CIRCULAR;
 8082dce:	e9c4 ec06 	strd	lr, ip, [r4, #24]
    HAL_DMA_DeInit(&hdma_sai_rx);
 8082dd2:	f002 fe11 	bl	80859f8 <HAL_DMA_DeInit>
    HAL_DMA_Init(&hdma_sai_rx);
 8082dd6:	4620      	mov	r0, r4
 8082dd8:	f002 fd70 	bl	80858bc <HAL_DMA_Init>
 8082ddc:	e7c5      	b.n	8082d6a <BSP_AUDIO_IN_MspInit+0xaa>
 8082dde:	bf00      	nop

08082de0 <BSP_AUDIO_IN_InitEx.part.0>:
uint8_t BSP_AUDIO_IN_InitEx(uint16_t InputDevice, uint32_t AudioFreq, uint32_t BitRes, uint32_t ChnlNbr)
 8082de0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  * @retval None
  */
static void SAIx_In_DeInit(void)
{
  /* Initialize the haudio_in_sai Instance parameter */
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082de2:	f645 4524 	movw	r5, #23588	; 0x5c24
 8082de6:	f24b 44a8 	movw	r4, #46248	; 0xb4a8
uint8_t BSP_AUDIO_IN_InitEx(uint16_t InputDevice, uint32_t AudioFreq, uint32_t BitRes, uint32_t ChnlNbr)
 8082dea:	460e      	mov	r6, r1
 8082dec:	4607      	mov	r7, r0
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082dee:	f2c4 0501 	movt	r5, #16385	; 0x4001
 8082df2:	f2c2 0400 	movt	r4, #8192	; 0x2000

  /* Disable SAI peripheral */
  __HAL_SAI_DISABLE(&haudio_in_sai);
 8082df6:	682b      	ldr	r3, [r5, #0]

  HAL_SAI_DeInit(&haudio_in_sai);
 8082df8:	4620      	mov	r0, r4
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082dfa:	6025      	str	r5, [r4, #0]
  __HAL_SAI_DISABLE(&haudio_in_sai);
 8082dfc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8082e00:	602b      	str	r3, [r5, #0]
  HAL_SAI_DeInit(&haudio_in_sai);
 8082e02:	f005 fd5f 	bl	80888c4 <HAL_SAI_DeInit>
    BSP_AUDIO_OUT_ClockConfig(&haudio_in_sai, AudioFreq, NULL); /* Clock config is shared between AUDIO IN and OUT */
 8082e06:	4620      	mov	r0, r4
 8082e08:	4631      	mov	r1, r6
 8082e0a:	2200      	movs	r2, #0
 8082e0c:	f7ff fe46 	bl	8082a9c <BSP_AUDIO_OUT_ClockConfig>
    if(HAL_SAI_GetState(&haudio_in_sai) == HAL_SAI_STATE_RESET)
 8082e10:	4620      	mov	r0, r4
    haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082e12:	6025      	str	r5, [r4, #0]
    if(HAL_SAI_GetState(&haudio_in_sai) == HAL_SAI_STATE_RESET)
 8082e14:	f005 ff9c 	bl	8088d50 <HAL_SAI_GetState>
 8082e18:	b320      	cbz	r0, 8082e64 <BSP_AUDIO_IN_InitEx.part.0+0x84>
    deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082e1a:	f24b 042c 	movw	r4, #45100	; 0xb02c
      slot_active = CODEC_AUDIOFRAME_SLOT_02;
 8082e1e:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
    SAIx_In_Init(SAI_MODEMASTER_RX, slot_active, AudioFreq);
 8082e22:	4632      	mov	r2, r6
 8082e24:	f04f 0001 	mov.w	r0, #1
    deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082e28:	f2c2 0400 	movt	r4, #8192	; 0x2000
    SAIx_In_Init(SAI_MODEMASTER_RX, slot_active, AudioFreq);
 8082e2c:	bf0c      	ite	eq
 8082e2e:	210a      	moveq	r1, #10
 8082e30:	2105      	movne	r1, #5
 8082e32:	f7ff fc29 	bl	8082688 <SAIx_In_Init>
    deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082e36:	68a3      	ldr	r3, [r4, #8]
 8082e38:	2034      	movs	r0, #52	; 0x34
 8082e3a:	4798      	blx	r3
    if((deviceid) == WM8994_ID)
 8082e3c:	f648 1394 	movw	r3, #35220	; 0x8994
 8082e40:	4298      	cmp	r0, r3
 8082e42:	d119      	bne.n	8082e78 <BSP_AUDIO_IN_InitEx.part.0+0x98>
      wm8994_drv.Reset(AUDIO_I2C_ADDRESS);
 8082e44:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8082e46:	2034      	movs	r0, #52	; 0x34
 8082e48:	4798      	blx	r3
      audio_drv = &wm8994_drv;
 8082e4a:	f24d 609c 	movw	r0, #54940	; 0xd69c
      audio_drv->Init(AUDIO_I2C_ADDRESS, InputDevice, 100, AudioFreq);
 8082e4e:	4633      	mov	r3, r6
 8082e50:	4639      	mov	r1, r7
      audio_drv = &wm8994_drv;
 8082e52:	f2c2 0002 	movt	r0, #8194	; 0x2002
      audio_drv->Init(AUDIO_I2C_ADDRESS, InputDevice, 100, AudioFreq);
 8082e56:	6825      	ldr	r5, [r4, #0]
 8082e58:	2264      	movs	r2, #100	; 0x64
      audio_drv = &wm8994_drv;
 8082e5a:	6004      	str	r4, [r0, #0]
      audio_drv->Init(AUDIO_I2C_ADDRESS, InputDevice, 100, AudioFreq);
 8082e5c:	2034      	movs	r0, #52	; 0x34
 8082e5e:	47a8      	blx	r5
      ret = AUDIO_OK;
 8082e60:	2000      	movs	r0, #0
}
 8082e62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8082e64:	4605      	mov	r5, r0
      BSP_AUDIO_OUT_MspInit(&haudio_in_sai, NULL);  /* Initialize GPIOs for SAI2 block A Master signals */
 8082e66:	4601      	mov	r1, r0
 8082e68:	4620      	mov	r0, r4
 8082e6a:	f7ff fd13 	bl	8082894 <BSP_AUDIO_OUT_MspInit>
      BSP_AUDIO_IN_MspInit(&haudio_in_sai, NULL);
 8082e6e:	4629      	mov	r1, r5
 8082e70:	4620      	mov	r0, r4
 8082e72:	f7ff ff25 	bl	8082cc0 <BSP_AUDIO_IN_MspInit>
 8082e76:	e7d0      	b.n	8082e1a <BSP_AUDIO_IN_InitEx.part.0+0x3a>
      ret = AUDIO_ERROR;
 8082e78:	2001      	movs	r0, #1
}
 8082e7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08082e7c <BSP_AUDIO_IN_Init>:
{
 8082e7c:	4601      	mov	r1, r0
 8082e7e:	f44f 7000 	mov.w	r0, #512	; 0x200
 8082e82:	f7ff bfad 	b.w	8082de0 <BSP_AUDIO_IN_InitEx.part.0>
 8082e86:	bf00      	nop

08082e88 <BSP_AUDIO_IN_OUT_Init>:
  if (InputDevice != INPUT_DEVICE_DIGITAL_MICROPHONE_2)  /* Only MICROPHONE_2 input supported */
 8082e88:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8082e8c:	d001      	beq.n	8082e92 <BSP_AUDIO_IN_OUT_Init+0xa>
    ret = AUDIO_ERROR;
 8082e8e:	2001      	movs	r0, #1
}
 8082e90:	4770      	bx	lr
{
 8082e92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082e96:	f645 4624 	movw	r6, #23588	; 0x5c24
 8082e9a:	f24b 44a8 	movw	r4, #46248	; 0xb4a8
 8082e9e:	4690      	mov	r8, r2
 8082ea0:	460f      	mov	r7, r1
 8082ea2:	f2c4 0601 	movt	r6, #16385	; 0x4001
 8082ea6:	f2c2 0400 	movt	r4, #8192	; 0x2000
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082eaa:	f24b 552c 	movw	r5, #46380	; 0xb52c
  __HAL_SAI_DISABLE(&haudio_in_sai);
 8082eae:	6833      	ldr	r3, [r6, #0]
  HAL_SAI_DeInit(&haudio_in_sai);
 8082eb0:	4620      	mov	r0, r4
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082eb2:	6026      	str	r6, [r4, #0]
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082eb4:	f2c2 0500 	movt	r5, #8192	; 0x2000
  __HAL_SAI_DISABLE(&haudio_in_sai);
 8082eb8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8082ebc:	6033      	str	r3, [r6, #0]
  HAL_SAI_DeInit(&haudio_in_sai);
 8082ebe:	f005 fd01 	bl	80888c4 <HAL_SAI_DeInit>
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082ec2:	f645 4304 	movw	r3, #23556	; 0x5c04
  HAL_SAI_DeInit(&haudio_out_sai);
 8082ec6:	4628      	mov	r0, r5
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082ec8:	f2c4 0301 	movt	r3, #16385	; 0x4001
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082ecc:	681a      	ldr	r2, [r3, #0]
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082ece:	602b      	str	r3, [r5, #0]
  __HAL_SAI_DISABLE(&haudio_out_sai);
 8082ed0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8082ed4:	601a      	str	r2, [r3, #0]
  HAL_SAI_DeInit(&haudio_out_sai);
 8082ed6:	f005 fcf5 	bl	80888c4 <HAL_SAI_DeInit>
    BSP_AUDIO_OUT_ClockConfig(&haudio_in_sai, AudioFreq, NULL); /* Clock config is shared between AUDIO IN and OUT */
 8082eda:	4620      	mov	r0, r4
 8082edc:	2200      	movs	r2, #0
 8082ede:	4641      	mov	r1, r8
 8082ee0:	f7ff fddc 	bl	8082a9c <BSP_AUDIO_OUT_ClockConfig>
    if(HAL_SAI_GetState(&haudio_in_sai) == HAL_SAI_STATE_RESET)
 8082ee4:	4620      	mov	r0, r4
    haudio_in_sai.Instance = AUDIO_IN_SAIx;
 8082ee6:	6026      	str	r6, [r4, #0]
    if(HAL_SAI_GetState(&haudio_in_sai) == HAL_SAI_STATE_RESET)
 8082ee8:	f005 ff32 	bl	8088d50 <HAL_SAI_GetState>
 8082eec:	b3a8      	cbz	r0, 8082f5a <BSP_AUDIO_IN_OUT_Init+0xd2>
    haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082eee:	f645 4304 	movw	r3, #23556	; 0x5c04
    if(HAL_SAI_GetState(&haudio_out_sai) == HAL_SAI_STATE_RESET)
 8082ef2:	f24b 502c 	movw	r0, #46380	; 0xb52c
    haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082ef6:	f2c4 0301 	movt	r3, #16385	; 0x4001
    if(HAL_SAI_GetState(&haudio_out_sai) == HAL_SAI_STATE_RESET)
 8082efa:	f2c2 0000 	movt	r0, #8192	; 0x2000
    haudio_out_sai.Instance = AUDIO_OUT_SAIx;
 8082efe:	602b      	str	r3, [r5, #0]
    if(HAL_SAI_GetState(&haudio_out_sai) == HAL_SAI_STATE_RESET)
 8082f00:	f005 ff26 	bl	8088d50 <HAL_SAI_GetState>
 8082f04:	4601      	mov	r1, r0
 8082f06:	b308      	cbz	r0, 8082f4c <BSP_AUDIO_IN_OUT_Init+0xc4>
    deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082f08:	f24b 042c 	movw	r4, #45100	; 0xb02c
    SAIx_In_Init(SAI_MODEMASTER_TX, slot_active, AudioFreq);
 8082f0c:	4642      	mov	r2, r8
 8082f0e:	210a      	movs	r1, #10
 8082f10:	2000      	movs	r0, #0
    deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082f12:	f2c2 0400 	movt	r4, #8192	; 0x2000
    SAIx_In_Init(SAI_MODEMASTER_TX, slot_active, AudioFreq);
 8082f16:	f7ff fbb7 	bl	8082688 <SAIx_In_Init>
    deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
 8082f1a:	2034      	movs	r0, #52	; 0x34
 8082f1c:	68a3      	ldr	r3, [r4, #8]
 8082f1e:	4798      	blx	r3
    if((deviceid) == WM8994_ID)
 8082f20:	f648 1394 	movw	r3, #35220	; 0x8994
 8082f24:	4298      	cmp	r0, r3
 8082f26:	d11d      	bne.n	8082f64 <BSP_AUDIO_IN_OUT_Init+0xdc>
      wm8994_drv.Reset(AUDIO_I2C_ADDRESS);
 8082f28:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8082f2a:	2034      	movs	r0, #52	; 0x34
 8082f2c:	4798      	blx	r3
      audio_drv = &wm8994_drv;
 8082f2e:	f24d 609c 	movw	r0, #54940	; 0xd69c
      audio_drv->Init(AUDIO_I2C_ADDRESS, InputDevice | OutputDevice, 100, AudioFreq);
 8082f32:	4643      	mov	r3, r8
 8082f34:	f447 7100 	orr.w	r1, r7, #512	; 0x200
      audio_drv = &wm8994_drv;
 8082f38:	f2c2 0002 	movt	r0, #8194	; 0x2002
      audio_drv->Init(AUDIO_I2C_ADDRESS, InputDevice | OutputDevice, 100, AudioFreq);
 8082f3c:	6825      	ldr	r5, [r4, #0]
 8082f3e:	2264      	movs	r2, #100	; 0x64
      audio_drv = &wm8994_drv;
 8082f40:	6004      	str	r4, [r0, #0]
      audio_drv->Init(AUDIO_I2C_ADDRESS, InputDevice | OutputDevice, 100, AudioFreq);
 8082f42:	2034      	movs	r0, #52	; 0x34
 8082f44:	47a8      	blx	r5
      ret = AUDIO_OK;
 8082f46:	2000      	movs	r0, #0
}
 8082f48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      BSP_AUDIO_OUT_MspInit(&haudio_out_sai, NULL);
 8082f4c:	f24b 502c 	movw	r0, #46380	; 0xb52c
 8082f50:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8082f54:	f7ff fc9e 	bl	8082894 <BSP_AUDIO_OUT_MspInit>
 8082f58:	e7d6      	b.n	8082f08 <BSP_AUDIO_IN_OUT_Init+0x80>
      BSP_AUDIO_IN_MspInit(&haudio_in_sai, NULL);
 8082f5a:	4601      	mov	r1, r0
 8082f5c:	4620      	mov	r0, r4
 8082f5e:	f7ff feaf 	bl	8082cc0 <BSP_AUDIO_IN_MspInit>
 8082f62:	e7c4      	b.n	8082eee <BSP_AUDIO_IN_OUT_Init+0x66>
    ret = AUDIO_ERROR;
 8082f64:	2001      	movs	r0, #1
}
 8082f66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8082f6a:	bf00      	nop

08082f6c <BSP_KEYS_Read>:
/**
 * @brief  Reads keys
 * @retval KEYS memory status
 */
uint8_t BSP_KEYS_Read(void)
{
 8082f6c:	b530      	push	{r4, r5, lr}
 8082f6e:	b083      	sub	sp, #12
  __ASM volatile ("cpsid i" : : : "memory");
 8082f70:	b672      	cpsid	i

	/* TODO: Supprimer apres test */
	__disable_irq();

	/* Enable Keys serializer */
	KEYS_CS_ENABLE();
 8082f72:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 8082f76:	2200      	movs	r2, #0
 8082f78:	2180      	movs	r1, #128	; 0x80

	/* Switch to serial mode */
	KEYS_SET_SERIAL_MODE();

	/* Read data */
	status = HAL_SPI_Receive(&SPIHandle, &KEYSBuffer,1,100);
 8082f7a:	f24d 6458 	movw	r4, #54872	; 0xd658
	KEYS_CS_ENABLE();
 8082f7e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082f82:	f003 fa8d 	bl	80864a0 <HAL_GPIO_WritePin>
	KEYS_SET_PARALLEL_MODE();
 8082f86:	2000      	movs	r0, #0
 8082f88:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	status = HAL_SPI_Receive(&SPIHandle, &KEYSBuffer,1,100);
 8082f8c:	f2c2 0402 	movt	r4, #8194	; 0x2002
	KEYS_SET_PARALLEL_MODE();
 8082f90:	4602      	mov	r2, r0
 8082f92:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082f96:	f003 fa83 	bl	80864a0 <HAL_GPIO_WritePin>
	status = HAL_SPI_Receive(&SPIHandle, &dummy,1,100);
 8082f9a:	f24d 60a0 	movw	r0, #54944	; 0xd6a0
 8082f9e:	2364      	movs	r3, #100	; 0x64
 8082fa0:	f10d 0107 	add.w	r1, sp, #7
 8082fa4:	2201      	movs	r2, #1
 8082fa6:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8082faa:	f007 f95f 	bl	808a26c <HAL_SPI_Receive>
	KEYS_SET_SERIAL_MODE();
 8082fae:	2000      	movs	r0, #0
 8082fb0:	2201      	movs	r2, #1
 8082fb2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8082fb6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8082fba:	f003 fa71 	bl	80864a0 <HAL_GPIO_WritePin>
	status = HAL_SPI_Receive(&SPIHandle, &KEYSBuffer,1,100);
 8082fbe:	f24d 60a0 	movw	r0, #54944	; 0xd6a0
 8082fc2:	4621      	mov	r1, r4
 8082fc4:	2364      	movs	r3, #100	; 0x64
 8082fc6:	2201      	movs	r2, #1
 8082fc8:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8082fcc:	f007 f94e 	bl	808a26c <HAL_SPI_Receive>
	KEYSBuffer = ~KEYSBuffer; // on inverse la polarité des touches: a 0 si relachée, à 1 si appuyée
 8082fd0:	7823      	ldrb	r3, [r4, #0]
	status = HAL_SPI_Receive(&SPIHandle, &KEYSBuffer,1,100);
 8082fd2:	4605      	mov	r5, r0

	/* Disable Keys serializer (free spi bus) */
	KEYS_CS_DISABLE();
 8082fd4:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	KEYSBuffer = ~KEYSBuffer; // on inverse la polarité des touches: a 0 si relachée, à 1 si appuyée
 8082fd8:	43db      	mvns	r3, r3
	KEYS_CS_DISABLE();
 8082fda:	2201      	movs	r2, #1
 8082fdc:	2180      	movs	r1, #128	; 0x80
 8082fde:	f2c4 0002 	movt	r0, #16386	; 0x4002
	KEYSBuffer = ~KEYSBuffer; // on inverse la polarité des touches: a 0 si relachée, à 1 si appuyée
 8082fe2:	7023      	strb	r3, [r4, #0]
	KEYS_CS_DISABLE();
 8082fe4:	f003 fa5c 	bl	80864a0 <HAL_GPIO_WritePin>

	if (status != HAL_OK)
 8082fe8:	b91d      	cbnz	r5, 8082ff2 <BSP_KEYS_Read+0x86>
  __ASM volatile ("cpsie i" : : : "memory");
 8082fea:	b662      	cpsie	i

	/* TODO: Supprimer apres test */
	__enable_irq();

	return KEYS_OK;
}
 8082fec:	4628      	mov	r0, r5
 8082fee:	b003      	add	sp, #12
 8082ff0:	bd30      	pop	{r4, r5, pc}
		return KEYS_ERROR;
 8082ff2:	2501      	movs	r5, #1
}
 8082ff4:	4628      	mov	r0, r5
 8082ff6:	b003      	add	sp, #12
 8082ff8:	bd30      	pop	{r4, r5, pc}
 8082ffa:	bf00      	nop

08082ffc <BSP_KEYS_GetKey>:
/**
 * @brief  Check if given key is pressed
 * @retval KEYS_PRESSED or KEYS_RELEASE
 */
uint8_t BSP_KEYS_GetKey(uint8_t key)
{
 8082ffc:	b510      	push	{r4, lr}
 8082ffe:	4604      	mov	r4, r0
	BSP_KEYS_Read();
 8083000:	f7ff ffb4 	bl	8082f6c <BSP_KEYS_Read>

	if (KEYSBuffer & key)
 8083004:	f24d 6358 	movw	r3, #54872	; 0xd658
 8083008:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808300c:	781b      	ldrb	r3, [r3, #0]
 808300e:	421c      	tst	r4, r3
	{
		return KEYS_PRESSED;
	}

	return KEYS_RELEASED;
}
 8083010:	bf14      	ite	ne
 8083012:	2001      	movne	r0, #1
 8083014:	2000      	moveq	r0, #0
 8083016:	bd10      	pop	{r4, pc}

08083018 <BSP_KEYS_GetKeys>:
/**
 * @brief  Return whole keys status
 * @retval Keys status
 */
uint8_t BSP_KEYS_GetKeys (void)
{
 8083018:	b508      	push	{r3, lr}
	BSP_KEYS_Read();
 808301a:	f7ff ffa7 	bl	8082f6c <BSP_KEYS_Read>

	return KEYSBuffer;
 808301e:	f24d 6358 	movw	r3, #54872	; 0xd658
 8083022:	f2c2 0302 	movt	r3, #8194	; 0x2002
}
 8083026:	7818      	ldrb	r0, [r3, #0]
 8083028:	bd08      	pop	{r3, pc}
 808302a:	bf00      	nop

0808302c <BSP_KEYS_MspInit>:
{
	GPIO_InitTypeDef gpio_init_structure;

	/*##-1- Enable peripherals and GPIO Clocks #################################*/
	/* Enable the Keys (SPI) interface clock */
	KEYS_CLK_ENABLE();
 808302c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
	/* KEYS CS GPIO pin configuration  */
	gpio_init_structure.Pin       = KEYS_CS_PIN;
	gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
	gpio_init_structure.Pull      = GPIO_NOPULL;
	gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
	HAL_GPIO_Init(KEYS_CS_GPIO_PORT, &gpio_init_structure);
 8083030:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	gpio_init_structure.Pin       = KEYS_CS_PIN;
 8083034:	f04f 0c80 	mov.w	ip, #128	; 0x80
	KEYS_CLK_ENABLE();
 8083038:	f2c4 0302 	movt	r3, #16386	; 0x4002
	HAL_GPIO_Init(KEYS_CS_GPIO_PORT, &gpio_init_structure);
 808303c:	f2c4 0002 	movt	r0, #16386	; 0x4002
	KEYS_CLK_ENABLE();
 8083040:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8083042:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
{
 8083046:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	KEYS_CLK_ENABLE();
 808304a:	641a      	str	r2, [r3, #64]	; 0x40
{
 808304c:	b08a      	sub	sp, #40	; 0x28
	KEYS_CLK_ENABLE();
 808304e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
 8083050:	2601      	movs	r6, #1

	/* KEYS CS GPIO pin configuration  */
	gpio_init_structure.Pin       = KEYS_LOAD_PIN;
	HAL_GPIO_Init(KEYS_LOAD_GPIO_PORT, &gpio_init_structure);
 8083052:	2400      	movs	r4, #0
	gpio_init_structure.Pull      = GPIO_NOPULL;
 8083054:	2500      	movs	r5, #0
	KEYS_CLK_ENABLE();
 8083056:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
	gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 808305a:	2703      	movs	r7, #3
	HAL_GPIO_Init(KEYS_LOAD_GPIO_PORT, &gpio_init_structure);
 808305c:	f2c4 0402 	movt	r4, #16386	; 0x4002

	//TODO: A supprimer quand le driver BMP280 sera pret
	/* BMP280 CS GPIO pin configuration , to put it high */
	gpio_init_structure.Pin       = GPIO_PIN_8;
 8083060:	f44f 7880 	mov.w	r8, #256	; 0x100
	KEYS_CLK_ENABLE();
 8083064:	9200      	str	r2, [sp, #0]
 8083066:	9a00      	ldr	r2, [sp, #0]
	KEYS_CS_GPIO_CLK_ENABLE();
 8083068:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808306a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 808306e:	631a      	str	r2, [r3, #48]	; 0x30
 8083070:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8083072:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8083076:	9201      	str	r2, [sp, #4]
 8083078:	9a01      	ldr	r2, [sp, #4]
	KEYS_CLK_GPIO_CLK_ENABLE();
 808307a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808307c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8083080:	631a      	str	r2, [r3, #48]	; 0x30
 8083082:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8083084:	f402 7280 	and.w	r2, r2, #256	; 0x100
 8083088:	9202      	str	r2, [sp, #8]
 808308a:	9a02      	ldr	r2, [sp, #8]
	KEYS_MISO_GPIO_CLK_ENABLE();
 808308c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808308e:	f042 0202 	orr.w	r2, r2, #2
 8083092:	631a      	str	r2, [r3, #48]	; 0x30
 8083094:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8083096:	f001 0102 	and.w	r1, r1, #2
 808309a:	9103      	str	r1, [sp, #12]
 808309c:	9a03      	ldr	r2, [sp, #12]
	KEYS_LOAD_GPIO_CLK_ENABLE();
 808309e:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80830a0:	4331      	orrs	r1, r6
 80830a2:	6319      	str	r1, [r3, #48]	; 0x30
	HAL_GPIO_Init(KEYS_CS_GPIO_PORT, &gpio_init_structure);
 80830a4:	a905      	add	r1, sp, #20
	KEYS_LOAD_GPIO_CLK_ENABLE();
 80830a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
	gpio_init_structure.Pin       = KEYS_CS_PIN;
 80830a8:	f8cd c014 	str.w	ip, [sp, #20]
	KEYS_LOAD_GPIO_CLK_ENABLE();
 80830ac:	4033      	ands	r3, r6
	gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 80830ae:	9708      	str	r7, [sp, #32]
	KEYS_LOAD_GPIO_CLK_ENABLE();
 80830b0:	9304      	str	r3, [sp, #16]
 80830b2:	9b04      	ldr	r3, [sp, #16]
	gpio_init_structure.Pull      = GPIO_NOPULL;
 80830b4:	e9cd 6506 	strd	r6, r5, [sp, #24]
	HAL_GPIO_Init(KEYS_CS_GPIO_PORT, &gpio_init_structure);
 80830b8:	f002 ffd2 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Pin       = KEYS_LOAD_PIN;
 80830bc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
	HAL_GPIO_Init(KEYS_LOAD_GPIO_PORT, &gpio_init_structure);
 80830c0:	4620      	mov	r0, r4
 80830c2:	a905      	add	r1, sp, #20
	gpio_init_structure.Pin       = KEYS_LOAD_PIN;
 80830c4:	9305      	str	r3, [sp, #20]
	HAL_GPIO_Init(KEYS_LOAD_GPIO_PORT, &gpio_init_structure);
 80830c6:	f002 ffcb 	bl	8086060 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOA, &gpio_init_structure);
 80830ca:	4620      	mov	r0, r4
 80830cc:	a905      	add	r1, sp, #20
	gpio_init_structure.Pin       = GPIO_PIN_8;
 80830ce:	f8cd 8014 	str.w	r8, [sp, #20]
	HAL_GPIO_Init(GPIOA, &gpio_init_structure);
 80830d2:	f002 ffc5 	bl	8086060 <HAL_GPIO_Init>

	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8,GPIO_PIN_SET);
 80830d6:	4632      	mov	r2, r6
 80830d8:	4641      	mov	r1, r8
 80830da:	4620      	mov	r0, r4

	/* KEYS CLK GPIO pin configuration  */
	gpio_init_structure.Pin       = KEYS_CLK_PIN;
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
	gpio_init_structure.Pull      = GPIO_NOPULL;
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
 80830dc:	2405      	movs	r4, #5
	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8,GPIO_PIN_SET);
 80830de:	f003 f9df 	bl	80864a0 <HAL_GPIO_WritePin>
	HAL_GPIO_Init(KEYS_CLK_GPIO_PORT, &gpio_init_structure);
 80830e2:	f44f 5000 	mov.w	r0, #8192	; 0x2000
	gpio_init_structure.Pin       = KEYS_CLK_PIN;
 80830e6:	2302      	movs	r3, #2
	HAL_GPIO_Init(KEYS_CLK_GPIO_PORT, &gpio_init_structure);
 80830e8:	a905      	add	r1, sp, #20
 80830ea:	f2c4 0002 	movt	r0, #16386	; 0x4002
	gpio_init_structure.Pull      = GPIO_NOPULL;
 80830ee:	9507      	str	r5, [sp, #28]
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
 80830f0:	9409      	str	r4, [sp, #36]	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 80830f2:	e9cd 3305 	strd	r3, r3, [sp, #20]
	HAL_GPIO_Init(KEYS_CLK_GPIO_PORT, &gpio_init_structure);
 80830f6:	f002 ffb3 	bl	8086060 <HAL_GPIO_Init>

	/* KEYS MISO GPIO pin configuration  */
	gpio_init_structure.Pin       = KEYS_MISO_PIN;
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
	HAL_GPIO_Init(KEYS_MISO_GPIO_PORT, &gpio_init_structure);
 80830fa:	f44f 6080 	mov.w	r0, #1024	; 0x400
	gpio_init_structure.Pin       = KEYS_MISO_PIN;
 80830fe:	f44f 4380 	mov.w	r3, #16384	; 0x4000
	HAL_GPIO_Init(KEYS_MISO_GPIO_PORT, &gpio_init_structure);
 8083102:	a905      	add	r1, sp, #20
 8083104:	f2c4 0002 	movt	r0, #16386	; 0x4002
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
 8083108:	9409      	str	r4, [sp, #36]	; 0x24
	gpio_init_structure.Pin       = KEYS_MISO_PIN;
 808310a:	9305      	str	r3, [sp, #20]
	HAL_GPIO_Init(KEYS_MISO_GPIO_PORT, &gpio_init_structure);
 808310c:	f002 ffa8 	bl	8086060 <HAL_GPIO_Init>

	/*##-3- Configure the NVIC for SPI2 #########################################*/
	/* NVIC configuration for SPI2 interrupt */
	HAL_NVIC_SetPriority(SPI2_IRQn, 0x0F, 0);
 8083110:	462a      	mov	r2, r5
 8083112:	210f      	movs	r1, #15
 8083114:	2024      	movs	r0, #36	; 0x24
 8083116:	f002 fb7b 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(SPI2_IRQn);
 808311a:	2024      	movs	r0, #36	; 0x24
 808311c:	f002 fbb4 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 8083120:	b00a      	add	sp, #40	; 0x28
 8083122:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8083126:	bf00      	nop

08083128 <BSP_KEYS_Init>:
{ 
 8083128:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SPIHandle.Instance = KEYS_SPIx;
 808312a:	f24d 64a0 	movw	r4, #54944	; 0xd6a0
 808312e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8083132:	f2c2 0402 	movt	r4, #8194	; 0x2002
 8083136:	f2c4 0300 	movt	r3, #16384	; 0x4000
	if (HAL_SPI_DeInit(&SPIHandle) != HAL_OK)
 808313a:	4620      	mov	r0, r4
	SPIHandle.Instance = KEYS_SPIx;
 808313c:	6023      	str	r3, [r4, #0]
	if (HAL_SPI_DeInit(&SPIHandle) != HAL_OK)
 808313e:	f006 fde3 	bl	8089d08 <HAL_SPI_DeInit>
 8083142:	b108      	cbz	r0, 8083148 <BSP_KEYS_Init+0x20>
		return KEYS_ERROR;
 8083144:	2001      	movs	r0, #1
}
 8083146:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8083148:	4605      	mov	r5, r0
	SPIHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
 808314a:	2738      	movs	r7, #56	; 0x38
	BSP_KEYS_MspInit();
 808314c:	f7ff ff6e 	bl	808302c <BSP_KEYS_MspInit>
	SPIHandle.Init.DataSize 		= SPI_DATASIZE_8BIT;
 8083150:	f44f 66e0 	mov.w	r6, #1792	; 0x700
	SPIHandle.Init.Mode 			=  SPI_MODE_MASTER;
 8083154:	f44f 7182 	mov.w	r1, #260	; 0x104
	SPIHandle.Init.NSS 				= SPI_NSS_SOFT;
 8083158:	f44f 7200 	mov.w	r2, #512	; 0x200
	SPIHandle.Init.CRCPolynomial    = 7;
 808315c:	2307      	movs	r3, #7
	if (HAL_SPI_Init(&SPIHandle) != HAL_OK)
 808315e:	4620      	mov	r0, r4
	SPIHandle.Init.Direction 		= SPI_DIRECTION_2LINES;
 8083160:	60a5      	str	r5, [r4, #8]
	SPIHandle.Init.CRCCalculation   = SPI_CRCCALCULATION_DISABLE;
 8083162:	62a5      	str	r5, [r4, #40]	; 0x28
	SPIHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
 8083164:	61e7      	str	r7, [r4, #28]
	SPIHandle.Init.DataSize 		= SPI_DATASIZE_8BIT;
 8083166:	60e6      	str	r6, [r4, #12]
	SPIHandle.Init.Mode 			=  SPI_MODE_MASTER;
 8083168:	6061      	str	r1, [r4, #4]
	SPIHandle.Init.NSS 				= SPI_NSS_SOFT;
 808316a:	61a2      	str	r2, [r4, #24]
	SPIHandle.Init.CRCPolynomial    = 7;
 808316c:	62e3      	str	r3, [r4, #44]	; 0x2c
	SPIHandle.Init.CLKPolarity 		= SPI_POLARITY_LOW;
 808316e:	e9c4 5504 	strd	r5, r5, [r4, #16]
	SPIHandle.Init.TIMode           = SPI_TIMODE_DISABLE;
 8083172:	e9c4 5508 	strd	r5, r5, [r4, #32]
	if (HAL_SPI_Init(&SPIHandle) != HAL_OK)
 8083176:	f006 fd53 	bl	8089c20 <HAL_SPI_Init>
 808317a:	4604      	mov	r4, r0
 808317c:	2800      	cmp	r0, #0
 808317e:	d1e1      	bne.n	8083144 <BSP_KEYS_Init+0x1c>
	KEYS_CS_DISABLE();
 8083180:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 8083184:	2201      	movs	r2, #1
 8083186:	2180      	movs	r1, #128	; 0x80
 8083188:	f2c4 0002 	movt	r0, #16386	; 0x4002
 808318c:	f003 f988 	bl	80864a0 <HAL_GPIO_WritePin>
	KEYS_SET_SERIAL_MODE();
 8083190:	2000      	movs	r0, #0
 8083192:	2201      	movs	r2, #1
 8083194:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8083198:	f2c4 0002 	movt	r0, #16386	; 0x4002
 808319c:	f003 f980 	bl	80864a0 <HAL_GPIO_WritePin>
	return KEYS_OK;
 80831a0:	4620      	mov	r0, r4
}
 80831a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080831a4 <LL_FillBuffer>:
 * @param  OffLine: Offset
 * @param  ColorIndex: Color index
 * @retval None
 */
static void LL_FillBuffer(uint32_t LayerIndex, void *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex) 
{
 80831a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	/* Register to memory mode with ARGB8888 as color Mode */
	hDma2dHandler.Init.Mode         = DMA2D_R2M;
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 80831a8:	f24b 6670 	movw	r6, #46704	; 0xb670
 80831ac:	f24d 7504 	movw	r5, #55044	; 0xd704
 80831b0:	f04f 0c34 	mov.w	ip, #52	; 0x34
{
 80831b4:	4607      	mov	r7, r0
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 80831b6:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80831ba:	f2c2 0502 	movt	r5, #8194	; 0x2002
{
 80831be:	4699      	mov	r9, r3
	hDma2dHandler.Init.Mode         = DMA2D_R2M;
 80831c0:	f24b 648c 	movw	r4, #46732	; 0xb68c
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 80831c4:	6830      	ldr	r0, [r6, #0]
{
 80831c6:	b083      	sub	sp, #12
	hDma2dHandler.Init.Mode         = DMA2D_R2M;
 80831c8:	f2c2 0400 	movt	r4, #8192	; 0x2000
{
 80831cc:	460e      	mov	r6, r1
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 80831ce:	fb0c 5000 	mla	r0, ip, r0, r5
{
 80831d2:	4690      	mov	r8, r2
	hDma2dHandler.Init.Mode         = DMA2D_R2M;
 80831d4:	f44f 3140 	mov.w	r1, #196608	; 0x30000
{
 80831d8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 80831da:	6c83      	ldr	r3, [r0, #72]	; 0x48
	hDma2dHandler.Init.OutputOffset = OffLine;

	hDma2dHandler.Instance = DMA2D;

	/* DMA2D Initialization */
	if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK)
 80831dc:	f24b 608c 	movw	r0, #46732	; 0xb68c
	hDma2dHandler.Init.Mode         = DMA2D_R2M;
 80831e0:	6061      	str	r1, [r4, #4]
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 80831e2:	2b02      	cmp	r3, #2
	if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK)
 80831e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
{
 80831e8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
		hDma2dHandler.Init.ColorMode    = DMA2D_ARGB8888;
 80831ea:	bf18      	it	ne
 80831ec:	2300      	movne	r3, #0
	hDma2dHandler.Init.OutputOffset = OffLine;
 80831ee:	60e2      	str	r2, [r4, #12]
		hDma2dHandler.Init.ColorMode    = DMA2D_ARGB8888;
 80831f0:	60a3      	str	r3, [r4, #8]
	hDma2dHandler.Instance = DMA2D;
 80831f2:	f44f 4330 	mov.w	r3, #45056	; 0xb000
 80831f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80831fa:	6023      	str	r3, [r4, #0]
	if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK)
 80831fc:	f002 fe02 	bl	8085e04 <HAL_DMA2D_Init>
 8083200:	b110      	cbz	r0, 8083208 <LL_FillBuffer+0x64>
				/* Polling For DMA transfer */
				HAL_DMA2D_PollForTransfer(&hDma2dHandler, 10);
			}
		}
	}
}
 8083202:	b003      	add	sp, #12
 8083204:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if(HAL_DMA2D_ConfigLayer(&hDma2dHandler, LayerIndex) == HAL_OK)
 8083208:	f24b 608c 	movw	r0, #46732	; 0xb68c
 808320c:	4639      	mov	r1, r7
 808320e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8083212:	f002 fec9 	bl	8085fa8 <HAL_DMA2D_ConfigLayer>
 8083216:	2800      	cmp	r0, #0
 8083218:	d1f3      	bne.n	8083202 <LL_FillBuffer+0x5e>
			if (HAL_DMA2D_Start(&hDma2dHandler, ColorIndex, (uint32_t)pDst, xSize, ySize) == HAL_OK)
 808321a:	f24b 608c 	movw	r0, #46732	; 0xb68c
 808321e:	f8cd 9000 	str.w	r9, [sp]
 8083222:	4643      	mov	r3, r8
 8083224:	4632      	mov	r2, r6
 8083226:	4629      	mov	r1, r5
 8083228:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808322c:	f002 fe1a 	bl	8085e64 <HAL_DMA2D_Start>
 8083230:	2800      	cmp	r0, #0
 8083232:	d1e6      	bne.n	8083202 <LL_FillBuffer+0x5e>
				HAL_DMA2D_PollForTransfer(&hDma2dHandler, 10);
 8083234:	f24b 608c 	movw	r0, #46732	; 0xb68c
 8083238:	210a      	movs	r1, #10
 808323a:	f2c2 0000 	movt	r0, #8192	; 0x2000
}
 808323e:	b003      	add	sp, #12
 8083240:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
				HAL_DMA2D_PollForTransfer(&hDma2dHandler, 10);
 8083244:	f002 be2a 	b.w	8085e9c <HAL_DMA2D_PollForTransfer>

08083248 <BSP_LCD_GetXSize>:
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083248:	f24b 6170 	movw	r1, #46704	; 0xb670
 808324c:	f24d 7204 	movw	r2, #55044	; 0xd704
 8083250:	2034      	movs	r0, #52	; 0x34
 8083252:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8083256:	f2c2 0202 	movt	r2, #8194	; 0x2002
 808325a:	680b      	ldr	r3, [r1, #0]
 808325c:	fb00 2303 	mla	r3, r0, r3, r2
}
 8083260:	6e18      	ldr	r0, [r3, #96]	; 0x60
 8083262:	4770      	bx	lr

08083264 <BSP_LCD_GetYSize>:
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
 8083264:	f24b 6170 	movw	r1, #46704	; 0xb670
 8083268:	f24d 7204 	movw	r2, #55044	; 0xd704
 808326c:	2034      	movs	r0, #52	; 0x34
 808326e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8083272:	f2c2 0202 	movt	r2, #8194	; 0x2002
 8083276:	680b      	ldr	r3, [r1, #0]
 8083278:	fb00 2303 	mla	r3, r0, r3, r2
}
 808327c:	6e58      	ldr	r0, [r3, #100]	; 0x64
 808327e:	4770      	bx	lr

08083280 <BSP_LCD_LayerRgb565Init>:
{     
 8083280:	b5f0      	push	{r4, r5, r6, r7, lr}
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083282:	f24b 6670 	movw	r6, #46704	; 0xb670
 8083286:	f24d 7504 	movw	r5, #55044	; 0xd704
 808328a:	2734      	movs	r7, #52	; 0x34
{     
 808328c:	b08f      	sub	sp, #60	; 0x3c
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 808328e:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8083292:	f2c2 0502 	movt	r5, #8194	; 0x2002
{     
 8083296:	4604      	mov	r4, r0
	layer_cfg.FBStartAdress = FB_Address;
 8083298:	910a      	str	r1, [sp, #40]	; 0x28
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 808329a:	6832      	ldr	r2, [r6, #0]
	layer_cfg.WindowX0 = 0;
 808329c:	2300      	movs	r3, #0
	layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 808329e:	f04f 0c02 	mov.w	ip, #2
	HAL_LTDC_ConfigLayer(&hLtdcHandler, &layer_cfg, LayerIndex);
 80832a2:	4628      	mov	r0, r5
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 80832a4:	fb07 5202 	mla	r2, r7, r2, r5
	layer_cfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
 80832a8:	f44f 66c0 	mov.w	r6, #1536	; 0x600
	/*else*/  layer_cfg.Alpha = 255;
 80832ac:	27ff      	movs	r7, #255	; 0xff
	layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 80832ae:	2507      	movs	r5, #7
	layer_cfg.WindowX0 = 0;
 80832b0:	9301      	str	r3, [sp, #4]
	layer_cfg.WindowY0 = 0;
 80832b2:	9303      	str	r3, [sp, #12]
	layer_cfg.Alpha0 = 0;
 80832b4:	9307      	str	r3, [sp, #28]
	layer_cfg.Backcolor.Blue = 0;
 80832b6:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
	layer_cfg.Backcolor.Green = 0;
 80832ba:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
	layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 80832be:	f8cd c014 	str.w	ip, [sp, #20]
	/*else*/  layer_cfg.Alpha = 255;
 80832c2:	9706      	str	r7, [sp, #24]
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
 80832c4:	e9d2 1218 	ldrd	r1, r2, [r2, #96]	; 0x60
	layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 80832c8:	e9cd 6508 	strd	r6, r5, [sp, #32]
	layer_cfg.WindowX1 = BSP_LCD_GetXSize();
 80832cc:	9102      	str	r1, [sp, #8]
	DrawProp[LayerIndex].TextColor = LCD_COLOR_BLACK;
 80832ce:	f04f 457f 	mov.w	r5, #4278190080	; 0xff000000
	layer_cfg.ImageWidth = BSP_LCD_GetXSize();
 80832d2:	910b      	str	r1, [sp, #44]	; 0x2c
	HAL_LTDC_ConfigLayer(&hLtdcHandler, &layer_cfg, LayerIndex);
 80832d4:	a901      	add	r1, sp, #4
	layer_cfg.WindowY1 = BSP_LCD_GetYSize();
 80832d6:	9204      	str	r2, [sp, #16]
	layer_cfg.ImageHeight = BSP_LCD_GetYSize();
 80832d8:	920c      	str	r2, [sp, #48]	; 0x30
	HAL_LTDC_ConfigLayer(&hLtdcHandler, &layer_cfg, LayerIndex);
 80832da:	4622      	mov	r2, r4
 80832dc:	f003 fdc6 	bl	8086e6c <HAL_LTDC_ConfigLayer>
	DrawProp[LayerIndex].BackColor = LCD_COLOR_WHITE;
 80832e0:	f24b 6374 	movw	r3, #46708	; 0xb674
 80832e4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
	DrawProp[LayerIndex].pFont     = &Font24;
 80832e8:	f24b 3264 	movw	r2, #45924	; 0xb364
	DrawProp[LayerIndex].BackColor = LCD_COLOR_WHITE;
 80832ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80832f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80832f4:	00a4      	lsls	r4, r4, #2
	DrawProp[LayerIndex].pFont     = &Font24;
 80832f6:	f2c2 0200 	movt	r2, #8192	; 0x2000
	DrawProp[LayerIndex].BackColor = LCD_COLOR_WHITE;
 80832fa:	1919      	adds	r1, r3, r4
	DrawProp[LayerIndex].TextColor = LCD_COLOR_BLACK;
 80832fc:	511d      	str	r5, [r3, r4]
	DrawProp[LayerIndex].pFont     = &Font24;
 80832fe:	e9c1 0201 	strd	r0, r2, [r1, #4]
}
 8083302:	b00f      	add	sp, #60	; 0x3c
 8083304:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8083306:	bf00      	nop

08083308 <BSP_LCD_SelectLayer>:
	ActiveLayer = LayerIndex;
 8083308:	f24b 6370 	movw	r3, #46704	; 0xb670
 808330c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8083310:	6018      	str	r0, [r3, #0]
} 
 8083312:	4770      	bx	lr

08083314 <BSP_LCD_SetColorKeying>:
{  
 8083314:	b538      	push	{r3, r4, r5, lr}
	HAL_LTDC_ConfigColorKeying(&hLtdcHandler, RGBValue, LayerIndex);
 8083316:	f24d 7404 	movw	r4, #55044	; 0xd704
{  
 808331a:	4605      	mov	r5, r0
	HAL_LTDC_ConfigColorKeying(&hLtdcHandler, RGBValue, LayerIndex);
 808331c:	4602      	mov	r2, r0
 808331e:	f2c2 0402 	movt	r4, #8194	; 0x2002
 8083322:	4620      	mov	r0, r4
 8083324:	f003 fdd2 	bl	8086ecc <HAL_LTDC_ConfigColorKeying>
	HAL_LTDC_EnableColorKeying(&hLtdcHandler, LayerIndex);
 8083328:	4629      	mov	r1, r5
 808332a:	4620      	mov	r0, r4
}
 808332c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	HAL_LTDC_EnableColorKeying(&hLtdcHandler, LayerIndex);
 8083330:	f003 bdec 	b.w	8086f0c <HAL_LTDC_EnableColorKeying>

08083334 <BSP_LCD_SetTextColor>:
	DrawProp[ActiveLayer].TextColor = Color;
 8083334:	f24b 6370 	movw	r3, #46704	; 0xb670
 8083338:	f24b 6274 	movw	r2, #46708	; 0xb674
 808333c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8083340:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8083344:	681b      	ldr	r3, [r3, #0]
 8083346:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 808334a:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
 808334e:	4770      	bx	lr

08083350 <BSP_LCD_GetTextColor>:
	return DrawProp[ActiveLayer].TextColor;
 8083350:	f24b 6370 	movw	r3, #46704	; 0xb670
 8083354:	f24b 6274 	movw	r2, #46708	; 0xb674
 8083358:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808335c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8083360:	681b      	ldr	r3, [r3, #0]
 8083362:	eb03 0343 	add.w	r3, r3, r3, lsl #1
}
 8083366:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 808336a:	4770      	bx	lr

0808336c <BSP_LCD_SetBackColor>:
	DrawProp[ActiveLayer].BackColor = Color;
 808336c:	f24b 6270 	movw	r2, #46704	; 0xb670
 8083370:	f24b 6374 	movw	r3, #46708	; 0xb674
 8083374:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8083378:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808337c:	6812      	ldr	r2, [r2, #0]
 808337e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8083382:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8083386:	6058      	str	r0, [r3, #4]
}
 8083388:	4770      	bx	lr
 808338a:	bf00      	nop

0808338c <BSP_LCD_SetFont>:
	DrawProp[ActiveLayer].pFont = fonts;
 808338c:	f24b 6270 	movw	r2, #46704	; 0xb670
 8083390:	f24b 6374 	movw	r3, #46708	; 0xb674
 8083394:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8083398:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808339c:	6812      	ldr	r2, [r2, #0]
 808339e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80833a2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80833a6:	6098      	str	r0, [r3, #8]
}
 80833a8:	4770      	bx	lr
 80833aa:	bf00      	nop

080833ac <BSP_LCD_GetFont>:
	return DrawProp[ActiveLayer].pFont;
 80833ac:	f24b 6270 	movw	r2, #46704	; 0xb670
 80833b0:	f24b 6374 	movw	r3, #46708	; 0xb674
 80833b4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80833b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80833bc:	6812      	ldr	r2, [r2, #0]
 80833be:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80833c2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
}
 80833c6:	6898      	ldr	r0, [r3, #8]
 80833c8:	4770      	bx	lr
 80833ca:	bf00      	nop

080833cc <BSP_LCD_Clear>:
	LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 80833cc:	f24b 6270 	movw	r2, #46704	; 0xb670
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
 80833d0:	f24d 7304 	movw	r3, #55044	; 0xd704
 80833d4:	2134      	movs	r1, #52	; 0x34
	LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 80833d6:	f2c2 0200 	movt	r2, #8192	; 0x2000
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
 80833da:	f2c2 0302 	movt	r3, #8194	; 0x2002
{ 
 80833de:	b510      	push	{r4, lr}
 80833e0:	b082      	sub	sp, #8
	LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 80833e2:	2400      	movs	r4, #0
 80833e4:	9001      	str	r0, [sp, #4]
 80833e6:	6810      	ldr	r0, [r2, #0]
 80833e8:	9400      	str	r4, [sp, #0]
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
 80833ea:	fb01 3100 	mla	r1, r1, r0, r3
	LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 80833ee:	e9d1 2318 	ldrd	r2, r3, [r1, #96]	; 0x60
 80833f2:	6dc9      	ldr	r1, [r1, #92]	; 0x5c
 80833f4:	f7ff fed6 	bl	80831a4 <LL_FillBuffer>
}
 80833f8:	b002      	add	sp, #8
 80833fa:	bd10      	pop	{r4, pc}

080833fc <BSP_LCD_ResetScreen>:
void BSP_LCD_ResetScreen(void) {
 80833fc:	b510      	push	{r4, lr}
	ActiveLayer = LayerIndex;
 80833fe:	f24b 6470 	movw	r4, #46704	; 0xb670
 8083402:	2300      	movs	r3, #0
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 8083404:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	ActiveLayer = LayerIndex;
 8083408:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808340c:	6023      	str	r3, [r4, #0]
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 808340e:	f7ff ffdd 	bl	80833cc <BSP_LCD_Clear>
	ActiveLayer = LayerIndex;
 8083412:	2301      	movs	r3, #1
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 8083414:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	ActiveLayer = LayerIndex;
 8083418:	6023      	str	r3, [r4, #0]
}
 808341a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 808341e:	f7ff bfd5 	b.w	80833cc <BSP_LCD_Clear>
 8083422:	bf00      	nop

08083424 <BSP_LCD_DrawHLine>:
{
 8083424:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083426:	f24b 6670 	movw	r6, #46704	; 0xb670
 808342a:	f24d 7504 	movw	r5, #55044	; 0xd704
 808342e:	1887      	adds	r7, r0, r2
 8083430:	2434      	movs	r4, #52	; 0x34
 8083432:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8083436:	f2c2 0502 	movt	r5, #8194	; 0x2002
{
 808343a:	b083      	sub	sp, #12
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, Length+1, 1, 0, DrawProp[ActiveLayer].TextColor);
 808343c:	3201      	adds	r2, #1
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 808343e:	6830      	ldr	r0, [r6, #0]
 8083440:	fb04 5400 	mla	r4, r4, r0, r5
 8083444:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8083446:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8083448:	fb03 f101 	mul.w	r1, r3, r1
 808344c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 808344e:	2d02      	cmp	r5, #2
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, Length+1, 1, 0, DrawProp[ActiveLayer].TextColor);
 8083450:	f24b 6474 	movw	r4, #46708	; 0xb674
 8083454:	f5c1 31ff 	rsb	r1, r1, #130560	; 0x1fe00
 8083458:	f04f 0500 	mov.w	r5, #0
 808345c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8083460:	eba1 0107 	sub.w	r1, r1, r7
		x_address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 2 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - (Xpos+Length) - (BSP_LCD_GetXSize() * Ypos));
 8083464:	bf0c      	ite	eq
 8083466:	eb03 0141 	addeq.w	r1, r3, r1, lsl #1
		x_address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - (Xpos+Length) - (BSP_LCD_GetXSize() * Ypos));
 808346a:	eb03 0181 	addne.w	r1, r3, r1, lsl #2
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, Length+1, 1, 0, DrawProp[ActiveLayer].TextColor);
 808346e:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 8083472:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 8083476:	2301      	movs	r3, #1
 8083478:	e9cd 5400 	strd	r5, r4, [sp]
 808347c:	f7ff fe92 	bl	80831a4 <LL_FillBuffer>
}
 8083480:	b003      	add	sp, #12
 8083482:	bdf0      	pop	{r4, r5, r6, r7, pc}

08083484 <BSP_LCD_DrawVLine>:
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083484:	f24b 6370 	movw	r3, #46704	; 0xb670
 8083488:	4411      	add	r1, r2
{
 808348a:	b570      	push	{r4, r5, r6, lr}
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 808348c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8083490:	f24d 7504 	movw	r5, #55044	; 0xd704
 8083494:	f5c0 36ff 	rsb	r6, r0, #130560	; 0x1fe00
 8083498:	2434      	movs	r4, #52	; 0x34
 808349a:	6818      	ldr	r0, [r3, #0]
 808349c:	f2c2 0502 	movt	r5, #8194	; 0x2002
{
 80834a0:	b082      	sub	sp, #8
 80834a2:	fb04 5400 	mla	r4, r4, r0, r5
 80834a6:	6e25      	ldr	r5, [r4, #96]	; 0x60
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 80834a8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80834aa:	fb05 6611 	mls	r6, r5, r1, r6
 80834ae:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80834b0:	2b02      	cmp	r3, #2
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, 1, Length+1, (BSP_LCD_GetXSize() - 1), DrawProp[ActiveLayer].TextColor);
 80834b2:	f24b 6474 	movw	r4, #46708	; 0xb674
 80834b6:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
 80834ba:	f102 0301 	add.w	r3, r2, #1
		x_address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 2 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - Xpos - (BSP_LCD_GetXSize() * (Ypos+Length)));
 80834be:	bf08      	it	eq
 80834c0:	eb01 0146 	addeq.w	r1, r1, r6, lsl #1
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, 1, Length+1, (BSP_LCD_GetXSize() - 1), DrawProp[ActiveLayer].TextColor);
 80834c4:	f2c2 0400 	movt	r4, #8192	; 0x2000
		x_address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - Xpos - (BSP_LCD_GetXSize() * (Ypos+Length)));
 80834c8:	bf18      	it	ne
 80834ca:	eb01 0186 	addne.w	r1, r1, r6, lsl #2
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, 1, Length+1, (BSP_LCD_GetXSize() - 1), DrawProp[ActiveLayer].TextColor);
 80834ce:	9500      	str	r5, [sp, #0]
 80834d0:	eb00 0640 	add.w	r6, r0, r0, lsl #1
 80834d4:	2201      	movs	r2, #1
 80834d6:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
 80834da:	9401      	str	r4, [sp, #4]
 80834dc:	f7ff fe62 	bl	80831a4 <LL_FillBuffer>
}
 80834e0:	b002      	add	sp, #8
 80834e2:	bd70      	pop	{r4, r5, r6, pc}

080834e4 <BSP_LCD_DrawRect>:
{
 80834e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80834e6:	461e      	mov	r6, r3
 80834e8:	460d      	mov	r5, r1
 80834ea:	4604      	mov	r4, r0
 80834ec:	4617      	mov	r7, r2
	BSP_LCD_DrawHLine(Xpos, Ypos, Width);
 80834ee:	f7ff ff99 	bl	8083424 <BSP_LCD_DrawHLine>
	BSP_LCD_DrawHLine(Xpos, (Ypos+ Height), Width);
 80834f2:	19a9      	adds	r1, r5, r6
 80834f4:	463a      	mov	r2, r7
 80834f6:	4620      	mov	r0, r4
 80834f8:	b289      	uxth	r1, r1
 80834fa:	f7ff ff93 	bl	8083424 <BSP_LCD_DrawHLine>
	BSP_LCD_DrawVLine(Xpos, Ypos, Height);
 80834fe:	4632      	mov	r2, r6
 8083500:	4629      	mov	r1, r5
 8083502:	4620      	mov	r0, r4
 8083504:	f7ff ffbe 	bl	8083484 <BSP_LCD_DrawVLine>
	BSP_LCD_DrawVLine((Xpos + Width), Ypos, Height);
 8083508:	19e0      	adds	r0, r4, r7
 808350a:	4632      	mov	r2, r6
 808350c:	4629      	mov	r1, r5
 808350e:	b280      	uxth	r0, r0
}
 8083510:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	BSP_LCD_DrawVLine((Xpos + Width), Ypos, Height);
 8083514:	f7ff bfb6 	b.w	8083484 <BSP_LCD_DrawVLine>

08083518 <BSP_LCD_DrawPixel>:
{
 8083518:	b470      	push	{r4, r5, r6}
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 808351a:	f24b 6570 	movw	r5, #46704	; 0xb670
 808351e:	f24d 7304 	movw	r3, #55044	; 0xd704
 8083522:	2634      	movs	r6, #52	; 0x34
		*(__IO uint16_t*) (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + 2 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - Xpos - BSP_LCD_GetXSize() * Ypos)) = (uint16_t)RGB_Code;
 8083524:	b292      	uxth	r2, r2
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083526:	f2c2 0500 	movt	r5, #8192	; 0x2000
 808352a:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808352e:	682c      	ldr	r4, [r5, #0]
 8083530:	fb06 3404 	mla	r4, r6, r4, r3
 8083534:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8083536:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8083538:	fb03 0101 	mla	r1, r3, r1, r0
 808353c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 808353e:	2d02      	cmp	r5, #2
 8083540:	f5c1 31ff 	rsb	r1, r1, #130560	; 0x1fe00
 8083544:	d003      	beq.n	808354e <BSP_LCD_DrawPixel+0x36>
		*(__IO uint32_t*) (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + 4 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - Xpos - BSP_LCD_GetXSize() * Ypos)) = (uint16_t)RGB_Code;
 8083546:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
}
 808354a:	bc70      	pop	{r4, r5, r6}
 808354c:	4770      	bx	lr
		*(__IO uint16_t*) (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + 2 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - Xpos - BSP_LCD_GetXSize() * Ypos)) = (uint16_t)RGB_Code;
 808354e:	f823 2011 	strh.w	r2, [r3, r1, lsl #1]
}
 8083552:	bc70      	pop	{r4, r5, r6}
 8083554:	4770      	bx	lr
 8083556:	bf00      	nop

08083558 <BSP_LCD_DisplayChar>:
	DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
 8083558:	f24b 6370 	movw	r3, #46704	; 0xb670
 808355c:	3a20      	subs	r2, #32
 808355e:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
 8083562:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
 8083566:	681b      	ldr	r3, [r3, #0]
 8083568:	f24b 6874 	movw	r8, #46708	; 0xb674
{
 808356c:	b087      	sub	sp, #28
	DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
 808356e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8083572:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8083576:	eb08 0883 	add.w	r8, r8, r3, lsl #2
 808357a:	f8d8 4008 	ldr.w	r4, [r8, #8]
															 DrawProp[ActiveLayer].pFont->Height * ((DrawProp[ActiveLayer].pFont->Width + 7) / 8)]);
 808357e:	88a7      	ldrh	r7, [r4, #4]
 8083580:	88e5      	ldrh	r5, [r4, #6]
 8083582:	1dfb      	adds	r3, r7, #7
	DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
 8083584:	6824      	ldr	r4, [r4, #0]
 8083586:	fb05 f202 	mul.w	r2, r5, r2
															 DrawProp[ActiveLayer].pFont->Height * ((DrawProp[ActiveLayer].pFont->Width + 7) / 8)]);
 808358a:	10de      	asrs	r6, r3, #3
 808358c:	9503      	str	r5, [sp, #12]
	offset =  8 *((width + 7)/8) -  width ;
 808358e:	ebc7 03c6 	rsb	r3, r7, r6, lsl #3
															 DrawProp[ActiveLayer].pFont->Height * ((DrawProp[ActiveLayer].pFont->Width + 7) / 8)]);
 8083592:	9602      	str	r6, [sp, #8]
 8083594:	fb06 f202 	mul.w	r2, r6, r2
	offset =  8 *((width + 7)/8) -  width ;
 8083598:	b2db      	uxtb	r3, r3
 808359a:	9305      	str	r3, [sp, #20]
	for(i = 0; i < height; i++)
 808359c:	2d00      	cmp	r5, #0
 808359e:	d03f      	beq.n	8083620 <BSP_LCD_DisplayChar+0xc8>
 80835a0:	18a3      	adds	r3, r4, r2
 80835a2:	4681      	mov	r9, r0
 80835a4:	f04f 0b00 	mov.w	fp, #0
 80835a8:	9104      	str	r1, [sp, #16]
 80835aa:	9301      	str	r3, [sp, #4]
 80835ac:	9b04      	ldr	r3, [sp, #16]
 80835ae:	eb03 040b 	add.w	r4, r3, fp
 80835b2:	9b01      	ldr	r3, [sp, #4]
 80835b4:	781d      	ldrb	r5, [r3, #0]
 80835b6:	b2a4      	uxth	r4, r4
		switch(((width + 7)/8))
 80835b8:	9b02      	ldr	r3, [sp, #8]
 80835ba:	2b01      	cmp	r3, #1
 80835bc:	d005      	beq.n	80835ca <BSP_LCD_DisplayChar+0x72>
 80835be:	2b02      	cmp	r3, #2
 80835c0:	d131      	bne.n	8083626 <BSP_LCD_DisplayChar+0xce>
			line =  (pchar[0]<< 8) | pchar[1];
 80835c2:	9b01      	ldr	r3, [sp, #4]
 80835c4:	881d      	ldrh	r5, [r3, #0]
 80835c6:	ba6d      	rev16	r5, r5
 80835c8:	b2ad      	uxth	r5, r5
		for (j = 0; j < width; j++)
 80835ca:	b307      	cbz	r7, 808360e <BSP_LCD_DisplayChar+0xb6>
 80835cc:	1e7e      	subs	r6, r7, #1
 80835ce:	9b05      	ldr	r3, [sp, #20]
 80835d0:	f04f 0a00 	mov.w	sl, #0
 80835d4:	441e      	add	r6, r3
 80835d6:	e007      	b.n	80835e8 <BSP_LCD_DisplayChar+0x90>
 80835d8:	f10a 0a01 	add.w	sl, sl, #1
				BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].TextColor);
 80835dc:	f8d8 2000 	ldr.w	r2, [r8]
 80835e0:	f7ff ff9a 	bl	8083518 <BSP_LCD_DrawPixel>
		for (j = 0; j < width; j++)
 80835e4:	45ba      	cmp	sl, r7
 80835e6:	d012      	beq.n	808360e <BSP_LCD_DisplayChar+0xb6>
			if(line & (1 << (width- j + offset- 1)))
 80835e8:	eba6 000a 	sub.w	r0, r6, sl
 80835ec:	2201      	movs	r2, #1
 80835ee:	eb09 030a 	add.w	r3, r9, sl
				BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].TextColor);
 80835f2:	4621      	mov	r1, r4
			if(line & (1 << (width- j + offset- 1)))
 80835f4:	4082      	lsls	r2, r0
 80835f6:	b29b      	uxth	r3, r3
 80835f8:	422a      	tst	r2, r5
				BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].TextColor);
 80835fa:	4618      	mov	r0, r3
			if(line & (1 << (width- j + offset- 1)))
 80835fc:	d1ec      	bne.n	80835d8 <BSP_LCD_DisplayChar+0x80>
		for (j = 0; j < width; j++)
 80835fe:	f10a 0a01 	add.w	sl, sl, #1
				BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].BackColor);
 8083602:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8083606:	f7ff ff87 	bl	8083518 <BSP_LCD_DrawPixel>
		for (j = 0; j < width; j++)
 808360a:	45ba      	cmp	sl, r7
 808360c:	d1ec      	bne.n	80835e8 <BSP_LCD_DisplayChar+0x90>
	for(i = 0; i < height; i++)
 808360e:	f10b 0b01 	add.w	fp, fp, #1
 8083612:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8083616:	4413      	add	r3, r2
 8083618:	9301      	str	r3, [sp, #4]
 808361a:	9b03      	ldr	r3, [sp, #12]
 808361c:	455b      	cmp	r3, fp
 808361e:	d1c5      	bne.n	80835ac <BSP_LCD_DisplayChar+0x54>
}
 8083620:	b007      	add	sp, #28
 8083622:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
 8083626:	9b01      	ldr	r3, [sp, #4]
 8083628:	042d      	lsls	r5, r5, #16
 808362a:	785a      	ldrb	r2, [r3, #1]
 808362c:	789b      	ldrb	r3, [r3, #2]
 808362e:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 8083632:	431d      	orrs	r5, r3
 8083634:	e7c9      	b.n	80835ca <BSP_LCD_DisplayChar+0x72>
 8083636:	bf00      	nop

08083638 <BSP_LCD_DisplayStringAt>:
{
 8083638:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 808363c:	4616      	mov	r6, r2
	while (*ptr++) size ++ ;
 808363e:	7812      	ldrb	r2, [r2, #0]
{
 8083640:	4604      	mov	r4, r0
 8083642:	4688      	mov	r8, r1
	while (*ptr++) size ++ ;
 8083644:	2a00      	cmp	r2, #0
 8083646:	d055      	beq.n	80836f4 <BSP_LCD_DisplayStringAt+0xbc>
 8083648:	1c71      	adds	r1, r6, #1
 808364a:	1b8d      	subs	r5, r1, r6
 808364c:	f811 0b01 	ldrb.w	r0, [r1], #1
 8083650:	2800      	cmp	r0, #0
 8083652:	d1fa      	bne.n	808364a <BSP_LCD_DisplayStringAt+0x12>
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083654:	f24b 6c70 	movw	ip, #46704	; 0xb670
	xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 8083658:	f24b 6174 	movw	r1, #46708	; 0xb674
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 808365c:	f24d 7004 	movw	r0, #55044	; 0xd704
 8083660:	2734      	movs	r7, #52	; 0x34
 8083662:	f2c2 0c00 	movt	ip, #8192	; 0x2000
	xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 8083666:	f2c2 0100 	movt	r1, #8192	; 0x2000
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 808366a:	f2c2 0002 	movt	r0, #8194	; 0x2002
	switch (Mode)
 808366e:	2b01      	cmp	r3, #1
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083670:	f8dc 9000 	ldr.w	r9, [ip]
	xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 8083674:	eb09 0c49 	add.w	ip, r9, r9, lsl #1
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083678:	fb07 0709 	mla	r7, r7, r9, r0
	xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 808367c:	eb01 018c 	add.w	r1, r1, ip, lsl #2
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083680:	f8d7 c060 	ldr.w	ip, [r7, #96]	; 0x60
	xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
 8083684:	688f      	ldr	r7, [r1, #8]
 8083686:	f8b7 e004 	ldrh.w	lr, [r7, #4]
 808368a:	fbbc f1fe 	udiv	r1, ip, lr
	switch (Mode)
 808368e:	d02a      	beq.n	80836e6 <BSP_LCD_DisplayStringAt+0xae>
 8083690:	2b02      	cmp	r3, #2
 8083692:	d022      	beq.n	80836da <BSP_LCD_DisplayStringAt+0xa2>
	if ((ref_column < 1) || (ref_column >= 0x8000))
 8083694:	b223      	sxth	r3, r4
	while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 8083696:	fa1f fc8c 	uxth.w	ip, ip
		ref_column = 1;
 808369a:	2b00      	cmp	r3, #0
 808369c:	bfd8      	it	le
 808369e:	2401      	movle	r4, #1
	while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 80836a0:	45e6      	cmp	lr, ip
 80836a2:	d818      	bhi.n	80836d6 <BSP_LCD_DisplayStringAt+0x9e>
 80836a4:	b1ba      	cbz	r2, 80836d6 <BSP_LCD_DisplayStringAt+0x9e>
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 80836a6:	2334      	movs	r3, #52	; 0x34
	while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 80836a8:	4635      	mov	r5, r6
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 80836aa:	fb03 0909 	mla	r9, r3, r9, r0
		BSP_LCD_DisplayChar(ref_column, Ypos, *Text);
 80836ae:	4620      	mov	r0, r4
 80836b0:	4641      	mov	r1, r8
 80836b2:	f7ff ff51 	bl	8083558 <BSP_LCD_DisplayChar>
	while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 80836b6:	f815 2f01 	ldrb.w	r2, [r5, #1]!
		ref_column += DrawProp[ActiveLayer].pFont->Width;
 80836ba:	88b8      	ldrh	r0, [r7, #4]
	while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 80836bc:	1bab      	subs	r3, r5, r6
 80836be:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
		ref_column += DrawProp[ActiveLayer].pFont->Width;
 80836c2:	4404      	add	r4, r0
	while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 80836c4:	b29b      	uxth	r3, r3
		ref_column += DrawProp[ActiveLayer].pFont->Width;
 80836c6:	b2a4      	uxth	r4, r4
	while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
 80836c8:	fb00 1313 	mls	r3, r0, r3, r1
 80836cc:	b29b      	uxth	r3, r3
 80836ce:	4283      	cmp	r3, r0
 80836d0:	d301      	bcc.n	80836d6 <BSP_LCD_DisplayStringAt+0x9e>
 80836d2:	2a00      	cmp	r2, #0
 80836d4:	d1eb      	bne.n	80836ae <BSP_LCD_DisplayStringAt+0x76>
}
 80836d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		ref_column = - Xpos + ((xsize - size)*DrawProp[ActiveLayer].pFont->Width);
 80836da:	1b49      	subs	r1, r1, r5
 80836dc:	fb11 f10e 	smulbb	r1, r1, lr
 80836e0:	1b0c      	subs	r4, r1, r4
 80836e2:	b2a4      	uxth	r4, r4
		break;
 80836e4:	e7d6      	b.n	8083694 <BSP_LCD_DisplayStringAt+0x5c>
		ref_column = Xpos + ((xsize - size)* DrawProp[ActiveLayer].pFont->Width) / 2;
 80836e6:	1b49      	subs	r1, r1, r5
 80836e8:	fb0e f101 	mul.w	r1, lr, r1
 80836ec:	eb04 0451 	add.w	r4, r4, r1, lsr #1
 80836f0:	b2a4      	uxth	r4, r4
		break;
 80836f2:	e7cf      	b.n	8083694 <BSP_LCD_DisplayStringAt+0x5c>
	uint32_t size = 0, xsize = 0;
 80836f4:	4615      	mov	r5, r2
 80836f6:	e7ad      	b.n	8083654 <BSP_LCD_DisplayStringAt+0x1c>

080836f8 <BSP_LCD_DisplayStringAtLine>:
{  
 80836f8:	b430      	push	{r4, r5}
	return DrawProp[ActiveLayer].pFont;
 80836fa:	f24b 6570 	movw	r5, #46704	; 0xb670
 80836fe:	f24b 6474 	movw	r4, #46708	; 0xb674
	BSP_LCD_DisplayStringAt(0, LINE(Line), ptr, LEFT_MODE);
 8083702:	460a      	mov	r2, r1
 8083704:	2303      	movs	r3, #3
	return DrawProp[ActiveLayer].pFont;
 8083706:	f2c2 0500 	movt	r5, #8192	; 0x2000
 808370a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808370e:	6829      	ldr	r1, [r5, #0]
 8083710:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8083714:	eb04 0481 	add.w	r4, r4, r1, lsl #2
	BSP_LCD_DisplayStringAt(0, LINE(Line), ptr, LEFT_MODE);
 8083718:	68a1      	ldr	r1, [r4, #8]
 808371a:	88c9      	ldrh	r1, [r1, #6]
 808371c:	fb11 f100 	smulbb	r1, r1, r0
 8083720:	2000      	movs	r0, #0
 8083722:	b289      	uxth	r1, r1
}
 8083724:	bc30      	pop	{r4, r5}
	BSP_LCD_DisplayStringAt(0, LINE(Line), ptr, LEFT_MODE);
 8083726:	f7ff bf87 	b.w	8083638 <BSP_LCD_DisplayStringAt>
 808372a:	bf00      	nop

0808372c <BSP_LCD_DrawLine>:
{
 808372c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 8083730:	1a17      	subs	r7, r2, r0
	deltay = ABS(y2 - y1);        /* The difference between the y's */
 8083732:	eba3 0801 	sub.w	r8, r3, r1
		xinc1 = 1;
 8083736:	4282      	cmp	r2, r0
 8083738:	bf34      	ite	cc
 808373a:	f04f 39ff 	movcc.w	r9, #4294967295	; 0xffffffff
 808373e:	f04f 0901 	movcs.w	r9, #1
		yinc1 = 1;
 8083742:	428b      	cmp	r3, r1
 8083744:	bf34      	ite	cc
 8083746:	f04f 3aff 	movcc.w	sl, #4294967295	; 0xffffffff
 808374a:	f04f 0a01 	movcs.w	sl, #1
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 808374e:	2f00      	cmp	r7, #0
{
 8083750:	b085      	sub	sp, #20
	x = x1;                       /* Start x off at the first pixel */
 8083752:	b206      	sxth	r6, r0
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 8083754:	bfb8      	it	lt
 8083756:	427f      	neglt	r7, r7
	deltay = ABS(y2 - y1);        /* The difference between the y's */
 8083758:	f1b8 0f00 	cmp.w	r8, #0
	y = y1;                       /* Start y off at the first pixel */
 808375c:	b20d      	sxth	r5, r1
	deltay = ABS(y2 - y1);        /* The difference between the y's */
 808375e:	bfb8      	it	lt
 8083760:	f1c8 0800 	rsblt	r8, r8, #0
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 8083764:	b23f      	sxth	r7, r7
	deltay = ABS(y2 - y1);        /* The difference between the y's */
 8083766:	fa0f f888 	sxth.w	r8, r8
	if (deltax >= deltay)         /* There is at least one x-value for every y-value */
 808376a:	4547      	cmp	r7, r8
 808376c:	db45      	blt.n	80837fa <BSP_LCD_DrawLine+0xce>
		num = deltax / 2;
 808376e:	2f00      	cmp	r7, #0
 8083770:	463c      	mov	r4, r7
 8083772:	46cb      	mov	fp, r9
		yinc2 = 0;                  /* Don't change the y for every iteration */
 8083774:	f04f 0900 	mov.w	r9, #0
		num = deltax / 2;
 8083778:	bfb8      	it	lt
 808377a:	1c7c      	addlt	r4, r7, #1
		xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
 808377c:	4648      	mov	r0, r9
		num = deltax / 2;
 808377e:	1064      	asrs	r4, r4, #1
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 8083780:	2f00      	cmp	r7, #0
 8083782:	db37      	blt.n	80837f4 <BSP_LCD_DrawLine+0xc8>
 8083784:	f24b 6270 	movw	r2, #46704	; 0xb670
 8083788:	fa1f f388 	uxth.w	r3, r8
 808378c:	f24b 6174 	movw	r1, #46708	; 0xb674
 8083790:	f04f 0800 	mov.w	r8, #0
 8083794:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8083798:	9302      	str	r3, [sp, #8]
 808379a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 808379e:	b283      	uxth	r3, r0
 80837a0:	6812      	ldr	r2, [r2, #0]
 80837a2:	fa1f fb8b 	uxth.w	fp, fp
 80837a6:	9303      	str	r3, [sp, #12]
 80837a8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80837ac:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
 80837b0:	9301      	str	r3, [sp, #4]
		BSP_LCD_DrawPixel(x, y, DrawProp[ActiveLayer].TextColor);   /* Draw the current pixel */
 80837b2:	b2b6      	uxth	r6, r6
 80837b4:	9a01      	ldr	r2, [sp, #4]
 80837b6:	b2ad      	uxth	r5, r5
 80837b8:	f108 0801 	add.w	r8, r8, #1
 80837bc:	4630      	mov	r0, r6
 80837be:	4629      	mov	r1, r5
 80837c0:	f7ff feaa 	bl	8083518 <BSP_LCD_DrawPixel>
		num += num_add;                            /* Increase the numerator by the top of the fraction */
 80837c4:	9b02      	ldr	r3, [sp, #8]
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 80837c6:	fa0f f288 	sxth.w	r2, r8
			x += xinc1;                             /* Change the x as appropriate */
 80837ca:	eb06 0009 	add.w	r0, r6, r9
		num += num_add;                            /* Increase the numerator by the top of the fraction */
 80837ce:	441c      	add	r4, r3
			y += yinc1;                             /* Change the y as appropriate */
 80837d0:	eb05 0c0a 	add.w	ip, r5, sl
		num += num_add;                            /* Increase the numerator by the top of the fraction */
 80837d4:	b2a1      	uxth	r1, r4
 80837d6:	b20c      	sxth	r4, r1
			num -= den;                             /* Calculate the new numerator value */
 80837d8:	1bc9      	subs	r1, r1, r7
		if (num >= den)                           /* Check if numerator >= denominator */
 80837da:	42a7      	cmp	r7, r4
 80837dc:	dc03      	bgt.n	80837e6 <BSP_LCD_DrawLine+0xba>
			num -= den;                             /* Calculate the new numerator value */
 80837de:	b20c      	sxth	r4, r1
			x += xinc1;                             /* Change the x as appropriate */
 80837e0:	b286      	uxth	r6, r0
			y += yinc1;                             /* Change the y as appropriate */
 80837e2:	fa1f f58c 	uxth.w	r5, ip
		y += yinc2;                               /* Change the y as appropriate */
 80837e6:	9b03      	ldr	r3, [sp, #12]
		x += xinc2;                               /* Change the x as appropriate */
 80837e8:	445e      	add	r6, fp
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 80837ea:	4297      	cmp	r7, r2
		y += yinc2;                               /* Change the y as appropriate */
 80837ec:	441d      	add	r5, r3
		x += xinc2;                               /* Change the x as appropriate */
 80837ee:	b236      	sxth	r6, r6
		y += yinc2;                               /* Change the y as appropriate */
 80837f0:	b22d      	sxth	r5, r5
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 80837f2:	dade      	bge.n	80837b2 <BSP_LCD_DrawLine+0x86>
}
 80837f4:	b005      	add	sp, #20
 80837f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		num = deltay / 2;
 80837fa:	f1b8 0f00 	cmp.w	r8, #0
 80837fe:	4644      	mov	r4, r8
 8083800:	463b      	mov	r3, r7
 8083802:	4650      	mov	r0, sl
 8083804:	bfb8      	it	lt
 8083806:	f108 0401 	addlt.w	r4, r8, #1
		yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
 808380a:	f04f 0a00 	mov.w	sl, #0
		num = deltay / 2;
 808380e:	4647      	mov	r7, r8
 8083810:	4698      	mov	r8, r3
 8083812:	f344 044f 	sbfx	r4, r4, #1, #16
		xinc2 = 0;                  /* Don't change the x for every iteration */
 8083816:	46d3      	mov	fp, sl
 8083818:	e7b2      	b.n	8083780 <BSP_LCD_DrawLine+0x54>
 808381a:	bf00      	nop

0808381c <BSP_LCD_DrawPolygon>:
	if(PointCount < 2)
 808381c:	2901      	cmp	r1, #1
 808381e:	d924      	bls.n	808386a <BSP_LCD_DrawPolygon+0x4e>
{
 8083820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BSP_LCD_DrawLine(Points->X, Points->Y, (Points+PointCount-1)->X, (Points+PointCount-1)->Y);
 8083822:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8083826:	460d      	mov	r5, r1
 8083828:	4606      	mov	r6, r0
 808382a:	4604      	mov	r4, r0
 808382c:	f6c3 73ff 	movt	r3, #16383	; 0x3fff
 8083830:	8841      	ldrh	r1, [r0, #2]
 8083832:	f834 0b04 	ldrh.w	r0, [r4], #4
 8083836:	442b      	add	r3, r5
 8083838:	3d02      	subs	r5, #2
 808383a:	f836 2023 	ldrh.w	r2, [r6, r3, lsl #2]
 808383e:	eb06 0783 	add.w	r7, r6, r3, lsl #2
 8083842:	b2ad      	uxth	r5, r5
 8083844:	3608      	adds	r6, #8
 8083846:	887b      	ldrh	r3, [r7, #2]
 8083848:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 808384c:	f7ff ff6e 	bl	808372c <BSP_LCD_DrawLine>
		BSP_LCD_DrawLine(x, y, Points->X, Points->Y);
 8083850:	8863      	ldrh	r3, [r4, #2]
 8083852:	3404      	adds	r4, #4
 8083854:	f834 2c04 	ldrh.w	r2, [r4, #-4]
 8083858:	f834 1c06 	ldrh.w	r1, [r4, #-6]
 808385c:	f834 0c08 	ldrh.w	r0, [r4, #-8]
 8083860:	f7ff ff64 	bl	808372c <BSP_LCD_DrawLine>
	while(--PointCount)
 8083864:	42ac      	cmp	r4, r5
 8083866:	d1f3      	bne.n	8083850 <BSP_LCD_DrawPolygon+0x34>
}
 8083868:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808386a:	4770      	bx	lr

0808386c <FillTriangle>:
{ 
 808386c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8083870:	b085      	sub	sp, #20
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 8083872:	1a0f      	subs	r7, r1, r0
		xinc1 = 1;
 8083874:	4281      	cmp	r1, r0
 8083876:	bf34      	ite	cc
 8083878:	f04f 39ff 	movcc.w	r9, #4294967295	; 0xffffffff
 808387c:	f04f 0901 	movcs.w	r9, #1
	x = x1;                       /* Start x off at the first pixel */
 8083880:	b205      	sxth	r5, r0
{ 
 8083882:	f8bd a038 	ldrh.w	sl, [sp, #56]	; 0x38
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 8083886:	2f00      	cmp	r7, #0
{ 
 8083888:	f8bd b03c 	ldrh.w	fp, [sp, #60]	; 0x3c
	y = y1;                       /* Start y off at the first pixel */
 808388c:	b21e      	sxth	r6, r3
	deltay = ABS(y2 - y1);        /* The difference between the y's */
 808388e:	ebaa 0403 	sub.w	r4, sl, r3
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 8083892:	bfb8      	it	lt
 8083894:	427f      	neglt	r7, r7
		yinc1 = 1;
 8083896:	459a      	cmp	sl, r3
 8083898:	bf34      	ite	cc
 808389a:	f04f 3aff 	movcc.w	sl, #4294967295	; 0xffffffff
 808389e:	f04f 0a01 	movcs.w	sl, #1
	deltay = ABS(y2 - y1);        /* The difference between the y's */
 80838a2:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
	deltax = ABS(x2 - x1);        /* The difference between the x's */
 80838a6:	b23f      	sxth	r7, r7
	deltay = ABS(y2 - y1);        /* The difference between the y's */
 80838a8:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
 80838ac:	b209      	sxth	r1, r1
	if (deltax >= deltay)         /* There is at least one x-value for every y-value */
 80838ae:	428f      	cmp	r7, r1
 80838b0:	db38      	blt.n	8083924 <FillTriangle+0xb8>
		num = deltax / 2;
 80838b2:	2f00      	cmp	r7, #0
 80838b4:	463c      	mov	r4, r7
 80838b6:	4648      	mov	r0, r9
		yinc2 = 0;                  /* Don't change the y for every iteration */
 80838b8:	f04f 0900 	mov.w	r9, #0
		num = deltax / 2;
 80838bc:	bfb8      	it	lt
 80838be:	1c7c      	addlt	r4, r7, #1
		xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
 80838c0:	464b      	mov	r3, r9
		num = deltax / 2;
 80838c2:	1064      	asrs	r4, r4, #1
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 80838c4:	2f00      	cmp	r7, #0
 80838c6:	db2a      	blt.n	808391e <FillTriangle+0xb2>
 80838c8:	9203      	str	r2, [sp, #12]
 80838ca:	b28a      	uxth	r2, r1
 80838cc:	b29b      	uxth	r3, r3
 80838ce:	f04f 0800 	mov.w	r8, #0
 80838d2:	9200      	str	r2, [sp, #0]
 80838d4:	b282      	uxth	r2, r0
 80838d6:	9302      	str	r3, [sp, #8]
 80838d8:	9201      	str	r2, [sp, #4]
		BSP_LCD_DrawLine(x, y, x3, y3);
 80838da:	b2ad      	uxth	r5, r5
 80838dc:	465b      	mov	r3, fp
 80838de:	b2b6      	uxth	r6, r6
 80838e0:	9a03      	ldr	r2, [sp, #12]
 80838e2:	4628      	mov	r0, r5
 80838e4:	f108 0801 	add.w	r8, r8, #1
 80838e8:	4631      	mov	r1, r6
 80838ea:	f7ff ff1f 	bl	808372c <BSP_LCD_DrawLine>
		num += num_add;              /* Increase the numerator by the top of the fraction */
 80838ee:	9b00      	ldr	r3, [sp, #0]
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 80838f0:	fa0f f288 	sxth.w	r2, r8
			x += xinc1;               /* Change the x as appropriate */
 80838f4:	eb05 0009 	add.w	r0, r5, r9
		num += num_add;              /* Increase the numerator by the top of the fraction */
 80838f8:	441c      	add	r4, r3
			y += yinc1;               /* Change the y as appropriate */
 80838fa:	eb06 010a 	add.w	r1, r6, sl
		num += num_add;              /* Increase the numerator by the top of the fraction */
 80838fe:	b2a3      	uxth	r3, r4
 8083900:	b21c      	sxth	r4, r3
			num -= den;               /* Calculate the new numerator value */
 8083902:	1bdb      	subs	r3, r3, r7
		if (num >= den)             /* Check if numerator >= denominator */
 8083904:	42a7      	cmp	r7, r4
 8083906:	dc02      	bgt.n	808390e <FillTriangle+0xa2>
			num -= den;               /* Calculate the new numerator value */
 8083908:	b21c      	sxth	r4, r3
			x += xinc1;               /* Change the x as appropriate */
 808390a:	b285      	uxth	r5, r0
			y += yinc1;               /* Change the y as appropriate */
 808390c:	b28e      	uxth	r6, r1
		x += xinc2;                 /* Change the x as appropriate */
 808390e:	9b01      	ldr	r3, [sp, #4]
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 8083910:	4297      	cmp	r7, r2
		x += xinc2;                 /* Change the x as appropriate */
 8083912:	441d      	add	r5, r3
		y += yinc2;                 /* Change the y as appropriate */
 8083914:	9b02      	ldr	r3, [sp, #8]
 8083916:	441e      	add	r6, r3
		x += xinc2;                 /* Change the x as appropriate */
 8083918:	b22d      	sxth	r5, r5
		y += yinc2;                 /* Change the y as appropriate */
 808391a:	b236      	sxth	r6, r6
	for (curpixel = 0; curpixel <= num_pixels; curpixel++)
 808391c:	dadd      	bge.n	80838da <FillTriangle+0x6e>
}
 808391e:	b005      	add	sp, #20
 8083920:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		num = deltay / 2;
 8083924:	2900      	cmp	r1, #0
 8083926:	460c      	mov	r4, r1
 8083928:	4638      	mov	r0, r7
 808392a:	4653      	mov	r3, sl
 808392c:	bfb8      	it	lt
 808392e:	1c4c      	addlt	r4, r1, #1
		yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
 8083930:	f04f 0a00 	mov.w	sl, #0
		num = deltay / 2;
 8083934:	460f      	mov	r7, r1
 8083936:	4601      	mov	r1, r0
 8083938:	f344 044f 	sbfx	r4, r4, #1, #16
		xinc2 = 0;                  /* Don't change the x for every iteration */
 808393c:	4650      	mov	r0, sl
 808393e:	e7c1      	b.n	80838c4 <FillTriangle+0x58>

08083940 <BSP_LCD_DrawCircle>:
{
 8083940:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8083944:	f24b 6570 	movw	r5, #46704	; 0xb670
 8083948:	b085      	sub	sp, #20
 808394a:	f24b 6474 	movw	r4, #46708	; 0xb674
	decision = 3 - (Radius << 1);
 808394e:	0053      	lsls	r3, r2, #1
 8083950:	f2c2 0500 	movt	r5, #8192	; 0x2000
{
 8083954:	9101      	str	r1, [sp, #4]
	decision = 3 - (Radius << 1);
 8083956:	f1c3 0303 	rsb	r3, r3, #3
 808395a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808395e:	6829      	ldr	r1, [r5, #0]
	current_x = 0;
 8083960:	2700      	movs	r7, #0
	decision = 3 - (Radius << 1);
 8083962:	9302      	str	r3, [sp, #8]
	current_y = Radius;
 8083964:	4613      	mov	r3, r2
 8083966:	eb01 0141 	add.w	r1, r1, r1, lsl #1
{
 808396a:	9000      	str	r0, [sp, #0]
 808396c:	f854 6021 	ldr.w	r6, [r4, r1, lsl #2]
 8083970:	e006      	b.n	8083980 <BSP_LCD_DrawCircle+0x40>
			current_y--;
 8083972:	3b01      	subs	r3, #1
		current_x++;
 8083974:	3701      	adds	r7, #1
			decision += ((current_x - current_y) << 2) + 10;
 8083976:	eb02 0281 	add.w	r2, r2, r1, lsl #2
	while (current_x <= current_y)
 808397a:	42bb      	cmp	r3, r7
			decision += ((current_x - current_y) << 2) + 10;
 808397c:	9202      	str	r2, [sp, #8]
	while (current_x <= current_y)
 808397e:	d35d      	bcc.n	8083a3c <BSP_LCD_DrawCircle+0xfc>
		BSP_LCD_DrawPixel((Xpos + current_x), (Ypos - current_y), DrawProp[ActiveLayer].TextColor);
 8083980:	b29d      	uxth	r5, r3
 8083982:	9901      	ldr	r1, [sp, #4]
 8083984:	b2bc      	uxth	r4, r7
 8083986:	9303      	str	r3, [sp, #12]
 8083988:	9b00      	ldr	r3, [sp, #0]
 808398a:	eba1 0805 	sub.w	r8, r1, r5
 808398e:	4632      	mov	r2, r6
 8083990:	eb04 0b03 	add.w	fp, r4, r3
 8083994:	fa1f f888 	uxth.w	r8, r8
 8083998:	fa1f fb8b 	uxth.w	fp, fp
 808399c:	4641      	mov	r1, r8
 808399e:	4658      	mov	r0, fp
 80839a0:	f7ff fdba 	bl	8083518 <BSP_LCD_DrawPixel>
 80839a4:	9a00      	ldr	r2, [sp, #0]
		BSP_LCD_DrawPixel((Xpos - current_x), (Ypos - current_y), DrawProp[ActiveLayer].TextColor);
 80839a6:	4641      	mov	r1, r8
 80839a8:	eba2 0a04 	sub.w	sl, r2, r4
 80839ac:	4632      	mov	r2, r6
 80839ae:	fa1f fa8a 	uxth.w	sl, sl
 80839b2:	4650      	mov	r0, sl
 80839b4:	f7ff fdb0 	bl	8083518 <BSP_LCD_DrawPixel>
 80839b8:	9b01      	ldr	r3, [sp, #4]
		BSP_LCD_DrawPixel((Xpos + current_y), (Ypos - current_x), DrawProp[ActiveLayer].TextColor);
 80839ba:	9900      	ldr	r1, [sp, #0]
 80839bc:	4632      	mov	r2, r6
 80839be:	eba3 0804 	sub.w	r8, r3, r4
 80839c2:	eb05 0901 	add.w	r9, r5, r1
 80839c6:	fa1f f888 	uxth.w	r8, r8
 80839ca:	fa1f f989 	uxth.w	r9, r9
 80839ce:	4641      	mov	r1, r8
 80839d0:	4648      	mov	r0, r9
 80839d2:	f7ff fda1 	bl	8083518 <BSP_LCD_DrawPixel>
		BSP_LCD_DrawPixel((Xpos - current_y), (Ypos - current_x), DrawProp[ActiveLayer].TextColor);
 80839d6:	9900      	ldr	r1, [sp, #0]
 80839d8:	4632      	mov	r2, r6
 80839da:	1b48      	subs	r0, r1, r5
 80839dc:	4641      	mov	r1, r8
 80839de:	fa1f f880 	uxth.w	r8, r0
 80839e2:	4640      	mov	r0, r8
 80839e4:	f7ff fd98 	bl	8083518 <BSP_LCD_DrawPixel>
		BSP_LCD_DrawPixel((Xpos + current_x), (Ypos + current_y), DrawProp[ActiveLayer].TextColor);
 80839e8:	9a01      	ldr	r2, [sp, #4]
 80839ea:	4658      	mov	r0, fp
 80839ec:	4415      	add	r5, r2
 80839ee:	4632      	mov	r2, r6
 80839f0:	b2ad      	uxth	r5, r5
 80839f2:	4629      	mov	r1, r5
 80839f4:	f7ff fd90 	bl	8083518 <BSP_LCD_DrawPixel>
		BSP_LCD_DrawPixel((Xpos - current_x), (Ypos + current_y), DrawProp[ActiveLayer].TextColor);
 80839f8:	4632      	mov	r2, r6
 80839fa:	4629      	mov	r1, r5
 80839fc:	4650      	mov	r0, sl
 80839fe:	f7ff fd8b 	bl	8083518 <BSP_LCD_DrawPixel>
 8083a02:	9a01      	ldr	r2, [sp, #4]
		BSP_LCD_DrawPixel((Xpos + current_y), (Ypos + current_x), DrawProp[ActiveLayer].TextColor);
 8083a04:	4648      	mov	r0, r9
 8083a06:	4414      	add	r4, r2
 8083a08:	4632      	mov	r2, r6
 8083a0a:	b2a4      	uxth	r4, r4
 8083a0c:	4621      	mov	r1, r4
 8083a0e:	f7ff fd83 	bl	8083518 <BSP_LCD_DrawPixel>
		BSP_LCD_DrawPixel((Xpos - current_y), (Ypos + current_x), DrawProp[ActiveLayer].TextColor);
 8083a12:	4632      	mov	r2, r6
 8083a14:	4621      	mov	r1, r4
 8083a16:	4640      	mov	r0, r8
 8083a18:	f7ff fd7e 	bl	8083518 <BSP_LCD_DrawPixel>
			decision += ((current_x - current_y) << 2) + 10;
 8083a1c:	9802      	ldr	r0, [sp, #8]
 8083a1e:	9b03      	ldr	r3, [sp, #12]
 8083a20:	4602      	mov	r2, r0
		if (decision < 0)
 8083a22:	2800      	cmp	r0, #0
			decision += ((current_x - current_y) << 2) + 10;
 8083a24:	eba7 0103 	sub.w	r1, r7, r3
 8083a28:	f102 020a 	add.w	r2, r2, #10
		if (decision < 0)
 8083a2c:	daa1      	bge.n	8083972 <BSP_LCD_DrawCircle+0x32>
			decision += (current_x << 2) + 6;
 8083a2e:	3a04      	subs	r2, #4
 8083a30:	eb02 0287 	add.w	r2, r2, r7, lsl #2
		current_x++;
 8083a34:	3701      	adds	r7, #1
	while (current_x <= current_y)
 8083a36:	42bb      	cmp	r3, r7
			decision += (current_x << 2) + 6;
 8083a38:	9202      	str	r2, [sp, #8]
	while (current_x <= current_y)
 8083a3a:	d2a1      	bcs.n	8083980 <BSP_LCD_DrawCircle+0x40>
}
 8083a3c:	b005      	add	sp, #20
 8083a3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8083a42:	bf00      	nop

08083a44 <BSP_LCD_DrawEllipse>:
{
 8083a44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8083a48:	f24b 6570 	movw	r5, #46704	; 0xb670
	rad2 = YRadius;
 8083a4c:	ee07 3a90 	vmov	s15, r3
 8083a50:	f24b 6474 	movw	r4, #46708	; 0xb674
 8083a54:	fa1f fb80 	uxth.w	fp, r0
 8083a58:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8083a5c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	rad1 = XRadius;
 8083a60:	ee07 2a90 	vmov	s15, r2
{
 8083a64:	b083      	sub	sp, #12
 8083a66:	6828      	ldr	r0, [r5, #0]
 8083a68:	f2c2 0400 	movt	r4, #8192	; 0x2000
	rad1 = XRadius;
 8083a6c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	int x = 0, y = -YRadius, err = 2-2*XRadius, e2;
 8083a70:	f1c2 0201 	rsb	r2, r2, #1
 8083a74:	b289      	uxth	r1, r1
 8083a76:	425f      	negs	r7, r3
 8083a78:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8083a7c:	2300      	movs	r3, #0
 8083a7e:	9100      	str	r1, [sp, #0]
	k = (float)(rad2/rad1);
 8083a80:	eec7 6a27 	vdiv.f32	s13, s14, s15
	int x = 0, y = -YRadius, err = 2-2*XRadius, e2;
 8083a84:	0055      	lsls	r5, r2, #1
 8083a86:	f854 a020 	ldr.w	sl, [r4, r0, lsl #2]
 8083a8a:	e001      	b.n	8083a90 <BSP_LCD_DrawEllipse+0x4c>
	while (y <= 0);
 8083a8c:	2f00      	cmp	r7, #0
 8083a8e:	dc41      	bgt.n	8083b14 <BSP_LCD_DrawEllipse+0xd0>
		BSP_LCD_DrawPixel((Xpos-(uint16_t)(x/k)), (Ypos+y), DrawProp[ActiveLayer].TextColor);
 8083a90:	ee07 3a90 	vmov	s15, r3
 8083a94:	9301      	str	r3, [sp, #4]
 8083a96:	9900      	ldr	r1, [sp, #0]
 8083a98:	b2bc      	uxth	r4, r7
 8083a9a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8083a9e:	4652      	mov	r2, sl
 8083aa0:	eb04 0901 	add.w	r9, r4, r1
 8083aa4:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8083aa8:	fa1f f989 	uxth.w	r9, r9
 8083aac:	4649      	mov	r1, r9
 8083aae:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8083ab2:	ee17 3a90 	vmov	r3, s15
 8083ab6:	b29e      	uxth	r6, r3
 8083ab8:	ebab 0806 	sub.w	r8, fp, r6
		BSP_LCD_DrawPixel((Xpos+(uint16_t)(x/k)), (Ypos+y), DrawProp[ActiveLayer].TextColor);
 8083abc:	445e      	add	r6, fp
		BSP_LCD_DrawPixel((Xpos-(uint16_t)(x/k)), (Ypos+y), DrawProp[ActiveLayer].TextColor);
 8083abe:	fa1f f888 	uxth.w	r8, r8
		BSP_LCD_DrawPixel((Xpos+(uint16_t)(x/k)), (Ypos+y), DrawProp[ActiveLayer].TextColor);
 8083ac2:	b2b6      	uxth	r6, r6
		BSP_LCD_DrawPixel((Xpos-(uint16_t)(x/k)), (Ypos+y), DrawProp[ActiveLayer].TextColor);
 8083ac4:	4640      	mov	r0, r8
 8083ac6:	f7ff fd27 	bl	8083518 <BSP_LCD_DrawPixel>
		BSP_LCD_DrawPixel((Xpos+(uint16_t)(x/k)), (Ypos+y), DrawProp[ActiveLayer].TextColor);
 8083aca:	4630      	mov	r0, r6
 8083acc:	4649      	mov	r1, r9
 8083ace:	4652      	mov	r2, sl
 8083ad0:	f7ff fd22 	bl	8083518 <BSP_LCD_DrawPixel>
		BSP_LCD_DrawPixel((Xpos+(uint16_t)(x/k)), (Ypos-y), DrawProp[ActiveLayer].TextColor);
 8083ad4:	9900      	ldr	r1, [sp, #0]
 8083ad6:	4652      	mov	r2, sl
 8083ad8:	1b0c      	subs	r4, r1, r4
 8083ada:	b2a4      	uxth	r4, r4
 8083adc:	4621      	mov	r1, r4
 8083ade:	f7ff fd1b 	bl	8083518 <BSP_LCD_DrawPixel>
		BSP_LCD_DrawPixel((Xpos-(uint16_t)(x/k)), (Ypos-y), DrawProp[ActiveLayer].TextColor);
 8083ae2:	4652      	mov	r2, sl
 8083ae4:	4621      	mov	r1, r4
 8083ae6:	4640      	mov	r0, r8
 8083ae8:	f7ff fd16 	bl	8083518 <BSP_LCD_DrawPixel>
		if (e2 <= x) {
 8083aec:	9b01      	ldr	r3, [sp, #4]
 8083aee:	462a      	mov	r2, r5
 8083af0:	42ab      	cmp	r3, r5
 8083af2:	db06      	blt.n	8083b02 <BSP_LCD_DrawEllipse+0xbe>
			err += ++x*2+1;
 8083af4:	3301      	adds	r3, #1
 8083af6:	eb05 0243 	add.w	r2, r5, r3, lsl #1
			if (-y == x && e2 <= y) e2 = 0;
 8083afa:	42fb      	cmn	r3, r7
			err += ++x*2+1;
 8083afc:	f102 0201 	add.w	r2, r2, #1
			if (-y == x && e2 <= y) e2 = 0;
 8083b00:	d00b      	beq.n	8083b1a <BSP_LCD_DrawEllipse+0xd6>
		if (e2 > y) err += ++y*2+1;
 8083b02:	42af      	cmp	r7, r5
 8083b04:	4615      	mov	r5, r2
 8083b06:	dac1      	bge.n	8083a8c <BSP_LCD_DrawEllipse+0x48>
 8083b08:	3701      	adds	r7, #1
 8083b0a:	eb02 0547 	add.w	r5, r2, r7, lsl #1
 8083b0e:	3501      	adds	r5, #1
	while (y <= 0);
 8083b10:	2f00      	cmp	r7, #0
 8083b12:	ddbd      	ble.n	8083a90 <BSP_LCD_DrawEllipse+0x4c>
}
 8083b14:	b003      	add	sp, #12
 8083b16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (-y == x && e2 <= y) e2 = 0;
 8083b1a:	42af      	cmp	r7, r5
 8083b1c:	f04f 0500 	mov.w	r5, #0
 8083b20:	daef      	bge.n	8083b02 <BSP_LCD_DrawEllipse+0xbe>
		if (e2 > y) err += ++y*2+1;
 8083b22:	3701      	adds	r7, #1
 8083b24:	eb02 0547 	add.w	r5, r2, r7, lsl #1
 8083b28:	3501      	adds	r5, #1
 8083b2a:	e7f1      	b.n	8083b10 <BSP_LCD_DrawEllipse+0xcc>

08083b2c <BSP_LCD_DrawBitmap>:
{
 8083b2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083b30:	f24d 7304 	movw	r3, #55044	; 0xd704
 8083b34:	f24b 6770 	movw	r7, #46704	; 0xb670
 8083b38:	2534      	movs	r5, #52	; 0x34
{
 8083b3a:	b08d      	sub	sp, #52	; 0x34
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083b3c:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8083b40:	f2c2 0700 	movt	r7, #8192	; 0x2000
	index = *(__IO uint16_t *) (pbmp + 10);
 8083b44:	8954      	ldrh	r4, [r2, #10]
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083b46:	461e      	mov	r6, r3
 8083b48:	f8d7 9000 	ldr.w	r9, [r7]
 8083b4c:	9303      	str	r3, [sp, #12]
 8083b4e:	fb05 6509 	mla	r5, r5, r9, r6
	index |= (*(__IO uint16_t *) (pbmp + 12)) << 16;
 8083b52:	8993      	ldrh	r3, [r2, #12]
	width |= (*(uint16_t *) (pbmp + 20)) << 16;
 8083b54:	f8d2 6012 	ldr.w	r6, [r2, #18]
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083b58:	f8d5 e048 	ldr.w	lr, [r5, #72]	; 0x48
	index |= (*(__IO uint16_t *) (pbmp + 12)) << 16;
 8083b5c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
	height |= (*(uint16_t *) (pbmp + 24)) << 16;
 8083b60:	f8d2 3016 	ldr.w	r3, [r2, #22]
 8083b64:	eb06 0c00 	add.w	ip, r6, r0
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083b68:	f1be 0f02 	cmp.w	lr, #2
	width |= (*(uint16_t *) (pbmp + 20)) << 16;
 8083b6c:	9608      	str	r6, [sp, #32]
	height |= (*(uint16_t *) (pbmp + 24)) << 16;
 8083b6e:	9304      	str	r3, [sp, #16]
	bit_pixel = *(uint16_t *) (pbmp + 28);
 8083b70:	8b96      	ldrh	r6, [r2, #28]
 8083b72:	e9d5 0517 	ldrd	r0, r5, [r5, #92]	; 0x5c
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083b76:	f000 80c2 	beq.w	8083cfe <BSP_LCD_DrawBitmap+0x1d2>
		address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + 4 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - (Xpos+width) - (BSP_LCD_GetXSize() * (Ypos+height))));
 8083b7a:	9b04      	ldr	r3, [sp, #16]
 8083b7c:	f5cc 3cff 	rsb	ip, ip, #130560	; 0x1fe00
 8083b80:	4419      	add	r1, r3
 8083b82:	fb05 c111 	mls	r1, r5, r1, ip
 8083b86:	eb00 0b81 	add.w	fp, r0, r1, lsl #2
	if ((bit_pixel/8) == 4)
 8083b8a:	f1a6 0120 	sub.w	r1, r6, #32
 8083b8e:	2907      	cmp	r1, #7
 8083b90:	f240 80b3 	bls.w	8083cfa <BSP_LCD_DrawBitmap+0x1ce>
	else if ((bit_pixel/8) == 2)
 8083b94:	f1a6 0110 	sub.w	r1, r6, #16
		input_color_mode = CM_RGB565;
 8083b98:	2907      	cmp	r1, #7
 8083b9a:	bf8c      	ite	hi
 8083b9c:	2501      	movhi	r5, #1
 8083b9e:	2502      	movls	r5, #2
	pbmp += (index + (width * (height - 1) * (bit_pixel/8)));
 8083ba0:	08f1      	lsrs	r1, r6, #3
 8083ba2:	9b04      	ldr	r3, [sp, #16]
 8083ba4:	9e08      	ldr	r6, [sp, #32]
 8083ba6:	1e58      	subs	r0, r3, #1
 8083ba8:	fb06 f101 	mul.w	r1, r6, r1
 8083bac:	fb01 4000 	mla	r0, r1, r0, r4
 8083bb0:	eb02 0a00 	add.w	sl, r2, r0
	for(index=0; index < height; index++)
 8083bb4:	2b00      	cmp	r3, #0
 8083bb6:	f000 809d 	beq.w	8083cf4 <BSP_LCD_DrawBitmap+0x1c8>
	uint16_t colorConversion=0;
	uint16_t *src_address_16=pSrc;
	uint16_t *dst_address=pDst;
	uint8_t * src_address_8 = pSrc;

	dst_address = dst_address+xSize-1;
 8083bba:	f64f 72ff 	movw	r2, #65535	; 0xffff
	hDma2dHandler.Instance = DMA2D;
 8083bbe:	f44f 4330 	mov.w	r3, #45056	; 0xb000
 8083bc2:	ebc6 70c6 	rsb	r0, r6, r6, lsl #31
		pbmp -= width*(bit_pixel/8);
 8083bc6:	4249      	negs	r1, r1
	dst_address = dst_address+xSize-1;
 8083bc8:	f6c7 72ff 	movt	r2, #32767	; 0x7fff
	hDma2dHandler.Instance = DMA2D;
 8083bcc:	f2c4 0302 	movt	r3, #16386	; 0x4002
	hDma2dHandler.Init.Mode         = DMA2D_M2M_PFC;
 8083bd0:	f24b 648c 	movw	r4, #46732	; 0xb68c
		pbmp -= width*(bit_pixel/8);
 8083bd4:	9106      	str	r1, [sp, #24]
	dst_address = dst_address+xSize-1;
 8083bd6:	4432      	add	r2, r6
 8083bd8:	0041      	lsls	r1, r0, #1
	hDma2dHandler.Instance = DMA2D;
 8083bda:	9307      	str	r3, [sp, #28]
	hDma2dHandler.Init.Mode         = DMA2D_M2M_PFC;
 8083bdc:	f2c2 0400 	movt	r4, #8192	; 0x2000
	dst_address = dst_address+xSize-1;
 8083be0:	0053      	lsls	r3, r2, #1
 8083be2:	910b      	str	r1, [sp, #44]	; 0x2c
	for(index=0; index < height; index++)
 8083be4:	2600      	movs	r6, #0
	dst_address = dst_address+xSize-1;
 8083be6:	f8cd 9014 	str.w	r9, [sp, #20]
 8083bea:	930a      	str	r3, [sp, #40]	; 0x28
 8083bec:	4673      	mov	r3, lr
 8083bee:	e02a      	b.n	8083c46 <BSP_LCD_DrawBitmap+0x11a>
	hDma2dHandler.Init.Mode         = DMA2D_M2M_PFC;
 8083bf0:	f44f 3180 	mov.w	r1, #65536	; 0x10000
	hDma2dHandler.Init.ColorMode    = DMA2D_ARGB8888;
 8083bf4:	2300      	movs	r3, #0
	if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK)
 8083bf6:	f24b 608c 	movw	r0, #46732	; 0xb68c
	hDma2dHandler.LayerCfg[1].InputAlpha = 0xFF;
 8083bfa:	22ff      	movs	r2, #255	; 0xff
	hDma2dHandler.Init.Mode         = DMA2D_M2M_PFC;
 8083bfc:	6061      	str	r1, [r4, #4]
	hDma2dHandler.Instance = DMA2D;
 8083bfe:	9907      	ldr	r1, [sp, #28]
	if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK)
 8083c00:	f2c2 0000 	movt	r0, #8192	; 0x2000
	hDma2dHandler.LayerCfg[1].InputColorMode = ColorMode;
 8083c04:	62e5      	str	r5, [r4, #44]	; 0x2c
	hDma2dHandler.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
 8083c06:	6323      	str	r3, [r4, #48]	; 0x30
	hDma2dHandler.LayerCfg[1].InputOffset = 0;
 8083c08:	62a3      	str	r3, [r4, #40]	; 0x28
	hDma2dHandler.LayerCfg[1].InputAlpha = 0xFF;
 8083c0a:	6362      	str	r2, [r4, #52]	; 0x34
	hDma2dHandler.Instance = DMA2D;
 8083c0c:	6021      	str	r1, [r4, #0]
	hDma2dHandler.Init.OutputOffset = 0;
 8083c0e:	e9c4 3302 	strd	r3, r3, [r4, #8]
	if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK)
 8083c12:	f002 f8f7 	bl	8085e04 <HAL_DMA2D_Init>
 8083c16:	2800      	cmp	r0, #0
 8083c18:	d057      	beq.n	8083cca <BSP_LCD_DrawBitmap+0x19e>
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083c1a:	683b      	ldr	r3, [r7, #0]
 8083c1c:	2234      	movs	r2, #52	; 0x34
 8083c1e:	9903      	ldr	r1, [sp, #12]
 8083c20:	fb02 1303 	mla	r3, r2, r3, r1
			address+=  (BSP_LCD_GetXSize()*4);
 8083c24:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8083c26:	eb0b 0b83 	add.w	fp, fp, r3, lsl #2
		pbmp -= width*(bit_pixel/8);
 8083c2a:	9b06      	ldr	r3, [sp, #24]
	for(index=0; index < height; index++)
 8083c2c:	3601      	adds	r6, #1
		pbmp -= width*(bit_pixel/8);
 8083c2e:	449a      	add	sl, r3
	for(index=0; index < height; index++)
 8083c30:	9b04      	ldr	r3, [sp, #16]
 8083c32:	42b3      	cmp	r3, r6
 8083c34:	d05e      	beq.n	8083cf4 <BSP_LCD_DrawBitmap+0x1c8>
 8083c36:	683b      	ldr	r3, [r7, #0]
 8083c38:	9903      	ldr	r1, [sp, #12]
 8083c3a:	461a      	mov	r2, r3
 8083c3c:	9305      	str	r3, [sp, #20]
 8083c3e:	2334      	movs	r3, #52	; 0x34
 8083c40:	fb03 1302 	mla	r3, r3, r2, r1
 8083c44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
		if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083c46:	2b02      	cmp	r3, #2
 8083c48:	d1d2      	bne.n	8083bf0 <BSP_LCD_DrawBitmap+0xc4>
	dst_address = dst_address+xSize-1;
 8083c4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8083c4c:	eb0b 0c03 	add.w	ip, fp, r3

	for (int i=0; i<xSize; i++ )
 8083c50:	9b08      	ldr	r3, [sp, #32]
 8083c52:	b343      	cbz	r3, 8083ca6 <BSP_LCD_DrawBitmap+0x17a>
 8083c54:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8083c56:	46d6      	mov	lr, sl
 8083c58:	9409      	str	r4, [sp, #36]	; 0x24
 8083c5a:	4654      	mov	r4, sl
 8083c5c:	eb0c 0803 	add.w	r8, ip, r3
 8083c60:	e018      	b.n	8083c94 <BSP_LCD_DrawBitmap+0x168>
 8083c62:	f89e 1000 	ldrb.w	r1, [lr]
		if (ColorMode == CM_RGB565)
		{
			colorConversion = (uint16_t)(*src_address_16);
			src_address_16++;
		}
		else if (ColorMode == CM_RGB888)
 8083c66:	2d01      	cmp	r5, #1
 8083c68:	f101 0202 	add.w	r2, r1, #2
 8083c6c:	f101 0001 	add.w	r0, r1, #1
			src_address_8 = src_address_8+3;
		}
		else
		{
			colorConversion=0;
			colorConversion=((uint16_t)((uint8_t)(*src_address_8+1))<<11) + ((uint16_t)((uint8_t)(*src_address_8+2))<<5) +((uint16_t)((uint8_t)(*src_address_8+3)));
 8083c70:	f101 0303 	add.w	r3, r1, #3
 8083c74:	b2d2      	uxtb	r2, r2
 8083c76:	b2c0      	uxtb	r0, r0
 8083c78:	ea4f 1942 	mov.w	r9, r2, lsl #5
		else if (ColorMode == CM_RGB888)
 8083c7c:	d01d      	beq.n	8083cba <BSP_LCD_DrawBitmap+0x18e>
			colorConversion=((uint16_t)((uint8_t)(*src_address_8+1))<<11) + ((uint16_t)((uint8_t)(*src_address_8+2))<<5) +((uint16_t)((uint8_t)(*src_address_8+3)));
 8083c7e:	eb09 20c0 	add.w	r0, r9, r0, lsl #11
			src_address_8 = src_address_8+4;
 8083c82:	f10e 0e04 	add.w	lr, lr, #4
			colorConversion=((uint16_t)((uint8_t)(*src_address_8+1))<<11) + ((uint16_t)((uint8_t)(*src_address_8+2))<<5) +((uint16_t)((uint8_t)(*src_address_8+3)));
 8083c86:	fa50 f383 	uxtab	r3, r0, r3
 8083c8a:	b29b      	uxth	r3, r3
		}

		*dst_address=colorConversion;
 8083c8c:	f82c 3902 	strh.w	r3, [ip], #-2
	for (int i=0; i<xSize; i++ )
 8083c90:	45e0      	cmp	r8, ip
 8083c92:	d007      	beq.n	8083ca4 <BSP_LCD_DrawBitmap+0x178>
		if (ColorMode == CM_RGB565)
 8083c94:	2d02      	cmp	r5, #2
 8083c96:	d1e4      	bne.n	8083c62 <BSP_LCD_DrawBitmap+0x136>
			colorConversion = (uint16_t)(*src_address_16);
 8083c98:	f834 3b02 	ldrh.w	r3, [r4], #2
		*dst_address=colorConversion;
 8083c9c:	f82c 3902 	strh.w	r3, [ip], #-2
	for (int i=0; i<xSize; i++ )
 8083ca0:	45e0      	cmp	r8, ip
 8083ca2:	d1f7      	bne.n	8083c94 <BSP_LCD_DrawBitmap+0x168>
 8083ca4:	9c09      	ldr	r4, [sp, #36]	; 0x24
	return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
 8083ca6:	2334      	movs	r3, #52	; 0x34
 8083ca8:	9a05      	ldr	r2, [sp, #20]
 8083caa:	9903      	ldr	r1, [sp, #12]
 8083cac:	fb03 1902 	mla	r9, r3, r2, r1
			address-=  (BSP_LCD_GetXSize()*2);
 8083cb0:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
 8083cb4:	ebab 0b43 	sub.w	fp, fp, r3, lsl #1
 8083cb8:	e7b7      	b.n	8083c2a <BSP_LCD_DrawBitmap+0xfe>
			colorConversion=((uint16_t)((uint8_t)(*src_address_8))<<11) + ((uint16_t)((uint8_t)(*src_address_8+1))<<5) +((uint16_t)((uint8_t)(*src_address_8+2)));
 8083cba:	eb02 23c1 	add.w	r3, r2, r1, lsl #11
			src_address_8 = src_address_8+3;
 8083cbe:	f10e 0e03 	add.w	lr, lr, #3
			colorConversion=((uint16_t)((uint8_t)(*src_address_8))<<11) + ((uint16_t)((uint8_t)(*src_address_8+1))<<5) +((uint16_t)((uint8_t)(*src_address_8+2)));
 8083cc2:	eb03 1340 	add.w	r3, r3, r0, lsl #5
 8083cc6:	b29b      	uxth	r3, r3
 8083cc8:	e7e0      	b.n	8083c8c <BSP_LCD_DrawBitmap+0x160>
		if(HAL_DMA2D_ConfigLayer(&hDma2dHandler, 1) == HAL_OK)
 8083cca:	2101      	movs	r1, #1
 8083ccc:	4620      	mov	r0, r4
 8083cce:	f002 f96b 	bl	8085fa8 <HAL_DMA2D_ConfigLayer>
 8083cd2:	2800      	cmp	r0, #0
 8083cd4:	d1a1      	bne.n	8083c1a <BSP_LCD_DrawBitmap+0xee>
			if (HAL_DMA2D_Start(&hDma2dHandler, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
 8083cd6:	2001      	movs	r0, #1
 8083cd8:	9b08      	ldr	r3, [sp, #32]
 8083cda:	465a      	mov	r2, fp
 8083cdc:	4651      	mov	r1, sl
 8083cde:	9000      	str	r0, [sp, #0]
 8083ce0:	4620      	mov	r0, r4
 8083ce2:	f002 f8bf 	bl	8085e64 <HAL_DMA2D_Start>
 8083ce6:	2800      	cmp	r0, #0
 8083ce8:	d197      	bne.n	8083c1a <BSP_LCD_DrawBitmap+0xee>
				HAL_DMA2D_PollForTransfer(&hDma2dHandler, 10);
 8083cea:	210a      	movs	r1, #10
 8083cec:	4620      	mov	r0, r4
 8083cee:	f002 f8d5 	bl	8085e9c <HAL_DMA2D_PollForTransfer>
 8083cf2:	e792      	b.n	8083c1a <BSP_LCD_DrawBitmap+0xee>
}
 8083cf4:	b00d      	add	sp, #52	; 0x34
 8083cf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		input_color_mode = CM_ARGB8888;
 8083cfa:	2500      	movs	r5, #0
 8083cfc:	e750      	b.n	8083ba0 <BSP_LCD_DrawBitmap+0x74>
		address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + 2 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - (Xpos+width) - (BSP_LCD_GetXSize() * (Ypos))));
 8083cfe:	fb05 f101 	mul.w	r1, r5, r1
 8083d02:	f5c1 31ff 	rsb	r1, r1, #130560	; 0x1fe00
 8083d06:	eba1 0c0c 	sub.w	ip, r1, ip
 8083d0a:	eb00 0b4c 	add.w	fp, r0, ip, lsl #1
 8083d0e:	e73c      	b.n	8083b8a <BSP_LCD_DrawBitmap+0x5e>

08083d10 <BSP_LCD_FillRect>:
{
 8083d10:	b5f0      	push	{r4, r5, r6, r7, lr}
	BSP_LCD_SetTextColor(DrawProp[ActiveLayer].TextColor);
 8083d12:	f24b 6570 	movw	r5, #46704	; 0xb670
 8083d16:	f24d 7604 	movw	r6, #55044	; 0xd704
 8083d1a:	2434      	movs	r4, #52	; 0x34
 8083d1c:	4419      	add	r1, r3
 8083d1e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8083d22:	f2c2 0602 	movt	r6, #8194	; 0x2002
 8083d26:	4410      	add	r0, r2
 8083d28:	3901      	subs	r1, #1
 8083d2a:	682d      	ldr	r5, [r5, #0]
 8083d2c:	f24b 6774 	movw	r7, #46708	; 0xb674
{
 8083d30:	b083      	sub	sp, #12
 8083d32:	fb04 6405 	mla	r4, r4, r5, r6
	BSP_LCD_SetTextColor(DrawProp[ActiveLayer].TextColor);
 8083d36:	eb05 0e45 	add.w	lr, r5, r5, lsl #1
 8083d3a:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8083d3e:	6e26      	ldr	r6, [r4, #96]	; 0x60
	if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
 8083d40:	f8d4 c048 	ldr.w	ip, [r4, #72]	; 0x48
 8083d44:	fb06 0101 	mla	r1, r6, r1, r0
 8083d48:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8083d4a:	f1bc 0f02 	cmp.w	ip, #2
	BSP_LCD_SetTextColor(DrawProp[ActiveLayer].TextColor);
 8083d4e:	f857 402e 	ldr.w	r4, [r7, lr, lsl #2]
 8083d52:	f5c1 31ff 	rsb	r1, r1, #130560	; 0x1fe00
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, Width, Height, (BSP_LCD_GetXSize() - Width), DrawProp[ActiveLayer].TextColor);
 8083d56:	eba6 0602 	sub.w	r6, r6, r2
		x_address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + 2 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - (Xpos+Width) - (BSP_LCD_GetXSize() * (Ypos+Height-1))));
 8083d5a:	bf0c      	ite	eq
 8083d5c:	eb00 0141 	addeq.w	r1, r0, r1, lsl #1
		x_address = (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + 4 * ((RK043FN48H_WIDTH*RK043FN48H_HEIGHT) - (Xpos+Width) - (BSP_LCD_GetXSize() * (Ypos+Height-1))));
 8083d60:	eb00 0181 	addne.w	r1, r0, r1, lsl #2
	LL_FillBuffer(ActiveLayer, (uint32_t *)x_address, Width, Height, (BSP_LCD_GetXSize() - Width), DrawProp[ActiveLayer].TextColor);
 8083d64:	4628      	mov	r0, r5
 8083d66:	e9cd 6400 	strd	r6, r4, [sp]
 8083d6a:	f7ff fa1b 	bl	80831a4 <LL_FillBuffer>
}
 8083d6e:	b003      	add	sp, #12
 8083d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8083d72:	bf00      	nop

08083d74 <BSP_LCD_FillCircle>:
{
 8083d74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	decision = 3 - (Radius << 1);
 8083d78:	0056      	lsls	r6, r2, #1
{
 8083d7a:	4681      	mov	r9, r0
 8083d7c:	4688      	mov	r8, r1
	current_x = 0;
 8083d7e:	2400      	movs	r4, #0
	current_y = Radius;
 8083d80:	4615      	mov	r5, r2
	decision = 3 - (Radius << 1);
 8083d82:	f1c6 0603 	rsb	r6, r6, #3
		if(current_y > 0)
 8083d86:	b975      	cbnz	r5, 8083da6 <BSP_LCD_FillCircle+0x32>
		if(current_x > 0)
 8083d88:	bb34      	cbnz	r4, 8083dd8 <BSP_LCD_FillCircle+0x64>
		if (decision < 0)
 8083d8a:	2e00      	cmp	r6, #0
			decision += ((current_x - current_y) << 2) + 10;
 8083d8c:	eba4 0205 	sub.w	r2, r4, r5
 8083d90:	f106 030a 	add.w	r3, r6, #10
		if (decision < 0)
 8083d94:	db3d      	blt.n	8083e12 <BSP_LCD_FillCircle+0x9e>
			decision += ((current_x - current_y) << 2) + 10;
 8083d96:	eb03 0682 	add.w	r6, r3, r2, lsl #2
			current_y--;
 8083d9a:	3d01      	subs	r5, #1
		current_x++;
 8083d9c:	3401      	adds	r4, #1
	while (current_x <= current_y)
 8083d9e:	42a5      	cmp	r5, r4
 8083da0:	d2f1      	bcs.n	8083d86 <BSP_LCD_FillCircle+0x12>
}
 8083da2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			BSP_LCD_DrawHLine(Xpos - current_y, Ypos + current_x, 2*current_y);
 8083da6:	b2af      	uxth	r7, r5
 8083da8:	fa1f fa84 	uxth.w	sl, r4
 8083dac:	eba9 0b07 	sub.w	fp, r9, r7
 8083db0:	007f      	lsls	r7, r7, #1
 8083db2:	eb08 010a 	add.w	r1, r8, sl
 8083db6:	fa1f fb8b 	uxth.w	fp, fp
 8083dba:	b2bf      	uxth	r7, r7
 8083dbc:	4658      	mov	r0, fp
 8083dbe:	b289      	uxth	r1, r1
 8083dc0:	463a      	mov	r2, r7
 8083dc2:	f7ff fb2f 	bl	8083424 <BSP_LCD_DrawHLine>
			BSP_LCD_DrawHLine(Xpos - current_y, Ypos - current_x, 2*current_y);
 8083dc6:	eba8 010a 	sub.w	r1, r8, sl
 8083dca:	463a      	mov	r2, r7
 8083dcc:	4658      	mov	r0, fp
 8083dce:	b289      	uxth	r1, r1
 8083dd0:	f7ff fb28 	bl	8083424 <BSP_LCD_DrawHLine>
		if(current_x > 0)
 8083dd4:	2c00      	cmp	r4, #0
 8083dd6:	d0d8      	beq.n	8083d8a <BSP_LCD_FillCircle+0x16>
 8083dd8:	b2a7      	uxth	r7, r4
			BSP_LCD_DrawHLine(Xpos - current_x, Ypos - current_y, 2*current_x);
 8083dda:	fa1f fa85 	uxth.w	sl, r5
 8083dde:	eba9 0b07 	sub.w	fp, r9, r7
 8083de2:	007f      	lsls	r7, r7, #1
 8083de4:	eba8 010a 	sub.w	r1, r8, sl
 8083de8:	fa1f fb8b 	uxth.w	fp, fp
 8083dec:	b2bf      	uxth	r7, r7
 8083dee:	4658      	mov	r0, fp
 8083df0:	b289      	uxth	r1, r1
 8083df2:	463a      	mov	r2, r7
 8083df4:	f7ff fb16 	bl	8083424 <BSP_LCD_DrawHLine>
			BSP_LCD_DrawHLine(Xpos - current_x, Ypos + current_y, 2*current_x);
 8083df8:	eb0a 0108 	add.w	r1, sl, r8
 8083dfc:	463a      	mov	r2, r7
 8083dfe:	4658      	mov	r0, fp
 8083e00:	b289      	uxth	r1, r1
 8083e02:	f7ff fb0f 	bl	8083424 <BSP_LCD_DrawHLine>
		if (decision < 0)
 8083e06:	2e00      	cmp	r6, #0
			decision += ((current_x - current_y) << 2) + 10;
 8083e08:	eba4 0205 	sub.w	r2, r4, r5
 8083e0c:	f106 030a 	add.w	r3, r6, #10
		if (decision < 0)
 8083e10:	dac1      	bge.n	8083d96 <BSP_LCD_FillCircle+0x22>
			decision += (current_x << 2) + 6;
 8083e12:	3606      	adds	r6, #6
 8083e14:	eb06 0684 	add.w	r6, r6, r4, lsl #2
 8083e18:	e7c0      	b.n	8083d9c <BSP_LCD_FillCircle+0x28>
 8083e1a:	bf00      	nop

08083e1c <BSP_LCD_FillPolygon>:
{
 8083e1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	image_left = image_right = Points->X;
 8083e20:	f9b0 5000 	ldrsh.w	r5, [r0]
{
 8083e24:	b085      	sub	sp, #20
	image_top= image_bottom = Points->Y;
 8083e26:	f9b0 6002 	ldrsh.w	r6, [r0, #2]
	for(counter = 1; counter < PointCount; counter++)
 8083e2a:	2901      	cmp	r1, #1
	image_left = image_right = Points->X;
 8083e2c:	b2ad      	uxth	r5, r5
	image_top= image_bottom = Points->Y;
 8083e2e:	b2b6      	uxth	r6, r6
	image_left = image_right = Points->X;
 8083e30:	46ac      	mov	ip, r5
 8083e32:	462f      	mov	r7, r5
	image_top= image_bottom = Points->Y;
 8083e34:	46b0      	mov	r8, r6
 8083e36:	4634      	mov	r4, r6
 8083e38:	e9cd 5602 	strd	r5, r6, [sp, #8]
	for(counter = 1; counter < PointCount; counter++)
 8083e3c:	dd1a      	ble.n	8083e74 <BSP_LCD_FillPolygon+0x58>
 8083e3e:	2301      	movs	r3, #1
		pixelX = POLY_X(counter);
 8083e40:	f930 2023 	ldrsh.w	r2, [r0, r3, lsl #2]
 8083e44:	eb00 0e83 	add.w	lr, r0, r3, lsl #2
 8083e48:	f103 0901 	add.w	r9, r3, #1
		if(pixelX < image_left)
 8083e4c:	42ba      	cmp	r2, r7
 8083e4e:	fa0f f389 	sxth.w	r3, r9
			image_left = pixelX;
 8083e52:	bfb8      	it	lt
 8083e54:	b297      	uxthlt	r7, r2
		if(pixelX > image_right)
 8083e56:	4562      	cmp	r2, ip
			image_right = pixelX;
 8083e58:	bfc8      	it	gt
 8083e5a:	fa1f fc82 	uxthgt.w	ip, r2
		pixelY = POLY_Y(counter);
 8083e5e:	f9be 2002 	ldrsh.w	r2, [lr, #2]
		if(pixelY < image_top)
 8083e62:	42a2      	cmp	r2, r4
			image_top = pixelY;
 8083e64:	bfb8      	it	lt
 8083e66:	b294      	uxthlt	r4, r2
		if(pixelY > image_bottom)
 8083e68:	4542      	cmp	r2, r8
			image_bottom = pixelY;
 8083e6a:	bfc8      	it	gt
 8083e6c:	fa1f f882 	uxthgt.w	r8, r2
	for(counter = 1; counter < PointCount; counter++)
 8083e70:	428b      	cmp	r3, r1
 8083e72:	dbe5      	blt.n	8083e40 <BSP_LCD_FillPolygon+0x24>
	if(PointCount < 2)
 8083e74:	2901      	cmp	r1, #1
 8083e76:	d94e      	bls.n	8083f16 <BSP_LCD_FillPolygon+0xfa>
 8083e78:	f1a1 0902 	sub.w	r9, r1, #2
	Y_center = (image_bottom + image_top)/2;
 8083e7c:	44a0      	add	r8, r4
	X_center = (image_left + image_right)/2;
 8083e7e:	4467      	add	r7, ip
 8083e80:	4604      	mov	r4, r0
 8083e82:	fa1f f989 	uxth.w	r9, r9
 8083e86:	f3c8 084f 	ubfx	r8, r8, #1, #16
 8083e8a:	f3c7 074f 	ubfx	r7, r7, #1, #16
 8083e8e:	eb00 0989 	add.w	r9, r0, r9, lsl #2
 8083e92:	e006      	b.n	8083ea2 <BSP_LCD_FillPolygon+0x86>
 8083e94:	f9b4 5004 	ldrsh.w	r5, [r4, #4]
 8083e98:	3404      	adds	r4, #4
 8083e9a:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
 8083e9e:	b2ad      	uxth	r5, r5
 8083ea0:	b2b6      	uxth	r6, r6
		FillTriangle(X, X2, X_center, Y, Y2, Y_center);
 8083ea2:	f8b4 a004 	ldrh.w	sl, [r4, #4]
 8083ea6:	4633      	mov	r3, r6
 8083ea8:	f8b4 b006 	ldrh.w	fp, [r4, #6]
 8083eac:	463a      	mov	r2, r7
 8083eae:	4651      	mov	r1, sl
 8083eb0:	4628      	mov	r0, r5
 8083eb2:	e9cd b800 	strd	fp, r8, [sp]
 8083eb6:	f7ff fcd9 	bl	808386c <FillTriangle>
		FillTriangle(X, X_center, X2, Y, Y_center, Y2);
 8083eba:	4652      	mov	r2, sl
 8083ebc:	4633      	mov	r3, r6
 8083ebe:	4639      	mov	r1, r7
 8083ec0:	4628      	mov	r0, r5
 8083ec2:	e9cd 8b00 	strd	r8, fp, [sp]
 8083ec6:	f7ff fcd1 	bl	808386c <FillTriangle>
		FillTriangle(X_center, X2, X, Y_center, Y2, Y);
 8083eca:	462a      	mov	r2, r5
 8083ecc:	4651      	mov	r1, sl
 8083ece:	4643      	mov	r3, r8
 8083ed0:	4638      	mov	r0, r7
 8083ed2:	e9cd b600 	strd	fp, r6, [sp]
 8083ed6:	f7ff fcc9 	bl	808386c <FillTriangle>
	while(--PointCount)
 8083eda:	45a1      	cmp	r9, r4
 8083edc:	d1da      	bne.n	8083e94 <BSP_LCD_FillPolygon+0x78>
	FillTriangle(X_first, X2, X_center, Y_first, Y2, Y_center);
 8083ede:	9d03      	ldr	r5, [sp, #12]
 8083ee0:	463a      	mov	r2, r7
 8083ee2:	9c02      	ldr	r4, [sp, #8]
 8083ee4:	4651      	mov	r1, sl
 8083ee6:	462b      	mov	r3, r5
 8083ee8:	f8cd 8004 	str.w	r8, [sp, #4]
 8083eec:	4620      	mov	r0, r4
 8083eee:	f8cd b000 	str.w	fp, [sp]
 8083ef2:	f7ff fcbb 	bl	808386c <FillTriangle>
	FillTriangle(X_first, X_center, X2, Y_first, Y_center, Y2);
 8083ef6:	462b      	mov	r3, r5
 8083ef8:	4652      	mov	r2, sl
 8083efa:	4639      	mov	r1, r7
 8083efc:	4620      	mov	r0, r4
 8083efe:	e9cd 8b00 	strd	r8, fp, [sp]
 8083f02:	f7ff fcb3 	bl	808386c <FillTriangle>
	FillTriangle(X_center, X2, X_first, Y_center, Y2, Y_first);
 8083f06:	4643      	mov	r3, r8
 8083f08:	4622      	mov	r2, r4
 8083f0a:	4651      	mov	r1, sl
 8083f0c:	4638      	mov	r0, r7
 8083f0e:	e9cd b500 	strd	fp, r5, [sp]
 8083f12:	f7ff fcab 	bl	808386c <FillTriangle>
}
 8083f16:	b005      	add	sp, #20
 8083f18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08083f1c <BSP_LCD_FillEllipse>:
	rad2 = YRadius;
 8083f1c:	ee07 3a90 	vmov	s15, r3
 8083f20:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	rad1 = XRadius;
 8083f24:	ee07 2a90 	vmov	s15, r2
	int x = 0, y = -YRadius, err = 2-2*XRadius, e2;
 8083f28:	f1c2 0201 	rsb	r2, r2, #1
	rad1 = XRadius;
 8083f2c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
{
 8083f30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8083f34:	fa1f f980 	uxth.w	r9, r0
	int x = 0, y = -YRadius, err = 2-2*XRadius, e2;
 8083f38:	f04f 0a00 	mov.w	sl, #0
 8083f3c:	fa1f f881 	uxth.w	r8, r1
 8083f40:	425e      	negs	r6, r3
 8083f42:	0055      	lsls	r5, r2, #1
{
 8083f44:	ed2d 8b02 	vpush	{d8}
	k = (float)(rad2/rad1);
 8083f48:	ee87 8a27 	vdiv.f32	s16, s14, s15
 8083f4c:	e001      	b.n	8083f52 <BSP_LCD_FillEllipse+0x36>
	while (y <= 0);
 8083f4e:	2e00      	cmp	r6, #0
 8083f50:	dc37      	bgt.n	8083fc2 <BSP_LCD_FillEllipse+0xa6>
		BSP_LCD_DrawHLine((Xpos-(uint16_t)(x/k)), (Ypos+y), (2*(uint16_t)(x/k) + 1));
 8083f52:	ee07 aa90 	vmov	s15, sl
 8083f56:	b2b7      	uxth	r7, r6
 8083f58:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8083f5c:	eb07 0108 	add.w	r1, r7, r8
 8083f60:	b289      	uxth	r1, r1
 8083f62:	eec7 7a08 	vdiv.f32	s15, s14, s16
 8083f66:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8083f6a:	ee17 3a90 	vmov	r3, s15
 8083f6e:	b29c      	uxth	r4, r3
 8083f70:	ea4f 0b44 	mov.w	fp, r4, lsl #1
 8083f74:	eba9 0404 	sub.w	r4, r9, r4
 8083f78:	f10b 0b01 	add.w	fp, fp, #1
 8083f7c:	b2a4      	uxth	r4, r4
 8083f7e:	fa1f fb8b 	uxth.w	fp, fp
 8083f82:	4620      	mov	r0, r4
 8083f84:	465a      	mov	r2, fp
 8083f86:	f7ff fa4d 	bl	8083424 <BSP_LCD_DrawHLine>
		BSP_LCD_DrawHLine((Xpos-(uint16_t)(x/k)), (Ypos-y), (2*(uint16_t)(x/k) + 1));
 8083f8a:	eba8 0107 	sub.w	r1, r8, r7
 8083f8e:	465a      	mov	r2, fp
 8083f90:	4620      	mov	r0, r4
 8083f92:	b289      	uxth	r1, r1
 8083f94:	f7ff fa46 	bl	8083424 <BSP_LCD_DrawHLine>
		if (e2 <= x)
 8083f98:	45aa      	cmp	sl, r5
 8083f9a:	462a      	mov	r2, r5
 8083f9c:	db08      	blt.n	8083fb0 <BSP_LCD_FillEllipse+0x94>
			err += ++x*2+1;
 8083f9e:	f10a 0a01 	add.w	sl, sl, #1
 8083fa2:	eb05 024a 	add.w	r2, r5, sl, lsl #1
			if (-y == x && e2 <= y) e2 = 0;
 8083fa6:	eb1a 0f06 	cmn.w	sl, r6
			err += ++x*2+1;
 8083faa:	f102 0201 	add.w	r2, r2, #1
			if (-y == x && e2 <= y) e2 = 0;
 8083fae:	d00c      	beq.n	8083fca <BSP_LCD_FillEllipse+0xae>
		if (e2 > y) err += ++y*2+1;
 8083fb0:	42ae      	cmp	r6, r5
 8083fb2:	4615      	mov	r5, r2
 8083fb4:	dacb      	bge.n	8083f4e <BSP_LCD_FillEllipse+0x32>
 8083fb6:	3601      	adds	r6, #1
 8083fb8:	eb02 0546 	add.w	r5, r2, r6, lsl #1
 8083fbc:	3501      	adds	r5, #1
	while (y <= 0);
 8083fbe:	2e00      	cmp	r6, #0
 8083fc0:	ddc7      	ble.n	8083f52 <BSP_LCD_FillEllipse+0x36>
}
 8083fc2:	ecbd 8b02 	vpop	{d8}
 8083fc6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (-y == x && e2 <= y) e2 = 0;
 8083fca:	42ae      	cmp	r6, r5
 8083fcc:	f04f 0500 	mov.w	r5, #0
 8083fd0:	daee      	bge.n	8083fb0 <BSP_LCD_FillEllipse+0x94>
		if (e2 > y) err += ++y*2+1;
 8083fd2:	3601      	adds	r6, #1
 8083fd4:	eb02 0546 	add.w	r5, r2, r6, lsl #1
 8083fd8:	3501      	adds	r5, #1
 8083fda:	e7f0      	b.n	8083fbe <BSP_LCD_FillEllipse+0xa2>

08083fdc <BSP_LCD_MspInit>:
	__HAL_RCC_LTDC_CLK_ENABLE();
 8083fdc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
	HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 8083fe0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
	gpio_init_structure.Pull      = GPIO_NOPULL;
 8083fe4:	f04f 0c00 	mov.w	ip, #0
	__HAL_RCC_LTDC_CLK_ENABLE();
 8083fe8:	f2c4 0302 	movt	r3, #16386	; 0x4002
	HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 8083fec:	f2c4 0002 	movt	r0, #16386	; 0x4002
	__HAL_RCC_LTDC_CLK_ENABLE();
 8083ff0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8083ff2:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
{
 8083ff6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__HAL_RCC_LTDC_CLK_ENABLE();
 8083ffa:	645a      	str	r2, [r3, #68]	; 0x44
{
 8083ffc:	b08e      	sub	sp, #56	; 0x38
	__HAL_RCC_LTDC_CLK_ENABLE();
 8083ffe:	6c5a      	ldr	r2, [r3, #68]	; 0x44
	gpio_init_structure.Pin       = GPIO_PIN_4;
 8084000:	2610      	movs	r6, #16
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8084002:	2402      	movs	r4, #2
	gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 8084004:	250e      	movs	r5, #14
	__HAL_RCC_LTDC_CLK_ENABLE();
 8084006:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
	HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 808400a:	a909      	add	r1, sp, #36	; 0x24
	HAL_GPIO_Init(GPIOI, &gpio_init_structure);
 808400c:	f44f 5700 	mov.w	r7, #8192	; 0x2000
	gpio_init_structure.Pin       = GPIO_PIN_12;
 8084010:	f44f 5880 	mov.w	r8, #4096	; 0x1000
	__HAL_RCC_LTDC_CLK_ENABLE();
 8084014:	9200      	str	r2, [sp, #0]
 8084016:	9a00      	ldr	r2, [sp, #0]
	HAL_GPIO_Init(GPIOI, &gpio_init_structure);
 8084018:	f2c4 0702 	movt	r7, #16386	; 0x4002
	__HAL_RCC_DMA2D_CLK_ENABLE();
 808401c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808401e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8084022:	631a      	str	r2, [r3, #48]	; 0x30
 8084024:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084026:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
 808402a:	9201      	str	r2, [sp, #4]
 808402c:	9a01      	ldr	r2, [sp, #4]
	__HAL_RCC_GPIOE_CLK_ENABLE();
 808402e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084030:	4332      	orrs	r2, r6
 8084032:	631a      	str	r2, [r3, #48]	; 0x30
 8084034:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084036:	4032      	ands	r2, r6
 8084038:	9202      	str	r2, [sp, #8]
 808403a:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_GPIOG_CLK_ENABLE();
 808403c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808403e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8084042:	631a      	str	r2, [r3, #48]	; 0x30
 8084044:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084046:	f002 0240 	and.w	r2, r2, #64	; 0x40
 808404a:	9203      	str	r2, [sp, #12]
 808404c:	9a03      	ldr	r2, [sp, #12]
	__HAL_RCC_GPIOI_CLK_ENABLE();
 808404e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084050:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8084054:	631a      	str	r2, [r3, #48]	; 0x30
 8084056:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084058:	f402 7280 	and.w	r2, r2, #256	; 0x100
 808405c:	9204      	str	r2, [sp, #16]
 808405e:	9a04      	ldr	r2, [sp, #16]
	__HAL_RCC_GPIOJ_CLK_ENABLE();
 8084060:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084062:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8084066:	631a      	str	r2, [r3, #48]	; 0x30
 8084068:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808406a:	f402 7200 	and.w	r2, r2, #512	; 0x200
 808406e:	9205      	str	r2, [sp, #20]
 8084070:	9a05      	ldr	r2, [sp, #20]
	__HAL_RCC_GPIOK_CLK_ENABLE();
 8084072:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084074:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8084078:	631a      	str	r2, [r3, #48]	; 0x30
 808407a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808407c:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 8084080:	9206      	str	r2, [sp, #24]
 8084082:	9a06      	ldr	r2, [sp, #24]
	LCD_DISP_GPIO_CLK_ENABLE();
 8084084:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084086:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 808408a:	631a      	str	r2, [r3, #48]	; 0x30
 808408c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808408e:	f402 7280 	and.w	r2, r2, #256	; 0x100
 8084092:	9207      	str	r2, [sp, #28]
 8084094:	9a07      	ldr	r2, [sp, #28]
	LCD_BL_CTRL_GPIO_CLK_ENABLE();
 8084096:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084098:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 808409c:	631a      	str	r2, [r3, #48]	; 0x30
 808409e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
	gpio_init_structure.Pull      = GPIO_NOPULL;
 80840a0:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
	LCD_BL_CTRL_GPIO_CLK_ENABLE();
 80840a4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
	gpio_init_structure.Pin       = GPIO_PIN_4;
 80840a8:	9609      	str	r6, [sp, #36]	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 80840aa:	940a      	str	r4, [sp, #40]	; 0x28
	HAL_GPIO_Init(GPIOK, &gpio_init_structure);
 80840ac:	f44f 5620 	mov.w	r6, #10240	; 0x2800
	LCD_BL_CTRL_GPIO_CLK_ENABLE();
 80840b0:	9308      	str	r3, [sp, #32]
	gpio_init_structure.Speed     = GPIO_SPEED_FAST;
 80840b2:	940c      	str	r4, [sp, #48]	; 0x30
	HAL_GPIO_Init(GPIOK, &gpio_init_structure);
 80840b4:	f2c4 0602 	movt	r6, #16386	; 0x4002
	LCD_BL_CTRL_GPIO_CLK_ENABLE();
 80840b8:	9b08      	ldr	r3, [sp, #32]
	gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 80840ba:	950d      	str	r5, [sp, #52]	; 0x34
	HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 80840bc:	f001 ffd0 	bl	8086060 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 80840c0:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	gpio_init_structure.Alternate = GPIO_AF9_LTDC;
 80840c4:	2309      	movs	r3, #9
	HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 80840c6:	a909      	add	r1, sp, #36	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 80840c8:	940a      	str	r4, [sp, #40]	; 0x28
	HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 80840ca:	f2c4 0002 	movt	r0, #16386	; 0x4002
	gpio_init_structure.Alternate = GPIO_AF9_LTDC;
 80840ce:	930d      	str	r3, [sp, #52]	; 0x34
	gpio_init_structure.Pin       = GPIO_PIN_12;
 80840d0:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 80840d4:	f001 ffc4 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Pin       = GPIO_PIN_9 | GPIO_PIN_10 | \
 80840d8:	f44f 4366 	mov.w	r3, #58880	; 0xe600
	HAL_GPIO_Init(GPIOI, &gpio_init_structure);
 80840dc:	4638      	mov	r0, r7
 80840de:	a909      	add	r1, sp, #36	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 80840e0:	940a      	str	r4, [sp, #40]	; 0x28
	gpio_init_structure.Pin       = GPIO_PIN_9 | GPIO_PIN_10 | \
 80840e2:	9309      	str	r3, [sp, #36]	; 0x24
	gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 80840e4:	950d      	str	r5, [sp, #52]	; 0x34
	HAL_GPIO_Init(GPIOI, &gpio_init_structure);
 80840e6:	f001 ffbb 	bl	8086060 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOJ, &gpio_init_structure);
 80840ea:	f44f 5010 	mov.w	r0, #9216	; 0x2400
	gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | \
 80840ee:	f64e 73ff 	movw	r3, #61439	; 0xefff
	HAL_GPIO_Init(GPIOJ, &gpio_init_structure);
 80840f2:	a909      	add	r1, sp, #36	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 80840f4:	940a      	str	r4, [sp, #40]	; 0x28
	HAL_GPIO_Init(GPIOJ, &gpio_init_structure);
 80840f6:	f2c4 0002 	movt	r0, #16386	; 0x4002
	gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | \
 80840fa:	9309      	str	r3, [sp, #36]	; 0x24
	gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 80840fc:	950d      	str	r5, [sp, #52]	; 0x34
	HAL_GPIO_Init(GPIOJ, &gpio_init_structure);
 80840fe:	f001 ffaf 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_4 | \
 8084102:	23f7      	movs	r3, #247	; 0xf7
	HAL_GPIO_Init(GPIOK, &gpio_init_structure);
 8084104:	4630      	mov	r0, r6
 8084106:	a909      	add	r1, sp, #36	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8084108:	940a      	str	r4, [sp, #40]	; 0x28
	gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
 808410a:	2401      	movs	r4, #1
	gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_4 | \
 808410c:	9309      	str	r3, [sp, #36]	; 0x24
	gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 808410e:	950d      	str	r5, [sp, #52]	; 0x34
	HAL_GPIO_Init(GPIOK, &gpio_init_structure);
 8084110:	f001 ffa6 	bl	8086060 <HAL_GPIO_Init>
	HAL_GPIO_Init(LCD_DISP_GPIO_PORT, &gpio_init_structure);
 8084114:	4638      	mov	r0, r7
 8084116:	a909      	add	r1, sp, #36	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
 8084118:	e9cd 8409 	strd	r8, r4, [sp, #36]	; 0x24
	HAL_GPIO_Init(LCD_DISP_GPIO_PORT, &gpio_init_structure);
 808411c:	f001 ffa0 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Pin       = LCD_BL_CTRL_PIN;  /* LCD_BL_CTRL pin has to be manually controlled */
 8084120:	2308      	movs	r3, #8
	HAL_GPIO_Init(LCD_BL_CTRL_GPIO_PORT, &gpio_init_structure);
 8084122:	4630      	mov	r0, r6
 8084124:	a909      	add	r1, sp, #36	; 0x24
	gpio_init_structure.Pin       = LCD_BL_CTRL_PIN;  /* LCD_BL_CTRL pin has to be manually controlled */
 8084126:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
	HAL_GPIO_Init(LCD_BL_CTRL_GPIO_PORT, &gpio_init_structure);
 808412a:	f001 ff99 	bl	8086060 <HAL_GPIO_Init>
}
 808412e:	b00e      	add	sp, #56	; 0x38
 8084130:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08084134 <BSP_LCD_ClockConfig>:
	periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 8084134:	f24b 63cc 	movw	r3, #46796	; 0xb6cc
	periph_clk_init_struct.PLLSAI.PLLSAIR = RK043FN48H_FREQUENCY_DIVIDER;
 8084138:	2105      	movs	r1, #5
	periph_clk_init_struct.PLLSAIDivR = RCC_PLLSAIDIVR_4;
 808413a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
	periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 808413e:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
 8084142:	b430      	push	{r4, r5}
	periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 8084144:	2508      	movs	r5, #8
	periph_clk_init_struct.PLLSAI.PLLSAIN = 192;
 8084146:	24c0      	movs	r4, #192	; 0xc0
	HAL_RCCEx_PeriphCLKConfig(&periph_clk_init_struct);
 8084148:	4618      	mov	r0, r3
	periph_clk_init_struct.PLLSAI.PLLSAIR = RK043FN48H_FREQUENCY_DIVIDER;
 808414a:	61d9      	str	r1, [r3, #28]
	periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 808414c:	601d      	str	r5, [r3, #0]
	periph_clk_init_struct.PLLSAI.PLLSAIN = 192;
 808414e:	615c      	str	r4, [r3, #20]
	periph_clk_init_struct.PLLSAIDivR = RCC_PLLSAIDIVR_4;
 8084150:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8084152:	bc30      	pop	{r4, r5}
	HAL_RCCEx_PeriphCLKConfig(&periph_clk_init_struct);
 8084154:	f003 be02 	b.w	8087d5c <HAL_RCCEx_PeriphCLKConfig>

08084158 <BSP_LCD_Init>:
{    
 8084158:	b570      	push	{r4, r5, r6, lr}
	hLtdcHandler.Init.HorizontalSync = (RK043FN48H_HSYNC - 1);
 808415a:	f24d 7404 	movw	r4, #55044	; 0xd704
 808415e:	2228      	movs	r2, #40	; 0x28
	hLtdcHandler.Init.VerticalSync = (RK043FN48H_VSYNC - 1);
 8084160:	2309      	movs	r3, #9
	hLtdcHandler.Init.AccumulatedHBP = (RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
 8084162:	2035      	movs	r0, #53	; 0x35
	hLtdcHandler.Init.HorizontalSync = (RK043FN48H_HSYNC - 1);
 8084164:	f2c2 0402 	movt	r4, #8194	; 0x2002
	hLtdcHandler.Init.AccumulatedVBP = (RK043FN48H_VSYNC + RK043FN48H_VBP - 1);
 8084168:	210b      	movs	r1, #11
	hLtdcHandler.Init.AccumulatedActiveW = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
 808416a:	f240 2515 	movw	r5, #533	; 0x215
	hLtdcHandler.Init.AccumulatedActiveH = (RK043FN48H_HEIGHT + RK043FN48H_VSYNC + RK043FN48H_VBP - 1);
 808416e:	f240 161b 	movw	r6, #283	; 0x11b
	hLtdcHandler.Init.HorizontalSync = (RK043FN48H_HSYNC - 1);
 8084172:	6162      	str	r2, [r4, #20]
	hLtdcHandler.Init.TotalHeigh = (RK043FN48H_HEIGHT + RK043FN48H_VSYNC + RK043FN48H_VBP + RK043FN48H_VFP - 1);
 8084174:	f240 121d 	movw	r2, #285	; 0x11d
	hLtdcHandler.Init.VerticalSync = (RK043FN48H_VSYNC - 1);
 8084178:	61a3      	str	r3, [r4, #24]
	hLtdcHandler.Init.TotalWidth = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP + RK043FN48H_HFP - 1);
 808417a:	f240 2335 	movw	r3, #565	; 0x235
	hLtdcHandler.Init.AccumulatedHBP = (RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
 808417e:	61e0      	str	r0, [r4, #28]
	BSP_LCD_ClockConfig(&hLtdcHandler, NULL);
 8084180:	4620      	mov	r0, r4
	hLtdcHandler.Init.AccumulatedVBP = (RK043FN48H_VSYNC + RK043FN48H_VBP - 1);
 8084182:	6221      	str	r1, [r4, #32]
	BSP_LCD_ClockConfig(&hLtdcHandler, NULL);
 8084184:	2100      	movs	r1, #0
	hLtdcHandler.Init.TotalWidth = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP + RK043FN48H_HFP - 1);
 8084186:	e9c4 320b 	strd	r3, r2, [r4, #44]	; 0x2c
	hLtdcHandler.Init.AccumulatedActiveW = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
 808418a:	e9c4 5609 	strd	r5, r6, [r4, #36]	; 0x24
	BSP_LCD_ClockConfig(&hLtdcHandler, NULL);
 808418e:	f7ff ffd1 	bl	8084134 <BSP_LCD_ClockConfig>
	hLtdcHandler.Instance = LTDC;
 8084192:	f44f 42d0 	mov.w	r2, #26624	; 0x6800
	hLtdcHandler.Init.Backcolor.Blue = 0;
 8084196:	2300      	movs	r3, #0
	hLtdcHandler.LayerCfg->ImageWidth  = RK043FN48H_WIDTH;
 8084198:	f44f 75f0 	mov.w	r5, #480	; 0x1e0
	hLtdcHandler.LayerCfg->ImageHeight = RK043FN48H_HEIGHT;
 808419c:	f44f 7188 	mov.w	r1, #272	; 0x110
	hLtdcHandler.Instance = LTDC;
 80841a0:	f2c4 0201 	movt	r2, #16385	; 0x4001
	if(HAL_LTDC_GetState(&hLtdcHandler) == HAL_LTDC_STATE_RESET)
 80841a4:	4620      	mov	r0, r4
	hLtdcHandler.Init.Backcolor.Blue = 0;
 80841a6:	86a3      	strh	r3, [r4, #52]	; 0x34
	hLtdcHandler.Instance = LTDC;
 80841a8:	6022      	str	r2, [r4, #0]
	hLtdcHandler.Init.Backcolor.Green = 0;
 80841aa:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
	hLtdcHandler.LayerCfg->ImageHeight = RK043FN48H_HEIGHT;
 80841ae:	e9c4 5118 	strd	r5, r1, [r4, #96]	; 0x60
	hLtdcHandler.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 80841b2:	e9c4 3301 	strd	r3, r3, [r4, #4]
	hLtdcHandler.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 80841b6:	e9c4 3303 	strd	r3, r3, [r4, #12]
	if(HAL_LTDC_GetState(&hLtdcHandler) == HAL_LTDC_STATE_RESET)
 80841ba:	f002 fec3 	bl	8086f44 <HAL_LTDC_GetState>
 80841be:	b918      	cbnz	r0, 80841c8 <BSP_LCD_Init+0x70>
		BSP_LCD_MspInit(&hLtdcHandler, NULL);
 80841c0:	4601      	mov	r1, r0
 80841c2:	4620      	mov	r0, r4
 80841c4:	f7ff ff0a 	bl	8083fdc <BSP_LCD_MspInit>
	HAL_LTDC_Init(&hLtdcHandler);
 80841c8:	f24d 7004 	movw	r0, #55044	; 0xd704
 80841cc:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80841d0:	f002 fdd2 	bl	8086d78 <HAL_LTDC_Init>
	HAL_GPIO_WritePin(LCD_DISP_GPIO_PORT, LCD_DISP_PIN, GPIO_PIN_SET);
 80841d4:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80841d8:	2201      	movs	r2, #1
 80841da:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80841de:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80841e2:	f002 f95d 	bl	80864a0 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_PORT, LCD_BL_CTRL_PIN, GPIO_PIN_SET);
 80841e6:	f44f 5020 	mov.w	r0, #10240	; 0x2800
 80841ea:	2201      	movs	r2, #1
 80841ec:	2108      	movs	r1, #8
 80841ee:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80841f2:	f002 f955 	bl	80864a0 <HAL_GPIO_WritePin>
	BSP_SDRAM_Init();
 80841f6:	f001 f86d 	bl	80852d4 <BSP_SDRAM_Init>
	DrawProp[ActiveLayer].pFont = fonts;
 80841fa:	f24b 6270 	movw	r2, #46704	; 0xb670
 80841fe:	f24b 6374 	movw	r3, #46708	; 0xb674
 8084202:	f24b 3164 	movw	r1, #45924	; 0xb364
 8084206:	f2c2 0200 	movt	r2, #8192	; 0x2000
}
 808420a:	2000      	movs	r0, #0
	DrawProp[ActiveLayer].pFont = fonts;
 808420c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8084210:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8084214:	6812      	ldr	r2, [r2, #0]
 8084216:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 808421a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 808421e:	6099      	str	r1, [r3, #8]
}
 8084220:	bd70      	pop	{r4, r5, r6, pc}
 8084222:	bf00      	nop

08084224 <BSP_LCD_DMA2D_IRQHandler>:
 * @brief  Handles DMA2D interrupt request.
 * @param  None
 * @retval None
 */
void BSP_LCD_DMA2D_IRQHandler(void)
{
 8084224:	e7fe      	b.n	8084224 <BSP_LCD_DMA2D_IRQHandler>
 8084226:	bf00      	nop

08084228 <HAL_DMA2D_MspInit>:
 * @retval None
 */
void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
	/*##-1- Enable peripherals and GPIO Clocks #################################*/
	__HAL_RCC_DMA2D_CLK_ENABLE();
 8084228:	f44f 5360 	mov.w	r3, #14336	; 0x3800

	/*##-2- NVIC configuration  ################################################*/
	/* NVIC configuration for DMA2D transfer complete interrupt */
	HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 808422c:	2200      	movs	r2, #0
 808422e:	205a      	movs	r0, #90	; 0x5a
	__HAL_RCC_DMA2D_CLK_ENABLE();
 8084230:	f2c4 0302 	movt	r3, #16386	; 0x4002
	HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 8084234:	4611      	mov	r1, r2
{
 8084236:	b510      	push	{r4, lr}
	__HAL_RCC_DMA2D_CLK_ENABLE();
 8084238:	6b1c      	ldr	r4, [r3, #48]	; 0x30
{
 808423a:	b082      	sub	sp, #8
	__HAL_RCC_DMA2D_CLK_ENABLE();
 808423c:	f444 0400 	orr.w	r4, r4, #8388608	; 0x800000
 8084240:	631c      	str	r4, [r3, #48]	; 0x30
 8084242:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8084244:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8084248:	9301      	str	r3, [sp, #4]
 808424a:	9b01      	ldr	r3, [sp, #4]
	HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 808424c:	f001 fae0 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA2D_IRQn);
 8084250:	205a      	movs	r0, #90	; 0x5a
}
 8084252:	b002      	add	sp, #8
 8084254:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_NVIC_EnableIRQ(DMA2D_IRQn);
 8084258:	f001 bb16 	b.w	8085888 <HAL_NVIC_EnableIRQ>

0808425c <platform_read>:
 * @param  len       number of consecutive register to read
 *
 */
static int32_t platform_read(void *handle, uint8_t reg, uint8_t *bufp,
		uint16_t len)
{
 808425c:	b510      	push	{r4, lr}
	/* Read multiple command */
	reg |= 0x80;
	HAL_I2C_Mem_Read(handle, LIS2MDL_I2C_ADD, reg,
 808425e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
{
 8084262:	b084      	sub	sp, #16
	HAL_I2C_Mem_Read(handle, LIS2MDL_I2C_ADD, reg,
 8084264:	e9cd 2300 	strd	r2, r3, [sp]
 8084268:	9402      	str	r4, [sp, #8]
 808426a:	f041 0280 	orr.w	r2, r1, #128	; 0x80
 808426e:	2301      	movs	r3, #1
 8084270:	213d      	movs	r1, #61	; 0x3d
 8084272:	f002 fbcb 	bl	8086a0c <HAL_I2C_Mem_Read>
			I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);

	return 0;
}
 8084276:	2000      	movs	r0, #0
 8084278:	b004      	add	sp, #16
 808427a:	bd10      	pop	{r4, pc}

0808427c <platform_write>:
{
 808427c:	b510      	push	{r4, lr}
	HAL_I2C_Mem_Write(handle, LIS2MDL_I2C_ADD, reg,
 808427e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
{
 8084282:	b084      	sub	sp, #16
	HAL_I2C_Mem_Write(handle, LIS2MDL_I2C_ADD, reg,
 8084284:	e9cd 2300 	strd	r2, r3, [sp]
 8084288:	9402      	str	r4, [sp, #8]
 808428a:	f041 0280 	orr.w	r2, r1, #128	; 0x80
 808428e:	2301      	movs	r3, #1
 8084290:	213d      	movs	r1, #61	; 0x3d
 8084292:	f002 fad7 	bl	8086844 <HAL_I2C_Mem_Write>
}
 8084296:	2000      	movs	r0, #0
 8084298:	b004      	add	sp, #16
 808429a:	bd10      	pop	{r4, pc}

0808429c <BSP_MAG_ReadValues>:
	if (magSensorEnabled)
 808429c:	f24b 739c 	movw	r3, #47004	; 0xb79c
 80842a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80842a4:	781b      	ldrb	r3, [r3, #0]
 80842a6:	b90b      	cbnz	r3, 80842ac <BSP_MAG_ReadValues+0x10>
	else status = MAG_ERROR;
 80842a8:	2001      	movs	r0, #1
}
 80842aa:	4770      	bx	lr
{
 80842ac:	b530      	push	{r4, r5, lr}
 80842ae:	4605      	mov	r5, r0
 80842b0:	b085      	sub	sp, #20
  __ASM volatile ("cpsid i" : : : "memory");
 80842b2:	b672      	cpsid	i
		lis2mdl_mag_data_ready_get(&magCtx, &reg);
 80842b4:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 80842b8:	f10d 0107 	add.w	r1, sp, #7
 80842bc:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80842c0:	f7fc feaa 	bl	8081018 <lis2mdl_mag_data_ready_get>
		if (reg)
 80842c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80842c8:	b91b      	cbnz	r3, 80842d2 <BSP_MAG_ReadValues+0x36>
			status =  MAG_NO_DATA;
 80842ca:	2003      	movs	r0, #3
  __ASM volatile ("cpsie i" : : : "memory");
 80842cc:	b662      	cpsie	i
}
 80842ce:	b005      	add	sp, #20
 80842d0:	bd30      	pop	{r4, r5, pc}
			lis2mdl_magnetic_raw_get(&magCtx, data_raw_magnetic.u8bit);
 80842d2:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
			memset(data_raw_magnetic.u8bit, 0x00, 3 * sizeof(int16_t));
 80842d6:	2400      	movs	r4, #0
			lis2mdl_magnetic_raw_get(&magCtx, data_raw_magnetic.u8bit);
 80842d8:	a902      	add	r1, sp, #8
 80842da:	f2c2 0002 	movt	r0, #8194	; 0x2002
			memset(data_raw_magnetic.u8bit, 0x00, 3 * sizeof(int16_t));
 80842de:	f8ad 400c 	strh.w	r4, [sp, #12]
 80842e2:	9402      	str	r4, [sp, #8]
			lis2mdl_magnetic_raw_get(&magCtx, data_raw_magnetic.u8bit);
 80842e4:	f7fc fea8 	bl	8081038 <lis2mdl_magnetic_raw_get>
			magnetic->x = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[0]);
 80842e8:	f9bd 0008 	ldrsh.w	r0, [sp, #8]
 80842ec:	f7fc fde2 	bl	8080eb4 <lis2mdl_from_lsb_to_mgauss>
			magnetic->y = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[1]);
 80842f0:	f9bd 000a 	ldrsh.w	r0, [sp, #10]
			magnetic->x = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[0]);
 80842f4:	ed85 0a00 	vstr	s0, [r5]
			magnetic->y = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[1]);
 80842f8:	f7fc fddc 	bl	8080eb4 <lis2mdl_from_lsb_to_mgauss>
			magnetic->z = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[2]);
 80842fc:	f9bd 000c 	ldrsh.w	r0, [sp, #12]
			magnetic->y = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[1]);
 8084300:	ed85 0a01 	vstr	s0, [r5, #4]
			magnetic->z = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[2]);
 8084304:	f7fc fdd6 	bl	8080eb4 <lis2mdl_from_lsb_to_mgauss>
	uint8_t status= MAG_OK;
 8084308:	4620      	mov	r0, r4
			magnetic->z = lis2mdl_from_lsb_to_mgauss( data_raw_magnetic.i16bit[2]);
 808430a:	ed85 0a02 	vstr	s0, [r5, #8]
 808430e:	b662      	cpsie	i
}
 8084310:	b005      	add	sp, #20
 8084312:	bd30      	pop	{r4, r5, pc}

08084314 <BSP_MAG_ReadTemperature>:
	if (magSensorEnabled)
 8084314:	f24b 739c 	movw	r3, #47004	; 0xb79c
 8084318:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808431c:	781b      	ldrb	r3, [r3, #0]
 808431e:	b90b      	cbnz	r3, 8084324 <BSP_MAG_ReadTemperature+0x10>
	else status = MAG_ERROR;
 8084320:	2001      	movs	r0, #1
}
 8084322:	4770      	bx	lr
{
 8084324:	b530      	push	{r4, r5, lr}
 8084326:	4605      	mov	r5, r0
 8084328:	b083      	sub	sp, #12
  __ASM volatile ("cpsid i" : : : "memory");
 808432a:	b672      	cpsid	i
		lis2mdl_mag_data_ready_get(&magCtx, &reg);
 808432c:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 8084330:	f10d 0103 	add.w	r1, sp, #3
 8084334:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084338:	f7fc fe6e 	bl	8081018 <lis2mdl_mag_data_ready_get>
		if (reg)
 808433c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8084340:	b91b      	cbnz	r3, 808434a <BSP_MAG_ReadTemperature+0x36>
			status =  MAG_NO_DATA;
 8084342:	2003      	movs	r0, #3
  __ASM volatile ("cpsie i" : : : "memory");
 8084344:	b662      	cpsie	i
}
 8084346:	b003      	add	sp, #12
 8084348:	bd30      	pop	{r4, r5, pc}
			lis2mdl_temperature_raw_get(&magCtx, data_raw_temperature.u8bit);
 808434a:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
			memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
 808434e:	2400      	movs	r4, #0
			lis2mdl_temperature_raw_get(&magCtx, data_raw_temperature.u8bit);
 8084350:	a901      	add	r1, sp, #4
 8084352:	f2c2 0002 	movt	r0, #8194	; 0x2002
			memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
 8084356:	f8ad 4004 	strh.w	r4, [sp, #4]
			lis2mdl_temperature_raw_get(&magCtx, data_raw_temperature.u8bit);
 808435a:	f7fc fe77 	bl	808104c <lis2mdl_temperature_raw_get>
			*temperature_degC = lis2mdl_from_lsb_to_celsius(data_raw_temperature.i16bit);
 808435e:	f9bd 0004 	ldrsh.w	r0, [sp, #4]
 8084362:	f7fc fdb1 	bl	8080ec8 <lis2mdl_from_lsb_to_celsius>
	uint8_t status= MAG_OK;
 8084366:	4620      	mov	r0, r4
			*temperature_degC = lis2mdl_from_lsb_to_celsius(data_raw_temperature.i16bit);
 8084368:	ed85 0a00 	vstr	s0, [r5]
 808436c:	b662      	cpsie	i
}
 808436e:	b003      	add	sp, #12
 8084370:	bd30      	pop	{r4, r5, pc}
 8084372:	bf00      	nop

08084374 <BSP_MAG_MspInit>:
 *           - Peripheral's GPIO Configuration
 *           - NVIC configuration for QSPI interrupt
 * @retval None
 */
__weak void BSP_MAG_MspInit(void)
{
 8084374:	b5f0      	push	{r4, r5, r6, r7, lr}
	GPIO_InitTypeDef gpio_init_structure;

	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8084376:	f44f 5460 	mov.w	r4, #14336	; 0x3800
	/*##-2- Configure peripheral GPIO ##########################################*/
	/* KEYS CS GPIO pin configuration  */
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
	gpio_init_structure.Mode = GPIO_MODE_AF_OD;
	gpio_init_structure.Pull = GPIO_PULLUP;
	gpio_init_structure.Speed = GPIO_SPEED_FAST;
 808437a:	2702      	movs	r7, #2
	gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 808437c:	f44f 6680 	mov.w	r6, #1024	; 0x400
{
 8084380:	b089      	sub	sp, #36	; 0x24
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8084382:	f2c4 0402 	movt	r4, #16386	; 0x4002
	gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 8084386:	2212      	movs	r2, #18
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8084388:	f2c4 0602 	movt	r6, #16386	; 0x4002
	gpio_init_structure.Pull = GPIO_PULLUP;
 808438c:	2001      	movs	r0, #1
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 808438e:	6b23      	ldr	r3, [r4, #48]	; 0x30
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
 8084390:	f44f 7580 	mov.w	r5, #256	; 0x100
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 8084394:	a903      	add	r1, sp, #12
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 8084396:	f043 0302 	orr.w	r3, r3, #2
 808439a:	6323      	str	r3, [r4, #48]	; 0x30
 808439c:	6b23      	ldr	r3, [r4, #48]	; 0x30
	gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 808439e:	9204      	str	r2, [sp, #16]
	gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
 80843a0:	2204      	movs	r2, #4
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 80843a2:	403b      	ands	r3, r7
	gpio_init_structure.Pull = GPIO_PULLUP;
 80843a4:	9005      	str	r0, [sp, #20]
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 80843a6:	4630      	mov	r0, r6
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
 80843a8:	9503      	str	r5, [sp, #12]
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 80843aa:	9301      	str	r3, [sp, #4]
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);

	/* IT DRDY GPIO pin configuration  */
	gpio_init_structure.Pin       = MAG_DRDY_PIN;
	gpio_init_structure.Pull 	  = GPIO_NOPULL;
 80843ac:	2500      	movs	r5, #0
	DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 80843ae:	9b01      	ldr	r3, [sp, #4]
	gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
 80843b0:	e9cd 7206 	strd	r7, r2, [sp, #24]
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 80843b4:	f001 fe54 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
 80843b8:	f44f 7300 	mov.w	r3, #512	; 0x200
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 80843bc:	4630      	mov	r0, r6
 80843be:	a903      	add	r1, sp, #12
	gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
 80843c0:	9303      	str	r3, [sp, #12]
	HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 80843c2:	f001 fe4d 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Speed 	  = GPIO_SPEED_FAST;
	gpio_init_structure.Mode 	  = GPIO_MODE_IT_RISING;
 80843c6:	462b      	mov	r3, r5
	HAL_GPIO_Init(MAG_DRDY_GPIO_PORT, &gpio_init_structure);
 80843c8:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
	gpio_init_structure.Pin       = MAG_DRDY_PIN;
 80843cc:	2240      	movs	r2, #64	; 0x40
	HAL_GPIO_Init(MAG_DRDY_GPIO_PORT, &gpio_init_structure);
 80843ce:	a903      	add	r1, sp, #12
	gpio_init_structure.Mode 	  = GPIO_MODE_IT_RISING;
 80843d0:	f2c1 0311 	movt	r3, #4113	; 0x1011
	HAL_GPIO_Init(MAG_DRDY_GPIO_PORT, &gpio_init_structure);
 80843d4:	f2c4 0002 	movt	r0, #16386	; 0x4002
	gpio_init_structure.Speed 	  = GPIO_SPEED_FAST;
 80843d8:	9706      	str	r7, [sp, #24]
	gpio_init_structure.Pull 	  = GPIO_NOPULL;
 80843da:	9505      	str	r5, [sp, #20]
	gpio_init_structure.Pin       = MAG_DRDY_PIN;
 80843dc:	e9cd 2303 	strd	r2, r3, [sp, #12]
	HAL_GPIO_Init(MAG_DRDY_GPIO_PORT, &gpio_init_structure);
 80843e0:	f001 fe3e 	bl	8086060 <HAL_GPIO_Init>
	//	HAL_NVIC_EnableIRQ(I2C1_  SPI2_IRQn);


	/*** Configure the I2C peripheral ***/
	/* Enable I2C clock */
	DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 80843e4:	6c23      	ldr	r3, [r4, #64]	; 0x40

	/* Release the I2C peripheral clock reset */
	DISCOVERY_EXT_I2Cx_RELEASE_RESET();

	/* Enable and set I2Cx Interrupt to a lower priority */
	HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 80843e6:	462a      	mov	r2, r5
 80843e8:	210f      	movs	r1, #15
	DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 80843ea:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
	HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 80843ee:	201f      	movs	r0, #31
	DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 80843f0:	6423      	str	r3, [r4, #64]	; 0x40
 80843f2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80843f4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80843f8:	9302      	str	r3, [sp, #8]
 80843fa:	9b02      	ldr	r3, [sp, #8]
	DISCOVERY_EXT_I2Cx_FORCE_RESET();
 80843fc:	6a23      	ldr	r3, [r4, #32]
 80843fe:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8084402:	6223      	str	r3, [r4, #32]
	DISCOVERY_EXT_I2Cx_RELEASE_RESET();
 8084404:	6a23      	ldr	r3, [r4, #32]
 8084406:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 808440a:	6223      	str	r3, [r4, #32]
	HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 808440c:	f001 fa00 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
 8084410:	201f      	movs	r0, #31
 8084412:	f001 fa39 	bl	8085888 <HAL_NVIC_EnableIRQ>

	/* Enable and set I2Cx Interrupt to a lower priority */
	HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x0F, 0);
 8084416:	462a      	mov	r2, r5
 8084418:	210f      	movs	r1, #15
 808441a:	2020      	movs	r0, #32
 808441c:	f001 f9f8 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
 8084420:	2020      	movs	r0, #32
 8084422:	f001 fa31 	bl	8085888 <HAL_NVIC_EnableIRQ>

	/* Enable and set EXTI9-5 Interrupt to the lowest priority */
	HAL_NVIC_SetPriority(MAG_DRDY_EXTI_IRQn, 0xFF, 0);
 8084426:	462a      	mov	r2, r5
 8084428:	21ff      	movs	r1, #255	; 0xff
 808442a:	2017      	movs	r0, #23
 808442c:	f001 f9f0 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(MAG_DRDY_EXTI_IRQn);
 8084430:	2017      	movs	r0, #23
 8084432:	f001 fa29 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 8084436:	b009      	add	sp, #36	; 0x24
 8084438:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808443a:	bf00      	nop

0808443c <BSP_MAG_Init>:
{ 
 808443c:	b5f0      	push	{r4, r5, r6, r7, lr}
	I2CHandle.Instance = MAG_I2Cx;
 808443e:	f24b 7450 	movw	r4, #46928	; 0xb750
 8084442:	f44f 45a8 	mov.w	r5, #21504	; 0x5400
{ 
 8084446:	b083      	sub	sp, #12
	I2CHandle.Instance = MAG_I2Cx;
 8084448:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808444c:	f2c4 0500 	movt	r5, #16384	; 0x4000
	if (HAL_I2C_DeInit(&I2CHandle) != HAL_OK)
 8084450:	4620      	mov	r0, r4
	I2CHandle.Instance = MAG_I2Cx;
 8084452:	6025      	str	r5, [r4, #0]
	if (HAL_I2C_DeInit(&I2CHandle) != HAL_OK)
 8084454:	f002 f9dc 	bl	8086810 <HAL_I2C_DeInit>
 8084458:	b118      	cbz	r0, 8084462 <BSP_MAG_Init+0x26>
		return MAG_ERROR;
 808445a:	2401      	movs	r4, #1
}
 808445c:	4620      	mov	r0, r4
 808445e:	b003      	add	sp, #12
 8084460:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8084462:	4606      	mov	r6, r0
	BSP_MAG_MspInit();
 8084464:	f7ff ff86 	bl	8084374 <BSP_MAG_MspInit>
	I2CHandle.Init.Timing          = MAG_I2C_TIMING;
 8084468:	f242 7232 	movw	r2, #10034	; 0x2732
	I2CHandle.Init.OwnAddress1     = 0xFF;
 808446c:	23ff      	movs	r3, #255	; 0xff
	I2CHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
 808446e:	2701      	movs	r7, #1
	if (HAL_I2C_Init(&I2CHandle) != HAL_OK)
 8084470:	4620      	mov	r0, r4
	I2CHandle.Init.Timing          = MAG_I2C_TIMING;
 8084472:	f2c4 0291 	movt	r2, #16529	; 0x4091
	I2CHandle.Instance             = MAG_I2Cx;
 8084476:	6025      	str	r5, [r4, #0]
	I2CHandle.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8084478:	6126      	str	r6, [r4, #16]
	I2CHandle.Init.OwnAddress2     = 0xFF;
 808447a:	6163      	str	r3, [r4, #20]
	I2CHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
 808447c:	60e7      	str	r7, [r4, #12]
	I2CHandle.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
 808447e:	e9c4 6607 	strd	r6, r6, [r4, #28]
	I2CHandle.Init.OwnAddress1     = 0xFF;
 8084482:	e9c4 2301 	strd	r2, r3, [r4, #4]
	if (HAL_I2C_Init(&I2CHandle) != HAL_OK)
 8084486:	f002 f96b 	bl	8086760 <HAL_I2C_Init>
 808448a:	2800      	cmp	r0, #0
 808448c:	d1e5      	bne.n	808445a <BSP_MAG_Init+0x1e>
	magCtx.write_reg = platform_write;
 808448e:	f24d 75ac 	movw	r5, #55212	; 0xd7ac
 8084492:	f244 227d 	movw	r2, #17021	; 0x427d
	magCtx.read_reg = platform_read;
 8084496:	f244 235d 	movw	r3, #16989	; 0x425d
	lis2mdl_device_id_get(&magCtx, &whoamI);
 808449a:	f10d 0106 	add.w	r1, sp, #6
	magCtx.write_reg = platform_write;
 808449e:	f2c2 0502 	movt	r5, #8194	; 0x2002
 80844a2:	f6c0 0208 	movt	r2, #2056	; 0x808
	magCtx.read_reg = platform_read;
 80844a6:	f6c0 0308 	movt	r3, #2056	; 0x808
	lis2mdl_device_id_get(&magCtx, &whoamI);
 80844aa:	4628      	mov	r0, r5
	magCtx.handle = &I2CHandle;
 80844ac:	60ac      	str	r4, [r5, #8]
	magCtx.read_reg = platform_read;
 80844ae:	e9c5 2300 	strd	r2, r3, [r5]
	lis2mdl_device_id_get(&magCtx, &whoamI);
 80844b2:	f7fc fdd5 	bl	8081060 <lis2mdl_device_id_get>
	if (whoamI != LIS2MDL_ID)
 80844b6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80844ba:	2b40      	cmp	r3, #64	; 0x40
 80844bc:	d1cd      	bne.n	808445a <BSP_MAG_Init+0x1e>
	lis2mdl_reset_set(&magCtx, PROPERTY_ENABLE);
 80844be:	4639      	mov	r1, r7
 80844c0:	4628      	mov	r0, r5
		lis2mdl_reset_get(&magCtx, &rst);
 80844c2:	462e      	mov	r6, r5
	lis2mdl_reset_set(&magCtx, PROPERTY_ENABLE);
 80844c4:	f7fc fdd6 	bl	8081074 <lis2mdl_reset_set>
		lis2mdl_reset_get(&magCtx, &rst);
 80844c8:	f10d 0107 	add.w	r1, sp, #7
 80844cc:	4630      	mov	r0, r6
 80844ce:	f7fc fdeb 	bl	80810a8 <lis2mdl_reset_get>
	} while (rst);
 80844d2:	f89d 4007 	ldrb.w	r4, [sp, #7]
 80844d6:	2c00      	cmp	r4, #0
 80844d8:	d1f6      	bne.n	80844c8 <BSP_MAG_Init+0x8c>
	lis2mdl_block_data_update_set(&magCtx, PROPERTY_ENABLE);
 80844da:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 80844de:	2101      	movs	r1, #1
 80844e0:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80844e4:	f7fc fd7e 	bl	8080fe4 <lis2mdl_block_data_update_set>
	lis2mdl_data_rate_set(&magCtx, LIS2MDL_ODR_100Hz);
 80844e8:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 80844ec:	2103      	movs	r1, #3
 80844ee:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80844f2:	f7fc fd0f 	bl	8080f14 <lis2mdl_data_rate_set>
	lis2mdl_set_rst_mode_set(&magCtx, LIS2MDL_SENS_OFF_CANC_EVERY_ODR);
 80844f6:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 80844fa:	2101      	movs	r1, #1
 80844fc:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084500:	f7fc fd56 	bl	8080fb0 <lis2mdl_set_rst_mode_set>
	lis2mdl_offset_temp_comp_set(&magCtx, PROPERTY_ENABLE);
 8084504:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 8084508:	2101      	movs	r1, #1
 808450a:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808450e:	f7fc fd1b 	bl	8080f48 <lis2mdl_offset_temp_comp_set>
	lis2mdl_low_pass_bandwidth_set(&magCtx, LIS2MDL_ODR_DIV_4);
 8084512:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 8084516:	2101      	movs	r1, #1
 8084518:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808451c:	f7fc fd2e 	bl	8080f7c <lis2mdl_low_pass_bandwidth_set>
	lis2mdl_operating_mode_set(&magCtx, LIS2MDL_CONTINUOUS_MODE);
 8084520:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 8084524:	4621      	mov	r1, r4
 8084526:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808452a:	f7fc fcd9 	bl	8080ee0 <lis2mdl_operating_mode_set>
	lis2mdl_drdy_on_pin_set(&magCtx, PROPERTY_ENABLE);
 808452e:	f24d 70ac 	movw	r0, #55212	; 0xd7ac
 8084532:	2101      	movs	r1, #1
 8084534:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084538:	f7fc fdc6 	bl	80810c8 <lis2mdl_drdy_on_pin_set>
	magSensorEnabled=1;
 808453c:	f24b 739c 	movw	r3, #47004	; 0xb79c
 8084540:	2201      	movs	r2, #1
 8084542:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8084546:	701a      	strb	r2, [r3, #0]
	return MAG_OK;
 8084548:	e788      	b.n	808445c <BSP_MAG_Init+0x20>
 808454a:	bf00      	nop

0808454c <BSP_PRESSURE_ReadCompensatedValues>:
uint8_t BSP_PRESSURE_ReadCompensatedValues(float *pressure, float *temperature)
{
	uint8_t status= PRESSURE_OK;
	float humidity;

	if (pressureSensorEnabled)
 808454c:	f64b 0304 	movw	r3, #47108	; 0xb804
 8084550:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
 8084554:	b570      	push	{r4, r5, r6, lr}
	if (pressureSensorEnabled)
 8084556:	781b      	ldrb	r3, [r3, #0]
{
 8084558:	b082      	sub	sp, #8
 808455a:	4606      	mov	r6, r0
	if (pressureSensorEnabled)
 808455c:	b1d3      	cbz	r3, 8084594 <BSP_PRESSURE_ReadCompensatedValues+0x48>
 808455e:	460d      	mov	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
 8084560:	b672      	cpsid	i
		__disable_irq(); // Set PRIMASK

		/*
		 * Read output only if new value is available
		 */
		while (bmp280_is_measuring(&PressureHandle));
 8084562:	f24d 74bc 	movw	r4, #55228	; 0xd7bc
 8084566:	f2c2 0402 	movt	r4, #8194	; 0x2002
 808456a:	4620      	mov	r0, r4
 808456c:	f7fc f944 	bl	80807f8 <bmp280_is_measuring>
 8084570:	2800      	cmp	r0, #0
 8084572:	d1fa      	bne.n	808456a <BSP_PRESSURE_ReadCompensatedValues+0x1e>

		if (bmp280_read_float(&PressureHandle, temperature, pressure, &humidity)==false)
 8084574:	f24d 70bc 	movw	r0, #55228	; 0xd7bc
 8084578:	4632      	mov	r2, r6
 808457a:	4629      	mov	r1, r5
 808457c:	ab01      	add	r3, sp, #4
 808457e:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084582:	f7fc fb19 	bl	8080bb8 <bmp280_read_float>
		{
			status =  PRESSURE_NO_DATA;
 8084586:	2800      	cmp	r0, #0
 8084588:	bf14      	ite	ne
 808458a:	2000      	movne	r0, #0
 808458c:	2003      	moveq	r0, #3
  __ASM volatile ("cpsie i" : : : "memory");
 808458e:	b662      	cpsie	i
		*temperature=0.0;
		status =  PRESSURE_NO_DATA;
	}

	return status;
}
 8084590:	b002      	add	sp, #8
 8084592:	bd70      	pop	{r4, r5, r6, pc}
		*pressure=0.0;
 8084594:	2300      	movs	r3, #0
		status =  PRESSURE_NO_DATA;
 8084596:	2003      	movs	r0, #3
		*pressure=0.0;
 8084598:	6033      	str	r3, [r6, #0]
		*temperature=0.0;
 808459a:	600b      	str	r3, [r1, #0]
}
 808459c:	b002      	add	sp, #8
 808459e:	bd70      	pop	{r4, r5, r6, pc}

080845a0 <BSP_PRESSURE_MspInit>:
{
	GPIO_InitTypeDef gpio_init_structure;

	/*##-1- Enable peripherals and GPIO Clocks #################################*/
	/* Enable the Keys (SPI) interface clock */
	PRESSURE_CLK_ENABLE();
 80845a0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
	/*##-2- Configure peripheral GPIO ##########################################*/
	/* PRESSURE CS GPIO pin configuration  */
	gpio_init_structure.Pin       = PRESSURE_CS_PIN;
	gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
	gpio_init_structure.Pull      = GPIO_NOPULL;
	gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 80845a4:	f04f 0c03 	mov.w	ip, #3
	PRESSURE_CLK_ENABLE();
 80845a8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80845ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80845ae:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
{
 80845b2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	PRESSURE_CLK_ENABLE();
 80845b6:	641a      	str	r2, [r3, #64]	; 0x40
{
 80845b8:	b08a      	sub	sp, #40	; 0x28
	PRESSURE_CLK_ENABLE();
 80845ba:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
 80845bc:	f04f 0801 	mov.w	r8, #1
	gpio_init_structure.Pin       = PRESSURE_CS_PIN;
 80845c0:	f44f 7780 	mov.w	r7, #256	; 0x100
	HAL_GPIO_Init(PRESSURE_CS_GPIO_PORT, &gpio_init_structure);
 80845c4:	2500      	movs	r5, #0
	PRESSURE_CLK_ENABLE();
 80845c6:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
	gpio_init_structure.Pull      = GPIO_NOPULL;
 80845ca:	2400      	movs	r4, #0
	HAL_GPIO_Init(PRESSURE_CS_GPIO_PORT, &gpio_init_structure);
 80845cc:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80845d0:	a905      	add	r1, sp, #20
	PRESSURE_CLK_ENABLE();
 80845d2:	9200      	str	r2, [sp, #0]
 80845d4:	9a00      	ldr	r2, [sp, #0]
	HAL_GPIO_Init(PRESSURE_CS_GPIO_PORT, &gpio_init_structure);
 80845d6:	4628      	mov	r0, r5
	PRESSURE_CS_GPIO_CLK_ENABLE();
 80845d8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80845da:	ea42 0208 	orr.w	r2, r2, r8
 80845de:	631a      	str	r2, [r3, #48]	; 0x30
 80845e0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80845e2:	ea02 0208 	and.w	r2, r2, r8
 80845e6:	9201      	str	r2, [sp, #4]
 80845e8:	9a01      	ldr	r2, [sp, #4]
	PRESSURE_CLK_GPIO_CLK_ENABLE();
 80845ea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80845ec:	433a      	orrs	r2, r7
 80845ee:	631a      	str	r2, [r3, #48]	; 0x30
 80845f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80845f2:	403a      	ands	r2, r7
 80845f4:	9202      	str	r2, [sp, #8]
 80845f6:	9a02      	ldr	r2, [sp, #8]
	PRESSURE_MISO_GPIO_CLK_ENABLE();
 80845f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80845fa:	f042 0202 	orr.w	r2, r2, #2
 80845fe:	631a      	str	r2, [r3, #48]	; 0x30
 8084600:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084602:	f002 0202 	and.w	r2, r2, #2
 8084606:	9203      	str	r2, [sp, #12]
 8084608:	9a03      	ldr	r2, [sp, #12]
	PRESSURE_MOSI_GPIO_CLK_ENABLE();
 808460a:	6b1e      	ldr	r6, [r3, #48]	; 0x30
 808460c:	f046 0602 	orr.w	r6, r6, #2
 8084610:	631e      	str	r6, [r3, #48]	; 0x30
	HAL_GPIO_Init(PRESSURE_CLK_GPIO_PORT, &gpio_init_structure);

	/* PRESSURE MISO GPIO pin configuration  */
	gpio_init_structure.Pin       = PRESSURE_MISO_PIN;
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
	HAL_GPIO_Init(PRESSURE_MISO_GPIO_PORT, &gpio_init_structure);
 8084612:	f44f 6680 	mov.w	r6, #1024	; 0x400
	PRESSURE_MOSI_GPIO_CLK_ENABLE();
 8084616:	6b1b      	ldr	r3, [r3, #48]	; 0x30
	gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 8084618:	f8cd c020 	str.w	ip, [sp, #32]
	HAL_GPIO_Init(PRESSURE_MISO_GPIO_PORT, &gpio_init_structure);
 808461c:	f2c4 0602 	movt	r6, #16386	; 0x4002
	PRESSURE_MOSI_GPIO_CLK_ENABLE();
 8084620:	f003 0302 	and.w	r3, r3, #2
	gpio_init_structure.Pin       = PRESSURE_CS_PIN;
 8084624:	9705      	str	r7, [sp, #20]
	PRESSURE_MOSI_GPIO_CLK_ENABLE();
 8084626:	9304      	str	r3, [sp, #16]
 8084628:	9b04      	ldr	r3, [sp, #16]
	gpio_init_structure.Pull      = GPIO_NOPULL;
 808462a:	e9cd 8406 	strd	r8, r4, [sp, #24]
	HAL_GPIO_Init(PRESSURE_CS_GPIO_PORT, &gpio_init_structure);
 808462e:	f001 fd17 	bl	8086060 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(PRESSURE_CS_GPIO_PORT, PRESSURE_CS_PIN, GPIO_PIN_SET );
 8084632:	4642      	mov	r2, r8
 8084634:	4639      	mov	r1, r7
 8084636:	4628      	mov	r0, r5
 8084638:	f001 ff32 	bl	80864a0 <HAL_GPIO_WritePin>
	HAL_GPIO_Init(PRESSURE_CLK_GPIO_PORT, &gpio_init_structure);
 808463c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
 8084640:	2505      	movs	r5, #5
	gpio_init_structure.Pin       = PRESSURE_CLK_PIN;
 8084642:	2302      	movs	r3, #2
	HAL_GPIO_Init(PRESSURE_CLK_GPIO_PORT, &gpio_init_structure);
 8084644:	a905      	add	r1, sp, #20
 8084646:	f2c4 0002 	movt	r0, #16386	; 0x4002
	gpio_init_structure.Pull      = GPIO_NOPULL;
 808464a:	9407      	str	r4, [sp, #28]
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
 808464c:	9509      	str	r5, [sp, #36]	; 0x24
	gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 808464e:	e9cd 3305 	strd	r3, r3, [sp, #20]
	HAL_GPIO_Init(PRESSURE_CLK_GPIO_PORT, &gpio_init_structure);
 8084652:	f001 fd05 	bl	8086060 <HAL_GPIO_Init>
	gpio_init_structure.Pin       = PRESSURE_MISO_PIN;
 8084656:	f44f 4380 	mov.w	r3, #16384	; 0x4000
	HAL_GPIO_Init(PRESSURE_MISO_GPIO_PORT, &gpio_init_structure);
 808465a:	4630      	mov	r0, r6
 808465c:	a905      	add	r1, sp, #20
	gpio_init_structure.Pin       = PRESSURE_MISO_PIN;
 808465e:	9305      	str	r3, [sp, #20]
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
 8084660:	9509      	str	r5, [sp, #36]	; 0x24
	HAL_GPIO_Init(PRESSURE_MISO_GPIO_PORT, &gpio_init_structure);
 8084662:	f001 fcfd 	bl	8086060 <HAL_GPIO_Init>

	/* PRESSURE MISO GPIO pin configuration  */
	gpio_init_structure.Pin       = PRESSURE_MOSI_PIN;
 8084666:	f44f 4300 	mov.w	r3, #32768	; 0x8000
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
	HAL_GPIO_Init(PRESSURE_MOSI_GPIO_PORT, &gpio_init_structure);
 808466a:	4630      	mov	r0, r6
 808466c:	a905      	add	r1, sp, #20
	gpio_init_structure.Alternate = GPIO_AF5_SPI2;
 808466e:	9509      	str	r5, [sp, #36]	; 0x24
	gpio_init_structure.Pin       = PRESSURE_MOSI_PIN;
 8084670:	9305      	str	r3, [sp, #20]
	HAL_GPIO_Init(PRESSURE_MOSI_GPIO_PORT, &gpio_init_structure);
 8084672:	f001 fcf5 	bl	8086060 <HAL_GPIO_Init>

	/*##-3- Configure the NVIC for SPI2 #########################################*/
	/* NVIC configuration for SPI2 interrupt */
	HAL_NVIC_SetPriority(SPI2_IRQn, 0x0F, 0);
 8084676:	4622      	mov	r2, r4
 8084678:	210f      	movs	r1, #15
 808467a:	2024      	movs	r0, #36	; 0x24
 808467c:	f001 f8c8 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(SPI2_IRQn);
 8084680:	2024      	movs	r0, #36	; 0x24
 8084682:	f001 f901 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 8084686:	b00a      	add	sp, #40	; 0x28
 8084688:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0808468c <BSP_PRESSURE_Init>:
{ 
 808468c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SPIHandle.Instance = PRESSURE_SPIx;
 808468e:	f24b 74a0 	movw	r4, #47008	; 0xb7a0
 8084692:	f44f 5260 	mov.w	r2, #14336	; 0x3800
	PressureHandle.hspi = &SPIHandle;
 8084696:	f24d 75bc 	movw	r5, #55228	; 0xd7bc
	PressureHandle.cs_gpio = PRESSURE_CS_GPIO_PORT;
 808469a:	2300      	movs	r3, #0
	PressureHandlePtr = &PressureHandle;
 808469c:	f24d 77b8 	movw	r7, #55224	; 0xd7b8
	SPIHandle.Instance = PRESSURE_SPIx;
 80846a0:	f2c2 0400 	movt	r4, #8192	; 0x2000
	PressureHandle.hspi = &SPIHandle;
 80846a4:	f2c2 0502 	movt	r5, #8194	; 0x2002
	SPIHandle.Instance = PRESSURE_SPIx;
 80846a8:	f2c4 0200 	movt	r2, #16384	; 0x4000
	PressureHandle.cs_gpio = PRESSURE_CS_GPIO_PORT;
 80846ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
	PressureHandlePtr = &PressureHandle;
 80846b0:	f2c2 0702 	movt	r7, #8194	; 0x2002
	PressureHandle.cs_pin = PRESSURE_CS_PIN;
 80846b4:	f44f 7180 	mov.w	r1, #256	; 0x100
	if (HAL_SPI_DeInit(&SPIHandle) != HAL_OK)
 80846b8:	4620      	mov	r0, r4
	SPIHandle.Instance = PRESSURE_SPIx;
 80846ba:	6022      	str	r2, [r4, #0]
	PressureHandle.cs_pin = PRESSURE_CS_PIN;
 80846bc:	85a9      	strh	r1, [r5, #44]	; 0x2c
	PressureHandlePtr = &PressureHandle;
 80846be:	603d      	str	r5, [r7, #0]
	PressureHandle.cs_gpio = PRESSURE_CS_GPIO_PORT;
 80846c0:	e9c5 4309 	strd	r4, r3, [r5, #36]	; 0x24
	if (HAL_SPI_DeInit(&SPIHandle) != HAL_OK)
 80846c4:	f005 fb20 	bl	8089d08 <HAL_SPI_DeInit>
 80846c8:	b108      	cbz	r0, 80846ce <BSP_PRESSURE_Init+0x42>
		return PRESSURE_ERROR;
 80846ca:	2001      	movs	r0, #1
}
 80846cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80846ce:	4606      	mov	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
 80846d0:	b672      	cpsid	i
	BSP_PRESSURE_MspInit();
 80846d2:	f7ff ff65 	bl	80845a0 <BSP_PRESSURE_MspInit>
	SPIHandle.Init.DataSize 		= SPI_DATASIZE_8BIT;
 80846d6:	f44f 60e0 	mov.w	r0, #1792	; 0x700
	SPIHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
 80846da:	f04f 0c38 	mov.w	ip, #56	; 0x38
	SPIHandle.Init.Mode 			= SPI_MODE_MASTER;
 80846de:	f44f 7182 	mov.w	r1, #260	; 0x104
	SPIHandle.Init.NSS 				= SPI_NSS_SOFT;
 80846e2:	f44f 7200 	mov.w	r2, #512	; 0x200
	SPIHandle.Init.CRCPolynomial    = 7;
 80846e6:	2307      	movs	r3, #7
	SPIHandle.Init.DataSize 		= SPI_DATASIZE_8BIT;
 80846e8:	60e0      	str	r0, [r4, #12]
	if (HAL_SPI_Init(&SPIHandle) != HAL_OK)
 80846ea:	4620      	mov	r0, r4
	SPIHandle.Init.CLKPhase 		= SPI_PHASE_1EDGE;
 80846ec:	6166      	str	r6, [r4, #20]
	SPIHandle.Init.CLKPolarity 		= SPI_POLARITY_LOW;
 80846ee:	6126      	str	r6, [r4, #16]
	SPIHandle.Init.Direction 		= SPI_DIRECTION_2LINES;
 80846f0:	60a6      	str	r6, [r4, #8]
	SPIHandle.Init.CRCCalculation   = SPI_CRCCALCULATION_DISABLE;
 80846f2:	62a6      	str	r6, [r4, #40]	; 0x28
	SPIHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
 80846f4:	f8c4 c01c 	str.w	ip, [r4, #28]
	SPIHandle.Init.Mode 			= SPI_MODE_MASTER;
 80846f8:	6061      	str	r1, [r4, #4]
	SPIHandle.Init.NSS 				= SPI_NSS_SOFT;
 80846fa:	61a2      	str	r2, [r4, #24]
	SPIHandle.Init.CRCPolynomial    = 7;
 80846fc:	62e3      	str	r3, [r4, #44]	; 0x2c
	SPIHandle.Init.TIMode           = SPI_TIMODE_DISABLE;
 80846fe:	e9c4 6608 	strd	r6, r6, [r4, #32]
	if (HAL_SPI_Init(&SPIHandle) != HAL_OK)
 8084702:	f005 fa8d 	bl	8089c20 <HAL_SPI_Init>
 8084706:	4604      	mov	r4, r0
 8084708:	2800      	cmp	r0, #0
 808470a:	d1de      	bne.n	80846ca <BSP_PRESSURE_Init+0x3e>
	PRESSURE_CS_DISABLE(PressureHandlePtr);
 808470c:	683b      	ldr	r3, [r7, #0]
 808470e:	2201      	movs	r2, #1
 8084710:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
 8084712:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8084714:	f001 fec4 	bl	80864a0 <HAL_GPIO_WritePin>
	bmp280_init_default_params(&PressureHandle.params);
 8084718:	f105 002e 	add.w	r0, r5, #46	; 0x2e
 808471c:	f7fb ff54 	bl	80805c8 <bmp280_init_default_params>
	if (!bmp280_init(&PressureHandle, &PressureHandle.params)) {
 8084720:	f105 012e 	add.w	r1, r5, #46	; 0x2e
 8084724:	4628      	mov	r0, r5
 8084726:	f7fb ff59 	bl	80805dc <bmp280_init>
 808472a:	2800      	cmp	r0, #0
 808472c:	d0cd      	beq.n	80846ca <BSP_PRESSURE_Init+0x3e>
	if (PressureHandle.id != BMP280_CHIP_ID) {
 808472e:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
 8084732:	2b58      	cmp	r3, #88	; 0x58
 8084734:	d1c9      	bne.n	80846ca <BSP_PRESSURE_Init+0x3e>
	pressureSensorEnabled=1;
 8084736:	f64b 0304 	movw	r3, #47108	; 0xb804
 808473a:	2201      	movs	r2, #1
 808473c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8084740:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8084742:	b662      	cpsie	i
	return PRESSURE_OK;
 8084744:	4620      	mov	r0, r4
}
 8084746:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08084748 <QSPI_AutoPollingMemReady.constprop.1>:
  * @brief  This function read the SR of the memory and wait the EOP.
  * @param  hqspi: QSPI handle
  * @param  Timeout
  * @retval None
  */
static uint8_t QSPI_AutoPollingMemReady(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
 8084748:	b570      	push	{r4, r5, r6, lr}
{
  QSPI_CommandTypeDef     s_command;
  QSPI_AutoPollingTypeDef s_config;

  /* Configure automatic polling mode to wait for memory ready */  
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 808474a:	f44f 7480 	mov.w	r4, #256	; 0x100
static uint8_t QSPI_AutoPollingMemReady(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
 808474e:	b094      	sub	sp, #80	; 0x50
  s_command.Instruction       = READ_STATUS_REG_CMD;
 8084750:	2505      	movs	r5, #5
  s_command.AddressMode       = QSPI_ADDRESS_NONE;
 8084752:	2200      	movs	r2, #0
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
  s_config.StatusBytesSize = 1;
  s_config.Interval        = 0x10;
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;

  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 8084754:	4603      	mov	r3, r0
  s_command.DataMode          = QSPI_DATA_1_LINE;
 8084756:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 808475a:	f24d 70f4 	movw	r0, #55284	; 0xd7f4
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 808475e:	940c      	str	r4, [sp, #48]	; 0x30
  s_command.Instruction       = READ_STATUS_REG_CMD;
 8084760:	9506      	str	r5, [sp, #24]
  s_config.Mask            = N25Q128A_SR_WIP;
 8084762:	2401      	movs	r4, #1
  s_config.Interval        = 0x10;
 8084764:	2610      	movs	r6, #16
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 8084766:	f44f 0580 	mov.w	r5, #4194304	; 0x400000
  s_command.DummyCycles       = 0;
 808476a:	920b      	str	r2, [sp, #44]	; 0x2c
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 808476c:	f2c2 0002 	movt	r0, #8194	; 0x2002
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 8084770:	9213      	str	r2, [sp, #76]	; 0x4c
  s_config.Match           = 0;
 8084772:	9200      	str	r2, [sp, #0]
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
 8084774:	9204      	str	r2, [sp, #16]
  s_command.DataMode          = QSPI_DATA_1_LINE;
 8084776:	910f      	str	r1, [sp, #60]	; 0x3c
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 8084778:	a906      	add	r1, sp, #24
  s_config.Mask            = N25Q128A_SR_WIP;
 808477a:	9401      	str	r4, [sp, #4]
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 808477c:	9505      	str	r5, [sp, #20]
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 808477e:	e9cd 220d 	strd	r2, r2, [sp, #52]	; 0x34
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 8084782:	e9cd 2211 	strd	r2, r2, [sp, #68]	; 0x44
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 8084786:	466a      	mov	r2, sp
  s_config.Interval        = 0x10;
 8084788:	e9cd 6402 	strd	r6, r4, [sp, #8]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 808478c:	f002 fde4 	bl	8087358 <HAL_QSPI_AutoPolling>
  {
    return QSPI_ERROR;
  }

  return QSPI_OK;
}
 8084790:	3000      	adds	r0, #0
 8084792:	bf18      	it	ne
 8084794:	2001      	movne	r0, #1
 8084796:	b014      	add	sp, #80	; 0x50
 8084798:	bd70      	pop	{r4, r5, r6, pc}
 808479a:	bf00      	nop

0808479c <QSPI_WriteEnable.constprop.3>:
static uint8_t QSPI_WriteEnable(QSPI_HandleTypeDef *hqspi)
 808479c:	b5f0      	push	{r4, r5, r6, r7, lr}
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 808479e:	f44f 7280 	mov.w	r2, #256	; 0x100
static uint8_t QSPI_WriteEnable(QSPI_HandleTypeDef *hqspi)
 80847a2:	b095      	sub	sp, #84	; 0x54
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80847a4:	f24d 70f4 	movw	r0, #55284	; 0xd7f4
  s_command.AddressMode       = QSPI_ADDRESS_NONE;
 80847a8:	2300      	movs	r3, #0
  s_command.Instruction       = WRITE_ENABLE_CMD;
 80847aa:	2406      	movs	r4, #6
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 80847ac:	920c      	str	r2, [sp, #48]	; 0x30
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80847ae:	a906      	add	r1, sp, #24
 80847b0:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80847b4:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.Instruction       = WRITE_ENABLE_CMD;
 80847b8:	9406      	str	r4, [sp, #24]
  s_command.DataMode          = QSPI_DATA_NONE;
 80847ba:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DummyCycles       = 0;
 80847bc:	930b      	str	r3, [sp, #44]	; 0x2c
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 80847be:	9313      	str	r3, [sp, #76]	; 0x4c
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 80847c0:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 80847c4:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80847c8:	f002 fd78 	bl	80872bc <HAL_QSPI_Command>
 80847cc:	b110      	cbz	r0, 80847d4 <QSPI_WriteEnable.constprop.3+0x38>
    return QSPI_ERROR;
 80847ce:	2001      	movs	r0, #1
}
 80847d0:	b015      	add	sp, #84	; 0x54
 80847d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80847d4:	4603      	mov	r3, r0
  s_config.Match           = N25Q128A_SR_WREN;
 80847d6:	2202      	movs	r2, #2
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80847d8:	f24d 70f4 	movw	r0, #55284	; 0xd7f4
  s_config.StatusBytesSize = 1;
 80847dc:	f04f 0c01 	mov.w	ip, #1
  s_config.Interval        = 0x10;
 80847e0:	2710      	movs	r7, #16
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 80847e2:	f44f 0680 	mov.w	r6, #4194304	; 0x400000
  s_command.Instruction    = READ_STATUS_REG_CMD;
 80847e6:	2505      	movs	r5, #5
  s_command.DataMode       = QSPI_DATA_1_LINE;
 80847e8:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
 80847ec:	9304      	str	r3, [sp, #16]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80847ee:	a906      	add	r1, sp, #24
  s_config.Match           = N25Q128A_SR_WREN;
 80847f0:	9200      	str	r2, [sp, #0]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80847f2:	f241 3388 	movw	r3, #5000	; 0x1388
  s_config.Mask            = N25Q128A_SR_WREN;
 80847f6:	9201      	str	r2, [sp, #4]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80847f8:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80847fc:	466a      	mov	r2, sp
  s_config.StatusBytesSize = 1;
 80847fe:	f8cd c00c 	str.w	ip, [sp, #12]
  s_config.Interval        = 0x10;
 8084802:	9702      	str	r7, [sp, #8]
  s_command.DataMode       = QSPI_DATA_1_LINE;
 8084804:	940f      	str	r4, [sp, #60]	; 0x3c
  s_command.Instruction    = READ_STATUS_REG_CMD;
 8084806:	e9cd 6505 	strd	r6, r5, [sp, #20]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 808480a:	f002 fda5 	bl	8087358 <HAL_QSPI_AutoPolling>
    return QSPI_ERROR;
 808480e:	3000      	adds	r0, #0
 8084810:	bf18      	it	ne
 8084812:	2001      	movne	r0, #1
}
 8084814:	b015      	add	sp, #84	; 0x54
 8084816:	bdf0      	pop	{r4, r5, r6, r7, pc}

08084818 <BSP_QSPI_Read>:
{
 8084818:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 808481a:	f24d 74f4 	movw	r4, #55284	; 0xd7f4
{
 808481e:	b08f      	sub	sp, #60	; 0x3c
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 8084820:	f44f 7580 	mov.w	r5, #256	; 0x100
  s_command.Instruction       = QUAD_INOUT_FAST_READ_CMD;
 8084824:	23eb      	movs	r3, #235	; 0xeb
  s_command.Address           = ReadAddr;
 8084826:	9101      	str	r1, [sp, #4]
  if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084828:	f2c2 0402 	movt	r4, #8194	; 0x2002
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 808482c:	f44f 6140 	mov.w	r1, #3072	; 0xc00
  s_command.NbData            = Size;
 8084830:	920a      	str	r2, [sp, #40]	; 0x28
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 8084832:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 8084836:	9506      	str	r5, [sp, #24]
  s_command.Instruction       = QUAD_INOUT_FAST_READ_CMD;
 8084838:	9300      	str	r3, [sp, #0]
  s_command.DataMode          = QSPI_DATA_4_LINES;
 808483a:	f04f 7640 	mov.w	r6, #50331648	; 0x3000000
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 808483e:	2300      	movs	r3, #0
  s_command.DummyCycles       = N25Q128A_DUMMY_CYCLES_READ_QUAD;
 8084840:	250a      	movs	r5, #10
{
 8084842:	4607      	mov	r7, r0
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 8084844:	9107      	str	r1, [sp, #28]
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 8084846:	9203      	str	r2, [sp, #12]
  if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084848:	4620      	mov	r0, r4
 808484a:	f241 3288 	movw	r2, #5000	; 0x1388
 808484e:	4669      	mov	r1, sp
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 8084850:	9308      	str	r3, [sp, #32]
  s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
 8084852:	930b      	str	r3, [sp, #44]	; 0x2c
  s_command.DataMode          = QSPI_DATA_4_LINES;
 8084854:	9609      	str	r6, [sp, #36]	; 0x24
  s_command.DummyCycles       = N25Q128A_DUMMY_CYCLES_READ_QUAD;
 8084856:	9505      	str	r5, [sp, #20]
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 8084858:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 808485c:	f002 fd2e 	bl	80872bc <HAL_QSPI_Command>
 8084860:	b110      	cbz	r0, 8084868 <BSP_QSPI_Read+0x50>
    return QSPI_ERROR;
 8084862:	2001      	movs	r0, #1
}
 8084864:	b00f      	add	sp, #60	; 0x3c
 8084866:	bdf0      	pop	{r4, r5, r6, r7, pc}
  MODIFY_REG(QSPIHandle.Instance->DCR, QUADSPI_DCR_CSHT, QSPI_CS_HIGH_TIME_3_CYCLE);
 8084868:	6825      	ldr	r5, [r4, #0]
  if (HAL_QSPI_Receive(&QSPIHandle, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 808486a:	4639      	mov	r1, r7
 808486c:	f241 3288 	movw	r2, #5000	; 0x1388
 8084870:	4620      	mov	r0, r4
  MODIFY_REG(QSPIHandle.Instance->DCR, QUADSPI_DCR_CSHT, QSPI_CS_HIGH_TIME_3_CYCLE);
 8084872:	686b      	ldr	r3, [r5, #4]
 8084874:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8084878:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 808487c:	606b      	str	r3, [r5, #4]
  if (HAL_QSPI_Receive(&QSPIHandle, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 808487e:	f002 feb3 	bl	80875e8 <HAL_QSPI_Receive>
 8084882:	2800      	cmp	r0, #0
 8084884:	d1ed      	bne.n	8084862 <BSP_QSPI_Read+0x4a>
  MODIFY_REG(QSPIHandle.Instance->DCR, QUADSPI_DCR_CSHT, QSPI_CS_HIGH_TIME_6_CYCLE);
 8084886:	6822      	ldr	r2, [r4, #0]
 8084888:	6853      	ldr	r3, [r2, #4]
 808488a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 808488e:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
 8084892:	6053      	str	r3, [r2, #4]
}
 8084894:	b00f      	add	sp, #60	; 0x3c
 8084896:	bdf0      	pop	{r4, r5, r6, r7, pc}

08084898 <BSP_QSPI_Write>:
{
 8084898:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 808489c:	f44f 7380 	mov.w	r3, #256	; 0x100
  current_size = N25Q128A_PAGE_SIZE - (WriteAddr % N25Q128A_PAGE_SIZE);
 80848a0:	b2cd      	uxtb	r5, r1
{
 80848a2:	b08e      	sub	sp, #56	; 0x38
  end_addr = WriteAddr + Size;
 80848a4:	188f      	adds	r7, r1, r2
  current_size = N25Q128A_PAGE_SIZE - (WriteAddr % N25Q128A_PAGE_SIZE);
 80848a6:	1b5d      	subs	r5, r3, r5
{
 80848a8:	460c      	mov	r4, r1
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 80848aa:	9306      	str	r3, [sp, #24]
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 80848ac:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80848b0:	4295      	cmp	r5, r2
    if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80848b2:	f24d 78f4 	movw	r8, #55284	; 0xd7f4
  s_command.Instruction       = EXT_QUAD_IN_FAST_PROG_CMD;
 80848b6:	f04f 0112 	mov.w	r1, #18
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 80848ba:	9307      	str	r3, [sp, #28]
 80848bc:	bf28      	it	cs
 80848be:	4615      	movcs	r5, r2
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 80848c0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 80848c4:	2300      	movs	r3, #0
{
 80848c6:	4606      	mov	r6, r0
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 80848c8:	9203      	str	r2, [sp, #12]
  s_command.DataMode          = QSPI_DATA_4_LINES;
 80848ca:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
    if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80848ce:	f2c2 0802 	movt	r8, #8194	; 0x2002
  s_command.Instruction       = EXT_QUAD_IN_FAST_PROG_CMD;
 80848d2:	9100      	str	r1, [sp, #0]
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 80848d4:	9308      	str	r3, [sp, #32]
  s_command.DummyCycles       = 0;
 80848d6:	9305      	str	r3, [sp, #20]
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 80848d8:	930d      	str	r3, [sp, #52]	; 0x34
  s_command.DataMode          = QSPI_DATA_4_LINES;
 80848da:	9209      	str	r2, [sp, #36]	; 0x24
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 80848dc:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 80848e0:	e01b      	b.n	808491a <BSP_QSPI_Write+0x82>
    if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80848e2:	f24d 70f4 	movw	r0, #55284	; 0xd7f4
 80848e6:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80848ea:	f002 fce7 	bl	80872bc <HAL_QSPI_Command>
    if (HAL_QSPI_Transmit(&QSPIHandle, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80848ee:	4631      	mov	r1, r6
 80848f0:	f241 3288 	movw	r2, #5000	; 0x1388
    pData += current_size;
 80848f4:	442e      	add	r6, r5
    current_size = ((current_addr + N25Q128A_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : N25Q128A_PAGE_SIZE;
 80848f6:	f44f 7580 	mov.w	r5, #256	; 0x100
    if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80848fa:	b9c0      	cbnz	r0, 808492e <BSP_QSPI_Write+0x96>
    if (HAL_QSPI_Transmit(&QSPIHandle, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80848fc:	4640      	mov	r0, r8
 80848fe:	f002 fe0d 	bl	808751c <HAL_QSPI_Transmit>
 8084902:	b9a0      	cbnz	r0, 808492e <BSP_QSPI_Write+0x96>
    if (QSPI_AutoPollingMemReady(&QSPIHandle, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK)
 8084904:	f241 3088 	movw	r0, #5000	; 0x1388
 8084908:	f7ff ff1e 	bl	8084748 <QSPI_AutoPollingMemReady.constprop.1>
    current_size = ((current_addr + N25Q128A_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : N25Q128A_PAGE_SIZE;
 808490c:	1963      	adds	r3, r4, r5
    if (QSPI_AutoPollingMemReady(&QSPIHandle, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK)
 808490e:	b970      	cbnz	r0, 808492e <BSP_QSPI_Write+0x96>
    current_size = ((current_addr + N25Q128A_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : N25Q128A_PAGE_SIZE;
 8084910:	42bb      	cmp	r3, r7
 8084912:	bf88      	it	hi
 8084914:	1b3d      	subhi	r5, r7, r4
  } while (current_addr < end_addr);
 8084916:	42a7      	cmp	r7, r4
 8084918:	d90a      	bls.n	8084930 <BSP_QSPI_Write+0x98>
    s_command.Address = current_addr;
 808491a:	9401      	str	r4, [sp, #4]
    current_addr += current_size;
 808491c:	442c      	add	r4, r5
    s_command.NbData  = current_size;
 808491e:	950a      	str	r5, [sp, #40]	; 0x28
    if (QSPI_WriteEnable(&QSPIHandle) != QSPI_OK)
 8084920:	f7ff ff3c 	bl	808479c <QSPI_WriteEnable.constprop.3>
    if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084924:	4669      	mov	r1, sp
 8084926:	f241 3288 	movw	r2, #5000	; 0x1388
    if (QSPI_WriteEnable(&QSPIHandle) != QSPI_OK)
 808492a:	2800      	cmp	r0, #0
 808492c:	d0d9      	beq.n	80848e2 <BSP_QSPI_Write+0x4a>
      return QSPI_ERROR;
 808492e:	2001      	movs	r0, #1
}
 8084930:	b00e      	add	sp, #56	; 0x38
 8084932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8084936:	bf00      	nop

08084938 <BSP_QSPI_Erase_Block>:
{
 8084938:	b530      	push	{r4, r5, lr}
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 808493a:	2300      	movs	r3, #0
{
 808493c:	b08f      	sub	sp, #60	; 0x3c
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 808493e:	f44f 7580 	mov.w	r5, #256	; 0x100
  s_command.Instruction       = SUBSECTOR_ERASE_CMD;
 8084942:	2420      	movs	r4, #32
  s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
 8084944:	f44f 6180 	mov.w	r1, #1024	; 0x400
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 8084948:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  s_command.Address           = BlockAddress;
 808494c:	9001      	str	r0, [sp, #4]
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 808494e:	9506      	str	r5, [sp, #24]
  s_command.Instruction       = SUBSECTOR_ERASE_CMD;
 8084950:	9400      	str	r4, [sp, #0]
  s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
 8084952:	9107      	str	r1, [sp, #28]
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 8084954:	9203      	str	r2, [sp, #12]
  s_command.DummyCycles       = 0;
 8084956:	9305      	str	r3, [sp, #20]
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 8084958:	930d      	str	r3, [sp, #52]	; 0x34
  s_command.DataMode          = QSPI_DATA_NONE;
 808495a:	e9cd 3308 	strd	r3, r3, [sp, #32]
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 808495e:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  if (QSPI_WriteEnable(&QSPIHandle) != QSPI_OK)
 8084962:	f7ff ff1b 	bl	808479c <QSPI_WriteEnable.constprop.3>
 8084966:	b110      	cbz	r0, 808496e <BSP_QSPI_Erase_Block+0x36>
    return QSPI_ERROR;
 8084968:	2001      	movs	r0, #1
}
 808496a:	b00f      	add	sp, #60	; 0x3c
 808496c:	bd30      	pop	{r4, r5, pc}
  if (HAL_QSPI_Command(&QSPIHandle, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 808496e:	f24d 70f4 	movw	r0, #55284	; 0xd7f4
 8084972:	f241 3288 	movw	r2, #5000	; 0x1388
 8084976:	4669      	mov	r1, sp
 8084978:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808497c:	f002 fc9e 	bl	80872bc <HAL_QSPI_Command>
 8084980:	2800      	cmp	r0, #0
 8084982:	d1f1      	bne.n	8084968 <BSP_QSPI_Erase_Block+0x30>
  if (QSPI_AutoPollingMemReady(&QSPIHandle, N25Q128A_SUBSECTOR_ERASE_MAX_TIME) != QSPI_OK)
 8084984:	f44f 7048 	mov.w	r0, #800	; 0x320
 8084988:	f7ff fede 	bl	8084748 <QSPI_AutoPollingMemReady.constprop.1>
    return QSPI_ERROR;
 808498c:	3000      	adds	r0, #0
 808498e:	bf18      	it	ne
 8084990:	2001      	movne	r0, #1
}
 8084992:	b00f      	add	sp, #60	; 0x3c
 8084994:	bd30      	pop	{r4, r5, pc}
 8084996:	bf00      	nop

08084998 <BSP_QSPI_GetInfo>:
{
 8084998:	b410      	push	{r4}
 808499a:	4603      	mov	r3, r0
  pInfo->FlashSize          = N25Q128A_FLASH_SIZE;
 808499c:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  pInfo->ProgPageSize       = N25Q128A_PAGE_SIZE;
 80849a0:	f44f 7080 	mov.w	r0, #256	; 0x100
  pInfo->ProgPagesNumber    = (N25Q128A_FLASH_SIZE/N25Q128A_PAGE_SIZE);
 80849a4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  pInfo->EraseSectorSize    = N25Q128A_SUBSECTOR_SIZE;
 80849a8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  pInfo->FlashSize          = N25Q128A_FLASH_SIZE;
 80849ac:	601c      	str	r4, [r3, #0]
  pInfo->ProgPageSize       = N25Q128A_PAGE_SIZE;
 80849ae:	60d8      	str	r0, [r3, #12]
}
 80849b0:	2000      	movs	r0, #0
  pInfo->ProgPagesNumber    = (N25Q128A_FLASH_SIZE/N25Q128A_PAGE_SIZE);
 80849b2:	6119      	str	r1, [r3, #16]
}
 80849b4:	f85d 4b04 	ldr.w	r4, [sp], #4
  pInfo->EraseSectorsNumber = (N25Q128A_FLASH_SIZE/N25Q128A_SUBSECTOR_SIZE);
 80849b8:	e9c3 2201 	strd	r2, r2, [r3, #4]
}
 80849bc:	4770      	bx	lr
 80849be:	bf00      	nop

080849c0 <BSP_QSPI_EnableMemoryMappedMode>:
{
 80849c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80849c2:	b091      	sub	sp, #68	; 0x44
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 80849c4:	2300      	movs	r3, #0
  s_command.Instruction       = QUAD_INOUT_FAST_READ_CMD;
 80849c6:	21eb      	movs	r1, #235	; 0xeb
  if (HAL_QSPI_MemoryMapped(&QSPIHandle, &s_command, &s_mem_mapped_cfg) != HAL_OK)
 80849c8:	f24d 70f4 	movw	r0, #55284	; 0xd7f4
  s_mem_mapped_cfg.TimeOutPeriod     = 0;
 80849cc:	aa10      	add	r2, sp, #64	; 0x40
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 80849ce:	930a      	str	r3, [sp, #40]	; 0x28
  s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
 80849d0:	930d      	str	r3, [sp, #52]	; 0x34
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 80849d2:	f44f 7780 	mov.w	r7, #256	; 0x100
  s_mem_mapped_cfg.TimeOutPeriod     = 0;
 80849d6:	f842 3d40 	str.w	r3, [r2, #-64]!
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 80849da:	f44f 6640 	mov.w	r6, #3072	; 0xc00
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 80849de:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 80849e0:	f44f 5500 	mov.w	r5, #8192	; 0x2000
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 80849e4:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DataMode          = QSPI_DATA_4_LINES;
 80849e6:	f04f 7440 	mov.w	r4, #50331648	; 0x3000000
  s_mem_mapped_cfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
 80849ea:	9301      	str	r3, [sp, #4]
  s_command.DummyCycles       = N25Q128A_DUMMY_CYCLES_READ_QUAD;
 80849ec:	230a      	movs	r3, #10
  s_command.Instruction       = QUAD_INOUT_FAST_READ_CMD;
 80849ee:	9102      	str	r1, [sp, #8]
  if (HAL_QSPI_MemoryMapped(&QSPIHandle, &s_command, &s_mem_mapped_cfg) != HAL_OK)
 80849f0:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80849f4:	a902      	add	r1, sp, #8
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 80849f6:	9708      	str	r7, [sp, #32]
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 80849f8:	9609      	str	r6, [sp, #36]	; 0x24
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
 80849fa:	9505      	str	r5, [sp, #20]
  s_command.DataMode          = QSPI_DATA_4_LINES;
 80849fc:	940b      	str	r4, [sp, #44]	; 0x2c
  s_command.DummyCycles       = N25Q128A_DUMMY_CYCLES_READ_QUAD;
 80849fe:	9307      	str	r3, [sp, #28]
  if (HAL_QSPI_MemoryMapped(&QSPIHandle, &s_command, &s_mem_mapped_cfg) != HAL_OK)
 8084a00:	f002 fd02 	bl	8087408 <HAL_QSPI_MemoryMapped>
}
 8084a04:	3000      	adds	r0, #0
 8084a06:	bf18      	it	ne
 8084a08:	2001      	movne	r0, #1
 8084a0a:	b011      	add	sp, #68	; 0x44
 8084a0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8084a0e:	bf00      	nop

08084a10 <BSP_QSPI_MspInit>:
  QSPI_CLK_ENABLE();
 8084a10:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8084a14:	2102      	movs	r1, #2
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8084a16:	f04f 0c01 	mov.w	ip, #1
  QSPI_CLK_ENABLE();
 8084a1a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8084a1e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8084a20:	430a      	orrs	r2, r1
{
 8084a22:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  QSPI_CLK_ENABLE();
 8084a26:	639a      	str	r2, [r3, #56]	; 0x38
{
 8084a28:	b08d      	sub	sp, #52	; 0x34
  QSPI_CLK_ENABLE();
 8084a2a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &gpio_init_structure);
 8084a2c:	f44f 6680 	mov.w	r6, #1024	; 0x400
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 8084a30:	2403      	movs	r4, #3
  gpio_init_structure.Pin       = QSPI_CS_PIN;
 8084a32:	f04f 0e40 	mov.w	lr, #64	; 0x40
  QSPI_CLK_ENABLE();
 8084a36:	400a      	ands	r2, r1
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &gpio_init_structure);
 8084a38:	f2c4 0602 	movt	r6, #16386	; 0x4002
  gpio_init_structure.Alternate = GPIO_AF10_QUADSPI;
 8084a3c:	270a      	movs	r7, #10
  HAL_GPIO_Init(QSPI_D0_GPIO_PORT, &gpio_init_structure);
 8084a3e:	f44f 6540 	mov.w	r5, #3072	; 0xc00
  QSPI_CLK_ENABLE();
 8084a42:	9200      	str	r2, [sp, #0]
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &gpio_init_structure);
 8084a44:	4630      	mov	r0, r6
  QSPI_CLK_ENABLE();
 8084a46:	9a00      	ldr	r2, [sp, #0]
  gpio_init_structure.Pin       = QSPI_CLK_PIN;
 8084a48:	f04f 0904 	mov.w	r9, #4
  QSPI_FORCE_RESET();
 8084a4c:	699a      	ldr	r2, [r3, #24]
  gpio_init_structure.Pull      = GPIO_NOPULL;
 8084a4e:	f04f 0800 	mov.w	r8, #0
  HAL_GPIO_Init(QSPI_D0_GPIO_PORT, &gpio_init_structure);
 8084a52:	f2c4 0502 	movt	r5, #16386	; 0x4002
  QSPI_FORCE_RESET();
 8084a56:	430a      	orrs	r2, r1
 8084a58:	619a      	str	r2, [r3, #24]
  QSPI_RELEASE_RESET();
 8084a5a:	699a      	ldr	r2, [r3, #24]
 8084a5c:	f022 0202 	bic.w	r2, r2, #2
 8084a60:	619a      	str	r2, [r3, #24]
  QSPI_CS_GPIO_CLK_ENABLE();
 8084a62:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a64:	430a      	orrs	r2, r1
 8084a66:	631a      	str	r2, [r3, #48]	; 0x30
 8084a68:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a6a:	400a      	ands	r2, r1
 8084a6c:	9201      	str	r2, [sp, #4]
 8084a6e:	9a01      	ldr	r2, [sp, #4]
  QSPI_CLK_GPIO_CLK_ENABLE();
 8084a70:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a72:	430a      	orrs	r2, r1
 8084a74:	631a      	str	r2, [r3, #48]	; 0x30
 8084a76:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a78:	400a      	ands	r2, r1
 8084a7a:	9202      	str	r2, [sp, #8]
 8084a7c:	9a02      	ldr	r2, [sp, #8]
  QSPI_D0_GPIO_CLK_ENABLE();
 8084a7e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a80:	f042 0208 	orr.w	r2, r2, #8
 8084a84:	631a      	str	r2, [r3, #48]	; 0x30
 8084a86:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a88:	f002 0208 	and.w	r2, r2, #8
 8084a8c:	9203      	str	r2, [sp, #12]
 8084a8e:	9a03      	ldr	r2, [sp, #12]
  QSPI_D1_GPIO_CLK_ENABLE();
 8084a90:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a92:	f042 0208 	orr.w	r2, r2, #8
 8084a96:	631a      	str	r2, [r3, #48]	; 0x30
 8084a98:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084a9a:	f002 0208 	and.w	r2, r2, #8
 8084a9e:	9204      	str	r2, [sp, #16]
 8084aa0:	9a04      	ldr	r2, [sp, #16]
  QSPI_D2_GPIO_CLK_ENABLE();
 8084aa2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084aa4:	f042 0210 	orr.w	r2, r2, #16
 8084aa8:	631a      	str	r2, [r3, #48]	; 0x30
 8084aaa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084aac:	f002 0210 	and.w	r2, r2, #16
 8084ab0:	9205      	str	r2, [sp, #20]
 8084ab2:	9a05      	ldr	r2, [sp, #20]
  QSPI_D3_GPIO_CLK_ENABLE();
 8084ab4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084ab6:	f042 0208 	orr.w	r2, r2, #8
 8084aba:	631a      	str	r2, [r3, #48]	; 0x30
 8084abc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8084abe:	9108      	str	r1, [sp, #32]
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &gpio_init_structure);
 8084ac0:	a907      	add	r1, sp, #28
  QSPI_D3_GPIO_CLK_ENABLE();
 8084ac2:	f003 0308 	and.w	r3, r3, #8
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 8084ac6:	940a      	str	r4, [sp, #40]	; 0x28
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8084ac8:	2409      	movs	r4, #9
  gpio_init_structure.Pin       = QSPI_CS_PIN;
 8084aca:	f8cd e01c 	str.w	lr, [sp, #28]
  QSPI_D3_GPIO_CLK_ENABLE();
 8084ace:	9306      	str	r3, [sp, #24]
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8084ad0:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  QSPI_D3_GPIO_CLK_ENABLE();
 8084ad4:	9b06      	ldr	r3, [sp, #24]
  gpio_init_structure.Alternate = GPIO_AF10_QUADSPI;
 8084ad6:	970b      	str	r7, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_CS_GPIO_PORT, &gpio_init_structure);
 8084ad8:	f001 fac2 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &gpio_init_structure);
 8084adc:	4630      	mov	r0, r6
 8084ade:	a907      	add	r1, sp, #28
  gpio_init_structure.Pin       = QSPI_CLK_PIN;
 8084ae0:	f8cd 901c 	str.w	r9, [sp, #28]
  gpio_init_structure.Pull      = GPIO_NOPULL;
 8084ae4:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8084ae8:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &gpio_init_structure);
 8084aea:	f001 fab9 	bl	8086060 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = QSPI_D0_PIN;
 8084aee:	f44f 6300 	mov.w	r3, #2048	; 0x800
  HAL_GPIO_Init(QSPI_D0_GPIO_PORT, &gpio_init_structure);
 8084af2:	4628      	mov	r0, r5
 8084af4:	a907      	add	r1, sp, #28
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8084af6:	940b      	str	r4, [sp, #44]	; 0x2c
  gpio_init_structure.Pin       = QSPI_D0_PIN;
 8084af8:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(QSPI_D0_GPIO_PORT, &gpio_init_structure);
 8084afa:	f001 fab1 	bl	8086060 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = QSPI_D1_PIN;
 8084afe:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  HAL_GPIO_Init(QSPI_D1_GPIO_PORT, &gpio_init_structure);
 8084b02:	4628      	mov	r0, r5
 8084b04:	a907      	add	r1, sp, #28
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8084b06:	940b      	str	r4, [sp, #44]	; 0x2c
  gpio_init_structure.Pin       = QSPI_D1_PIN;
 8084b08:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(QSPI_D1_GPIO_PORT, &gpio_init_structure);
 8084b0a:	f001 faa9 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(QSPI_D2_GPIO_PORT, &gpio_init_structure);
 8084b0e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8084b12:	a907      	add	r1, sp, #28
  gpio_init_structure.Pin       = QSPI_D2_PIN;
 8084b14:	f8cd 901c 	str.w	r9, [sp, #28]
  HAL_GPIO_Init(QSPI_D2_GPIO_PORT, &gpio_init_structure);
 8084b18:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8084b1c:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_D2_GPIO_PORT, &gpio_init_structure);
 8084b1e:	f001 fa9f 	bl	8086060 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = QSPI_D3_PIN;
 8084b22:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(QSPI_D3_GPIO_PORT, &gpio_init_structure);
 8084b26:	4628      	mov	r0, r5
 8084b28:	a907      	add	r1, sp, #28
  gpio_init_structure.Pin       = QSPI_D3_PIN;
 8084b2a:	9307      	str	r3, [sp, #28]
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8084b2c:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_D3_GPIO_PORT, &gpio_init_structure);
 8084b2e:	f001 fa97 	bl	8086060 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(QUADSPI_IRQn, 0x0F, 0);
 8084b32:	4642      	mov	r2, r8
 8084b34:	210f      	movs	r1, #15
 8084b36:	205c      	movs	r0, #92	; 0x5c
 8084b38:	f000 fe6a 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(QUADSPI_IRQn);
 8084b3c:	205c      	movs	r0, #92	; 0x5c
 8084b3e:	f000 fea3 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 8084b42:	b00d      	add	sp, #52	; 0x34
 8084b44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08084b48 <BSP_QSPI_Init>:
{ 
 8084b48:	b5f0      	push	{r4, r5, r6, r7, lr}
  QSPIHandle.Instance = QUADSPI;
 8084b4a:	f24d 74f4 	movw	r4, #55284	; 0xd7f4
 8084b4e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
{ 
 8084b52:	b091      	sub	sp, #68	; 0x44
  QSPIHandle.Instance = QUADSPI;
 8084b54:	f2c2 0402 	movt	r4, #8194	; 0x2002
 8084b58:	f2ca 0300 	movt	r3, #40960	; 0xa000
  if (HAL_QSPI_DeInit(&QSPIHandle) != HAL_OK)
 8084b5c:	4620      	mov	r0, r4
  QSPIHandle.Instance = QUADSPI;
 8084b5e:	6023      	str	r3, [r4, #0]
  if (HAL_QSPI_DeInit(&QSPIHandle) != HAL_OK)
 8084b60:	f002 fb8e 	bl	8087280 <HAL_QSPI_DeInit>
 8084b64:	b118      	cbz	r0, 8084b6e <BSP_QSPI_Init+0x26>
    return QSPI_ERROR;
 8084b66:	2501      	movs	r5, #1
}
 8084b68:	4628      	mov	r0, r5
 8084b6a:	b011      	add	sp, #68	; 0x44
 8084b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  BSP_QSPI_MspInit(&QSPIHandle, NULL);
 8084b6e:	4601      	mov	r1, r0
 8084b70:	4605      	mov	r5, r0
 8084b72:	4620      	mov	r0, r4
  QSPIHandle.Init.ClockPrescaler     = 1; /* QSPI freq = 216 MHz/(1+1) = 108 Mhz */
 8084b74:	2601      	movs	r6, #1
  BSP_QSPI_MspInit(&QSPIHandle, NULL);
 8084b76:	f7ff ff4b 	bl	8084a10 <BSP_QSPI_MspInit>
  QSPIHandle.Init.FifoThreshold      = 4;
 8084b7a:	2204      	movs	r2, #4
  QSPIHandle.Init.SampleShifting     = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
 8084b7c:	2310      	movs	r3, #16
  QSPIHandle.Init.ClockPrescaler     = 1; /* QSPI freq = 216 MHz/(1+1) = 108 Mhz */
 8084b7e:	6066      	str	r6, [r4, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8084b80:	f04f 7780 	mov.w	r7, #16777216	; 0x1000000
  QSPIHandle.Init.SampleShifting     = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
 8084b84:	e9c4 2302 	strd	r2, r3, [r4, #8]
 8084b88:	fa97 f3a7 	rbit	r3, r7
  QSPIHandle.Init.FlashSize          = POSITION_VAL(N25Q128A_FLASH_SIZE) - 1;
 8084b8c:	fab3 f383 	clz	r3, r3
  QSPIHandle.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_6_CYCLE; /* Min 50ns for nonRead */
 8084b90:	f44f 62a0 	mov.w	r2, #1280	; 0x500
  if (HAL_QSPI_Init(&QSPIHandle) != HAL_OK)
 8084b94:	4620      	mov	r0, r4
  QSPIHandle.Init.ClockMode          = QSPI_CLOCK_MODE_0;
 8084b96:	61a5      	str	r5, [r4, #24]
  QSPIHandle.Init.FlashSize          = POSITION_VAL(N25Q128A_FLASH_SIZE) - 1;
 8084b98:	3b01      	subs	r3, #1
  QSPIHandle.Init.DualFlash          = QSPI_DUALFLASH_DISABLE;
 8084b9a:	e9c4 5507 	strd	r5, r5, [r4, #28]
  QSPIHandle.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_6_CYCLE; /* Min 50ns for nonRead */
 8084b9e:	e9c4 3204 	strd	r3, r2, [r4, #16]
  if (HAL_QSPI_Init(&QSPIHandle) != HAL_OK)
 8084ba2:	f002 fb07 	bl	80871b4 <HAL_QSPI_Init>
 8084ba6:	4603      	mov	r3, r0
 8084ba8:	2800      	cmp	r0, #0
 8084baa:	d1dc      	bne.n	8084b66 <BSP_QSPI_Init+0x1e>
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 8084bac:	f44f 7580 	mov.w	r5, #256	; 0x100
  s_command.Instruction       = RESET_ENABLE_CMD;
 8084bb0:	f04f 0c66 	mov.w	ip, #102	; 0x66
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084bb4:	f241 3288 	movw	r2, #5000	; 0x1388
 8084bb8:	a902      	add	r1, sp, #8
  s_command.DataMode          = QSPI_DATA_NONE;
 8084bba:	930b      	str	r3, [sp, #44]	; 0x2c
  s_command.DummyCycles       = 0;
 8084bbc:	9307      	str	r3, [sp, #28]
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 8084bbe:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 8084bc0:	9508      	str	r5, [sp, #32]
  s_command.Instruction       = RESET_ENABLE_CMD;
 8084bc2:	f8cd c008 	str.w	ip, [sp, #8]
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 8084bc6:	e9cd 0009 	strd	r0, r0, [sp, #36]	; 0x24
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084bca:	4620      	mov	r0, r4
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 8084bcc:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084bd0:	f002 fb74 	bl	80872bc <HAL_QSPI_Command>
 8084bd4:	b118      	cbz	r0, 8084bde <BSP_QSPI_Init+0x96>
    return QSPI_NOT_SUPPORTED;
 8084bd6:	2504      	movs	r5, #4
}
 8084bd8:	4628      	mov	r0, r5
 8084bda:	b011      	add	sp, #68	; 0x44
 8084bdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  s_command.Instruction = RESET_MEMORY_CMD;
 8084bde:	2399      	movs	r3, #153	; 0x99
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084be0:	f241 3288 	movw	r2, #5000	; 0x1388
 8084be4:	a902      	add	r1, sp, #8
 8084be6:	4620      	mov	r0, r4
  s_command.Instruction = RESET_MEMORY_CMD;
 8084be8:	9302      	str	r3, [sp, #8]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084bea:	f002 fb67 	bl	80872bc <HAL_QSPI_Command>
 8084bee:	2800      	cmp	r0, #0
 8084bf0:	d1f1      	bne.n	8084bd6 <BSP_QSPI_Init+0x8e>
  if (QSPI_AutoPollingMemReady(hqspi, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK)
 8084bf2:	f241 3088 	movw	r0, #5000	; 0x1388
 8084bf6:	f7ff fda7 	bl	8084748 <QSPI_AutoPollingMemReady.constprop.1>
 8084bfa:	4603      	mov	r3, r0
 8084bfc:	2800      	cmp	r0, #0
 8084bfe:	d1ea      	bne.n	8084bd6 <BSP_QSPI_Init+0x8e>
  s_command.Instruction       = READ_VOL_CFG_REG_CMD;
 8084c00:	f04f 0c85 	mov.w	ip, #133	; 0x85
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c04:	f241 3288 	movw	r2, #5000	; 0x1388
 8084c08:	a902      	add	r1, sp, #8
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 8084c0a:	9508      	str	r5, [sp, #32]
  s_command.DataMode          = QSPI_DATA_1_LINE;
 8084c0c:	970b      	str	r7, [sp, #44]	; 0x2c
  s_command.DummyCycles       = 0;
 8084c0e:	9307      	str	r3, [sp, #28]
  s_command.Instruction       = READ_VOL_CFG_REG_CMD;
 8084c10:	f8cd c008 	str.w	ip, [sp, #8]
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 8084c14:	e9cd 0009 	strd	r0, r0, [sp, #36]	; 0x24
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c18:	4620      	mov	r0, r4
  s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
 8084c1a:	e9cd 630c 	strd	r6, r3, [sp, #48]	; 0x30
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 8084c1e:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c22:	f002 fb4b 	bl	80872bc <HAL_QSPI_Command>
 8084c26:	2800      	cmp	r0, #0
 8084c28:	d1d5      	bne.n	8084bd6 <BSP_QSPI_Init+0x8e>
  if (HAL_QSPI_Receive(hqspi, &reg, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c2a:	f241 3288 	movw	r2, #5000	; 0x1388
 8084c2e:	4620      	mov	r0, r4
 8084c30:	f10d 0107 	add.w	r1, sp, #7
 8084c34:	f002 fcd8 	bl	80875e8 <HAL_QSPI_Receive>
 8084c38:	2800      	cmp	r0, #0
 8084c3a:	d1cc      	bne.n	8084bd6 <BSP_QSPI_Init+0x8e>
  if (QSPI_WriteEnable(hqspi) != QSPI_OK)
 8084c3c:	f7ff fdae 	bl	808479c <QSPI_WriteEnable.constprop.3>
 8084c40:	4605      	mov	r5, r0
 8084c42:	2800      	cmp	r0, #0
 8084c44:	d1c7      	bne.n	8084bd6 <BSP_QSPI_Init+0x8e>
  s_command.Instruction = WRITE_VOL_CFG_REG_CMD;
 8084c46:	2381      	movs	r3, #129	; 0x81
 8084c48:	22f0      	movs	r2, #240	; 0xf0
 8084c4a:	9302      	str	r3, [sp, #8]
 8084c4c:	fa92 f2a2 	rbit	r2, r2
  MODIFY_REG(reg, N25Q128A_VCR_NB_DUMMY, (N25Q128A_DUMMY_CYCLES_READ_QUAD << POSITION_VAL(N25Q128A_VCR_NB_DUMMY)));
 8084c50:	260a      	movs	r6, #10
 8084c52:	fab2 f282 	clz	r2, r2
 8084c56:	f89d 3007 	ldrb.w	r3, [sp, #7]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c5a:	a902      	add	r1, sp, #8
  MODIFY_REG(reg, N25Q128A_VCR_NB_DUMMY, (N25Q128A_DUMMY_CYCLES_READ_QUAD << POSITION_VAL(N25Q128A_VCR_NB_DUMMY)));
 8084c5c:	4096      	lsls	r6, r2
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c5e:	4620      	mov	r0, r4
  MODIFY_REG(reg, N25Q128A_VCR_NB_DUMMY, (N25Q128A_DUMMY_CYCLES_READ_QUAD << POSITION_VAL(N25Q128A_VCR_NB_DUMMY)));
 8084c60:	f003 030f 	and.w	r3, r3, #15
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c64:	f241 3288 	movw	r2, #5000	; 0x1388
  MODIFY_REG(reg, N25Q128A_VCR_NB_DUMMY, (N25Q128A_DUMMY_CYCLES_READ_QUAD << POSITION_VAL(N25Q128A_VCR_NB_DUMMY)));
 8084c68:	4333      	orrs	r3, r6
 8084c6a:	f88d 3007 	strb.w	r3, [sp, #7]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c6e:	f002 fb25 	bl	80872bc <HAL_QSPI_Command>
 8084c72:	2800      	cmp	r0, #0
 8084c74:	d1af      	bne.n	8084bd6 <BSP_QSPI_Init+0x8e>
  if (HAL_QSPI_Transmit(hqspi, &reg, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8084c76:	f10d 0107 	add.w	r1, sp, #7
 8084c7a:	4620      	mov	r0, r4
 8084c7c:	f241 3288 	movw	r2, #5000	; 0x1388
 8084c80:	f002 fc4c 	bl	808751c <HAL_QSPI_Transmit>
 8084c84:	2800      	cmp	r0, #0
 8084c86:	f43f af6f 	beq.w	8084b68 <BSP_QSPI_Init+0x20>
 8084c8a:	e7a4      	b.n	8084bd6 <BSP_QSPI_Init+0x8e>

08084c8c <BSP_RNG_InitGenerator>:
  * @param  RNG_HandleTypeDef
  * @retval None
  */
void BSP_RNG_InitGenerator(void)
{
	RNG_Handle.State = HAL_RNG_STATE_RESET;
 8084c8c:	f64b 0308 	movw	r3, #47112	; 0xb808
 8084c90:	2200      	movs	r2, #0
 8084c92:	f2c2 0300 	movt	r3, #8192	; 0x2000
	HAL_RNG_Init(&RNG_Handle);
 8084c96:	4618      	mov	r0, r3
	RNG_Handle.State = HAL_RNG_STATE_RESET;
 8084c98:	725a      	strb	r2, [r3, #9]
	HAL_RNG_Init(&RNG_Handle);
 8084c9a:	f003 bc9d 	b.w	80885d8 <HAL_RNG_Init>
 8084c9e:	bf00      	nop

08084ca0 <BSP_RNG_GetNumber>:
  * @brief  Get random number
  * @param  RNG_HandleTypeDef
  * @retval 32 bit random value
  */
uint32_t BSP_RNG_GetNumber(void)
{
 8084ca0:	b510      	push	{r4, lr}
uint32_t val;

	if (HAL_RNG_GenerateRandomNumber(&RNG_Handle, &val) == HAL_OK)
 8084ca2:	f64b 0408 	movw	r4, #47112	; 0xb808
{
 8084ca6:	b082      	sub	sp, #8
	if (HAL_RNG_GenerateRandomNumber(&RNG_Handle, &val) == HAL_OK)
 8084ca8:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8084cac:	a901      	add	r1, sp, #4
 8084cae:	4620      	mov	r0, r4
 8084cb0:	f003 fcaa 	bl	8088608 <HAL_RNG_GenerateRandomNumber>
 8084cb4:	b110      	cbz	r0, 8084cbc <BSP_RNG_GetNumber+0x1c>
		return val;
	else
		return RNG_Handle.RandomNumber;
 8084cb6:	6860      	ldr	r0, [r4, #4]
}
 8084cb8:	b002      	add	sp, #8
 8084cba:	bd10      	pop	{r4, pc}
		return val;
 8084cbc:	9801      	ldr	r0, [sp, #4]
}
 8084cbe:	b002      	add	sp, #8
 8084cc0:	bd10      	pop	{r4, pc}
 8084cc2:	bf00      	nop

08084cc4 <HAL_RNG_MspInit>:
  * @retval None
  */
void HAL_RNG_MspInit(RNG_HandleTypeDef *hrng)
{
	/* Reset RNG */
	__HAL_RCC_RNG_FORCE_RESET();
 8084cc4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
{
 8084cc8:	b082      	sub	sp, #8
	__HAL_RCC_RNG_RELEASE_RESET();

	/* Enable clock for RNG */
	__HAL_RCC_RNG_CLK_ENABLE();

	hrng->Instance = RNG;
 8084cca:	f44f 6100 	mov.w	r1, #2048	; 0x800
	__HAL_RCC_RNG_FORCE_RESET();
 8084cce:	f2c4 0302 	movt	r3, #16386	; 0x4002
	hrng->Instance = RNG;
 8084cd2:	f2c5 0106 	movt	r1, #20486	; 0x5006
	__HAL_RCC_RNG_FORCE_RESET();
 8084cd6:	695a      	ldr	r2, [r3, #20]
 8084cd8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8084cdc:	615a      	str	r2, [r3, #20]
	__HAL_RCC_RNG_RELEASE_RESET();
 8084cde:	695a      	ldr	r2, [r3, #20]
 8084ce0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8084ce4:	615a      	str	r2, [r3, #20]
	__HAL_RCC_RNG_CLK_ENABLE();
 8084ce6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8084ce8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8084cec:	635a      	str	r2, [r3, #52]	; 0x34
 8084cee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
	hrng->Instance = RNG;
 8084cf0:	6001      	str	r1, [r0, #0]
	__HAL_RCC_RNG_CLK_ENABLE();
 8084cf2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8084cf6:	9301      	str	r3, [sp, #4]
 8084cf8:	9b01      	ldr	r3, [sp, #4]
}
 8084cfa:	b002      	add	sp, #8
 8084cfc:	4770      	bx	lr
 8084cfe:	bf00      	nop

08084d00 <BSP_SD_IsDetected>:
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t      status = SD_PRESENT;
  
  /* Check SD card detect pin */
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
 8084d00:	f44f 6000 	mov.w	r0, #2048	; 0x800
  __IO uint8_t      status = SD_PRESENT;
 8084d04:	2301      	movs	r3, #1
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
 8084d06:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8084d0a:	f2c4 0002 	movt	r0, #16386	; 0x4002
{
 8084d0e:	b500      	push	{lr}
 8084d10:	b083      	sub	sp, #12
  __IO uint8_t      status = SD_PRESENT;
 8084d12:	f88d 3007 	strb.w	r3, [sp, #7]
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
 8084d16:	f001 fbbd 	bl	8086494 <HAL_GPIO_ReadPin>
 8084d1a:	2801      	cmp	r0, #1
 8084d1c:	d102      	bne.n	8084d24 <BSP_SD_IsDetected+0x24>
  {
    status = SD_NOT_PRESENT;
 8084d1e:	2300      	movs	r3, #0
 8084d20:	f88d 3007 	strb.w	r3, [sp, #7]
  }

  return status;
 8084d24:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8084d28:	b003      	add	sp, #12
 8084d2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8084d2e:	bf00      	nop

08084d30 <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 8084d30:	b500      	push	{lr}
 8084d32:	b083      	sub	sp, #12
  if(HAL_SD_ReadBlocks(&uSdHandle, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
 8084d34:	9300      	str	r3, [sp, #0]
 8084d36:	4613      	mov	r3, r2
 8084d38:	460a      	mov	r2, r1
 8084d3a:	4601      	mov	r1, r0
 8084d3c:	f64d 0040 	movw	r0, #55360	; 0xd840
 8084d40:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084d44:	f004 f876 	bl	8088e34 <HAL_SD_ReadBlocks>
  }
  else
  {
    return MSD_OK;
  }
}
 8084d48:	3000      	adds	r0, #0
 8084d4a:	bf18      	it	ne
 8084d4c:	2001      	movne	r0, #1
 8084d4e:	b003      	add	sp, #12
 8084d50:	f85d fb04 	ldr.w	pc, [sp], #4

08084d54 <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 8084d54:	b500      	push	{lr}
 8084d56:	b083      	sub	sp, #12
  if(HAL_SD_WriteBlocks(&uSdHandle, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK)
 8084d58:	9300      	str	r3, [sp, #0]
 8084d5a:	4613      	mov	r3, r2
 8084d5c:	460a      	mov	r2, r1
 8084d5e:	4601      	mov	r1, r0
 8084d60:	f64d 0040 	movw	r0, #55360	; 0xd840
 8084d64:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084d68:	f004 f97a 	bl	8089060 <HAL_SD_WriteBlocks>
  }
  else
  {
    return MSD_OK;
  }
}
 8084d6c:	3000      	adds	r0, #0
 8084d6e:	bf18      	it	ne
 8084d70:	2001      	movne	r0, #1
 8084d72:	b003      	add	sp, #12
 8084d74:	f85d fb04 	ldr.w	pc, [sp], #4

08084d78 <BSP_SD_Erase>:
  * @param  EndAddr: End byte address
  * @retval SD status
  */
uint8_t BSP_SD_Erase(uint32_t StartAddr, uint32_t EndAddr)
{
  if(HAL_SD_Erase(&uSdHandle, StartAddr, EndAddr) != HAL_OK)
 8084d78:	460a      	mov	r2, r1
 8084d7a:	4601      	mov	r1, r0
 8084d7c:	f64d 0040 	movw	r0, #55360	; 0xd840
{
 8084d80:	b508      	push	{r3, lr}
  if(HAL_SD_Erase(&uSdHandle, StartAddr, EndAddr) != HAL_OK)
 8084d82:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084d86:	f004 fa6b 	bl	8089260 <HAL_SD_Erase>
  }
  else
  {
    return MSD_OK;
  }
}
 8084d8a:	3000      	adds	r0, #0
 8084d8c:	bf18      	it	ne
 8084d8e:	2001      	movne	r0, #1
 8084d90:	bd08      	pop	{r3, pc}
 8084d92:	bf00      	nop

08084d94 <BSP_SD_MspInit>:
  static DMA_HandleTypeDef dma_rx_handle;
  static DMA_HandleTypeDef dma_tx_handle;
  GPIO_InitTypeDef gpio_init_structure;

  /* Enable SDIO clock */
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084d94:	f44f 5260 	mov.w	r2, #14336	; 0x3800
  gpio_init_structure.Pull      = GPIO_PULLUP;
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
  gpio_init_structure.Alternate = GPIO_AF12_SDMMC1;
  
  /* GPIOC configuration */
  gpio_init_structure.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8084d98:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
  gpio_init_structure.Alternate = GPIO_AF12_SDMMC1;
 8084d9c:	230c      	movs	r3, #12
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084d9e:	f2c4 0202 	movt	r2, #16386	; 0x4002
{
 8084da2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084da6:	6c55      	ldr	r5, [r2, #68]	; 0x44
{
 8084da8:	b08d      	sub	sp, #52	; 0x34
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);

  /* GPIOD configuration */
  gpio_init_structure.Pin = GPIO_PIN_2;
 8084daa:	2704      	movs	r7, #4
{
 8084dac:	4606      	mov	r6, r0
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084dae:	f445 6500 	orr.w	r5, r5, #2048	; 0x800
  gpio_init_structure.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8084db2:	f10d 0830 	add.w	r8, sp, #48	; 0x30
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 8084db6:	f44f 6000 	mov.w	r0, #2048	; 0x800
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8084dba:	f04f 0e01 	mov.w	lr, #1
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084dbe:	6455      	str	r5, [r2, #68]	; 0x44
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 8084dc0:	f04f 0b03 	mov.w	fp, #3
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084dc4:	f8d2 a044 	ldr.w	sl, [r2, #68]	; 0x44
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8084dc8:	f04f 0902 	mov.w	r9, #2
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 8084dcc:	f2c4 0002 	movt	r0, #16386	; 0x4002
  HAL_NVIC_SetPriority(SDMMC1_IRQn, 0x0E, 0);
  HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
    
  /* Configure DMA Rx parameters */
  dma_rx_handle.Init.Channel             = SD_DMAx_Rx_CHANNEL;
  dma_rx_handle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 8084dd0:	2500      	movs	r5, #0
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084dd2:	f40a 6a00 	and.w	sl, sl, #2048	; 0x800
  dma_rx_handle.Init.Channel             = SD_DMAx_Rx_CHANNEL;
 8084dd6:	f64b 0414 	movw	r4, #47124	; 0xb814
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084dda:	f8cd a00c 	str.w	sl, [sp, #12]
  dma_rx_handle.Init.Channel             = SD_DMAx_Rx_CHANNEL;
 8084dde:	f2c2 0400 	movt	r4, #8192	; 0x2000
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8084de2:	f8dd a00c 	ldr.w	sl, [sp, #12]
  __DMAx_TxRx_CLK_ENABLE();
 8084de6:	f8d2 a030 	ldr.w	sl, [r2, #48]	; 0x30
 8084dea:	f44a 0a80 	orr.w	sl, sl, #4194304	; 0x400000
 8084dee:	f8c2 a030 	str.w	sl, [r2, #48]	; 0x30
 8084df2:	f8d2 a030 	ldr.w	sl, [r2, #48]	; 0x30
 8084df6:	f40a 0a80 	and.w	sl, sl, #4194304	; 0x400000
 8084dfa:	f8cd a010 	str.w	sl, [sp, #16]
 8084dfe:	f8dd a010 	ldr.w	sl, [sp, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8084e02:	f8d2 a030 	ldr.w	sl, [r2, #48]	; 0x30
 8084e06:	ea4a 0a07 	orr.w	sl, sl, r7
 8084e0a:	f8c2 a030 	str.w	sl, [r2, #48]	; 0x30
 8084e0e:	f8d2 a030 	ldr.w	sl, [r2, #48]	; 0x30
 8084e12:	ea0a 0a07 	and.w	sl, sl, r7
 8084e16:	f8cd a014 	str.w	sl, [sp, #20]
 8084e1a:	f8dd a014 	ldr.w	sl, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8084e1e:	f8d2 a030 	ldr.w	sl, [r2, #48]	; 0x30
 8084e22:	f04a 0a08 	orr.w	sl, sl, #8
 8084e26:	f8c2 a030 	str.w	sl, [r2, #48]	; 0x30
  dma_rx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
  dma_rx_handle.Init.MemInc              = DMA_MINC_ENABLE;
  dma_rx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  dma_rx_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
  dma_rx_handle.Init.Mode                = DMA_PFCTRL;
 8084e2a:	f04f 0a20 	mov.w	sl, #32
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8084e2e:	6b12      	ldr	r2, [r2, #48]	; 0x30
  gpio_init_structure.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8084e30:	f848 1d14 	str.w	r1, [r8, #-20]!
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 8084e34:	4641      	mov	r1, r8
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8084e36:	f002 0208 	and.w	r2, r2, #8
 8084e3a:	9206      	str	r2, [sp, #24]
 8084e3c:	9a06      	ldr	r2, [sp, #24]
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8084e3e:	e9cd 9e08 	strd	r9, lr, [sp, #32]
  gpio_init_structure.Alternate = GPIO_AF12_SDMMC1;
 8084e42:	e9cd b30a 	strd	fp, r3, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 8084e46:	f001 f90b 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8084e4a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8084e4e:	4641      	mov	r1, r8
  gpio_init_structure.Pin = GPIO_PIN_2;
 8084e50:	9707      	str	r7, [sp, #28]
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8084e52:	f2c4 0002 	movt	r0, #16386	; 0x4002
  dma_rx_handle.Init.Priority            = DMA_PRIORITY_VERY_HIGH;
 8084e56:	f44f 3940 	mov.w	r9, #196608	; 0x30000
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8084e5a:	f001 f901 	bl	8086060 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(SDMMC1_IRQn, 0x0E, 0);
 8084e5e:	462a      	mov	r2, r5
 8084e60:	210e      	movs	r1, #14
 8084e62:	2031      	movs	r0, #49	; 0x31
 8084e64:	f000 fcd4 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
 8084e68:	2031      	movs	r0, #49	; 0x31
 8084e6a:	f000 fd0d 	bl	8085888 <HAL_NVIC_EnableIRQ>
  dma_rx_handle.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;
  dma_rx_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dma_rx_handle.Init.MemBurst            = DMA_MBURST_INC4;
  dma_rx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
  
  dma_rx_handle.Instance = SD_DMAx_Rx_STREAM;
 8084e6e:	f246 4258 	movw	r2, #25688	; 0x6458
  dma_rx_handle.Init.Channel             = SD_DMAx_Rx_CHANNEL;
 8084e72:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  dma_rx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
 8084e76:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  dma_rx_handle.Instance = SD_DMAx_Rx_STREAM;
 8084e7a:	f2c4 0202 	movt	r2, #16386	; 0x4002
  
  /* Associate the DMA handle */
  __HAL_LINKDMA(hsd, hdmarx, dma_rx_handle);
 8084e7e:	63f4      	str	r4, [r6, #60]	; 0x3c
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_rx_handle);
 8084e80:	4620      	mov	r0, r4
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_rx_handle);
  
  /* Configure DMA Tx parameters */
  dma_tx_handle.Init.Channel             = SD_DMAx_Tx_CHANNEL;
 8084e82:	f64b 0874 	movw	r8, #47220	; 0xb874
  dma_rx_handle.Instance = SD_DMAx_Rx_STREAM;
 8084e86:	6022      	str	r2, [r4, #0]
  dma_rx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8084e88:	f44f 6280 	mov.w	r2, #1024	; 0x400
  dma_rx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
 8084e8c:	9101      	str	r1, [sp, #4]
  dma_tx_handle.Init.Channel             = SD_DMAx_Tx_CHANNEL;
 8084e8e:	f2c2 0800 	movt	r8, #8192	; 0x2000
  __HAL_LINKDMA(hsd, hdmarx, dma_rx_handle);
 8084e92:	63a6      	str	r6, [r4, #56]	; 0x38
  dma_rx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
 8084e94:	60e5      	str	r5, [r4, #12]
  dma_rx_handle.Init.Priority            = DMA_PRIORITY_VERY_HIGH;
 8084e96:	f8c4 9020 	str.w	r9, [r4, #32]
  dma_rx_handle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 8084e9a:	e9c4 3501 	strd	r3, r5, [r4, #4]
  dma_rx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8084e9e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8084ea2:	e9c4 2304 	strd	r2, r3, [r4, #16]
  dma_rx_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 8084ea6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  dma_rx_handle.Init.Mode                = DMA_PFCTRL;
 8084eaa:	e9c4 3a06 	strd	r3, sl, [r4, #24]
  dma_rx_handle.Init.MemBurst            = DMA_MBURST_INC4;
 8084eae:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  dma_rx_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8084eb2:	e9c4 7b09 	strd	r7, fp, [r4, #36]	; 0x24
  dma_rx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
 8084eb6:	e9c4 310b 	strd	r3, r1, [r4, #44]	; 0x2c
  HAL_DMA_DeInit(&dma_rx_handle);
 8084eba:	f000 fd9d 	bl	80859f8 <HAL_DMA_DeInit>
  HAL_DMA_Init(&dma_rx_handle);
 8084ebe:	4620      	mov	r0, r4
 8084ec0:	f000 fcfc 	bl	80858bc <HAL_DMA_Init>
  dma_tx_handle.Init.Channel             = SD_DMAx_Tx_CHANNEL;
 8084ec4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  dma_tx_handle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
  dma_tx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
  dma_tx_handle.Init.MemInc              = DMA_MINC_ENABLE;
  dma_tx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8084ec8:	f44f 6180 	mov.w	r1, #1024	; 0x400
  dma_tx_handle.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;
  dma_tx_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dma_tx_handle.Init.MemBurst            = DMA_MBURST_INC4;
  dma_tx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
  
  dma_tx_handle.Instance = SD_DMAx_Tx_STREAM;
 8084ecc:	f246 44a0 	movw	r4, #25760	; 0x64a0
  dma_tx_handle.Init.Channel             = SD_DMAx_Tx_CHANNEL;
 8084ed0:	f8c8 2004 	str.w	r2, [r8, #4]
  dma_tx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8084ed4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  dma_tx_handle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
 8084ed8:	2340      	movs	r3, #64	; 0x40
  dma_tx_handle.Instance = SD_DMAx_Tx_STREAM;
 8084eda:	f2c4 0402 	movt	r4, #16386	; 0x4002
  
  /* Associate the DMA handle */
  __HAL_LINKDMA(hsd, hdmatx, dma_tx_handle);
 8084ede:	f8c6 8040 	str.w	r8, [r6, #64]	; 0x40
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_tx_handle);
 8084ee2:	4640      	mov	r0, r8
  dma_tx_handle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
 8084ee4:	f8c8 3008 	str.w	r3, [r8, #8]
  dma_tx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
 8084ee8:	f8c8 500c 	str.w	r5, [r8, #12]
  dma_tx_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8084eec:	f8c8 b028 	str.w	fp, [r8, #40]	; 0x28
  __HAL_LINKDMA(hsd, hdmatx, dma_tx_handle);
 8084ef0:	f8c8 6038 	str.w	r6, [r8, #56]	; 0x38
  dma_tx_handle.Instance = SD_DMAx_Tx_STREAM;
 8084ef4:	f8c8 4000 	str.w	r4, [r8]
  dma_tx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8084ef8:	e9c8 1204 	strd	r1, r2, [r8, #16]
  dma_tx_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 8084efc:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  dma_tx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
 8084f00:	9901      	ldr	r1, [sp, #4]
  dma_tx_handle.Init.Mode                = DMA_PFCTRL;
 8084f02:	e9c8 2a06 	strd	r2, sl, [r8, #24]
  dma_tx_handle.Init.MemBurst            = DMA_MBURST_INC4;
 8084f06:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  dma_tx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
 8084f0a:	f8c8 1030 	str.w	r1, [r8, #48]	; 0x30
  dma_tx_handle.Init.MemBurst            = DMA_MBURST_INC4;
 8084f0e:	f8c8 202c 	str.w	r2, [r8, #44]	; 0x2c
  dma_tx_handle.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;
 8084f12:	e9c8 9708 	strd	r9, r7, [r8, #32]
  HAL_DMA_DeInit(&dma_tx_handle);
 8084f16:	f000 fd6f 	bl	80859f8 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_tx_handle); 
 8084f1a:	4640      	mov	r0, r8
 8084f1c:	f000 fcce 	bl	80858bc <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SD_DMAx_Rx_IRQn, 0x0F, 0);
 8084f20:	462a      	mov	r2, r5
 8084f22:	210f      	movs	r1, #15
 8084f24:	203b      	movs	r0, #59	; 0x3b
 8084f26:	f000 fc73 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SD_DMAx_Rx_IRQn);
 8084f2a:	203b      	movs	r0, #59	; 0x3b
 8084f2c:	f000 fcac 	bl	8085888 <HAL_NVIC_EnableIRQ>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SD_DMAx_Tx_IRQn, 0x0F, 0);
 8084f30:	462a      	mov	r2, r5
 8084f32:	210f      	movs	r1, #15
 8084f34:	2045      	movs	r0, #69	; 0x45
 8084f36:	f000 fc6b 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SD_DMAx_Tx_IRQn);
 8084f3a:	2045      	movs	r0, #69	; 0x45
 8084f3c:	f000 fca4 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 8084f40:	b00d      	add	sp, #52	; 0x34
 8084f42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8084f46:	bf00      	nop

08084f48 <BSP_SD_Detect_MspInit>:
  */
__weak void BSP_SD_Detect_MspInit(SD_HandleTypeDef *hsd, void *Params)
{
  GPIO_InitTypeDef  gpio_init_structure;

  SD_DETECT_GPIO_CLK_ENABLE();
 8084f48:	f44f 5360 	mov.w	r3, #14336	; 0x3800

  /* GPIO configuration in input for uSD_Detect signal */
  gpio_init_structure.Pin       = SD_DETECT_PIN;
 8084f4c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  gpio_init_structure.Mode      = GPIO_MODE_INPUT;
  gpio_init_structure.Pull      = GPIO_PULLUP;
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
 8084f50:	f44f 6000 	mov.w	r0, #2048	; 0x800
  SD_DETECT_GPIO_CLK_ENABLE();
 8084f54:	f2c4 0302 	movt	r3, #16386	; 0x4002
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
 8084f58:	f2c4 0002 	movt	r0, #16386	; 0x4002
  SD_DETECT_GPIO_CLK_ENABLE();
 8084f5c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8084f5e:	f042 0204 	orr.w	r2, r2, #4
{
 8084f62:	b570      	push	{r4, r5, r6, lr}
  SD_DETECT_GPIO_CLK_ENABLE();
 8084f64:	631a      	str	r2, [r3, #48]	; 0x30
{
 8084f66:	b086      	sub	sp, #24
  SD_DETECT_GPIO_CLK_ENABLE();
 8084f68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  gpio_init_structure.Mode      = GPIO_MODE_INPUT;
 8084f6a:	2600      	movs	r6, #0
  gpio_init_structure.Pin       = SD_DETECT_PIN;
 8084f6c:	9101      	str	r1, [sp, #4]
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8084f6e:	2501      	movs	r5, #1
  SD_DETECT_GPIO_CLK_ENABLE();
 8084f70:	f003 0304 	and.w	r3, r3, #4
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 8084f74:	2403      	movs	r4, #3
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
 8084f76:	a901      	add	r1, sp, #4
  SD_DETECT_GPIO_CLK_ENABLE();
 8084f78:	9300      	str	r3, [sp, #0]
 8084f7a:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
 8084f7c:	9404      	str	r4, [sp, #16]
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8084f7e:	e9cd 6502 	strd	r6, r5, [sp, #8]
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
 8084f82:	f001 f86d 	bl	8086060 <HAL_GPIO_Init>
}
 8084f86:	b006      	add	sp, #24
 8084f88:	bd70      	pop	{r4, r5, r6, pc}
 8084f8a:	bf00      	nop

08084f8c <BSP_SD_Init>:
  uSdHandle.Instance = SDMMC1;
 8084f8c:	f64d 0340 	movw	r3, #55360	; 0xd840
 8084f90:	f44f 5230 	mov.w	r2, #11264	; 0x2c00
{ 
 8084f94:	b530      	push	{r4, r5, lr}
  uSdHandle.Instance = SDMMC1;
 8084f96:	f2c2 0302 	movt	r3, #8194	; 0x2002
  uSdHandle.Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8084f9a:	2400      	movs	r4, #0
  uSdHandle.Instance = SDMMC1;
 8084f9c:	f2c4 0201 	movt	r2, #16385	; 0x4001
  uSdHandle.Init.ClockDiv            = SDMMC_TRANSFER_CLK_DIV;
 8084fa0:	2510      	movs	r5, #16
{ 
 8084fa2:	b083      	sub	sp, #12
  BSP_SD_Detect_MspInit(&uSdHandle, NULL);
 8084fa4:	4618      	mov	r0, r3
 8084fa6:	4621      	mov	r1, r4
  uSdHandle.Instance = SDMMC1;
 8084fa8:	601a      	str	r2, [r3, #0]
  uSdHandle.Init.ClockDiv            = SDMMC_TRANSFER_CLK_DIV;
 8084faa:	619d      	str	r5, [r3, #24]
  uSdHandle.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 8084fac:	615c      	str	r4, [r3, #20]
  uSdHandle.Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
 8084fae:	e9c3 4401 	strd	r4, r4, [r3, #4]
  uSdHandle.Init.BusWide             = SDMMC_BUS_WIDE_1B;
 8084fb2:	e9c3 4403 	strd	r4, r4, [r3, #12]
  BSP_SD_Detect_MspInit(&uSdHandle, NULL);
 8084fb6:	f7ff ffc7 	bl	8084f48 <BSP_SD_Detect_MspInit>
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
 8084fba:	f44f 6000 	mov.w	r0, #2048	; 0x800
  __IO uint8_t      status = SD_PRESENT;
 8084fbe:	2301      	movs	r3, #1
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
 8084fc0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8084fc4:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __IO uint8_t      status = SD_PRESENT;
 8084fc8:	f88d 3007 	strb.w	r3, [sp, #7]
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
 8084fcc:	f001 fa62 	bl	8086494 <HAL_GPIO_ReadPin>
 8084fd0:	2801      	cmp	r0, #1
 8084fd2:	d101      	bne.n	8084fd8 <BSP_SD_Init+0x4c>
    status = SD_NOT_PRESENT;
 8084fd4:	f88d 4007 	strb.w	r4, [sp, #7]
  return status;
 8084fd8:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8084fdc:	b2e4      	uxtb	r4, r4
  if(BSP_SD_IsDetected() != SD_PRESENT)   /* Check if SD card is present */
 8084fde:	2c01      	cmp	r4, #1
 8084fe0:	d002      	beq.n	8084fe8 <BSP_SD_Init+0x5c>
    return MSD_ERROR_SD_NOT_PRESENT;
 8084fe2:	2002      	movs	r0, #2
}
 8084fe4:	b003      	add	sp, #12
 8084fe6:	bd30      	pop	{r4, r5, pc}
  BSP_SD_MspInit(&uSdHandle, NULL);
 8084fe8:	f64d 0040 	movw	r0, #55360	; 0xd840
 8084fec:	2100      	movs	r1, #0
 8084fee:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084ff2:	f7ff fecf 	bl	8084d94 <BSP_SD_MspInit>
  if(HAL_SD_Init(&uSdHandle) != HAL_OK)
 8084ff6:	f64d 0040 	movw	r0, #55360	; 0xd840
 8084ffa:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8084ffe:	f004 fb89 	bl	8089714 <HAL_SD_Init>
 8085002:	b110      	cbz	r0, 808500a <BSP_SD_Init+0x7e>
    sd_state = MSD_ERROR;
 8085004:	4620      	mov	r0, r4
}
 8085006:	b003      	add	sp, #12
 8085008:	bd30      	pop	{r4, r5, pc}
    if(HAL_SD_ConfigWideBusOperation(&uSdHandle, SDMMC_BUS_WIDE_4B) != HAL_OK)
 808500a:	f64d 0040 	movw	r0, #55360	; 0xd840
 808500e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8085012:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8085016:	f004 fbaf 	bl	8089778 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
 808501a:	3000      	adds	r0, #0
 808501c:	bf18      	it	ne
 808501e:	2001      	movne	r0, #1
}
 8085020:	b003      	add	sp, #12
 8085022:	bd30      	pop	{r4, r5, pc}

08085024 <BSP_SD_GetCardInfo>:
  * @retval None 
  */
void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&uSdHandle, CardInfo);
 8085024:	4601      	mov	r1, r0
 8085026:	f64d 0040 	movw	r0, #55360	; 0xd840
 808502a:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808502e:	f004 bb8d 	b.w	808974c <HAL_SD_GetCardInfo>
 8085032:	bf00      	nop

08085034 <BSP_SDRAM_Initialization_sequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
 8085034:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  __IO uint32_t tmpmrd = 0;
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 8085038:	f64b 04d4 	movw	r4, #47316	; 0xb8d4
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 808503c:	f64d 05c4 	movw	r5, #55492	; 0xd8c4
{
 8085040:	b083      	sub	sp, #12
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 8085042:	2601      	movs	r6, #1
 8085044:	f2c2 0400 	movt	r4, #8192	; 0x2000
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8085048:	f2c2 0502 	movt	r5, #8194	; 0x2002
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 808504c:	2710      	movs	r7, #16
  __IO uint32_t tmpmrd = 0;
 808504e:	f04f 0800 	mov.w	r8, #0
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8085052:	4621      	mov	r1, r4
{
 8085054:	4681      	mov	r9, r0
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8085056:	f64f 72ff 	movw	r2, #65535	; 0xffff
 808505a:	4628      	mov	r0, r5
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 808505c:	6026      	str	r6, [r4, #0]
  Command.ModeRegisterDefinition = 0;
 808505e:	f8c4 800c 	str.w	r8, [r4, #12]
  __IO uint32_t tmpmrd = 0;
 8085062:	f8cd 8004 	str.w	r8, [sp, #4]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 8085066:	e9c4 7601 	strd	r7, r6, [r4, #4]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 808506a:	f004 fccb 	bl	8089a04 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);
 808506e:	4630      	mov	r0, r6
 8085070:	f000 fba4 	bl	80857bc <HAL_Delay>
    
  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
 8085074:	2302      	movs	r3, #2
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 8085076:	4621      	mov	r1, r4
 8085078:	4628      	mov	r0, r5
 808507a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
 808507e:	6023      	str	r3, [r4, #0]
  Command.ModeRegisterDefinition = 0;
 8085080:	f8c4 800c 	str.w	r8, [r4, #12]
  Command.AutoRefreshNumber      = 1;
 8085084:	e9c4 7601 	strd	r7, r6, [r4, #4]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 8085088:	f004 fcbc 	bl	8089a04 <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 808508c:	f04f 0c03 	mov.w	ip, #3
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 8;
 8085090:	2308      	movs	r3, #8
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 8085092:	4621      	mov	r1, r4
 8085094:	4628      	mov	r0, r5
 8085096:	f64f 72ff 	movw	r2, #65535	; 0xffff
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 808509a:	f8c4 c000 	str.w	ip, [r4]
  Command.AutoRefreshNumber      = 8;
 808509e:	60a3      	str	r3, [r4, #8]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 80850a0:	6067      	str	r7, [r4, #4]
  Command.ModeRegisterDefinition = 0;
 80850a2:	f8c4 800c 	str.w	r8, [r4, #12]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 80850a6:	f004 fcad 	bl	8089a04 <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 80850aa:	f44f 7308 	mov.w	r3, #544	; 0x220
                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
                     SDRAM_MODEREG_CAS_LATENCY_2           |\
                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
  
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
 80850ae:	f04f 0c04 	mov.w	ip, #4
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = tmpmrd;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 80850b2:	4621      	mov	r1, r4
 80850b4:	4628      	mov	r0, r5
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 80850b6:	9301      	str	r3, [sp, #4]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 80850b8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  Command.ModeRegisterDefinition = tmpmrd;
 80850bc:	9b01      	ldr	r3, [sp, #4]
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
 80850be:	f8c4 c000 	str.w	ip, [r4]
  Command.ModeRegisterDefinition = tmpmrd;
 80850c2:	60e3      	str	r3, [r4, #12]
  Command.AutoRefreshNumber      = 1;
 80850c4:	e9c4 7601 	strd	r7, r6, [r4, #4]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 80850c8:	f004 fc9c 	bl	8089a04 <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 80850cc:	4649      	mov	r1, r9
 80850ce:	4628      	mov	r0, r5
}
 80850d0:	b003      	add	sp, #12
 80850d2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 80850d6:	f004 bcaf 	b.w	8089a38 <HAL_SDRAM_ProgramRefreshRate>
 80850da:	bf00      	nop

080850dc <BSP_SDRAM_ReadData>:
  * @param  pData: Pointer to data to be read  
  * @param  uwDataSize: Size of read data from the memory
  * @retval SDRAM status
  */
uint8_t BSP_SDRAM_ReadData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
{
 80850dc:	b508      	push	{r3, lr}
  if(HAL_SDRAM_Read_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
 80850de:	4613      	mov	r3, r2
 80850e0:	460a      	mov	r2, r1
 80850e2:	4601      	mov	r1, r0
 80850e4:	f64d 00c4 	movw	r0, #55492	; 0xd8c4
 80850e8:	f2c2 0002 	movt	r0, #8194	; 0x2002
 80850ec:	f004 fbf2 	bl	80898d4 <HAL_SDRAM_Read_32b>
  }
  else
  {
    return SDRAM_OK;
  } 
}
 80850f0:	3000      	adds	r0, #0
 80850f2:	bf18      	it	ne
 80850f4:	2001      	movne	r0, #1
 80850f6:	bd08      	pop	{r3, pc}

080850f8 <BSP_SDRAM_ReadData_DMA>:
  * @param  pData: Pointer to data to be read  
  * @param  uwDataSize: Size of read data from the memory
  * @retval SDRAM status
  */
uint8_t BSP_SDRAM_ReadData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize)
{
 80850f8:	b508      	push	{r3, lr}
  if(HAL_SDRAM_Read_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
 80850fa:	4613      	mov	r3, r2
 80850fc:	460a      	mov	r2, r1
 80850fe:	4601      	mov	r1, r0
 8085100:	f64d 00c4 	movw	r0, #55492	; 0xd8c4
 8085104:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8085108:	f004 fc2c 	bl	8089964 <HAL_SDRAM_Read_DMA>
  }
  else
  {
    return SDRAM_OK;
  }     
}
 808510c:	3000      	adds	r0, #0
 808510e:	bf18      	it	ne
 8085110:	2001      	movne	r0, #1
 8085112:	bd08      	pop	{r3, pc}

08085114 <BSP_SDRAM_WriteData>:
  * @param  pData: Pointer to data to be written  
  * @param  uwDataSize: Size of written data from the memory
  * @retval SDRAM status
  */
uint8_t BSP_SDRAM_WriteData(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
{
 8085114:	b508      	push	{r3, lr}
  if(HAL_SDRAM_Write_32b(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
 8085116:	4613      	mov	r3, r2
 8085118:	460a      	mov	r2, r1
 808511a:	4601      	mov	r1, r0
 808511c:	f64d 00c4 	movw	r0, #55492	; 0xd8c4
 8085120:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8085124:	f004 fbfa 	bl	808991c <HAL_SDRAM_Write_32b>
  }
  else
  {
    return SDRAM_OK;
  }
}
 8085128:	3000      	adds	r0, #0
 808512a:	bf18      	it	ne
 808512c:	2001      	movne	r0, #1
 808512e:	bd08      	pop	{r3, pc}

08085130 <BSP_SDRAM_WriteData_DMA>:
  * @param  pData: Pointer to data to be written  
  * @param  uwDataSize: Size of written data from the memory
  * @retval SDRAM status
  */
uint8_t BSP_SDRAM_WriteData_DMA(uint32_t uwStartAddress, uint32_t *pData, uint32_t uwDataSize) 
{
 8085130:	b508      	push	{r3, lr}
  if(HAL_SDRAM_Write_DMA(&sdramHandle, (uint32_t *)uwStartAddress, pData, uwDataSize) != HAL_OK)
 8085132:	4613      	mov	r3, r2
 8085134:	460a      	mov	r2, r1
 8085136:	4601      	mov	r1, r0
 8085138:	f64d 00c4 	movw	r0, #55492	; 0xd8c4
 808513c:	f2c2 0002 	movt	r0, #8194	; 0x2002
 8085140:	f004 fc36 	bl	80899b0 <HAL_SDRAM_Write_DMA>
  }
  else
  {
    return SDRAM_OK;
  } 
}
 8085144:	3000      	adds	r0, #0
 8085146:	bf18      	it	ne
 8085148:	2001      	movne	r0, #1
 808514a:	bd08      	pop	{r3, pc}

0808514c <BSP_SDRAM_MspInit>:
{  
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
 808514c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8085150:	2102      	movs	r1, #2
  __HAL_RCC_FMC_CLK_ENABLE();
 8085152:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8085156:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8085158:	f042 0201 	orr.w	r2, r2, #1
{  
 808515c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_RCC_FMC_CLK_ENABLE();
 808515e:	639a      	str	r2, [r3, #56]	; 0x38
{  
 8085160:	b08f      	sub	sp, #60	; 0x3c
  __HAL_RCC_FMC_CLK_ENABLE();
 8085162:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  gpio_init_structure.Pull      = GPIO_PULLUP;
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
  
  /* GPIOC configuration */
  gpio_init_structure.Pin   = GPIO_PIN_3;
 8085164:	2408      	movs	r4, #8
 8085166:	ad0e      	add	r5, sp, #56	; 0x38
{  
 8085168:	4606      	mov	r6, r0
  __HAL_RCC_FMC_CLK_ENABLE();
 808516a:	f002 0201 	and.w	r2, r2, #1
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 808516e:	f44f 6000 	mov.w	r0, #2048	; 0x800
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8085172:	2701      	movs	r7, #1
  __HAL_RCC_FMC_CLK_ENABLE();
 8085174:	9201      	str	r2, [sp, #4]
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 8085176:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __HAL_RCC_FMC_CLK_ENABLE();
 808517a:	9a01      	ldr	r2, [sp, #4]
  __DMAx_CLK_ENABLE();
 808517c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 808517e:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8085182:	631a      	str	r2, [r3, #48]	; 0x30
 8085184:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8085186:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 808518a:	9202      	str	r2, [sp, #8]
 808518c:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 808518e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8085190:	f042 0204 	orr.w	r2, r2, #4
 8085194:	631a      	str	r2, [r3, #48]	; 0x30
 8085196:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8085198:	f002 0204 	and.w	r2, r2, #4
 808519c:	9203      	str	r2, [sp, #12]
 808519e:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80851a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851a2:	4322      	orrs	r2, r4
 80851a4:	631a      	str	r2, [r3, #48]	; 0x30
 80851a6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851a8:	4022      	ands	r2, r4
 80851aa:	9204      	str	r2, [sp, #16]
 80851ac:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80851ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851b0:	f042 0210 	orr.w	r2, r2, #16
 80851b4:	631a      	str	r2, [r3, #48]	; 0x30
 80851b6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851b8:	f002 0210 	and.w	r2, r2, #16
 80851bc:	9205      	str	r2, [sp, #20]
 80851be:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80851c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851c2:	f042 0220 	orr.w	r2, r2, #32
 80851c6:	631a      	str	r2, [r3, #48]	; 0x30
 80851c8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851ca:	f002 0220 	and.w	r2, r2, #32
 80851ce:	9206      	str	r2, [sp, #24]
 80851d0:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80851d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851d4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80851d8:	631a      	str	r2, [r3, #48]	; 0x30
 80851da:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851dc:	f002 0240 	and.w	r2, r2, #64	; 0x40
 80851e0:	9207      	str	r2, [sp, #28]
 80851e2:	9a07      	ldr	r2, [sp, #28]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80851e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80851e6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80851ea:	631a      	str	r2, [r3, #48]	; 0x30
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 80851ec:	220c      	movs	r2, #12
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80851ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  gpio_init_structure.Pin   = GPIO_PIN_3;
 80851f0:	f845 4d14 	str.w	r4, [r5, #-20]!
  /* GPIOH configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 80851f4:	f64b 1400 	movw	r4, #47360	; 0xb900
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80851f8:	f003 0380 	and.w	r3, r3, #128	; 0x80
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 80851fc:	910a      	str	r1, [sp, #40]	; 0x28
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
 80851fe:	910c      	str	r1, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 8085200:	4629      	mov	r1, r5
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8085202:	9308      	str	r3, [sp, #32]
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 8085204:	f2c2 0400 	movt	r4, #8192	; 0x2000
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 8085208:	920d      	str	r2, [sp, #52]	; 0x34
  __HAL_RCC_GPIOH_CLK_ENABLE();
 808520a:	9b08      	ldr	r3, [sp, #32]
  gpio_init_structure.Pull      = GPIO_PULLUP;
 808520c:	970b      	str	r7, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 808520e:	f000 ff27 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8085212:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
 8085216:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 808521a:	4629      	mov	r1, r5
 808521c:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
 8085220:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8085222:	f000 ff1d 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 8085226:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 808522a:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 808522e:	4629      	mov	r1, r5
 8085230:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 8085234:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 8085236:	f000 ff13 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 808523a:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 808523e:	f64f 033f 	movw	r3, #63551	; 0xf83f
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 8085242:	4629      	mov	r1, r5
 8085244:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 8085248:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 808524a:	f000 ff09 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 808524e:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
 8085252:	f248 1333 	movw	r3, #33075	; 0x8133
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 8085256:	4629      	mov	r1, r5
 8085258:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
 808525c:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 808525e:	f000 feff 	bl	8086060 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 8085262:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
 8085266:	2328      	movs	r3, #40	; 0x28
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 8085268:	4629      	mov	r1, r5
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 808526a:	2500      	movs	r5, #0
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 808526c:	f2c4 0002 	movt	r0, #16386	; 0x4002
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
 8085270:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 8085272:	f000 fef5 	bl	8086060 <HAL_GPIO_Init>
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 8085276:	2280      	movs	r2, #128	; 0x80
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
 8085278:	f44f 7000 	mov.w	r0, #512	; 0x200
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 808527c:	f44f 6180 	mov.w	r1, #1024	; 0x400
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 8085280:	60a2      	str	r2, [r4, #8]
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
  
  dma_handle.Instance = SDRAM_DMAx_STREAM;
 8085282:	f246 4310 	movw	r3, #25616	; 0x6410
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8085286:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
 808528a:	60e0      	str	r0, [r4, #12]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 808528c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  dma_handle.Instance = SDRAM_DMAx_STREAM;
 8085290:	f2c4 0302 	movt	r3, #16386	; 0x4002
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 8085294:	6121      	str	r1, [r4, #16]
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
 8085296:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 808529a:	6162      	str	r2, [r4, #20]
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 808529c:	2203      	movs	r2, #3
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 808529e:	6325      	str	r5, [r4, #48]	; 0x30
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 80852a0:	61a0      	str	r0, [r4, #24]
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
 80852a2:	4620      	mov	r0, r4
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 80852a4:	6334      	str	r4, [r6, #48]	; 0x30
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
 80852a6:	6221      	str	r1, [r4, #32]
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 80852a8:	62a2      	str	r2, [r4, #40]	; 0x28
  dma_handle.Init.Mode                = DMA_NORMAL;
 80852aa:	61e5      	str	r5, [r4, #28]
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
 80852ac:	6265      	str	r5, [r4, #36]	; 0x24
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
 80852ae:	62e5      	str	r5, [r4, #44]	; 0x2c
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 80852b0:	63a6      	str	r6, [r4, #56]	; 0x38
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 80852b2:	e9c4 3500 	strd	r3, r5, [r4]
  HAL_DMA_DeInit(&dma_handle);
 80852b6:	f000 fb9f 	bl	80859f8 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
 80852ba:	4620      	mov	r0, r4
 80852bc:	f000 fafe 	bl	80858bc <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0x0F, 0);
 80852c0:	462a      	mov	r2, r5
 80852c2:	210f      	movs	r1, #15
 80852c4:	2038      	movs	r0, #56	; 0x38
 80852c6:	f000 faa3 	bl	8085810 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
 80852ca:	2038      	movs	r0, #56	; 0x38
 80852cc:	f000 fadc 	bl	8085888 <HAL_NVIC_EnableIRQ>
}
 80852d0:	b00f      	add	sp, #60	; 0x3c
 80852d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080852d4 <BSP_SDRAM_Init>:
{ 
 80852d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 80852d6:	f44f 72a0 	mov.w	r2, #320	; 0x140
 80852da:	f64d 04c4 	movw	r4, #55492	; 0xd8c4
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 80852de:	2140      	movs	r1, #64	; 0x40
  sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 80852e0:	2610      	movs	r6, #16
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 80852e2:	f2c2 0402 	movt	r4, #8194	; 0x2002
 80852e6:	f2ca 0200 	movt	r2, #40960	; 0xa000
  Timing.LoadToActiveDelay    = 2;
 80852ea:	f64b 05e4 	movw	r5, #47332	; 0xb8e4
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
 80852ee:	2300      	movs	r3, #0
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 80852f0:	6022      	str	r2, [r4, #0]
  sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 80852f2:	f44f 6200 	mov.w	r2, #2048	; 0x800
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 80852f6:	6161      	str	r1, [r4, #20]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
 80852f8:	f44f 7080 	mov.w	r0, #256	; 0x100
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 80852fc:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  Timing.LoadToActiveDelay    = 2;
 8085300:	f2c2 0500 	movt	r5, #8192	; 0x2000
  sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 8085304:	6126      	str	r6, [r4, #16]
  Timing.SelfRefreshTime      = 4;
 8085306:	2704      	movs	r7, #4
  sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 8085308:	6222      	str	r2, [r4, #32]
  Timing.ExitSelfRefreshDelay = 7;
 808530a:	2607      	movs	r6, #7
  Timing.LoadToActiveDelay    = 2;
 808530c:	2202      	movs	r2, #2
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
 808530e:	61a0      	str	r0, [r4, #24]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 8085310:	6261      	str	r1, [r4, #36]	; 0x24
  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 8085312:	4620      	mov	r0, r4
 8085314:	4619      	mov	r1, r3
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
 8085316:	6063      	str	r3, [r4, #4]
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 8085318:	60a3      	str	r3, [r4, #8]
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 808531a:	61e3      	str	r3, [r4, #28]
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
 808531c:	62a3      	str	r3, [r4, #40]	; 0x28
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 808531e:	60e7      	str	r7, [r4, #12]
  Timing.LoadToActiveDelay    = 2;
 8085320:	602a      	str	r2, [r5, #0]
  Timing.RCDDelay             = 2;
 8085322:	61aa      	str	r2, [r5, #24]
  Timing.SelfRefreshTime      = 4;
 8085324:	60af      	str	r7, [r5, #8]
  Timing.ExitSelfRefreshDelay = 7;
 8085326:	606e      	str	r6, [r5, #4]
  Timing.RowCycleDelay        = 7;
 8085328:	60ee      	str	r6, [r5, #12]
  Timing.RPDelay              = 2;
 808532a:	e9c5 2204 	strd	r2, r2, [r5, #16]
  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 808532e:	f7ff ff0d 	bl	808514c <BSP_SDRAM_MspInit>
  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 8085332:	4620      	mov	r0, r4
 8085334:	4629      	mov	r1, r5
    sdramstatus = SDRAM_ERROR;
 8085336:	f24b 0480 	movw	r4, #45184	; 0xb080
  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 808533a:	f004 faa9 	bl	8089890 <HAL_SDRAM_Init>
 808533e:	b940      	cbnz	r0, 8085352 <BSP_SDRAM_Init+0x7e>
    sdramstatus = SDRAM_OK;
 8085340:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8085344:	7020      	strb	r0, [r4, #0]
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
 8085346:	f240 6003 	movw	r0, #1539	; 0x603
 808534a:	f7ff fe73 	bl	8085034 <BSP_SDRAM_Initialization_sequence>
}
 808534e:	7820      	ldrb	r0, [r4, #0]
 8085350:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    sdramstatus = SDRAM_ERROR;
 8085352:	2301      	movs	r3, #1
 8085354:	f2c2 0400 	movt	r4, #8192	; 0x2000
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
 8085358:	f240 6003 	movw	r0, #1539	; 0x603
    sdramstatus = SDRAM_ERROR;
 808535c:	7023      	strb	r3, [r4, #0]
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
 808535e:	f7ff fe69 	bl	8085034 <BSP_SDRAM_Initialization_sequence>
}
 8085362:	7820      	ldrb	r0, [r4, #0]
 8085364:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8085366:	bf00      	nop

08085368 <BSP_STDIO_SendData>:
/**
 * @brief  Send data
 * @retval STDIO status
 */
uint8_t BSP_STDIO_SendData   (uint8_t* data, uint16_t len)
{
 8085368:	b510      	push	{r4, lr}
	uint8_t status;

	for (int i=0; i<len; i++)
 808536a:	460a      	mov	r2, r1
 808536c:	b151      	cbz	r1, 8085384 <BSP_STDIO_SendData+0x1c>
 808536e:	f64d 03f8 	movw	r3, #55544	; 0xd8f8
 8085372:	1844      	adds	r4, r0, r1
 8085374:	f2c2 0302 	movt	r3, #8194	; 0x2002
	{
		stdoutBuffer[i] = (char)data[i];
 8085378:	f810 1b01 	ldrb.w	r1, [r0], #1
	for (int i=0; i<len; i++)
 808537c:	42a0      	cmp	r0, r4
		stdoutBuffer[i] = (char)data[i];
 808537e:	f803 1b01 	strb.w	r1, [r3], #1
	for (int i=0; i<len; i++)
 8085382:	d1f9      	bne.n	8085378 <BSP_STDIO_SendData+0x10>
	}

	status = HAL_UART_Transmit(&UARTHandle, (uint8_t*)stdoutBuffer, len, 100);
 8085384:	f64d 01f8 	movw	r1, #55544	; 0xd8f8
 8085388:	f64b 1060 	movw	r0, #47456	; 0xb960
 808538c:	2364      	movs	r3, #100	; 0x64
 808538e:	f2c2 0102 	movt	r1, #8194	; 0x2002
 8085392:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8085396:	f005 fb23 	bl	808a9e0 <HAL_UART_Transmit>
	{
		return STDIO_ERROR;
	}

	return STDIO_OK;
}
 808539a:	3000      	adds	r0, #0
 808539c:	bf18      	it	ne
 808539e:	2001      	movne	r0, #1
 80853a0:	bd10      	pop	{r4, pc}
 80853a2:	bf00      	nop

080853a4 <BSP_STDIO_IRQHandler>:

void BSP_STDIO_IRQHandler	(void)
{
	HAL_UART_IRQHandler(&UARTHandle);
 80853a4:	f64b 1060 	movw	r0, #47456	; 0xb960
 80853a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80853ac:	f005 bbb8 	b.w	808ab20 <HAL_UART_IRQHandler>

080853b0 <BSP_STDIO_DataReceived>:
}

__weak void BSP_STDIO_DataReceived	(char* data, uint16_t length)
{
 80853b0:	b510      	push	{r4, lr}
	//volatile uint8_t status;

	for (int i=0; i<length;i++)
 80853b2:	460a      	mov	r2, r1
 80853b4:	b151      	cbz	r1, 80853cc <BSP_STDIO_DataReceived+0x1c>
 80853b6:	f64d 03f8 	movw	r3, #55544	; 0xd8f8
 80853ba:	1844      	adds	r4, r0, r1
 80853bc:	f2c2 0302 	movt	r3, #8194	; 0x2002
	{
		stdoutBuffer[i] = data[i];
 80853c0:	f810 1b01 	ldrb.w	r1, [r0], #1
	for (int i=0; i<length;i++)
 80853c4:	42a0      	cmp	r0, r4
		stdoutBuffer[i] = data[i];
 80853c6:	f803 1b01 	strb.w	r1, [r3], #1
	for (int i=0; i<length;i++)
 80853ca:	d1f9      	bne.n	80853c0 <BSP_STDIO_DataReceived+0x10>
	}

	HAL_UART_Transmit(&UARTHandle, (uint8_t*)stdoutBuffer, length, 100);
 80853cc:	f64d 01f8 	movw	r1, #55544	; 0xd8f8
 80853d0:	f64b 1060 	movw	r0, #47456	; 0xb960
 80853d4:	2364      	movs	r3, #100	; 0x64
 80853d6:	f2c2 0102 	movt	r1, #8194	; 0x2002
 80853da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80853de:	f005 faff 	bl	808a9e0 <HAL_UART_Transmit>

	HAL_UART_Receive_IT(&UARTHandle,(uint8_t*)stdinBuffer, 1);
 80853e2:	f64d 115c 	movw	r1, #55644	; 0xd95c
 80853e6:	f64b 1060 	movw	r0, #47456	; 0xb960
 80853ea:	2201      	movs	r2, #1
 80853ec:	f2c2 0102 	movt	r1, #8194	; 0x2002
 80853f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
}
 80853f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_UART_Receive_IT(&UARTHandle,(uint8_t*)stdinBuffer, 1);
 80853f8:	f005 ba72 	b.w	808a8e0 <HAL_UART_Receive_IT>

080853fc <BSP_STDIO_MspInit>:
 *           - Peripheral's GPIO Configuration
 *           - NVIC configuration for QSPI interrupt
 * @retval None
 */
__weak void BSP_STDIO_MspInit(void)
{
 80853fc:	b508      	push	{r3, lr}
	/*##-3- Configure the NVIC for USART1 #########################################*/
	/* NVIC configuration for USART1 interrupt */
	HAL_NVIC_SetPriority(DISCOVERY_COM1_IRQn, 0x0F, 0);
 80853fe:	2025      	movs	r0, #37	; 0x25
 8085400:	2200      	movs	r2, #0
 8085402:	210f      	movs	r1, #15
 8085404:	f000 fa04 	bl	8085810 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DISCOVERY_COM1_IRQn);
 8085408:	2025      	movs	r0, #37	; 0x25
}
 808540a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	HAL_NVIC_EnableIRQ(DISCOVERY_COM1_IRQn);
 808540e:	f000 ba3b 	b.w	8085888 <HAL_NVIC_EnableIRQ>
 8085412:	bf00      	nop

08085414 <BSP_STDIO_Init>:
{ 
 8085414:	b538      	push	{r3, r4, r5, lr}
	UARTHandle.Instance = USART1;
 8085416:	f64b 1460 	movw	r4, #47456	; 0xb960
 808541a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 808541e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8085422:	f2c4 0301 	movt	r3, #16385	; 0x4001
	if (HAL_UART_DeInit(&UARTHandle) != HAL_OK)
 8085426:	4620      	mov	r0, r4
	UARTHandle.Instance = USART1;
 8085428:	6023      	str	r3, [r4, #0]
	if (HAL_UART_DeInit(&UARTHandle) != HAL_OK)
 808542a:	f005 fa3d 	bl	808a8a8 <HAL_UART_DeInit>
 808542e:	b108      	cbz	r0, 8085434 <BSP_STDIO_Init+0x20>
		return STDIO_ERROR;
 8085430:	2001      	movs	r0, #1
}
 8085432:	bd38      	pop	{r3, r4, r5, pc}
	UARTHandle.Init.BaudRate = 115200;
 8085434:	f44f 35e1 	mov.w	r5, #115200	; 0x1c200
	UARTHandle.Init.Mode = USART_MODE_TX_RX;
 8085438:	220c      	movs	r2, #12
	if (BSP_COM_Init(COM1, &UARTHandle) != HAL_OK)
 808543a:	4621      	mov	r1, r4
	UARTHandle.Init.OverSampling = USART_OVERSAMPLING_16;
 808543c:	61e0      	str	r0, [r4, #28]
	UARTHandle.Init.Mode = USART_MODE_TX_RX;
 808543e:	6162      	str	r2, [r4, #20]
	UARTHandle.Init.BaudRate = 115200;
 8085440:	e9c4 5001 	strd	r5, r0, [r4, #4]
	UARTHandle.Init.StopBits = USART_STOPBITS_1;
 8085444:	e9c4 0003 	strd	r0, r0, [r4, #12]
	if (BSP_COM_Init(COM1, &UARTHandle) != HAL_OK)
 8085448:	f7fc fe70 	bl	808212c <BSP_COM_Init>
 808544c:	4605      	mov	r5, r0
 808544e:	2800      	cmp	r0, #0
 8085450:	d1ee      	bne.n	8085430 <BSP_STDIO_Init+0x1c>
	BSP_STDIO_MspInit();
 8085452:	f7ff ffd3 	bl	80853fc <BSP_STDIO_MspInit>
	HAL_UART_Receive_IT(&UARTHandle,(uint8_t*)stdinBuffer, 1);
 8085456:	f64d 115c 	movw	r1, #55644	; 0xd95c
 808545a:	4620      	mov	r0, r4
 808545c:	2201      	movs	r2, #1
 808545e:	f2c2 0102 	movt	r1, #8194	; 0x2002
 8085462:	f005 fa3d 	bl	808a8e0 <HAL_UART_Receive_IT>
	return STDIO_OK;
 8085466:	4628      	mov	r0, r5
}
 8085468:	bd38      	pop	{r3, r4, r5, pc}
 808546a:	bf00      	nop

0808546c <BSP_TS_Init>:
 * @param  ts_SizeX: Maximum X size of the TS area on LCD
 * @param  ts_SizeY: Maximum Y size of the TS area on LCD
 * @retval TS_OK if all initializations are OK. Other value if error.
 */
uint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)
{
 808546c:	b570      	push	{r4, r5, r6, lr}
	uint8_t status = TS_OK;
	tsXBoundary = ts_SizeX;
 808546e:	f64b 2202 	movw	r2, #47618	; 0xba02
	tsYBoundary = ts_SizeY;

	/* Read ID and verify if the touch screen driver is ready */
	ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 8085472:	f24b 0400 	movw	r4, #45056	; 0xb000
	tsYBoundary = ts_SizeY;
 8085476:	f64b 2304 	movw	r3, #47620	; 0xba04
	tsXBoundary = ts_SizeX;
 808547a:	f2c2 0200 	movt	r2, #8192	; 0x2000
	ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 808547e:	f2c2 0400 	movt	r4, #8192	; 0x2000
	tsYBoundary = ts_SizeY;
 8085482:	f2c2 0300 	movt	r3, #8192	; 0x2000
	tsXBoundary = ts_SizeX;
 8085486:	8010      	strh	r0, [r2, #0]
	ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 8085488:	2070      	movs	r0, #112	; 0x70
 808548a:	6822      	ldr	r2, [r4, #0]
	tsYBoundary = ts_SizeY;
 808548c:	8019      	strh	r1, [r3, #0]
	ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 808548e:	4790      	blx	r2
	if(ft5336_ts_drv.ReadID(TS_I2C_ADDRESS) == FT5336_ID_VALUE)
 8085490:	6863      	ldr	r3, [r4, #4]
 8085492:	2070      	movs	r0, #112	; 0x70
 8085494:	4798      	blx	r3
 8085496:	2851      	cmp	r0, #81	; 0x51
 8085498:	d115      	bne.n	80854c6 <BSP_TS_Init+0x5a>
	{
		/* Initialize the TS driver structure */
		tsDriver = &ft5336_ts_drv;
 808549a:	f64b 11fc 	movw	r1, #47612	; 0xb9fc
		I2cAddress = TS_I2C_ADDRESS;
 808549e:	f64b 12d0 	movw	r2, #47568	; 0xb9d0
		tsOrientation = TS_SWAP_XY;
 80854a2:	f64b 2300 	movw	r3, #47616	; 0xba00
		I2cAddress = TS_I2C_ADDRESS;
 80854a6:	2570      	movs	r5, #112	; 0x70
		tsDriver = &ft5336_ts_drv;
 80854a8:	f2c2 0100 	movt	r1, #8192	; 0x2000
		I2cAddress = TS_I2C_ADDRESS;
 80854ac:	f2c2 0200 	movt	r2, #8192	; 0x2000
		tsOrientation = TS_SWAP_XY;
 80854b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80854b4:	2608      	movs	r6, #8
		tsDriver = &ft5336_ts_drv;
 80854b6:	600c      	str	r4, [r1, #0]

		/* Initialize the TS driver */
		tsDriver->Start(I2cAddress);
 80854b8:	4628      	mov	r0, r5
 80854ba:	68e1      	ldr	r1, [r4, #12]
		I2cAddress = TS_I2C_ADDRESS;
 80854bc:	7015      	strb	r5, [r2, #0]
		tsOrientation = TS_SWAP_XY;
 80854be:	701e      	strb	r6, [r3, #0]
		tsDriver->Start(I2cAddress);
 80854c0:	4788      	blx	r1
	uint8_t status = TS_OK;
 80854c2:	2000      	movs	r0, #0
	{
		status = TS_DEVICE_NOT_FOUND;
	}

	return status;
}
 80854c4:	bd70      	pop	{r4, r5, r6, pc}
		status = TS_DEVICE_NOT_FOUND;
 80854c6:	2003      	movs	r0, #3
}
 80854c8:	bd70      	pop	{r4, r5, r6, pc}
 80854ca:	bf00      	nop

080854cc <BSP_TS_Get_GestureId>:
 * @brief  Update gesture Id following a touch detected.
 * @param  TS_State: Pointer to touch screen current state structure
 * @retval TS_OK if all initializations are OK. Other value if error.
 */
uint8_t BSP_TS_Get_GestureId(TS_StateTypeDef *TS_State)
{
 80854cc:	b530      	push	{r4, r5, lr}
	uint32_t gestureId = 0;
	uint8_t  ts_status = TS_OK;

	/* Get gesture Id */
	ft5336_TS_GetGestureID(I2cAddress, &gestureId);
 80854ce:	f64b 13d0 	movw	r3, #47568	; 0xb9d0
{
 80854d2:	b083      	sub	sp, #12
	uint32_t gestureId = 0;
 80854d4:	2400      	movs	r4, #0
{
 80854d6:	4605      	mov	r5, r0
	uint32_t gestureId = 0;
 80854d8:	a902      	add	r1, sp, #8
	ft5336_TS_GetGestureID(I2cAddress, &gestureId);
 80854da:	f2c2 0300 	movt	r3, #8192	; 0x2000
	uint32_t gestureId = 0;
 80854de:	f841 4d04 	str.w	r4, [r1, #-4]!
	ft5336_TS_GetGestureID(I2cAddress, &gestureId);
 80854e2:	7818      	ldrb	r0, [r3, #0]
 80854e4:	f7fb fc88 	bl	8080df8 <ft5336_TS_GetGestureID>

	/* Remap gesture Id to a TS_GestureIdTypeDef value */
	switch(gestureId)
 80854e8:	9801      	ldr	r0, [sp, #4]
 80854ea:	2818      	cmp	r0, #24
 80854ec:	d02b      	beq.n	8085546 <BSP_TS_Get_GestureId+0x7a>
 80854ee:	d908      	bls.n	8085502 <BSP_TS_Get_GestureId+0x36>
 80854f0:	2840      	cmp	r0, #64	; 0x40
 80854f2:	d019      	beq.n	8085528 <BSP_TS_Get_GestureId+0x5c>
 80854f4:	2849      	cmp	r0, #73	; 0x49
 80854f6:	d00d      	beq.n	8085514 <BSP_TS_Get_GestureId+0x48>
 80854f8:	281c      	cmp	r0, #28
 80854fa:	d01a      	beq.n	8085532 <BSP_TS_Get_GestureId+0x66>
		break;
	case FT5336_GEST_ID_ZOOM_OUT :
		TS_State->gestureId = GEST_ID_ZOOM_OUT;
		break;
	default :
		ts_status = TS_ERROR;
 80854fc:	2001      	movs	r0, #1
		break;
	} /* of switch(gestureId) */

	return(ts_status);
}
 80854fe:	b003      	add	sp, #12
 8085500:	bd30      	pop	{r4, r5, pc}
	switch(gestureId)
 8085502:	2810      	cmp	r0, #16
 8085504:	d01a      	beq.n	808553c <BSP_TS_Get_GestureId+0x70>
 8085506:	2814      	cmp	r0, #20
 8085508:	d009      	beq.n	808551e <BSP_TS_Get_GestureId+0x52>
 808550a:	2800      	cmp	r0, #0
 808550c:	d1f6      	bne.n	80854fc <BSP_TS_Get_GestureId+0x30>
		TS_State->gestureId = GEST_ID_NO_GESTURE;
 808550e:	62a8      	str	r0, [r5, #40]	; 0x28
}
 8085510:	b003      	add	sp, #12
 8085512:	bd30      	pop	{r4, r5, pc}
		TS_State->gestureId = GEST_ID_ZOOM_OUT;
 8085514:	2306      	movs	r3, #6
	uint8_t  ts_status = TS_OK;
 8085516:	4620      	mov	r0, r4
		TS_State->gestureId = GEST_ID_ZOOM_OUT;
 8085518:	62ab      	str	r3, [r5, #40]	; 0x28
}
 808551a:	b003      	add	sp, #12
 808551c:	bd30      	pop	{r4, r5, pc}
		TS_State->gestureId = GEST_ID_MOVE_RIGHT;
 808551e:	2302      	movs	r3, #2
	uint8_t  ts_status = TS_OK;
 8085520:	4620      	mov	r0, r4
		TS_State->gestureId = GEST_ID_MOVE_RIGHT;
 8085522:	62ab      	str	r3, [r5, #40]	; 0x28
}
 8085524:	b003      	add	sp, #12
 8085526:	bd30      	pop	{r4, r5, pc}
		TS_State->gestureId = GEST_ID_ZOOM_IN;
 8085528:	2305      	movs	r3, #5
	uint8_t  ts_status = TS_OK;
 808552a:	4620      	mov	r0, r4
		TS_State->gestureId = GEST_ID_ZOOM_IN;
 808552c:	62ab      	str	r3, [r5, #40]	; 0x28
}
 808552e:	b003      	add	sp, #12
 8085530:	bd30      	pop	{r4, r5, pc}
		TS_State->gestureId = GEST_ID_MOVE_LEFT;
 8085532:	2304      	movs	r3, #4
	uint8_t  ts_status = TS_OK;
 8085534:	4620      	mov	r0, r4
		TS_State->gestureId = GEST_ID_MOVE_LEFT;
 8085536:	62ab      	str	r3, [r5, #40]	; 0x28
}
 8085538:	b003      	add	sp, #12
 808553a:	bd30      	pop	{r4, r5, pc}
		TS_State->gestureId = GEST_ID_MOVE_UP;
 808553c:	2301      	movs	r3, #1
	uint8_t  ts_status = TS_OK;
 808553e:	4620      	mov	r0, r4
		TS_State->gestureId = GEST_ID_MOVE_UP;
 8085540:	62ab      	str	r3, [r5, #40]	; 0x28
}
 8085542:	b003      	add	sp, #12
 8085544:	bd30      	pop	{r4, r5, pc}
		TS_State->gestureId = GEST_ID_MOVE_DOWN;
 8085546:	2303      	movs	r3, #3
	uint8_t  ts_status = TS_OK;
 8085548:	4620      	mov	r0, r4
		TS_State->gestureId = GEST_ID_MOVE_DOWN;
 808554a:	62ab      	str	r3, [r5, #40]	; 0x28
}
 808554c:	b003      	add	sp, #12
 808554e:	bd30      	pop	{r4, r5, pc}

08085550 <BSP_TS_GetState>:
{
 8085550:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 8085554:	f64b 19fc 	movw	r9, #47612	; 0xb9fc
 8085558:	f64b 1bd0 	movw	fp, #47568	; 0xb9d0
{
 808555c:	b097      	sub	sp, #92	; 0x5c
	uint32_t weight = 0;
 808555e:	2400      	movs	r4, #0
	TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 8085560:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8085564:	f2c2 0b00 	movt	fp, #8192	; 0x2000
{
 8085568:	4605      	mov	r5, r0
 808556a:	9003      	str	r0, [sp, #12]
	TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 808556c:	f8d9 3000 	ldr.w	r3, [r9]
	uint32_t weight = 0;
 8085570:	9407      	str	r4, [sp, #28]
	TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 8085572:	f89b 0000 	ldrb.w	r0, [fp]
 8085576:	691b      	ldr	r3, [r3, #16]
	uint32_t event = 0;
 8085578:	e9cd 4408 	strd	r4, r4, [sp, #32]
	TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 808557c:	4798      	blx	r3
 808557e:	7028      	strb	r0, [r5, #0]
	if(TS_State->touchDetected)
 8085580:	2800      	cmp	r0, #0
 8085582:	f000 80a5 	beq.w	80856d0 <BSP_TS_GetState+0x180>
 8085586:	462b      	mov	r3, r5
 8085588:	f64b 2200 	movw	r2, #47616	; 0xba00
 808558c:	f64b 18d4 	movw	r8, #47572	; 0xb9d4
 8085590:	f64b 1ae8 	movw	sl, #47592	; 0xb9e8
 8085594:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8085598:	ad10      	add	r5, sp, #64	; 0x40
 808559a:	f2c2 0800 	movt	r8, #8192	; 0x2000
 808559e:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80855a2:	f103 0716 	add.w	r7, r3, #22
 80855a6:	1c9e      	adds	r6, r3, #2
 80855a8:	9204      	str	r2, [sp, #16]
 80855aa:	f8cd 9014 	str.w	r9, [sp, #20]
 80855ae:	f8cd b008 	str.w	fp, [sp, #8]
			tsDriver->GetXY(I2cAddress, &(brute_x[index]), &(brute_y[index]));
 80855b2:	9b05      	ldr	r3, [sp, #20]
 80855b4:	aa13      	add	r2, sp, #76	; 0x4c
 80855b6:	9802      	ldr	r0, [sp, #8]
 80855b8:	4629      	mov	r1, r5
 80855ba:	681b      	ldr	r3, [r3, #0]
 80855bc:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 80855c0:	7800      	ldrb	r0, [r0, #0]
 80855c2:	695b      	ldr	r3, [r3, #20]
 80855c4:	4798      	blx	r3
			if(tsOrientation == TS_SWAP_NONE)
 80855c6:	9b04      	ldr	r3, [sp, #16]
 80855c8:	781b      	ldrb	r3, [r3, #0]
 80855ca:	2b01      	cmp	r3, #1
 80855cc:	f000 80ad 	beq.w	808572a <BSP_TS_GetState+0x1da>
			if(tsOrientation & TS_SWAP_X)
 80855d0:	0799      	lsls	r1, r3, #30
 80855d2:	d505      	bpl.n	80855e0 <BSP_TS_GetState+0x90>
				x[index] = 4096 - brute_x[index];
 80855d4:	882a      	ldrh	r2, [r5, #0]
 80855d6:	a90a      	add	r1, sp, #40	; 0x28
 80855d8:	f5c2 5280 	rsb	r2, r2, #4096	; 0x1000
 80855dc:	f821 2014 	strh.w	r2, [r1, r4, lsl #1]
			if(tsOrientation & TS_SWAP_Y)
 80855e0:	075a      	lsls	r2, r3, #29
 80855e2:	d507      	bpl.n	80855f4 <BSP_TS_GetState+0xa4>
				y[index] = 4096 - brute_y[index];
 80855e4:	aa13      	add	r2, sp, #76	; 0x4c
 80855e6:	a90d      	add	r1, sp, #52	; 0x34
 80855e8:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
 80855ec:	f5c2 5280 	rsb	r2, r2, #4096	; 0x1000
 80855f0:	f821 2014 	strh.w	r2, [r1, r4, lsl #1]
			if(tsOrientation & TS_SWAP_XY)
 80855f4:	071b      	lsls	r3, r3, #28
 80855f6:	d477      	bmi.n	80856e8 <BSP_TS_GetState+0x198>
 80855f8:	ab0a      	add	r3, sp, #40	; 0x28
 80855fa:	f833 2014 	ldrh.w	r2, [r3, r4, lsl #1]
 80855fe:	ab0d      	add	r3, sp, #52	; 0x34
	if ((int32_t)(480 - x[index])>=0)
 8085600:	f5d2 72f0 	rsbs	r2, r2, #480	; 0x1e0
 8085604:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
 8085608:	d47b      	bmi.n	8085702 <BSP_TS_GetState+0x1b2>
		x[index] = 480 - x[index];
 808560a:	b292      	uxth	r2, r2
 808560c:	a90a      	add	r1, sp, #40	; 0x28
	if ((int32_t)(260 - y[index])>=0)
 808560e:	f5d3 7382 	rsbs	r3, r3, #260	; 0x104
		x[index] = 480 - x[index];
 8085612:	f821 2014 	strh.w	r2, [r1, r4, lsl #1]
 8085616:	4693      	mov	fp, r2
	if ((int32_t)(260 - y[index])>=0)
 8085618:	d47e      	bmi.n	8085718 <BSP_TS_GetState+0x1c8>
		y[index] = 260 - y[index];
 808561a:	b29b      	uxth	r3, r3
 808561c:	a90d      	add	r1, sp, #52	; 0x34
 808561e:	4699      	mov	r9, r3
 8085620:	f821 3014 	strh.w	r3, [r1, r4, lsl #1]
	x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 8085624:	f858 0024 	ldr.w	r0, [r8, r4, lsl #2]
 8085628:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 808562c:	b281      	uxth	r1, r0
 808562e:	4558      	cmp	r0, fp
	y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 8085630:	f85a e00c 	ldr.w	lr, [sl, ip]
	x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 8085634:	bf34      	ite	cc
 8085636:	1a51      	subcc	r1, r2, r1
 8085638:	1a89      	subcs	r1, r1, r2
 808563a:	fa1f f08e 	uxth.w	r0, lr
	y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 808563e:	45ce      	cmp	lr, r9
	x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 8085640:	b289      	uxth	r1, r1
	y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 8085642:	bf34      	ite	cc
 8085644:	1a18      	subcc	r0, r3, r0
 8085646:	1ac0      	subcs	r0, r0, r3
 8085648:	b280      	uxth	r0, r0
	if ((x_diff + y_diff) > 5)
 808564a:	4408      	add	r0, r1
 808564c:	2805      	cmp	r0, #5
 808564e:	dd03      	ble.n	8085658 <BSP_TS_GetState+0x108>
		_x[index] = x[index];
 8085650:	f848 b00c 	str.w	fp, [r8, ip]
		_y[index] = y[index];
 8085654:	f84a 900c 	str.w	r9, [sl, ip]
	if(I2cAddress == FT5336_I2C_SLAVE_ADDRESS)
 8085658:	9902      	ldr	r1, [sp, #8]
 808565a:	7808      	ldrb	r0, [r1, #0]
 808565c:	2870      	cmp	r0, #112	; 0x70
 808565e:	d014      	beq.n	808568a <BSP_TS_GetState+0x13a>
		TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 8085660:	f64b 2e02 	movw	lr, #47618	; 0xba02
		TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 8085664:	f64b 2104 	movw	r1, #47620	; 0xba04
		TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 8085668:	f858 200c 	ldr.w	r2, [r8, ip]
 808566c:	f2c2 0e00 	movt	lr, #8192	; 0x2000
		TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 8085670:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8085674:	f85a 300c 	ldr.w	r3, [sl, ip]
 8085678:	8809      	ldrh	r1, [r1, #0]
		TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 808567a:	f8be c000 	ldrh.w	ip, [lr]
		TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 808567e:	fb03 f301 	mul.w	r3, r3, r1
		TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 8085682:	fb02 f20c 	mul.w	r2, r2, ip
		TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 8085686:	0b1b      	lsrs	r3, r3, #12
		TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 8085688:	0b12      	lsrs	r2, r2, #12
		TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 808568a:	8173      	strh	r3, [r6, #10]
	ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
 808568c:	ab09      	add	r3, sp, #36	; 0x24
		TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 808568e:	8032      	strh	r2, [r6, #0]
	ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
 8085690:	4621      	mov	r1, r4
 8085692:	9300      	str	r3, [sp, #0]
 8085694:	aa07      	add	r2, sp, #28
 8085696:	ab08      	add	r3, sp, #32
 8085698:	f7fb fbc0 	bl	8080e1c <ft5336_TS_GetTouchInfo>
	switch(event)
 808569c:	9b09      	ldr	r3, [sp, #36]	; 0x24
	TS_State->touchArea[index]   = area;
 808569e:	e9dd 1207 	ldrd	r1, r2, [sp, #28]
	TS_State->touchWeight[index] = weight;
 80856a2:	f807 1b01 	strb.w	r1, [r7], #1
	TS_State->touchArea[index]   = area;
 80856a6:	727a      	strb	r2, [r7, #9]
	switch(event)
 80856a8:	2b03      	cmp	r3, #3
 80856aa:	d806      	bhi.n	80856ba <BSP_TS_GetState+0x16a>
 80856ac:	e8df f003 	tbb	[pc, r3]
 80856b0:	02131619 	.word	0x02131619
		TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
 80856b4:	f04f 0300 	mov.w	r3, #0
 80856b8:	713b      	strb	r3, [r7, #4]
		for(index=0; index < TS_State->touchDetected; index++)
 80856ba:	9b03      	ldr	r3, [sp, #12]
 80856bc:	3401      	adds	r4, #1
 80856be:	3502      	adds	r5, #2
 80856c0:	3602      	adds	r6, #2
 80856c2:	781b      	ldrb	r3, [r3, #0]
 80856c4:	42a3      	cmp	r3, r4
 80856c6:	f63f af74 	bhi.w	80855b2 <BSP_TS_GetState+0x62>
		ts_status = BSP_TS_Get_GestureId(TS_State);
 80856ca:	9803      	ldr	r0, [sp, #12]
 80856cc:	f7ff fefe 	bl	80854cc <BSP_TS_Get_GestureId>
}
 80856d0:	b017      	add	sp, #92	; 0x5c
 80856d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		TS_State->touchEventId[index] = TOUCH_EVENT_CONTACT;
 80856d6:	2303      	movs	r3, #3
 80856d8:	713b      	strb	r3, [r7, #4]
		break;
 80856da:	e7ee      	b.n	80856ba <BSP_TS_GetState+0x16a>
		TS_State->touchEventId[index] = TOUCH_EVENT_LIFT_UP;
 80856dc:	2302      	movs	r3, #2
 80856de:	713b      	strb	r3, [r7, #4]
		break;
 80856e0:	e7eb      	b.n	80856ba <BSP_TS_GetState+0x16a>
		TS_State->touchEventId[index] = TOUCH_EVENT_PRESS_DOWN;
 80856e2:	2301      	movs	r3, #1
 80856e4:	713b      	strb	r3, [r7, #4]
		break;
 80856e6:	e7e8      	b.n	80856ba <BSP_TS_GetState+0x16a>
				y[index] = brute_x[index];
 80856e8:	a90d      	add	r1, sp, #52	; 0x34
 80856ea:	882b      	ldrh	r3, [r5, #0]
				x[index] = brute_y[index];
 80856ec:	aa13      	add	r2, sp, #76	; 0x4c
				y[index] = brute_x[index];
 80856ee:	f821 3014 	strh.w	r3, [r1, r4, lsl #1]
				x[index] = brute_y[index];
 80856f2:	a90a      	add	r1, sp, #40	; 0x28
 80856f4:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
 80856f8:	f821 2014 	strh.w	r2, [r1, r4, lsl #1]
	if ((int32_t)(480 - x[index])>=0)
 80856fc:	f5d2 72f0 	rsbs	r2, r2, #480	; 0x1e0
 8085700:	d583      	bpl.n	808560a <BSP_TS_GetState+0xba>
		x[index] = 0;
 8085702:	aa0a      	add	r2, sp, #40	; 0x28
 8085704:	f04f 0b00 	mov.w	fp, #0
 8085708:	f04f 0100 	mov.w	r1, #0
	if ((int32_t)(260 - y[index])>=0)
 808570c:	f5d3 7382 	rsbs	r3, r3, #260	; 0x104
		x[index] = 0;
 8085710:	f822 1014 	strh.w	r1, [r2, r4, lsl #1]
 8085714:	465a      	mov	r2, fp
	if ((int32_t)(260 - y[index])>=0)
 8085716:	d580      	bpl.n	808561a <BSP_TS_GetState+0xca>
		y[index] = 0;
 8085718:	ab0d      	add	r3, sp, #52	; 0x34
 808571a:	f04f 0900 	mov.w	r9, #0
 808571e:	f04f 0100 	mov.w	r1, #0
 8085722:	f823 1014 	strh.w	r1, [r3, r4, lsl #1]
 8085726:	464b      	mov	r3, r9
 8085728:	e77c      	b.n	8085624 <BSP_TS_GetState+0xd4>
				x[index] = brute_x[index];
 808572a:	8829      	ldrh	r1, [r5, #0]
				y[index] = brute_y[index];
 808572c:	aa13      	add	r2, sp, #76	; 0x4c
				x[index] = brute_x[index];
 808572e:	a80a      	add	r0, sp, #40	; 0x28
				y[index] = brute_y[index];
 8085730:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
				x[index] = brute_x[index];
 8085734:	f820 1014 	strh.w	r1, [r0, r4, lsl #1]
				y[index] = brute_y[index];
 8085738:	a90d      	add	r1, sp, #52	; 0x34
 808573a:	f821 2014 	strh.w	r2, [r1, r4, lsl #1]
 808573e:	e759      	b.n	80855f4 <BSP_TS_GetState+0xa4>

08085740 <BSP_TS_ITClear>:
 * @brief  Clears all touch screen interrupts.
 */
void BSP_TS_ITClear(void)
{
	/* Clear TS IT pending bits */
	tsDriver->ClearIT(I2cAddress);
 8085740:	f64b 12fc 	movw	r2, #47612	; 0xb9fc
 8085744:	f64b 13d0 	movw	r3, #47568	; 0xb9d0
 8085748:	f2c2 0200 	movt	r2, #8192	; 0x2000
 808574c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8085750:	6812      	ldr	r2, [r2, #0]
 8085752:	7818      	ldrb	r0, [r3, #0]
 8085754:	69d3      	ldr	r3, [r2, #28]
 8085756:	4718      	bx	r3

08085758 <BSP_WIFI_IRQHandler>:
	return WIFI_OK;
}

void BSP_WIFI_IRQHandler	(void)
{
	HAL_UART_IRQHandler(&UARTHandle);
 8085758:	f64b 2008 	movw	r0, #47624	; 0xba08
 808575c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8085760:	f005 b9de 	b.w	808ab20 <HAL_UART_IRQHandler>

08085764 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8085764:	b508      	push	{r3, lr}
  /* Configure Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 8085766:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 808576a:	2003      	movs	r0, #3
   __HAL_FLASH_ART_ENABLE();
 808576c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8085770:	681a      	ldr	r2, [r3, #0]
 8085772:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8085776:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8085778:	681a      	ldr	r2, [r3, #0]
 808577a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 808577e:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8085780:	f000 f830 	bl	80857e4 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8085784:	200f      	movs	r0, #15
 8085786:	f005 f833 	bl	808a7f0 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 808578a:	f00c fbc3 	bl	8091f14 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 808578e:	2000      	movs	r0, #0
 8085790:	bd08      	pop	{r3, pc}
 8085792:	bf00      	nop

08085794 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8085794:	f64d 13c0 	movw	r3, #55744	; 0xd9c0
 8085798:	f24b 0181 	movw	r1, #45185	; 0xb081
 808579c:	f2c2 0302 	movt	r3, #8194	; 0x2002
 80857a0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80857a4:	6818      	ldr	r0, [r3, #0]
 80857a6:	780a      	ldrb	r2, [r1, #0]
 80857a8:	4402      	add	r2, r0
 80857aa:	601a      	str	r2, [r3, #0]
}
 80857ac:	4770      	bx	lr
 80857ae:	bf00      	nop

080857b0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80857b0:	f64d 13c0 	movw	r3, #55744	; 0xd9c0
 80857b4:	f2c2 0302 	movt	r3, #8194	; 0x2002
 80857b8:	6818      	ldr	r0, [r3, #0]
}
 80857ba:	4770      	bx	lr

080857bc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80857bc:	b538      	push	{r3, r4, r5, lr}
 80857be:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80857c0:	f7ff fff6 	bl	80857b0 <HAL_GetTick>
 80857c4:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80857c6:	1c63      	adds	r3, r4, #1
 80857c8:	d005      	beq.n	80857d6 <HAL_Delay+0x1a>
  {
    wait += (uint32_t)(uwTickFreq);
 80857ca:	f24b 0381 	movw	r3, #45185	; 0xb081
 80857ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80857d2:	781b      	ldrb	r3, [r3, #0]
 80857d4:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80857d6:	f7ff ffeb 	bl	80857b0 <HAL_GetTick>
 80857da:	1b40      	subs	r0, r0, r5
 80857dc:	42a0      	cmp	r0, r4
 80857de:	d3fa      	bcc.n	80857d6 <HAL_Delay+0x1a>
  {
  }
}
 80857e0:	bd38      	pop	{r3, r4, r5, pc}
 80857e2:	bf00      	nop

080857e4 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80857e4:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 80857e8:	2300      	movs	r3, #0
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 80857ea:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80857ec:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80857f0:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 80857f4:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80857f8:	68d1      	ldr	r1, [r2, #12]
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80857fa:	b410      	push	{r4}
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80857fc:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 8085800:	4021      	ands	r1, r4
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8085802:	f85d 4b04 	ldr.w	r4, [sp], #4
 8085806:	430b      	orrs	r3, r1
  reg_value  =  (reg_value                                   |
 8085808:	4318      	orrs	r0, r3
  SCB->AIRCR =  reg_value;
 808580a:	60d0      	str	r0, [r2, #12]
 808580c:	4770      	bx	lr
 808580e:	bf00      	nop

08085810 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8085810:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8085814:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8085818:	68db      	ldr	r3, [r3, #12]
 808581a:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 808581e:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8085820:	f1c3 0507 	rsb	r5, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8085824:	1d1c      	adds	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8085826:	2d04      	cmp	r5, #4
 8085828:	bf28      	it	cs
 808582a:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 808582c:	2c06      	cmp	r4, #6
 808582e:	d91d      	bls.n	808586c <HAL_NVIC_SetPriority+0x5c>
 8085830:	3b03      	subs	r3, #3
 8085832:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8085836:	409c      	lsls	r4, r3
 8085838:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 808583c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) < 0)
 8085840:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8085842:	fa02 f205 	lsl.w	r2, r2, r5
 8085846:	ea21 0102 	bic.w	r1, r1, r2
 808584a:	fa01 f203 	lsl.w	r2, r1, r3
 808584e:	ea42 0204 	orr.w	r2, r2, r4
 8085852:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8085856:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) < 0)
 8085858:	db0b      	blt.n	8085872 <HAL_NVIC_SetPriority+0x62>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 808585a:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 808585e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8085862:	4403      	add	r3, r0
 8085864:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8085868:	bc30      	pop	{r4, r5}
 808586a:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 808586c:	2400      	movs	r4, #0
 808586e:	4623      	mov	r3, r4
 8085870:	e7e4      	b.n	808583c <HAL_NVIC_SetPriority+0x2c>
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8085872:	f64e 43fc 	movw	r3, #60668	; 0xecfc
 8085876:	f000 000f 	and.w	r0, r0, #15
 808587a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 808587e:	4403      	add	r3, r0
 8085880:	761a      	strb	r2, [r3, #24]
 8085882:	bc30      	pop	{r4, r5}
 8085884:	4770      	bx	lr
 8085886:	bf00      	nop

08085888 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8085888:	f000 011f 	and.w	r1, r0, #31
 808588c:	2301      	movs	r3, #1
 808588e:	f44f 4261 	mov.w	r2, #57600	; 0xe100
 8085892:	0940      	lsrs	r0, r0, #5
 8085894:	408b      	lsls	r3, r1
 8085896:	f2ce 0200 	movt	r2, #57344	; 0xe000
 808589a:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 808589e:	4770      	bx	lr

080858a0 <HAL_NVIC_DisableIRQ>:
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80858a0:	0943      	lsrs	r3, r0, #5
 80858a2:	2201      	movs	r2, #1
 80858a4:	f44f 4161 	mov.w	r1, #57600	; 0xe100
 80858a8:	f000 001f 	and.w	r0, r0, #31
 80858ac:	3320      	adds	r3, #32
 80858ae:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80858b2:	fa02 f000 	lsl.w	r0, r2, r0
 80858b6:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 80858ba:	4770      	bx	lr

080858bc <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 80858bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80858be:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 80858c0:	f7ff ff76 	bl	80857b0 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80858c4:	2c00      	cmp	r4, #0
 80858c6:	d05f      	beq.n	8085988 <HAL_DMA_Init+0xcc>
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80858c8:	2202      	movs	r2, #2
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80858ca:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hdma);
 80858cc:	2100      	movs	r1, #0
 80858ce:	4605      	mov	r5, r0
  hdma->State = HAL_DMA_STATE_BUSY;
 80858d0:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 80858d4:	681a      	ldr	r2, [r3, #0]
  __HAL_UNLOCK(hdma);
 80858d6:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 80858da:	f022 0201 	bic.w	r2, r2, #1
 80858de:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80858e0:	e005      	b.n	80858ee <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80858e2:	f7ff ff65 	bl	80857b0 <HAL_GetTick>
 80858e6:	1b40      	subs	r0, r0, r5
 80858e8:	2805      	cmp	r0, #5
 80858ea:	d846      	bhi.n	808597a <HAL_DMA_Init+0xbe>
 80858ec:	6823      	ldr	r3, [r4, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80858ee:	681a      	ldr	r2, [r3, #0]
 80858f0:	07d1      	lsls	r1, r2, #31
 80858f2:	d4f6      	bmi.n	80858e2 <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80858f4:	e9d4 0602 	ldrd	r0, r6, [r4, #8]
 80858f8:	6862      	ldr	r2, [r4, #4]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80858fa:	f248 013f 	movw	r1, #32831	; 0x803f
  tmp = hdma->Instance->CR;
 80858fe:	681f      	ldr	r7, [r3, #0]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8085900:	4302      	orrs	r2, r0
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8085902:	f2cf 0110 	movt	r1, #61456	; 0xf010
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8085906:	e9d4 5004 	ldrd	r5, r0, [r4, #16]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 808590a:	4332      	orrs	r2, r6
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 808590c:	69a6      	ldr	r6, [r4, #24]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 808590e:	4039      	ands	r1, r7
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8085910:	432a      	orrs	r2, r5
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8085912:	69e5      	ldr	r5, [r4, #28]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8085914:	4302      	orrs	r2, r0
          hdma->Init.Mode                | hdma->Init.Priority;
 8085916:	6a20      	ldr	r0, [r4, #32]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8085918:	4332      	orrs	r2, r6
 808591a:	432a      	orrs	r2, r5

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 808591c:	6a65      	ldr	r5, [r4, #36]	; 0x24
          hdma->Init.Mode                | hdma->Init.Priority;
 808591e:	4302      	orrs	r2, r0
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8085920:	2d04      	cmp	r5, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8085922:	ea42 0201 	orr.w	r2, r2, r1
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8085926:	d031      	beq.n	808598c <HAL_DMA_Init+0xd0>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8085928:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 808592a:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 808592c:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8085930:	4315      	orrs	r5, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8085932:	b2da      	uxtb	r2, r3
 8085934:	f64a 26ab 	movw	r6, #43691	; 0xaaab
  hdma->Instance->FCR = tmp;
 8085938:	615d      	str	r5, [r3, #20]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 808593a:	f642 108c 	movw	r0, #10636	; 0x298c
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 808593e:	f6ca 26aa 	movt	r6, #43690	; 0xaaaa
 8085942:	3a10      	subs	r2, #16
 8085944:	f44f 417c 	mov.w	r1, #64512	; 0xfc00
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8085948:	f6c0 0009 	movt	r0, #2057	; 0x809
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 808594c:	fba6 5202 	umull	r5, r2, r6, r2
  hdma->State = HAL_DMA_STATE_READY;
 8085950:	2501      	movs	r5, #1
 8085952:	f6cf 71ff 	movt	r1, #65535	; 0xffff
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8085956:	0912      	lsrs	r2, r2, #4
 8085958:	4019      	ands	r1, r3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 808595a:	233f      	movs	r3, #63	; 0x3f
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 808595c:	5c80      	ldrb	r0, [r0, r2]
  
  if (stream_number > 3U)
 808595e:	2a03      	cmp	r2, #3
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8085960:	f04f 0200 	mov.w	r2, #0
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8085964:	bf88      	it	hi
 8085966:	3104      	addhi	r1, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085968:	4083      	lsls	r3, r0
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 808596a:	65e0      	str	r0, [r4, #92]	; 0x5c
  return HAL_OK;
 808596c:	4610      	mov	r0, r2
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 808596e:	65a1      	str	r1, [r4, #88]	; 0x58
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085970:	608b      	str	r3, [r1, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8085972:	6562      	str	r2, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8085974:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
}
 8085978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 808597a:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 808597c:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 808597e:	4618      	mov	r0, r3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8085980:	6562      	str	r2, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8085982:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 8085986:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8085988:	2001      	movs	r0, #1
}
 808598a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 808598c:	e9d4 010b 	ldrd	r0, r1, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 8085990:	6aa7      	ldr	r7, [r4, #40]	; 0x28
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8085992:	4301      	orrs	r1, r0
    tmp |= hdma->Init.FIFOThreshold;
 8085994:	f047 0504 	orr.w	r5, r7, #4
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8085998:	430a      	orrs	r2, r1
  hdma->Instance->CR = tmp;  
 808599a:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 808599c:	695a      	ldr	r2, [r3, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 808599e:	f022 0207 	bic.w	r2, r2, #7
    tmp |= hdma->Init.FIFOThreshold;
 80859a2:	4315      	orrs	r5, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 80859a4:	2800      	cmp	r0, #0
 80859a6:	d0c4      	beq.n	8085932 <HAL_DMA_Init+0x76>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 80859a8:	b17e      	cbz	r6, 80859ca <HAL_DMA_Init+0x10e>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80859aa:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
 80859ae:	d016      	beq.n	80859de <HAL_DMA_Init+0x122>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 80859b0:	2f02      	cmp	r7, #2
 80859b2:	d903      	bls.n	80859bc <HAL_DMA_Init+0x100>
 80859b4:	2f03      	cmp	r7, #3
 80859b6:	d1bc      	bne.n	8085932 <HAL_DMA_Init+0x76>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80859b8:	01c2      	lsls	r2, r0, #7
 80859ba:	d5ba      	bpl.n	8085932 <HAL_DMA_Init+0x76>
        hdma->State = HAL_DMA_STATE_READY;
 80859bc:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80859be:	2240      	movs	r2, #64	; 0x40
        return HAL_ERROR; 
 80859c0:	4618      	mov	r0, r3
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80859c2:	6562      	str	r2, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 80859c4:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 80859c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (tmp)
 80859ca:	2f01      	cmp	r7, #1
 80859cc:	d003      	beq.n	80859d6 <HAL_DMA_Init+0x11a>
 80859ce:	d3f3      	bcc.n	80859b8 <HAL_DMA_Init+0xfc>
 80859d0:	2f02      	cmp	r7, #2
 80859d2:	d1ae      	bne.n	8085932 <HAL_DMA_Init+0x76>
 80859d4:	e7f0      	b.n	80859b8 <HAL_DMA_Init+0xfc>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80859d6:	f1b0 7fc0 	cmp.w	r0, #25165824	; 0x1800000
 80859da:	d1aa      	bne.n	8085932 <HAL_DMA_Init+0x76>
 80859dc:	e7ee      	b.n	80859bc <HAL_DMA_Init+0x100>
    switch (tmp)
 80859de:	2f03      	cmp	r7, #3
 80859e0:	d8a7      	bhi.n	8085932 <HAL_DMA_Init+0x76>
 80859e2:	a201      	add	r2, pc, #4	; (adr r2, 80859e8 <HAL_DMA_Init+0x12c>)
 80859e4:	f852 f027 	ldr.w	pc, [r2, r7, lsl #2]
 80859e8:	080859bd 	.word	0x080859bd
 80859ec:	080859b9 	.word	0x080859b9
 80859f0:	080859bd 	.word	0x080859bd
 80859f4:	080859d7 	.word	0x080859d7

080859f8 <HAL_DMA_DeInit>:
  if(hdma == NULL)
 80859f8:	2800      	cmp	r0, #0
 80859fa:	d03e      	beq.n	8085a7a <HAL_DMA_DeInit+0x82>
 80859fc:	4603      	mov	r3, r0
  if(hdma->State == HAL_DMA_STATE_BUSY)
 80859fe:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
 8085a02:	b2c0      	uxtb	r0, r0
 8085a04:	2802      	cmp	r0, #2
 8085a06:	d03a      	beq.n	8085a7e <HAL_DMA_DeInit+0x86>
  __HAL_DMA_DISABLE(hdma);
 8085a08:	681a      	ldr	r2, [r3, #0]
{
 8085a0a:	b470      	push	{r4, r5, r6}
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8085a0c:	b2d1      	uxtb	r1, r2
 8085a0e:	f64a 26ab 	movw	r6, #43691	; 0xaaab
  __HAL_DMA_DISABLE(hdma);
 8085a12:	6810      	ldr	r0, [r2, #0]
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8085a14:	f642 158c 	movw	r5, #10636	; 0x298c
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8085a18:	f6ca 26aa 	movt	r6, #43690	; 0xaaaa
 8085a1c:	3910      	subs	r1, #16
 8085a1e:	f44f 447c 	mov.w	r4, #64512	; 0xfc00
  __HAL_DMA_DISABLE(hdma);
 8085a22:	f020 0001 	bic.w	r0, r0, #1
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8085a26:	fba6 6101 	umull	r6, r1, r6, r1
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8085a2a:	f6c0 0509 	movt	r5, #2057	; 0x809
 8085a2e:	f6cf 74ff 	movt	r4, #65535	; 0xffff
  __HAL_DMA_DISABLE(hdma);
 8085a32:	6010      	str	r0, [r2, #0]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8085a34:	0909      	lsrs	r1, r1, #4
  hdma->Instance->CR   = 0U;
 8085a36:	2000      	movs	r0, #0
 8085a38:	4014      	ands	r4, r2
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 8085a3a:	2621      	movs	r6, #33	; 0x21
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8085a3c:	5c6d      	ldrb	r5, [r5, r1]
  if (stream_number > 3U)
 8085a3e:	2903      	cmp	r1, #3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085a40:	f04f 013f 	mov.w	r1, #63	; 0x3f
  hdma->Instance->CR   = 0U;
 8085a44:	6010      	str	r0, [r2, #0]
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8085a46:	bf88      	it	hi
 8085a48:	3404      	addhi	r4, #4
  hdma->Instance->NDTR = 0U;
 8085a4a:	6050      	str	r0, [r2, #4]
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085a4c:	40a9      	lsls	r1, r5
  hdma->Instance->PAR  = 0U;
 8085a4e:	6090      	str	r0, [r2, #8]
  hdma->Instance->M0AR = 0U;
 8085a50:	60d0      	str	r0, [r2, #12]
  hdma->Instance->M1AR = 0U;
 8085a52:	6110      	str	r0, [r2, #16]
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 8085a54:	6156      	str	r6, [r2, #20]
  hdma->XferCpltCallback = NULL;
 8085a56:	2200      	movs	r2, #0
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8085a58:	65dd      	str	r5, [r3, #92]	; 0x5c
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 8085a5a:	659c      	str	r4, [r3, #88]	; 0x58
  return HAL_OK;
 8085a5c:	4610      	mov	r0, r2
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085a5e:	60a1      	str	r1, [r4, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8085a60:	655a      	str	r2, [r3, #84]	; 0x54
  __HAL_UNLOCK(hdma);
 8085a62:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_RESET;
 8085a66:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  hdma->XferHalfCpltCallback = NULL;
 8085a6a:	e9c3 220f 	strd	r2, r2, [r3, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
 8085a6e:	e9c3 2211 	strd	r2, r2, [r3, #68]	; 0x44
  hdma->XferAbortCallback = NULL;  
 8085a72:	e9c3 2213 	strd	r2, r2, [r3, #76]	; 0x4c
}
 8085a76:	bc70      	pop	{r4, r5, r6}
 8085a78:	4770      	bx	lr
    return HAL_ERROR;
 8085a7a:	2001      	movs	r0, #1
 8085a7c:	4770      	bx	lr
}
 8085a7e:	4770      	bx	lr

08085a80 <HAL_DMA_Start_IT>:
{
 8085a80:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(hdma);
 8085a82:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 8085a86:	2c01      	cmp	r4, #1
 8085a88:	d038      	beq.n	8085afc <HAL_DMA_Start_IT+0x7c>
 8085a8a:	2501      	movs	r5, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8085a8c:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8085a90:	6d86      	ldr	r6, [r0, #88]	; 0x58
  if(HAL_DMA_STATE_READY == hdma->State)
 8085a92:	42ac      	cmp	r4, r5
  __HAL_LOCK(hdma);
 8085a94:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8085a98:	d129      	bne.n	8085aee <HAL_DMA_Start_IT+0x6e>
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8085a9a:	6804      	ldr	r4, [r0, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 8085a9c:	2702      	movs	r7, #2
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8085a9e:	2500      	movs	r5, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 8085aa0:	f880 7035 	strb.w	r7, [r0, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8085aa4:	6545      	str	r5, [r0, #84]	; 0x54
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8085aa6:	6887      	ldr	r7, [r0, #8]
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8085aa8:	6825      	ldr	r5, [r4, #0]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8085aaa:	2f40      	cmp	r7, #64	; 0x40
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8085aac:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
 8085ab0:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 8085ab2:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8085ab4:	d026      	beq.n	8085b04 <HAL_DMA_Start_IT+0x84>
    hdma->Instance->PAR = SrcAddress;
 8085ab6:	60a1      	str	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 8085ab8:	60e2      	str	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085aba:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8085abc:	233f      	movs	r3, #63	; 0x3f
    if(hdma->XferHalfCpltCallback != NULL)
 8085abe:	6c02      	ldr	r2, [r0, #64]	; 0x40
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085ac0:	408b      	lsls	r3, r1
 8085ac2:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8085ac4:	6823      	ldr	r3, [r4, #0]
 8085ac6:	f043 0316 	orr.w	r3, r3, #22
 8085aca:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8085acc:	6963      	ldr	r3, [r4, #20]
 8085ace:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8085ad2:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 8085ad4:	b11a      	cbz	r2, 8085ade <HAL_DMA_Start_IT+0x5e>
      hdma->Instance->CR  |= DMA_IT_HT;
 8085ad6:	6823      	ldr	r3, [r4, #0]
 8085ad8:	f043 0308 	orr.w	r3, r3, #8
 8085adc:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 8085ade:	6822      	ldr	r2, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8085ae0:	2300      	movs	r3, #0
    __HAL_DMA_ENABLE(hdma);
 8085ae2:	f042 0201 	orr.w	r2, r2, #1
}
 8085ae6:	4618      	mov	r0, r3
    __HAL_DMA_ENABLE(hdma);
 8085ae8:	6022      	str	r2, [r4, #0]
}
 8085aea:	bcf0      	pop	{r4, r5, r6, r7}
 8085aec:	4770      	bx	lr
    __HAL_UNLOCK(hdma);	  
 8085aee:	2200      	movs	r2, #0
    status = HAL_BUSY;
 8085af0:	2302      	movs	r3, #2
    __HAL_UNLOCK(hdma);	  
 8085af2:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
}
 8085af6:	4618      	mov	r0, r3
 8085af8:	bcf0      	pop	{r4, r5, r6, r7}
 8085afa:	4770      	bx	lr
  __HAL_LOCK(hdma);
 8085afc:	2302      	movs	r3, #2
}
 8085afe:	bcf0      	pop	{r4, r5, r6, r7}
 8085b00:	4618      	mov	r0, r3
 8085b02:	4770      	bx	lr
    hdma->Instance->PAR = DstAddress;
 8085b04:	60a2      	str	r2, [r4, #8]
    hdma->Instance->M0AR = SrcAddress;
 8085b06:	60e1      	str	r1, [r4, #12]
 8085b08:	e7d7      	b.n	8085aba <HAL_DMA_Start_IT+0x3a>
 8085b0a:	bf00      	nop

08085b0c <HAL_DMA_Abort>:
{
 8085b0c:	b570      	push	{r4, r5, r6, lr}
 8085b0e:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8085b10:	6d86      	ldr	r6, [r0, #88]	; 0x58
  uint32_t tickstart = HAL_GetTick();
 8085b12:	f7ff fe4d 	bl	80857b0 <HAL_GetTick>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8085b16:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 8085b1a:	2b02      	cmp	r3, #2
 8085b1c:	d006      	beq.n	8085b2c <HAL_DMA_Abort+0x20>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8085b1e:	2280      	movs	r2, #128	; 0x80
    __HAL_UNLOCK(hdma);
 8085b20:	2300      	movs	r3, #0
    return HAL_ERROR;
 8085b22:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8085b24:	6562      	str	r2, [r4, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 8085b26:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8085b2a:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8085b2c:	6823      	ldr	r3, [r4, #0]
 8085b2e:	4605      	mov	r5, r0
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8085b30:	6c21      	ldr	r1, [r4, #64]	; 0x40
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8085b32:	681a      	ldr	r2, [r3, #0]
 8085b34:	f022 0216 	bic.w	r2, r2, #22
 8085b38:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 8085b3a:	695a      	ldr	r2, [r3, #20]
 8085b3c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8085b40:	615a      	str	r2, [r3, #20]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8085b42:	b339      	cbz	r1, 8085b94 <HAL_DMA_Abort+0x88>
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 8085b44:	681a      	ldr	r2, [r3, #0]
 8085b46:	f022 0208 	bic.w	r2, r2, #8
 8085b4a:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 8085b4c:	681a      	ldr	r2, [r3, #0]
 8085b4e:	f022 0201 	bic.w	r2, r2, #1
 8085b52:	601a      	str	r2, [r3, #0]
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8085b54:	e005      	b.n	8085b62 <HAL_DMA_Abort+0x56>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8085b56:	f7ff fe2b 	bl	80857b0 <HAL_GetTick>
 8085b5a:	1b40      	subs	r0, r0, r5
 8085b5c:	2805      	cmp	r0, #5
 8085b5e:	d80f      	bhi.n	8085b80 <HAL_DMA_Abort+0x74>
 8085b60:	6823      	ldr	r3, [r4, #0]
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8085b62:	681b      	ldr	r3, [r3, #0]
 8085b64:	f013 0301 	ands.w	r3, r3, #1
 8085b68:	d1f5      	bne.n	8085b56 <HAL_DMA_Abort+0x4a>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085b6a:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8085b6c:	223f      	movs	r2, #63	; 0x3f
  return HAL_OK;
 8085b6e:	4618      	mov	r0, r3
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085b70:	408a      	lsls	r2, r1
    hdma->State = HAL_DMA_STATE_READY;
 8085b72:	2101      	movs	r1, #1
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085b74:	60b2      	str	r2, [r6, #8]
    __HAL_UNLOCK(hdma);
 8085b76:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_READY;
 8085b7a:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
}
 8085b7e:	bd70      	pop	{r4, r5, r6, pc}
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8085b80:	2303      	movs	r3, #3
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8085b82:	2120      	movs	r1, #32
        __HAL_UNLOCK(hdma);
 8085b84:	2200      	movs	r2, #0
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8085b86:	6561      	str	r1, [r4, #84]	; 0x54
        return HAL_TIMEOUT;
 8085b88:	4618      	mov	r0, r3
        __HAL_UNLOCK(hdma);
 8085b8a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8085b8e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 8085b92:	bd70      	pop	{r4, r5, r6, pc}
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8085b94:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8085b96:	2a00      	cmp	r2, #0
 8085b98:	d1d4      	bne.n	8085b44 <HAL_DMA_Abort+0x38>
 8085b9a:	e7d7      	b.n	8085b4c <HAL_DMA_Abort+0x40>

08085b9c <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8085b9c:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
{
 8085ba0:	4603      	mov	r3, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8085ba2:	2a02      	cmp	r2, #2
 8085ba4:	d003      	beq.n	8085bae <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8085ba6:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 8085ba8:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8085baa:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 8085bac:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 8085bae:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8085bb0:	2105      	movs	r1, #5
  return HAL_OK;
 8085bb2:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_ABORT;
 8085bb4:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8085bb8:	6813      	ldr	r3, [r2, #0]
 8085bba:	f023 0301 	bic.w	r3, r3, #1
 8085bbe:	6013      	str	r3, [r2, #0]
}
 8085bc0:	4770      	bx	lr
 8085bc2:	bf00      	nop

08085bc4 <HAL_DMA_IRQHandler>:
{
 8085bc4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8085bc6:	4604      	mov	r4, r0
 8085bc8:	b083      	sub	sp, #12
  __IO uint32_t count = 0;
 8085bca:	2000      	movs	r0, #0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8085bcc:	2208      	movs	r2, #8
  uint32_t timeout = SystemCoreClock / 9600;
 8085bce:	f24b 3174 	movw	r1, #45940	; 0xb374
  __IO uint32_t count = 0;
 8085bd2:	9001      	str	r0, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600;
 8085bd4:	f2c2 0100 	movt	r1, #8192	; 0x2000
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8085bd8:	e9d4 7316 	ldrd	r7, r3, [r4, #88]	; 0x58
  uint32_t timeout = SystemCoreClock / 9600;
 8085bdc:	680e      	ldr	r6, [r1, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8085bde:	409a      	lsls	r2, r3
  tmpisr = regs->ISR;
 8085be0:	683d      	ldr	r5, [r7, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8085be2:	422a      	tst	r2, r5
 8085be4:	d003      	beq.n	8085bee <HAL_DMA_IRQHandler+0x2a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8085be6:	6821      	ldr	r1, [r4, #0]
 8085be8:	6808      	ldr	r0, [r1, #0]
 8085bea:	0740      	lsls	r0, r0, #29
 8085bec:	d45d      	bmi.n	8085caa <HAL_DMA_IRQHandler+0xe6>
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8085bee:	2201      	movs	r2, #1
 8085bf0:	409a      	lsls	r2, r3
 8085bf2:	422a      	tst	r2, r5
 8085bf4:	d003      	beq.n	8085bfe <HAL_DMA_IRQHandler+0x3a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8085bf6:	6821      	ldr	r1, [r4, #0]
 8085bf8:	6949      	ldr	r1, [r1, #20]
 8085bfa:	0608      	lsls	r0, r1, #24
 8085bfc:	d478      	bmi.n	8085cf0 <HAL_DMA_IRQHandler+0x12c>
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8085bfe:	2204      	movs	r2, #4
 8085c00:	409a      	lsls	r2, r3
 8085c02:	422a      	tst	r2, r5
 8085c04:	d003      	beq.n	8085c0e <HAL_DMA_IRQHandler+0x4a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8085c06:	6821      	ldr	r1, [r4, #0]
 8085c08:	6809      	ldr	r1, [r1, #0]
 8085c0a:	0789      	lsls	r1, r1, #30
 8085c0c:	d46a      	bmi.n	8085ce4 <HAL_DMA_IRQHandler+0x120>
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8085c0e:	2210      	movs	r2, #16
 8085c10:	409a      	lsls	r2, r3
 8085c12:	422a      	tst	r2, r5
 8085c14:	d003      	beq.n	8085c1e <HAL_DMA_IRQHandler+0x5a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8085c16:	6821      	ldr	r1, [r4, #0]
 8085c18:	6808      	ldr	r0, [r1, #0]
 8085c1a:	0700      	lsls	r0, r0, #28
 8085c1c:	d44f      	bmi.n	8085cbe <HAL_DMA_IRQHandler+0xfa>
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8085c1e:	2220      	movs	r2, #32
 8085c20:	409a      	lsls	r2, r3
 8085c22:	422a      	tst	r2, r5
 8085c24:	d015      	beq.n	8085c52 <HAL_DMA_IRQHandler+0x8e>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8085c26:	6821      	ldr	r1, [r4, #0]
 8085c28:	6808      	ldr	r0, [r1, #0]
 8085c2a:	06c0      	lsls	r0, r0, #27
 8085c2c:	d511      	bpl.n	8085c52 <HAL_DMA_IRQHandler+0x8e>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8085c2e:	60ba      	str	r2, [r7, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8085c30:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 8085c34:	2a05      	cmp	r2, #5
 8085c36:	d067      	beq.n	8085d08 <HAL_DMA_IRQHandler+0x144>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8085c38:	680b      	ldr	r3, [r1, #0]
 8085c3a:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8085c3e:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8085c40:	f000 8082 	beq.w	8085d48 <HAL_DMA_IRQHandler+0x184>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8085c44:	0319      	lsls	r1, r3, #12
 8085c46:	f140 808d 	bpl.w	8085d64 <HAL_DMA_IRQHandler+0x1a0>
        if(hdma->XferCpltCallback != NULL)
 8085c4a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8085c4c:	b10b      	cbz	r3, 8085c52 <HAL_DMA_IRQHandler+0x8e>
          hdma->XferCpltCallback(hdma);
 8085c4e:	4620      	mov	r0, r4
 8085c50:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8085c52:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8085c54:	b33b      	cbz	r3, 8085ca6 <HAL_DMA_IRQHandler+0xe2>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8085c56:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8085c58:	07da      	lsls	r2, r3, #31
 8085c5a:	d51d      	bpl.n	8085c98 <HAL_DMA_IRQHandler+0xd4>
      hdma->State = HAL_DMA_STATE_ABORT;
 8085c5c:	2305      	movs	r3, #5
      __HAL_DMA_DISABLE(hdma);
 8085c5e:	6822      	ldr	r2, [r4, #0]
  uint32_t timeout = SystemCoreClock / 9600;
 8085c60:	f248 11b5 	movw	r1, #33205	; 0x81b5
      hdma->State = HAL_DMA_STATE_ABORT;
 8085c64:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  uint32_t timeout = SystemCoreClock / 9600;
 8085c68:	f6c1 314e 	movt	r1, #6990	; 0x1b4e
      __HAL_DMA_DISABLE(hdma);
 8085c6c:	6813      	ldr	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600;
 8085c6e:	fba1 1606 	umull	r1, r6, r1, r6
      __HAL_DMA_DISABLE(hdma);
 8085c72:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600;
 8085c76:	0ab6      	lsrs	r6, r6, #10
      __HAL_DMA_DISABLE(hdma);
 8085c78:	6013      	str	r3, [r2, #0]
 8085c7a:	e002      	b.n	8085c82 <HAL_DMA_IRQHandler+0xbe>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8085c7c:	6813      	ldr	r3, [r2, #0]
 8085c7e:	07db      	lsls	r3, r3, #31
 8085c80:	d504      	bpl.n	8085c8c <HAL_DMA_IRQHandler+0xc8>
        if (++count > timeout)
 8085c82:	9b01      	ldr	r3, [sp, #4]
 8085c84:	3301      	adds	r3, #1
 8085c86:	42b3      	cmp	r3, r6
 8085c88:	9301      	str	r3, [sp, #4]
 8085c8a:	d9f7      	bls.n	8085c7c <HAL_DMA_IRQHandler+0xb8>
      __HAL_UNLOCK(hdma);
 8085c8c:	2200      	movs	r2, #0
      hdma->State = HAL_DMA_STATE_READY;
 8085c8e:	2301      	movs	r3, #1
      __HAL_UNLOCK(hdma);
 8085c90:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8085c94:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
 8085c98:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8085c9a:	b123      	cbz	r3, 8085ca6 <HAL_DMA_IRQHandler+0xe2>
      hdma->XferErrorCallback(hdma);
 8085c9c:	4620      	mov	r0, r4
}
 8085c9e:	b003      	add	sp, #12
 8085ca0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      hdma->XferErrorCallback(hdma);
 8085ca4:	4718      	bx	r3
}
 8085ca6:	b003      	add	sp, #12
 8085ca8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8085caa:	6808      	ldr	r0, [r1, #0]
 8085cac:	f020 0004 	bic.w	r0, r0, #4
 8085cb0:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8085cb2:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8085cb4:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8085cb6:	f042 0201 	orr.w	r2, r2, #1
 8085cba:	6562      	str	r2, [r4, #84]	; 0x54
 8085cbc:	e797      	b.n	8085bee <HAL_DMA_IRQHandler+0x2a>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8085cbe:	60ba      	str	r2, [r7, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8085cc0:	680a      	ldr	r2, [r1, #0]
 8085cc2:	f412 2f80 	tst.w	r2, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8085cc6:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8085cc8:	d118      	bne.n	8085cfc <HAL_DMA_IRQHandler+0x138>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8085cca:	05d2      	lsls	r2, r2, #23
 8085ccc:	d403      	bmi.n	8085cd6 <HAL_DMA_IRQHandler+0x112>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8085cce:	680a      	ldr	r2, [r1, #0]
 8085cd0:	f022 0208 	bic.w	r2, r2, #8
 8085cd4:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 8085cd6:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8085cd8:	2a00      	cmp	r2, #0
 8085cda:	d0a0      	beq.n	8085c1e <HAL_DMA_IRQHandler+0x5a>
          hdma->XferHalfCpltCallback(hdma);
 8085cdc:	4620      	mov	r0, r4
 8085cde:	4790      	blx	r2
 8085ce0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8085ce2:	e79c      	b.n	8085c1e <HAL_DMA_IRQHandler+0x5a>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8085ce4:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8085ce6:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8085ce8:	f042 0204 	orr.w	r2, r2, #4
 8085cec:	6562      	str	r2, [r4, #84]	; 0x54
 8085cee:	e78e      	b.n	8085c0e <HAL_DMA_IRQHandler+0x4a>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8085cf0:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8085cf2:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8085cf4:	f042 0202 	orr.w	r2, r2, #2
 8085cf8:	6562      	str	r2, [r4, #84]	; 0x54
 8085cfa:	e780      	b.n	8085bfe <HAL_DMA_IRQHandler+0x3a>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8085cfc:	0311      	lsls	r1, r2, #12
 8085cfe:	d5ea      	bpl.n	8085cd6 <HAL_DMA_IRQHandler+0x112>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8085d00:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8085d02:	2a00      	cmp	r2, #0
 8085d04:	d1ea      	bne.n	8085cdc <HAL_DMA_IRQHandler+0x118>
 8085d06:	e78a      	b.n	8085c1e <HAL_DMA_IRQHandler+0x5a>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8085d08:	680a      	ldr	r2, [r1, #0]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8085d0a:	6c20      	ldr	r0, [r4, #64]	; 0x40
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8085d0c:	f022 0216 	bic.w	r2, r2, #22
 8085d10:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8085d12:	694a      	ldr	r2, [r1, #20]
 8085d14:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8085d18:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8085d1a:	b340      	cbz	r0, 8085d6e <HAL_DMA_IRQHandler+0x1aa>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8085d1c:	680a      	ldr	r2, [r1, #0]
 8085d1e:	f022 0208 	bic.w	r2, r2, #8
 8085d22:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085d24:	223f      	movs	r2, #63	; 0x3f
        __HAL_UNLOCK(hdma);
 8085d26:	2000      	movs	r0, #0
        hdma->State = HAL_DMA_STATE_READY;
 8085d28:	2101      	movs	r1, #1
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085d2a:	fa02 f303 	lsl.w	r3, r2, r3
        if(hdma->XferAbortCallback != NULL)
 8085d2e:	6d22      	ldr	r2, [r4, #80]	; 0x50
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8085d30:	60bb      	str	r3, [r7, #8]
        __HAL_UNLOCK(hdma);
 8085d32:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8085d36:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 8085d3a:	2a00      	cmp	r2, #0
 8085d3c:	d0b3      	beq.n	8085ca6 <HAL_DMA_IRQHandler+0xe2>
          hdma->XferAbortCallback(hdma);
 8085d3e:	4620      	mov	r0, r4
}
 8085d40:	b003      	add	sp, #12
 8085d42:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
          hdma->XferAbortCallback(hdma);
 8085d46:	4710      	bx	r2
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8085d48:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8085d4c:	f47f af7d 	bne.w	8085c4a <HAL_DMA_IRQHandler+0x86>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8085d50:	680a      	ldr	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8085d52:	2001      	movs	r0, #1
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8085d54:	f022 0210 	bic.w	r2, r2, #16
 8085d58:	600a      	str	r2, [r1, #0]
          __HAL_UNLOCK(hdma);
 8085d5a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8085d5e:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
 8085d62:	e772      	b.n	8085c4a <HAL_DMA_IRQHandler+0x86>
          if(hdma->XferM1CpltCallback != NULL)
 8085d64:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8085d66:	2b00      	cmp	r3, #0
 8085d68:	f47f af71 	bne.w	8085c4e <HAL_DMA_IRQHandler+0x8a>
 8085d6c:	e771      	b.n	8085c52 <HAL_DMA_IRQHandler+0x8e>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8085d6e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8085d70:	2a00      	cmp	r2, #0
 8085d72:	d1d3      	bne.n	8085d1c <HAL_DMA_IRQHandler+0x158>
 8085d74:	e7d6      	b.n	8085d24 <HAL_DMA_IRQHandler+0x160>
 8085d76:	bf00      	nop

08085d78 <DMA2D_SetConfig>:
  * @param  Width      The width of data to be transferred from source to destination.
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
{  
 8085d78:	b470      	push	{r4, r5, r6}
 8085d7a:	9c03      	ldr	r4, [sp, #12]
  uint32_t tmp2 = 0;
  uint32_t tmp3 = 0;
  uint32_t tmp4 = 0;
    
  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos))); 
 8085d7c:	6805      	ldr	r5, [r0, #0]
 8085d7e:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
  
  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
 
  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8085d82:	6846      	ldr	r6, [r0, #4]
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos))); 
 8085d84:	6c6c      	ldr	r4, [r5, #68]	; 0x44
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8085d86:	f5b6 3f40 	cmp.w	r6, #196608	; 0x30000
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos))); 
 8085d8a:	f004 4440 	and.w	r4, r4, #3221225472	; 0xc0000000
 8085d8e:	ea43 0304 	orr.w	r3, r3, r4
 8085d92:	646b      	str	r3, [r5, #68]	; 0x44
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
 8085d94:	63ea      	str	r2, [r5, #60]	; 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8085d96:	d002      	beq.n	8085d9e <DMA2D_SetConfig+0x26>
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);    
  } 
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
 8085d98:	60e9      	str	r1, [r5, #12]
  }
}
 8085d9a:	bc70      	pop	{r4, r5, r6}
 8085d9c:	4770      	bx	lr
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
 8085d9e:	6882      	ldr	r2, [r0, #8]
 8085da0:	b1b2      	cbz	r2, 8085dd0 <DMA2D_SetConfig+0x58>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
 8085da2:	2a01      	cmp	r2, #1
 8085da4:	d017      	beq.n	8085dd6 <DMA2D_SetConfig+0x5e>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
 8085da6:	2a02      	cmp	r2, #2
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
 8085da8:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
 8085dac:	f401 447f 	and.w	r4, r1, #65280	; 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
 8085db0:	b2c8      	uxtb	r0, r1
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
 8085db2:	d013      	beq.n	8085ddc <DMA2D_SetConfig+0x64>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
 8085db4:	2a03      	cmp	r2, #3
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
 8085db6:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
 8085dba:	d017      	beq.n	8085dec <DMA2D_SetConfig+0x74>
      tmp2 = (tmp2 >> 20);
 8085dbc:	0d1b      	lsrs	r3, r3, #20
      tmp3 = (tmp3 >> 12);
 8085dbe:	0b24      	lsrs	r4, r4, #12
      tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
 8085dc0:	021b      	lsls	r3, r3, #8
      tmp1 = (tmp1 >> 28);
 8085dc2:	0f09      	lsrs	r1, r1, #28
      tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
 8085dc4:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 8085dc8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8085dcc:	ea43 3101 	orr.w	r1, r3, r1, lsl #12
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);    
 8085dd0:	63a9      	str	r1, [r5, #56]	; 0x38
}
 8085dd2:	bc70      	pop	{r4, r5, r6}
 8085dd4:	4770      	bx	lr
      tmp = (tmp3 | tmp2 | tmp4);  
 8085dd6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8085dda:	e7f9      	b.n	8085dd0 <DMA2D_SetConfig+0x58>
      tmp2 = (tmp2 >> 19);
 8085ddc:	0cd9      	lsrs	r1, r3, #19
      tmp3 = (tmp3 >> 10);
 8085dde:	0aa4      	lsrs	r4, r4, #10
      tmp  = ((tmp3 << 5) | (tmp2 << 11) | tmp4); 
 8085de0:	02c9      	lsls	r1, r1, #11
 8085de2:	ea41 1144 	orr.w	r1, r1, r4, lsl #5
 8085de6:	ea41 01d0 	orr.w	r1, r1, r0, lsr #3
 8085dea:	e7f1      	b.n	8085dd0 <DMA2D_SetConfig+0x58>
      tmp2 = (tmp2 >> 19);
 8085dec:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11);
 8085dee:	0ae4      	lsrs	r4, r4, #11
      tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
 8085df0:	029b      	lsls	r3, r3, #10
      tmp1 = (tmp1 >> 31);
 8085df2:	0fc9      	lsrs	r1, r1, #31
      tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
 8085df4:	ea43 1344 	orr.w	r3, r3, r4, lsl #5
 8085df8:	ea43 03d0 	orr.w	r3, r3, r0, lsr #3
 8085dfc:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
 8085e00:	e7e6      	b.n	8085dd0 <DMA2D_SetConfig+0x58>
 8085e02:	bf00      	nop

08085e04 <HAL_DMA2D_Init>:
  if(hdma2d == NULL)
 8085e04:	b358      	cbz	r0, 8085e5e <HAL_DMA2D_Init+0x5a>
{ 
 8085e06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 8085e08:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8085e0c:	4604      	mov	r4, r0
 8085e0e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8085e12:	b1fb      	cbz	r3, 8085e54 <HAL_DMA2D_Init+0x50>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;  
 8085e14:	2002      	movs	r0, #2
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8085e16:	68a6      	ldr	r6, [r4, #8]
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);  
 8085e18:	68e7      	ldr	r7, [r4, #12]
 8085e1a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
  hdma2d->State = HAL_DMA2D_STATE_BUSY;  
 8085e1e:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8085e22:	2500      	movs	r5, #0
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);  
 8085e24:	f6cf 72ff 	movt	r2, #65535	; 0xffff
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8085e28:	e9d4 3100 	ldrd	r3, r1, [r4]
 8085e2c:	6818      	ldr	r0, [r3, #0]
 8085e2e:	f420 3040 	bic.w	r0, r0, #196608	; 0x30000
 8085e32:	4308      	orrs	r0, r1
 8085e34:	6018      	str	r0, [r3, #0]
  return HAL_OK;
 8085e36:	4628      	mov	r0, r5
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8085e38:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8085e3a:	f021 0107 	bic.w	r1, r1, #7
 8085e3e:	4331      	orrs	r1, r6
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8085e40:	2601      	movs	r6, #1
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8085e42:	6359      	str	r1, [r3, #52]	; 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);  
 8085e44:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8085e46:	400a      	ands	r2, r1
 8085e48:	433a      	orrs	r2, r7
 8085e4a:	641a      	str	r2, [r3, #64]	; 0x40
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8085e4c:	63e5      	str	r5, [r4, #60]	; 0x3c
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8085e4e:	f884 6039 	strb.w	r6, [r4, #57]	; 0x39
}
 8085e52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hdma2d->Lock = HAL_UNLOCKED;
 8085e54:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_DMA2D_MspInit(hdma2d);
 8085e58:	f7fe f9e6 	bl	8084228 <HAL_DMA2D_MspInit>
 8085e5c:	e7da      	b.n	8085e14 <HAL_DMA2D_Init+0x10>
     return HAL_ERROR;
 8085e5e:	2001      	movs	r0, #1
}
 8085e60:	4770      	bx	lr
 8085e62:	bf00      	nop

08085e64 <HAL_DMA2D_Start>:
{
 8085e64:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma2d);
 8085e66:	f890 5038 	ldrb.w	r5, [r0, #56]	; 0x38
{
 8085e6a:	b083      	sub	sp, #12
  __HAL_LOCK(hdma2d);
 8085e6c:	2d01      	cmp	r5, #1
 8085e6e:	d011      	beq.n	8085e94 <HAL_DMA2D_Start+0x30>
 8085e70:	2601      	movs	r6, #1
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
 8085e72:	9f08      	ldr	r7, [sp, #32]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8085e74:	2502      	movs	r5, #2
 8085e76:	4604      	mov	r4, r0
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
 8085e78:	9700      	str	r7, [sp, #0]
  __HAL_LOCK(hdma2d);
 8085e7a:	f880 6038 	strb.w	r6, [r0, #56]	; 0x38
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8085e7e:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
 8085e82:	f7ff ff79 	bl	8085d78 <DMA2D_SetConfig>
  __HAL_DMA2D_ENABLE(hdma2d);
 8085e86:	6822      	ldr	r2, [r4, #0]
  return HAL_OK;
 8085e88:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
 8085e8a:	6813      	ldr	r3, [r2, #0]
 8085e8c:	4333      	orrs	r3, r6
 8085e8e:	6013      	str	r3, [r2, #0]
}
 8085e90:	b003      	add	sp, #12
 8085e92:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(hdma2d);
 8085e94:	2002      	movs	r0, #2
}
 8085e96:	b003      	add	sp, #12
 8085e98:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8085e9a:	bf00      	nop

08085e9c <HAL_DMA2D_PollForTransfer>:
{
 8085e9c:	b570      	push	{r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0;  
 8085e9e:	2200      	movs	r2, #0
{
 8085ea0:	b082      	sub	sp, #8
  if((hdma2d->Instance->CR & DMA2D_CR_START) != RESET)
 8085ea2:	6803      	ldr	r3, [r0, #0]
{
 8085ea4:	4605      	mov	r5, r0
  __IO uint32_t isrflags = 0x0;  
 8085ea6:	9201      	str	r2, [sp, #4]
{
 8085ea8:	460c      	mov	r4, r1
  if((hdma2d->Instance->CR & DMA2D_CR_START) != RESET)
 8085eaa:	681a      	ldr	r2, [r3, #0]
 8085eac:	07d6      	lsls	r6, r2, #31
 8085eae:	d420      	bmi.n	8085ef2 <HAL_DMA2D_PollForTransfer+0x56>
  if (((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != RESET)  || 
 8085eb0:	69da      	ldr	r2, [r3, #28]
 8085eb2:	0691      	lsls	r1, r2, #26
 8085eb4:	d402      	bmi.n	8085ebc <HAL_DMA2D_PollForTransfer+0x20>
      ((hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START) != RESET))
 8085eb6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  if (((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != RESET)  || 
 8085eb8:	0692      	lsls	r2, r2, #26
 8085eba:	d50f      	bpl.n	8085edc <HAL_DMA2D_PollForTransfer+0x40>
    tickstart = HAL_GetTick();
 8085ebc:	f7ff fc78 	bl	80857b0 <HAL_GetTick>
 8085ec0:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
 8085ec2:	682b      	ldr	r3, [r5, #0]
 8085ec4:	e007      	b.n	8085ed6 <HAL_DMA2D_PollForTransfer+0x3a>
      isrflags = READ_REG(hdma2d->Instance->ISR);   
 8085ec6:	685a      	ldr	r2, [r3, #4]
 8085ec8:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE|DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != RESET)        
 8085eca:	9a01      	ldr	r2, [sp, #4]
 8085ecc:	f012 0f29 	tst.w	r2, #41	; 0x29
 8085ed0:	d12f      	bne.n	8085f32 <HAL_DMA2D_PollForTransfer+0x96>
      if(Timeout != HAL_MAX_DELAY)
 8085ed2:	1c61      	adds	r1, r4, #1
 8085ed4:	d14d      	bne.n	8085f72 <HAL_DMA2D_PollForTransfer+0xd6>
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
 8085ed6:	685a      	ldr	r2, [r3, #4]
 8085ed8:	06d2      	lsls	r2, r2, #27
 8085eda:	d5f4      	bpl.n	8085ec6 <HAL_DMA2D_PollForTransfer+0x2a>
  __HAL_UNLOCK(hdma2d);
 8085edc:	2200      	movs	r2, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 8085ede:	2412      	movs	r4, #18
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8085ee0:	2101      	movs	r1, #1
  return HAL_OK;
 8085ee2:	4610      	mov	r0, r2
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 8085ee4:	609c      	str	r4, [r3, #8]
  __HAL_UNLOCK(hdma2d);
 8085ee6:	f885 2038 	strb.w	r2, [r5, #56]	; 0x38
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8085eea:	f885 1039 	strb.w	r1, [r5, #57]	; 0x39
}
 8085eee:	b002      	add	sp, #8
 8085ef0:	bd70      	pop	{r4, r5, r6, pc}
   tickstart = HAL_GetTick();
 8085ef2:	f7ff fc5d 	bl	80857b0 <HAL_GetTick>
 8085ef6:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
 8085ef8:	682b      	ldr	r3, [r5, #0]
 8085efa:	e001      	b.n	8085f00 <HAL_DMA2D_PollForTransfer+0x64>
      if(Timeout != HAL_MAX_DELAY)
 8085efc:	1c62      	adds	r2, r4, #1
 8085efe:	d14a      	bne.n	8085f96 <HAL_DMA2D_PollForTransfer+0xfa>
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
 8085f00:	685a      	ldr	r2, [r3, #4]
 8085f02:	0790      	lsls	r0, r2, #30
 8085f04:	d4d4      	bmi.n	8085eb0 <HAL_DMA2D_PollForTransfer+0x14>
      isrflags = READ_REG(hdma2d->Instance->ISR); 
 8085f06:	685a      	ldr	r2, [r3, #4]
 8085f08:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != RESET)
 8085f0a:	9a01      	ldr	r2, [sp, #4]
 8085f0c:	f012 0f21 	tst.w	r2, #33	; 0x21
 8085f10:	d0f4      	beq.n	8085efc <HAL_DMA2D_PollForTransfer+0x60>
        if ((isrflags & DMA2D_FLAG_CE) != RESET)
 8085f12:	9a01      	ldr	r2, [sp, #4]
 8085f14:	0690      	lsls	r0, r2, #26
 8085f16:	d503      	bpl.n	8085f20 <HAL_DMA2D_PollForTransfer+0x84>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;        
 8085f18:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8085f1a:	f042 0202 	orr.w	r2, r2, #2
 8085f1e:	63ea      	str	r2, [r5, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_TE) != RESET)        
 8085f20:	9a01      	ldr	r2, [sp, #4]
 8085f22:	07d1      	lsls	r1, r2, #31
 8085f24:	d503      	bpl.n	8085f2e <HAL_DMA2D_PollForTransfer+0x92>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;        
 8085f26:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8085f28:	f042 0201 	orr.w	r2, r2, #1
 8085f2c:	63ea      	str	r2, [r5, #60]	; 0x3c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8085f2e:	2421      	movs	r4, #33	; 0x21
 8085f30:	e015      	b.n	8085f5e <HAL_DMA2D_PollForTransfer+0xc2>
        if ((isrflags & DMA2D_FLAG_CAE) != RESET)
 8085f32:	9a01      	ldr	r2, [sp, #4]
 8085f34:	0716      	lsls	r6, r2, #28
 8085f36:	d503      	bpl.n	8085f40 <HAL_DMA2D_PollForTransfer+0xa4>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;        
 8085f38:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8085f3a:	f042 0204 	orr.w	r2, r2, #4
 8085f3e:	63ea      	str	r2, [r5, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_CE) != RESET)             
 8085f40:	9a01      	ldr	r2, [sp, #4]
 8085f42:	0694      	lsls	r4, r2, #26
 8085f44:	d503      	bpl.n	8085f4e <HAL_DMA2D_PollForTransfer+0xb2>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;        
 8085f46:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8085f48:	f042 0202 	orr.w	r2, r2, #2
 8085f4c:	63ea      	str	r2, [r5, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_TE) != RESET)        
 8085f4e:	9a01      	ldr	r2, [sp, #4]
 8085f50:	07d0      	lsls	r0, r2, #31
 8085f52:	d503      	bpl.n	8085f5c <HAL_DMA2D_PollForTransfer+0xc0>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;        
 8085f54:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8085f56:	f042 0201 	orr.w	r2, r2, #1
 8085f5a:	63ea      	str	r2, [r5, #60]	; 0x3c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8085f5c:	2429      	movs	r4, #41	; 0x29
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 8085f5e:	2104      	movs	r1, #4
        __HAL_UNLOCK(hdma2d);
 8085f60:	2200      	movs	r2, #0
        return HAL_ERROR;      
 8085f62:	2001      	movs	r0, #1
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8085f64:	609c      	str	r4, [r3, #8]
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 8085f66:	f885 1039 	strb.w	r1, [r5, #57]	; 0x39
        __HAL_UNLOCK(hdma2d);
 8085f6a:	f885 2038 	strb.w	r2, [r5, #56]	; 0x38
}
 8085f6e:	b002      	add	sp, #8
 8085f70:	bd70      	pop	{r4, r5, r6, pc}
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8085f72:	b124      	cbz	r4, 8085f7e <HAL_DMA2D_PollForTransfer+0xe2>
 8085f74:	f7ff fc1c 	bl	80857b0 <HAL_GetTick>
 8085f78:	1b80      	subs	r0, r0, r6
 8085f7a:	42a0      	cmp	r0, r4
 8085f7c:	d9a1      	bls.n	8085ec2 <HAL_DMA2D_PollForTransfer+0x26>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8085f7e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8085f80:	2203      	movs	r2, #3
          __HAL_UNLOCK(hdma2d);
 8085f82:	2100      	movs	r1, #0
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8085f84:	f043 0320 	orr.w	r3, r3, #32
          return HAL_TIMEOUT;
 8085f88:	4610      	mov	r0, r2
          __HAL_UNLOCK(hdma2d);
 8085f8a:	f885 1038 	strb.w	r1, [r5, #56]	; 0x38
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8085f8e:	63eb      	str	r3, [r5, #60]	; 0x3c
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8085f90:	f885 2039 	strb.w	r2, [r5, #57]	; 0x39
          return HAL_TIMEOUT;
 8085f94:	e7ab      	b.n	8085eee <HAL_DMA2D_PollForTransfer+0x52>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8085f96:	2c00      	cmp	r4, #0
 8085f98:	d0f1      	beq.n	8085f7e <HAL_DMA2D_PollForTransfer+0xe2>
 8085f9a:	f7ff fc09 	bl	80857b0 <HAL_GetTick>
 8085f9e:	1b80      	subs	r0, r0, r6
 8085fa0:	42a0      	cmp	r0, r4
 8085fa2:	d9a9      	bls.n	8085ef8 <HAL_DMA2D_PollForTransfer+0x5c>
 8085fa4:	e7eb      	b.n	8085f7e <HAL_DMA2D_PollForTransfer+0xe2>
 8085fa6:	bf00      	nop

08085fa8 <HAL_DMA2D_ConfigLayer>:
  __HAL_LOCK(hdma2d);
 8085fa8:	f890 2038 	ldrb.w	r2, [r0, #56]	; 0x38
 8085fac:	2a01      	cmp	r2, #1
 8085fae:	d055      	beq.n	808605c <HAL_DMA2D_ConfigLayer+0xb4>
 8085fb0:	4603      	mov	r3, r0
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 8085fb2:	eb00 1001 	add.w	r0, r0, r1, lsl #4
{ 
 8085fb6:	b4f0      	push	{r4, r5, r6, r7}
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 8085fb8:	e9d0 2507 	ldrd	r2, r5, [r0, #28]
  __HAL_LOCK(hdma2d);
 8085fbc:	2701      	movs	r7, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY;  
 8085fbe:	2402      	movs	r4, #2
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8085fc0:	f1a2 0609 	sub.w	r6, r2, #9
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 8085fc4:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
  __HAL_LOCK(hdma2d);
 8085fc8:	f883 7038 	strb.w	r7, [r3, #56]	; 0x38
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8085fcc:	42be      	cmp	r6, r7
 8085fce:	6a45      	ldr	r5, [r0, #36]	; 0x24
  hdma2d->State = HAL_DMA2D_STATE_BUSY;  
 8085fd0:	f883 4039 	strb.w	r4, [r3, #57]	; 0x39
 8085fd4:	681c      	ldr	r4, [r3, #0]
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8085fd6:	d920      	bls.n	808601a <HAL_DMA2D_ConfigLayer+0x72>
    regValue |=  (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
 8085fd8:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
  if(LayerIdx == 0)
 8085fdc:	b191      	cbz	r1, 8086004 <HAL_DMA2D_ConfigLayer+0x5c>
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8085fde:	f64f 71f0 	movw	r1, #65520	; 0xfff0
 8085fe2:	69e5      	ldr	r5, [r4, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);      
 8085fe4:	6980      	ldr	r0, [r0, #24]
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8085fe6:	f2c0 01fc 	movt	r1, #252	; 0xfc
 8085fea:	4029      	ands	r1, r5
 8085fec:	430a      	orrs	r2, r1
 8085fee:	61e2      	str	r2, [r4, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);      
 8085ff0:	6120      	str	r0, [r4, #16]
  __HAL_UNLOCK(hdma2d);  
 8085ff2:	2200      	movs	r2, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8085ff4:	2101      	movs	r1, #1
  return HAL_OK;
 8085ff6:	4610      	mov	r0, r2
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8085ff8:	f883 1039 	strb.w	r1, [r3, #57]	; 0x39
  __HAL_UNLOCK(hdma2d);  
 8085ffc:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
}
 8086000:	bcf0      	pop	{r4, r5, r6, r7}
 8086002:	4770      	bx	lr
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8086004:	f64f 71f0 	movw	r1, #65520	; 0xfff0
 8086008:	6a65      	ldr	r5, [r4, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 808600a:	6998      	ldr	r0, [r3, #24]
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 808600c:	f2c0 01fc 	movt	r1, #252	; 0xfc
 8086010:	4029      	ands	r1, r5
 8086012:	430a      	orrs	r2, r1
 8086014:	6262      	str	r2, [r4, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8086016:	61a0      	str	r0, [r4, #24]
 8086018:	e7eb      	b.n	8085ff2 <HAL_DMA2D_ConfigLayer+0x4a>
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 808601a:	f005 467f 	and.w	r6, r5, #4278190080	; 0xff000000
 808601e:	4332      	orrs	r2, r6
  if(LayerIdx == 0)
 8086020:	b169      	cbz	r1, 808603e <HAL_DMA2D_ConfigLayer+0x96>
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 8086022:	f64f 71f0 	movw	r1, #65520	; 0xfff0
 8086026:	69e6      	ldr	r6, [r4, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);      
 8086028:	6980      	ldr	r0, [r0, #24]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));      
 808602a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 808602e:	f2c0 01fc 	movt	r1, #252	; 0xfc
 8086032:	4031      	ands	r1, r6
 8086034:	430a      	orrs	r2, r1
 8086036:	61e2      	str	r2, [r4, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);      
 8086038:	6120      	str	r0, [r4, #16]
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));      
 808603a:	6225      	str	r5, [r4, #32]
 808603c:	e7d9      	b.n	8085ff2 <HAL_DMA2D_ConfigLayer+0x4a>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 808603e:	f64f 71f0 	movw	r1, #65520	; 0xfff0
 8086042:	6a65      	ldr	r5, [r4, #36]	; 0x24
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 8086044:	6a58      	ldr	r0, [r3, #36]	; 0x24
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8086046:	f2c0 01fc 	movt	r1, #252	; 0xfc
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 808604a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 808604e:	4029      	ands	r1, r5
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8086050:	699d      	ldr	r5, [r3, #24]
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8086052:	430a      	orrs	r2, r1
 8086054:	6262      	str	r2, [r4, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8086056:	61a5      	str	r5, [r4, #24]
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 8086058:	62a0      	str	r0, [r4, #40]	; 0x28
 808605a:	e7ca      	b.n	8085ff2 <HAL_DMA2D_ConfigLayer+0x4a>
  __HAL_LOCK(hdma2d);
 808605c:	2002      	movs	r0, #2
}
 808605e:	4770      	bx	lr

08086060 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8086060:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8086064:	f44f 5860 	mov.w	r8, #14336	; 0x3800
{
 8086068:	468e      	mov	lr, r1

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 808606a:	2200      	movs	r2, #0
 808606c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8086070:	4643      	mov	r3, r8
 8086072:	f44f 6400 	mov.w	r4, #2048	; 0x800
 8086076:	f44f 6540 	mov.w	r5, #3072	; 0xc00
 808607a:	f44f 5680 	mov.w	r6, #4096	; 0x1000
 808607e:	f44f 57a0 	mov.w	r7, #5120	; 0x1400
{
 8086082:	b08b      	sub	sp, #44	; 0x2c
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8086084:	f2c4 0502 	movt	r5, #16386	; 0x4002
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8086088:	f44f 5c70 	mov.w	ip, #15360	; 0x3c00
 808608c:	f2c4 0301 	movt	r3, #16385	; 0x4001
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8086090:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8086094:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8086098:	f2c4 0402 	movt	r4, #16386	; 0x4002
 808609c:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80860a0:	f2c4 0702 	movt	r7, #16386	; 0x4002
 80860a4:	9505      	str	r5, [sp, #20]
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80860a6:	f2c4 0802 	movt	r8, #16386	; 0x4002
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80860aa:	f8de 9000 	ldr.w	r9, [lr]
        temp = EXTI->IMR;
 80860ae:	f2c4 0c01 	movt	ip, #16385	; 0x4001
 80860b2:	9301      	str	r3, [sp, #4]
  for(position = 0; position < GPIO_NUMBER; position++)
 80860b4:	2500      	movs	r5, #0
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80860b6:	9202      	str	r2, [sp, #8]
 80860b8:	9103      	str	r1, [sp, #12]
 80860ba:	9404      	str	r4, [sp, #16]
 80860bc:	9606      	str	r6, [sp, #24]
 80860be:	9707      	str	r7, [sp, #28]
 80860c0:	e003      	b.n	80860ca <HAL_GPIO_Init+0x6a>
  for(position = 0; position < GPIO_NUMBER; position++)
 80860c2:	3501      	adds	r5, #1
 80860c4:	2d10      	cmp	r5, #16
 80860c6:	f000 80bf 	beq.w	8086248 <HAL_GPIO_Init+0x1e8>
    ioposition = ((uint32_t)0x01) << position;
 80860ca:	2301      	movs	r3, #1
 80860cc:	40ab      	lsls	r3, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80860ce:	ea09 0103 	and.w	r1, r9, r3
    if(iocurrent == ioposition)
 80860d2:	428b      	cmp	r3, r1
 80860d4:	d1f5      	bne.n	80860c2 <HAL_GPIO_Init+0x62>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80860d6:	f8de 4004 	ldr.w	r4, [lr, #4]
 80860da:	f024 0710 	bic.w	r7, r4, #16
 80860de:	2f02      	cmp	r7, #2
 80860e0:	f040 80b5 	bne.w	808624e <HAL_GPIO_Init+0x1ee>
        temp = GPIOx->AFR[position >> 3];
 80860e4:	08ee      	lsrs	r6, r5, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80860e6:	f005 0a07 	and.w	sl, r5, #7
 80860ea:	f04f 0b0f 	mov.w	fp, #15
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 80860ee:	f8de 2010 	ldr.w	r2, [lr, #16]
 80860f2:	eb00 0686 	add.w	r6, r0, r6, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80860f6:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = GPIOx->AFR[position >> 3];
 80860fa:	6a37      	ldr	r7, [r6, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80860fc:	fa0b fb0a 	lsl.w	fp, fp, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8086100:	fa02 f20a 	lsl.w	r2, r2, sl
 8086104:	ea4f 0a45 	mov.w	sl, r5, lsl #1
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8086108:	ea27 0b0b 	bic.w	fp, r7, fp
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 808610c:	2703      	movs	r7, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 808610e:	ea42 020b 	orr.w	r2, r2, fp
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8086112:	fa07 f70a 	lsl.w	r7, r7, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8086116:	f004 0b03 	and.w	fp, r4, #3
        GPIOx->AFR[position >> 3] = temp;
 808611a:	6232      	str	r2, [r6, #32]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 808611c:	43fa      	mvns	r2, r7
      temp = GPIOx->MODER;
 808611e:	6806      	ldr	r6, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8086120:	fa0b fb0a 	lsl.w	fp, fp, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8086124:	4016      	ands	r6, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8086126:	ea4b 0606 	orr.w	r6, fp, r6
      GPIOx->MODER = temp;
 808612a:	6006      	str	r6, [r0, #0]
        temp = GPIOx->OSPEEDR; 
 808612c:	6887      	ldr	r7, [r0, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 808612e:	f3c4 1600 	ubfx	r6, r4, #4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8086132:	ea07 0b02 	and.w	fp, r7, r2
        temp |= (GPIO_Init->Speed << (position * 2));
 8086136:	f8de 700c 	ldr.w	r7, [lr, #12]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 808613a:	40ae      	lsls	r6, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 808613c:	fa07 f70a 	lsl.w	r7, r7, sl
 8086140:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 8086144:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8086146:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8086148:	ea27 0303 	bic.w	r3, r7, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 808614c:	4333      	orrs	r3, r6
        GPIOx->OTYPER = temp;
 808614e:	6043      	str	r3, [r0, #4]
      temp = GPIOx->PUPDR;
 8086150:	68c6      	ldr	r6, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8086152:	00e7      	lsls	r7, r4, #3
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8086154:	f8de 3008 	ldr.w	r3, [lr, #8]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8086158:	ea02 0206 	and.w	r2, r2, r6
      temp |= ((GPIO_Init->Pull) << (position * 2));
 808615c:	fa03 f30a 	lsl.w	r3, r3, sl
 8086160:	ea42 0203 	orr.w	r2, r2, r3
      GPIOx->PUPDR = temp;
 8086164:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8086166:	d5ac      	bpl.n	80860c2 <HAL_GPIO_Init+0x62>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8086168:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
 808616c:	f025 0603 	bic.w	r6, r5, #3
 8086170:	9a01      	ldr	r2, [sp, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8086172:	f005 0303 	and.w	r3, r5, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8086176:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 808617a:	f04f 0a0f 	mov.w	sl, #15
 808617e:	4416      	add	r6, r2
 8086180:	009b      	lsls	r3, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8086182:	f8c8 7044 	str.w	r7, [r8, #68]	; 0x44
 8086186:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 808618a:	fa0a f203 	lsl.w	r2, sl, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 808618e:	f407 4780 	and.w	r7, r7, #16384	; 0x4000
 8086192:	9709      	str	r7, [sp, #36]	; 0x24
 8086194:	9f09      	ldr	r7, [sp, #36]	; 0x24
        temp = SYSCFG->EXTICR[position >> 2];
 8086196:	68b7      	ldr	r7, [r6, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8086198:	ea27 0202 	bic.w	r2, r7, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 808619c:	9f02      	ldr	r7, [sp, #8]
 808619e:	42b8      	cmp	r0, r7
 80861a0:	d02b      	beq.n	80861fa <HAL_GPIO_Init+0x19a>
 80861a2:	9f03      	ldr	r7, [sp, #12]
 80861a4:	42b8      	cmp	r0, r7
 80861a6:	d069      	beq.n	808627c <HAL_GPIO_Init+0x21c>
 80861a8:	9f04      	ldr	r7, [sp, #16]
 80861aa:	42b8      	cmp	r0, r7
 80861ac:	d06b      	beq.n	8086286 <HAL_GPIO_Init+0x226>
 80861ae:	9f05      	ldr	r7, [sp, #20]
 80861b0:	42b8      	cmp	r0, r7
 80861b2:	d06d      	beq.n	8086290 <HAL_GPIO_Init+0x230>
 80861b4:	9f06      	ldr	r7, [sp, #24]
 80861b6:	42b8      	cmp	r0, r7
 80861b8:	d06f      	beq.n	808629a <HAL_GPIO_Init+0x23a>
 80861ba:	9f07      	ldr	r7, [sp, #28]
 80861bc:	42b8      	cmp	r0, r7
 80861be:	d076      	beq.n	80862ae <HAL_GPIO_Init+0x24e>
 80861c0:	f44f 57c0 	mov.w	r7, #6144	; 0x1800
 80861c4:	f2c4 0702 	movt	r7, #16386	; 0x4002
 80861c8:	42b8      	cmp	r0, r7
 80861ca:	d075      	beq.n	80862b8 <HAL_GPIO_Init+0x258>
 80861cc:	f44f 57e0 	mov.w	r7, #7168	; 0x1c00
 80861d0:	f2c4 0702 	movt	r7, #16386	; 0x4002
 80861d4:	42b8      	cmp	r0, r7
 80861d6:	d065      	beq.n	80862a4 <HAL_GPIO_Init+0x244>
 80861d8:	f44f 5700 	mov.w	r7, #8192	; 0x2000
 80861dc:	f2c4 0702 	movt	r7, #16386	; 0x4002
 80861e0:	42b8      	cmp	r0, r7
 80861e2:	d06e      	beq.n	80862c2 <HAL_GPIO_Init+0x262>
 80861e4:	f44f 5710 	mov.w	r7, #9216	; 0x2400
 80861e8:	f2c4 0702 	movt	r7, #16386	; 0x4002
 80861ec:	42b8      	cmp	r0, r7
 80861ee:	bf0c      	ite	eq
 80861f0:	2709      	moveq	r7, #9
 80861f2:	270a      	movne	r7, #10
 80861f4:	fa07 f303 	lsl.w	r3, r7, r3
 80861f8:	431a      	orrs	r2, r3
        SYSCFG->EXTICR[position >> 2] = temp;
 80861fa:	60b2      	str	r2, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
 80861fc:	43ca      	mvns	r2, r1
        temp = EXTI->IMR;
 80861fe:	f8dc 3000 	ldr.w	r3, [ip]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8086202:	03e6      	lsls	r6, r4, #15
  for(position = 0; position < GPIO_NUMBER; position++)
 8086204:	f105 0501 	add.w	r5, r5, #1
        temp &= ~((uint32_t)iocurrent);
 8086208:	bf54      	ite	pl
 808620a:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 808620c:	430b      	orrmi	r3, r1
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 808620e:	03a7      	lsls	r7, r4, #14
        EXTI->IMR = temp;
 8086210:	f8cc 3000 	str.w	r3, [ip]
        temp = EXTI->EMR;
 8086214:	f8dc 3004 	ldr.w	r3, [ip, #4]
        temp &= ~((uint32_t)iocurrent);
 8086218:	bf54      	ite	pl
 808621a:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 808621c:	430b      	orrmi	r3, r1
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 808621e:	02e6      	lsls	r6, r4, #11
        EXTI->EMR = temp;
 8086220:	f8cc 3004 	str.w	r3, [ip, #4]
        temp = EXTI->RTSR;
 8086224:	f8dc 3008 	ldr.w	r3, [ip, #8]
        temp &= ~((uint32_t)iocurrent);
 8086228:	bf54      	ite	pl
 808622a:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 808622c:	430b      	orrmi	r3, r1
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 808622e:	02a4      	lsls	r4, r4, #10
        EXTI->RTSR = temp;
 8086230:	f8cc 3008 	str.w	r3, [ip, #8]
        temp = EXTI->FTSR;
 8086234:	f8dc 300c 	ldr.w	r3, [ip, #12]
        temp &= ~((uint32_t)iocurrent);
 8086238:	bf54      	ite	pl
 808623a:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 808623c:	430b      	orrmi	r3, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 808623e:	2d10      	cmp	r5, #16
        }
        EXTI->FTSR = temp;
 8086240:	f8cc 300c 	str.w	r3, [ip, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8086244:	f47f af41 	bne.w	80860ca <HAL_GPIO_Init+0x6a>
      }
    }
  }
}
 8086248:	b00b      	add	sp, #44	; 0x2c
 808624a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 808624e:	ea4f 0a45 	mov.w	sl, r5, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8086252:	2203      	movs	r2, #3
      temp = GPIOx->MODER;
 8086254:	f8d0 b000 	ldr.w	fp, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8086258:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 808625a:	ea04 0602 	and.w	r6, r4, r2
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 808625e:	fa02 f20a 	lsl.w	r2, r2, sl
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8086262:	2f01      	cmp	r7, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8086264:	ea6f 0202 	mvn.w	r2, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8086268:	fa06 f60a 	lsl.w	r6, r6, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 808626c:	ea02 0b0b 	and.w	fp, r2, fp
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8086270:	ea46 060b 	orr.w	r6, r6, fp
      GPIOx->MODER = temp;
 8086274:	6006      	str	r6, [r0, #0]
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8086276:	f63f af6b 	bhi.w	8086150 <HAL_GPIO_Init+0xf0>
 808627a:	e757      	b.n	808612c <HAL_GPIO_Init+0xcc>
 808627c:	2701      	movs	r7, #1
 808627e:	fa07 f303 	lsl.w	r3, r7, r3
 8086282:	431a      	orrs	r2, r3
 8086284:	e7b9      	b.n	80861fa <HAL_GPIO_Init+0x19a>
 8086286:	2702      	movs	r7, #2
 8086288:	fa07 f303 	lsl.w	r3, r7, r3
 808628c:	431a      	orrs	r2, r3
 808628e:	e7b4      	b.n	80861fa <HAL_GPIO_Init+0x19a>
 8086290:	2703      	movs	r7, #3
 8086292:	fa07 f303 	lsl.w	r3, r7, r3
 8086296:	431a      	orrs	r2, r3
 8086298:	e7af      	b.n	80861fa <HAL_GPIO_Init+0x19a>
 808629a:	2704      	movs	r7, #4
 808629c:	fa07 f303 	lsl.w	r3, r7, r3
 80862a0:	431a      	orrs	r2, r3
 80862a2:	e7aa      	b.n	80861fa <HAL_GPIO_Init+0x19a>
 80862a4:	2707      	movs	r7, #7
 80862a6:	fa07 f303 	lsl.w	r3, r7, r3
 80862aa:	431a      	orrs	r2, r3
 80862ac:	e7a5      	b.n	80861fa <HAL_GPIO_Init+0x19a>
 80862ae:	2705      	movs	r7, #5
 80862b0:	fa07 f303 	lsl.w	r3, r7, r3
 80862b4:	431a      	orrs	r2, r3
 80862b6:	e7a0      	b.n	80861fa <HAL_GPIO_Init+0x19a>
 80862b8:	2706      	movs	r7, #6
 80862ba:	fa07 f303 	lsl.w	r3, r7, r3
 80862be:	431a      	orrs	r2, r3
 80862c0:	e79b      	b.n	80861fa <HAL_GPIO_Init+0x19a>
 80862c2:	2708      	movs	r7, #8
 80862c4:	fa07 f303 	lsl.w	r3, r7, r3
 80862c8:	431a      	orrs	r2, r3
 80862ca:	e796      	b.n	80861fa <HAL_GPIO_Init+0x19a>

080862cc <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 80862cc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 80862d0:	2200      	movs	r2, #0
{
 80862d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80862d6:	469c      	mov	ip, r3
 80862d8:	b089      	sub	sp, #36	; 0x24
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 80862da:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80862de:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80862e2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80862e6:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80862ea:	f44f 6640 	mov.w	r6, #3072	; 0xc00
 80862ee:	f44f 5780 	mov.w	r7, #4096	; 0x1000
 80862f2:	9201      	str	r2, [sp, #4]
 80862f4:	461a      	mov	r2, r3
 80862f6:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 80862fa:	f2c4 0502 	movt	r5, #16386	; 0x4002
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 80862fe:	f44f 5a70 	mov.w	sl, #15360	; 0x3c00
 8086302:	f2c4 0c01 	movt	ip, #16385	; 0x4001
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 8086306:	f2c4 0402 	movt	r4, #16386	; 0x4002
 808630a:	f2c4 0602 	movt	r6, #16386	; 0x4002
 808630e:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8086312:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8086316:	f2c4 0302 	movt	r3, #16386	; 0x4002
 808631a:	9504      	str	r5, [sp, #16]
 808631c:	f8cd c000 	str.w	ip, [sp]
        EXTI->IMR &= ~((uint32_t)iocurrent);
 8086320:	f2c4 0a01 	movt	sl, #16385	; 0x4001
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 8086324:	9402      	str	r4, [sp, #8]
  for(position = 0; position < GPIO_NUMBER; position++)
 8086326:	2500      	movs	r5, #0
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 8086328:	9606      	str	r6, [sp, #24]
  for(position = 0; position < GPIO_NUMBER; position++)
 808632a:	4689      	mov	r9, r1
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 808632c:	9707      	str	r7, [sp, #28]
 808632e:	9203      	str	r2, [sp, #12]
 8086330:	9305      	str	r3, [sp, #20]
 8086332:	e003      	b.n	808633c <HAL_GPIO_DeInit+0x70>
  for(position = 0; position < GPIO_NUMBER; position++)
 8086334:	3501      	adds	r5, #1
 8086336:	2d10      	cmp	r5, #16
 8086338:	f000 8086 	beq.w	8086448 <HAL_GPIO_DeInit+0x17c>
    ioposition = ((uint32_t)0x01) << position;
 808633c:	f04f 0c01 	mov.w	ip, #1
 8086340:	fa0c f305 	lsl.w	r3, ip, r5
    if(iocurrent == ioposition)
 8086344:	ea33 0209 	bics.w	r2, r3, r9
 8086348:	d1f4      	bne.n	8086334 <HAL_GPIO_DeInit+0x68>
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 808634a:	f04f 0b03 	mov.w	fp, #3
 808634e:	fa05 f20c 	lsl.w	r2, r5, ip
 8086352:	6801      	ldr	r1, [r0, #0]
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8086354:	f005 0607 	and.w	r6, r5, #7
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 8086358:	fa0b f202 	lsl.w	r2, fp, r2
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 808635c:	fa25 f70b 	lsr.w	r7, r5, fp
 8086360:	f04f 0e0f 	mov.w	lr, #15
 8086364:	00b6      	lsls	r6, r6, #2
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 8086366:	43d2      	mvns	r2, r2
 8086368:	eb00 0787 	add.w	r7, r0, r7, lsl #2
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 808636c:	fa0e f606 	lsl.w	r6, lr, r6
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 8086370:	43db      	mvns	r3, r3
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2));
 8086372:	4011      	ands	r1, r2
 8086374:	9c00      	ldr	r4, [sp, #0]
 8086376:	f025 0803 	bic.w	r8, r5, #3
 808637a:	6001      	str	r1, [r0, #0]
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 808637c:	6a39      	ldr	r1, [r7, #32]
 808637e:	44a0      	add	r8, r4
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8086380:	ea05 040b 	and.w	r4, r5, fp
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8086384:	ea21 0606 	bic.w	r6, r1, r6
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8086388:	00a4      	lsls	r4, r4, #2
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 808638a:	623e      	str	r6, [r7, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 808638c:	6881      	ldr	r1, [r0, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 808638e:	fa0e fe04 	lsl.w	lr, lr, r4
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8086392:	4011      	ands	r1, r2
 8086394:	6081      	str	r1, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 8086396:	6841      	ldr	r1, [r0, #4]
 8086398:	4019      	ands	r1, r3
 808639a:	6041      	str	r1, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 808639c:	68c1      	ldr	r1, [r0, #12]
 808639e:	400a      	ands	r2, r1
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 80863a0:	9901      	ldr	r1, [sp, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 80863a2:	60c2      	str	r2, [r0, #12]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 80863a4:	4288      	cmp	r0, r1
      tmp = SYSCFG->EXTICR[position >> 2];
 80863a6:	f8d8 2008 	ldr.w	r2, [r8, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 80863aa:	ea0e 0202 	and.w	r2, lr, r2
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 80863ae:	d056      	beq.n	808645e <HAL_GPIO_DeInit+0x192>
 80863b0:	9902      	ldr	r1, [sp, #8]
 80863b2:	4288      	cmp	r0, r1
 80863b4:	d04d      	beq.n	8086452 <HAL_GPIO_DeInit+0x186>
 80863b6:	9904      	ldr	r1, [sp, #16]
 80863b8:	4288      	cmp	r0, r1
 80863ba:	d048      	beq.n	808644e <HAL_GPIO_DeInit+0x182>
 80863bc:	9906      	ldr	r1, [sp, #24]
 80863be:	4288      	cmp	r0, r1
 80863c0:	d04f      	beq.n	8086462 <HAL_GPIO_DeInit+0x196>
 80863c2:	9907      	ldr	r1, [sp, #28]
 80863c4:	4288      	cmp	r0, r1
 80863c6:	d04f      	beq.n	8086468 <HAL_GPIO_DeInit+0x19c>
 80863c8:	9903      	ldr	r1, [sp, #12]
 80863ca:	4288      	cmp	r0, r1
 80863cc:	d051      	beq.n	8086472 <HAL_GPIO_DeInit+0x1a6>
 80863ce:	9905      	ldr	r1, [sp, #20]
 80863d0:	4288      	cmp	r0, r1
 80863d2:	d053      	beq.n	808647c <HAL_GPIO_DeInit+0x1b0>
 80863d4:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 80863d8:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80863dc:	4288      	cmp	r0, r1
 80863de:	d051      	beq.n	8086484 <HAL_GPIO_DeInit+0x1b8>
 80863e0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80863e4:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80863e8:	4288      	cmp	r0, r1
 80863ea:	d04f      	beq.n	808648c <HAL_GPIO_DeInit+0x1c0>
 80863ec:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 80863f0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80863f4:	4288      	cmp	r0, r1
 80863f6:	bf0c      	ite	eq
 80863f8:	2109      	moveq	r1, #9
 80863fa:	210a      	movne	r1, #10
 80863fc:	fa01 f404 	lsl.w	r4, r1, r4
 8086400:	42a2      	cmp	r2, r4
 8086402:	d197      	bne.n	8086334 <HAL_GPIO_DeInit+0x68>
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8086404:	f8d8 2008 	ldr.w	r2, [r8, #8]
  for(position = 0; position < GPIO_NUMBER; position++)
 8086408:	3501      	adds	r5, #1
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 808640a:	ea22 020e 	bic.w	r2, r2, lr
  for(position = 0; position < GPIO_NUMBER; position++)
 808640e:	2d10      	cmp	r5, #16
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8086410:	f8c8 2008 	str.w	r2, [r8, #8]
        EXTI->IMR &= ~((uint32_t)iocurrent);
 8086414:	f8da 2000 	ldr.w	r2, [sl]
 8086418:	ea02 0203 	and.w	r2, r2, r3
 808641c:	f8ca 2000 	str.w	r2, [sl]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 8086420:	f8da 2004 	ldr.w	r2, [sl, #4]
 8086424:	ea02 0203 	and.w	r2, r2, r3
 8086428:	f8ca 2004 	str.w	r2, [sl, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 808642c:	f8da 2008 	ldr.w	r2, [sl, #8]
 8086430:	ea02 0203 	and.w	r2, r2, r3
 8086434:	f8ca 2008 	str.w	r2, [sl, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 8086438:	f8da 200c 	ldr.w	r2, [sl, #12]
 808643c:	ea03 0302 	and.w	r3, r3, r2
 8086440:	f8ca 300c 	str.w	r3, [sl, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8086444:	f47f af7a 	bne.w	808633c <HAL_GPIO_DeInit+0x70>
	  }
    }
  }
}
 8086448:	b009      	add	sp, #36	; 0x24
 808644a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 808644e:	f04f 0c02 	mov.w	ip, #2
 8086452:	fa0c f404 	lsl.w	r4, ip, r4
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03))))
 8086456:	42a2      	cmp	r2, r4
 8086458:	f47f af6c 	bne.w	8086334 <HAL_GPIO_DeInit+0x68>
 808645c:	e7d2      	b.n	8086404 <HAL_GPIO_DeInit+0x138>
 808645e:	2400      	movs	r4, #0
 8086460:	e7f9      	b.n	8086456 <HAL_GPIO_DeInit+0x18a>
 8086462:	fa0b f404 	lsl.w	r4, fp, r4
 8086466:	e7f6      	b.n	8086456 <HAL_GPIO_DeInit+0x18a>
 8086468:	f04f 0c04 	mov.w	ip, #4
 808646c:	fa0c f404 	lsl.w	r4, ip, r4
 8086470:	e7f1      	b.n	8086456 <HAL_GPIO_DeInit+0x18a>
 8086472:	f04f 0c05 	mov.w	ip, #5
 8086476:	fa0c f404 	lsl.w	r4, ip, r4
 808647a:	e7ec      	b.n	8086456 <HAL_GPIO_DeInit+0x18a>
 808647c:	2106      	movs	r1, #6
 808647e:	fa01 f404 	lsl.w	r4, r1, r4
 8086482:	e7e8      	b.n	8086456 <HAL_GPIO_DeInit+0x18a>
 8086484:	2107      	movs	r1, #7
 8086486:	fa01 f404 	lsl.w	r4, r1, r4
 808648a:	e7e4      	b.n	8086456 <HAL_GPIO_DeInit+0x18a>
 808648c:	2108      	movs	r1, #8
 808648e:	fa01 f404 	lsl.w	r4, r1, r4
 8086492:	e7e0      	b.n	8086456 <HAL_GPIO_DeInit+0x18a>

08086494 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8086494:	6903      	ldr	r3, [r0, #16]
 8086496:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8086498:	bf14      	ite	ne
 808649a:	2001      	movne	r0, #1
 808649c:	2000      	moveq	r0, #0
 808649e:	4770      	bx	lr

080864a0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80864a0:	b902      	cbnz	r2, 80864a4 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 80864a2:	0409      	lsls	r1, r1, #16
 80864a4:	6181      	str	r1, [r0, #24]
  }
}
 80864a6:	4770      	bx	lr

080864a8 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 80864a8:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 80864aa:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80864ae:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80864b2:	6959      	ldr	r1, [r3, #20]
 80864b4:	4201      	tst	r1, r0
 80864b6:	d100      	bne.n	80864ba <HAL_GPIO_EXTI_IRQHandler+0x12>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}
 80864b8:	bd08      	pop	{r3, pc}
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80864ba:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80864bc:	f00b fca0 	bl	8091e00 <HAL_GPIO_EXTI_Callback>
}
 80864c0:	bd08      	pop	{r3, pc}
 80864c2:	bf00      	nop

080864c4 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
 80864c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80864c8:	4680      	mov	r8, r0
 80864ca:	460f      	mov	r7, r1
 80864cc:	4616      	mov	r6, r2
 80864ce:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80864d0:	f8d8 4000 	ldr.w	r4, [r8]
 80864d4:	e001      	b.n	80864da <I2C_WaitOnFlagUntilTimeout+0x16>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80864d6:	1c6b      	adds	r3, r5, #1
 80864d8:	d10a      	bne.n	80864f0 <I2C_WaitOnFlagUntilTimeout+0x2c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80864da:	69a0      	ldr	r0, [r4, #24]
 80864dc:	ea37 0300 	bics.w	r3, r7, r0
 80864e0:	bf0c      	ite	eq
 80864e2:	2001      	moveq	r0, #1
 80864e4:	2000      	movne	r0, #0
 80864e6:	42b0      	cmp	r0, r6
 80864e8:	d0f5      	beq.n	80864d6 <I2C_WaitOnFlagUntilTimeout+0x12>
        __HAL_UNLOCK(hi2c);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80864ea:	2000      	movs	r0, #0
}
 80864ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 80864f0:	b12d      	cbz	r5, 80864fe <I2C_WaitOnFlagUntilTimeout+0x3a>
 80864f2:	f7ff f95d 	bl	80857b0 <HAL_GetTick>
 80864f6:	9b06      	ldr	r3, [sp, #24]
 80864f8:	1ac0      	subs	r0, r0, r3
 80864fa:	42a8      	cmp	r0, r5
 80864fc:	d9e8      	bls.n	80864d0 <I2C_WaitOnFlagUntilTimeout+0xc>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80864fe:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 8086500:	2220      	movs	r2, #32
        return HAL_TIMEOUT;
 8086502:	2003      	movs	r0, #3
        hi2c->State = HAL_I2C_STATE_READY;
 8086504:	f888 2041 	strb.w	r2, [r8, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 8086508:	f888 3040 	strb.w	r3, [r8, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 808650c:	f888 3042 	strb.w	r3, [r8, #66]	; 0x42
        return HAL_TIMEOUT;
 8086510:	e7ec      	b.n	80864ec <I2C_WaitOnFlagUntilTimeout+0x28>
 8086512:	bf00      	nop

08086514 <I2C_IsAcknowledgeFailed.part.0>:
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
 8086514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8086516:	4606      	mov	r6, r0
 8086518:	460d      	mov	r5, r1
 808651a:	4617      	mov	r7, r2
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 808651c:	6834      	ldr	r4, [r6, #0]
 808651e:	e001      	b.n	8086524 <I2C_IsAcknowledgeFailed.part.0+0x10>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8086520:	1c68      	adds	r0, r5, #1
 8086522:	d125      	bne.n	8086570 <I2C_IsAcknowledgeFailed.part.0+0x5c>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8086524:	69a3      	ldr	r3, [r4, #24]
 8086526:	0699      	lsls	r1, r3, #26
 8086528:	d5fa      	bpl.n	8086520 <I2C_IsAcknowledgeFailed.part.0+0xc>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 808652a:	2210      	movs	r2, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 808652c:	2320      	movs	r3, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 808652e:	61e2      	str	r2, [r4, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8086530:	61e3      	str	r3, [r4, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8086532:	69a3      	ldr	r3, [r4, #24]
 8086534:	079a      	lsls	r2, r3, #30
 8086536:	d501      	bpl.n	808653c <I2C_IsAcknowledgeFailed.part.0+0x28>
    hi2c->Instance->TXDR = 0x00U;
 8086538:	2300      	movs	r3, #0
 808653a:	62a3      	str	r3, [r4, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 808653c:	69a3      	ldr	r3, [r4, #24]
 808653e:	07db      	lsls	r3, r3, #31
 8086540:	d403      	bmi.n	808654a <I2C_IsAcknowledgeFailed.part.0+0x36>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8086542:	69a3      	ldr	r3, [r4, #24]
 8086544:	f043 0301 	orr.w	r3, r3, #1
 8086548:	61a3      	str	r3, [r4, #24]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 808654a:	f44f 4168 	mov.w	r1, #59392	; 0xe800
 808654e:	6863      	ldr	r3, [r4, #4]

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8086550:	2200      	movs	r2, #0
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8086552:	2704      	movs	r7, #4
    I2C_RESET_CR2(hi2c);
 8086554:	f6cf 6100 	movt	r1, #65024	; 0xfe00
    hi2c->State = HAL_I2C_STATE_READY;
 8086558:	2520      	movs	r5, #32

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_ERROR;
 808655a:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 808655c:	400b      	ands	r3, r1
 808655e:	6063      	str	r3, [r4, #4]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8086560:	6477      	str	r7, [r6, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
 8086562:	f886 2040 	strb.w	r2, [r6, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 8086566:	f886 5041 	strb.w	r5, [r6, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 808656a:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
  }
  return HAL_OK;
}
 808656e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8086570:	b125      	cbz	r5, 808657c <I2C_IsAcknowledgeFailed.part.0+0x68>
 8086572:	f7ff f91d 	bl	80857b0 <HAL_GetTick>
 8086576:	1bc0      	subs	r0, r0, r7
 8086578:	4285      	cmp	r5, r0
 808657a:	d2cf      	bcs.n	808651c <I2C_IsAcknowledgeFailed.part.0+0x8>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 808657c:	2300      	movs	r3, #0
          hi2c->State = HAL_I2C_STATE_READY;
 808657e:	2220      	movs	r2, #32
          return HAL_TIMEOUT;
 8086580:	2003      	movs	r0, #3
          hi2c->State = HAL_I2C_STATE_READY;
 8086582:	f886 2041 	strb.w	r2, [r6, #65]	; 0x41
          __HAL_UNLOCK(hi2c);
 8086586:	f886 3040 	strb.w	r3, [r6, #64]	; 0x40
          hi2c->Mode = HAL_I2C_MODE_NONE;
 808658a:	f886 3042 	strb.w	r3, [r6, #66]	; 0x42
}
 808658e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08086590 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8086590:	b570      	push	{r4, r5, r6, lr}
 8086592:	4605      	mov	r5, r0
 8086594:	460c      	mov	r4, r1
 8086596:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8086598:	e001      	b.n	808659e <I2C_WaitOnTXISFlagUntilTimeout+0xe>
    if (Timeout != HAL_MAX_DELAY)
 808659a:	1c61      	adds	r1, r4, #1
 808659c:	d111      	bne.n	80865c2 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 808659e:	682b      	ldr	r3, [r5, #0]
 80865a0:	699a      	ldr	r2, [r3, #24]
 80865a2:	0792      	lsls	r2, r2, #30
 80865a4:	d40b      	bmi.n	80865be <I2C_WaitOnTXISFlagUntilTimeout+0x2e>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80865a6:	699b      	ldr	r3, [r3, #24]
 80865a8:	06d8      	lsls	r0, r3, #27
 80865aa:	d5f6      	bpl.n	808659a <I2C_WaitOnTXISFlagUntilTimeout+0xa>
 80865ac:	4632      	mov	r2, r6
 80865ae:	4621      	mov	r1, r4
 80865b0:	4628      	mov	r0, r5
 80865b2:	f7ff ffaf 	bl	8086514 <I2C_IsAcknowledgeFailed.part.0>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 80865b6:	2800      	cmp	r0, #0
 80865b8:	d0ef      	beq.n	808659a <I2C_WaitOnTXISFlagUntilTimeout+0xa>
      return HAL_ERROR;
 80865ba:	2001      	movs	r0, #1
}
 80865bc:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 80865be:	2000      	movs	r0, #0
}
 80865c0:	bd70      	pop	{r4, r5, r6, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 80865c2:	b124      	cbz	r4, 80865ce <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
 80865c4:	f7ff f8f4 	bl	80857b0 <HAL_GetTick>
 80865c8:	1b80      	subs	r0, r0, r6
 80865ca:	42a0      	cmp	r0, r4
 80865cc:	d9e7      	bls.n	808659e <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80865ce:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80865d0:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80865d2:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 80865d4:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80865d6:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 80865d8:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80865dc:	646b      	str	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80865de:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80865e2:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 80865e6:	bd70      	pop	{r4, r5, r6, pc}

080865e8 <I2C_RequestMemoryWrite>:
{
 80865e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80865ec:	f44f 4c18 	mov.w	ip, #38912	; 0x9800
 80865f0:	6807      	ldr	r7, [r0, #0]
 80865f2:	f44f 5400 	mov.w	r4, #8192	; 0x2000
 80865f6:	f3c1 0109 	ubfx	r1, r1, #0, #10
 80865fa:	687d      	ldr	r5, [r7, #4]
 80865fc:	f6cf 4c00 	movt	ip, #64512	; 0xfc00
 8086600:	f2c8 1400 	movt	r4, #33024	; 0x8100
{
 8086604:	4690      	mov	r8, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086606:	ea05 020c 	and.w	r2, r5, ip
{
 808660a:	4699      	mov	r9, r3
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 808660c:	430c      	orrs	r4, r1
 808660e:	b2db      	uxtb	r3, r3
{
 8086610:	b083      	sub	sp, #12
 8086612:	4606      	mov	r6, r0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086614:	4314      	orrs	r4, r2
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8086616:	990a      	ldr	r1, [sp, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086618:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 808661c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 808661e:	607c      	str	r4, [r7, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8086620:	f7ff ffb6 	bl	8086590 <I2C_WaitOnTXISFlagUntilTimeout>
 8086624:	b9e0      	cbnz	r0, 8086660 <I2C_RequestMemoryWrite+0x78>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8086626:	f1b9 0f01 	cmp.w	r9, #1
 808662a:	6833      	ldr	r3, [r6, #0]
 808662c:	d10f      	bne.n	808664e <I2C_RequestMemoryWrite+0x66>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 808662e:	fa5f f288 	uxtb.w	r2, r8
 8086632:	629a      	str	r2, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8086634:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8086636:	4630      	mov	r0, r6
 8086638:	2200      	movs	r2, #0
 808663a:	2180      	movs	r1, #128	; 0x80
 808663c:	9300      	str	r3, [sp, #0]
 808663e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8086640:	f7ff ff40 	bl	80864c4 <I2C_WaitOnFlagUntilTimeout>
 8086644:	b180      	cbz	r0, 8086668 <I2C_RequestMemoryWrite+0x80>
      return HAL_TIMEOUT;
 8086646:	2003      	movs	r0, #3
}
 8086648:	b003      	add	sp, #12
 808664a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 808664e:	ea4f 2018 	mov.w	r0, r8, lsr #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8086652:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8086656:	6298      	str	r0, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8086658:	4630      	mov	r0, r6
 808665a:	f7ff ff99 	bl	8086590 <I2C_WaitOnTXISFlagUntilTimeout>
 808665e:	b130      	cbz	r0, 808666e <I2C_RequestMemoryWrite+0x86>
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8086660:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8086662:	2b04      	cmp	r3, #4
 8086664:	d1ef      	bne.n	8086646 <I2C_RequestMemoryWrite+0x5e>
      return HAL_ERROR;
 8086666:	2001      	movs	r0, #1
}
 8086668:	b003      	add	sp, #12
 808666a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 808666e:	fa5f f388 	uxtb.w	r3, r8
 8086672:	6832      	ldr	r2, [r6, #0]
 8086674:	6293      	str	r3, [r2, #40]	; 0x28
 8086676:	e7dd      	b.n	8086634 <I2C_RequestMemoryWrite+0x4c>

08086678 <I2C_RequestMemoryRead>:
{
 8086678:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 808667c:	f44f 4c18 	mov.w	ip, #38912	; 0x9800
 8086680:	6807      	ldr	r7, [r0, #0]
 8086682:	f44f 5400 	mov.w	r4, #8192	; 0x2000
 8086686:	f3c1 0109 	ubfx	r1, r1, #0, #10
 808668a:	687d      	ldr	r5, [r7, #4]
 808668c:	f6cf 4c00 	movt	ip, #64512	; 0xfc00
 8086690:	f2c8 0400 	movt	r4, #32768	; 0x8000
{
 8086694:	4690      	mov	r8, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086696:	ea05 020c 	and.w	r2, r5, ip
{
 808669a:	4699      	mov	r9, r3
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 808669c:	430c      	orrs	r4, r1
 808669e:	b2db      	uxtb	r3, r3
{
 80866a0:	b083      	sub	sp, #12
 80866a2:	4606      	mov	r6, r0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80866a4:	4314      	orrs	r4, r2
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80866a6:	990a      	ldr	r1, [sp, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80866a8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80866ac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80866ae:	607c      	str	r4, [r7, #4]
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80866b0:	f7ff ff6e 	bl	8086590 <I2C_WaitOnTXISFlagUntilTimeout>
 80866b4:	b9e0      	cbnz	r0, 80866f0 <I2C_RequestMemoryRead+0x78>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80866b6:	f1b9 0f01 	cmp.w	r9, #1
 80866ba:	6833      	ldr	r3, [r6, #0]
 80866bc:	d10f      	bne.n	80866de <I2C_RequestMemoryRead+0x66>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80866be:	fa5f f288 	uxtb.w	r2, r8
 80866c2:	629a      	str	r2, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 80866c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80866c6:	4630      	mov	r0, r6
 80866c8:	2200      	movs	r2, #0
 80866ca:	2140      	movs	r1, #64	; 0x40
 80866cc:	9300      	str	r3, [sp, #0]
 80866ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80866d0:	f7ff fef8 	bl	80864c4 <I2C_WaitOnFlagUntilTimeout>
 80866d4:	b180      	cbz	r0, 80866f8 <I2C_RequestMemoryRead+0x80>
      return HAL_TIMEOUT;
 80866d6:	2003      	movs	r0, #3
}
 80866d8:	b003      	add	sp, #12
 80866da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 80866de:	ea4f 2018 	mov.w	r0, r8, lsr #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80866e2:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 80866e6:	6298      	str	r0, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80866e8:	4630      	mov	r0, r6
 80866ea:	f7ff ff51 	bl	8086590 <I2C_WaitOnTXISFlagUntilTimeout>
 80866ee:	b130      	cbz	r0, 80866fe <I2C_RequestMemoryRead+0x86>
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80866f0:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80866f2:	2b04      	cmp	r3, #4
 80866f4:	d1ef      	bne.n	80866d6 <I2C_RequestMemoryRead+0x5e>
      return HAL_ERROR;
 80866f6:	2001      	movs	r0, #1
}
 80866f8:	b003      	add	sp, #12
 80866fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 80866fe:	fa5f f388 	uxtb.w	r3, r8
 8086702:	6832      	ldr	r2, [r6, #0]
 8086704:	6293      	str	r3, [r2, #40]	; 0x28
 8086706:	e7dd      	b.n	80866c4 <I2C_RequestMemoryRead+0x4c>

08086708 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8086708:	b570      	push	{r4, r5, r6, lr}
 808670a:	4605      	mov	r5, r0
 808670c:	460c      	mov	r4, r1
 808670e:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8086710:	682b      	ldr	r3, [r5, #0]
 8086712:	699a      	ldr	r2, [r3, #24]
 8086714:	0692      	lsls	r2, r2, #26
 8086716:	d41e      	bmi.n	8086756 <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8086718:	699b      	ldr	r3, [r3, #24]
 808671a:	06d9      	lsls	r1, r3, #27
 808671c:	d412      	bmi.n	8086744 <I2C_WaitOnSTOPFlagUntilTimeout+0x3c>
    if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 808671e:	b124      	cbz	r4, 808672a <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
 8086720:	f7ff f846 	bl	80857b0 <HAL_GetTick>
 8086724:	1b80      	subs	r0, r0, r6
 8086726:	42a0      	cmp	r0, r4
 8086728:	d9f2      	bls.n	8086710 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 808672a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 808672c:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 808672e:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 8086730:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8086732:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 8086734:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8086738:	646b      	str	r3, [r5, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 808673a:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 808673e:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
}
 8086742:	bd70      	pop	{r4, r5, r6, pc}
 8086744:	4632      	mov	r2, r6
 8086746:	4621      	mov	r1, r4
 8086748:	4628      	mov	r0, r5
 808674a:	f7ff fee3 	bl	8086514 <I2C_IsAcknowledgeFailed.part.0>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 808674e:	2800      	cmp	r0, #0
 8086750:	d0e5      	beq.n	808671e <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
      return HAL_ERROR;
 8086752:	2001      	movs	r0, #1
}
 8086754:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8086756:	2000      	movs	r0, #0
}
 8086758:	bd70      	pop	{r4, r5, r6, pc}
 808675a:	bf00      	nop

0808675c <HAL_I2C_MspInit>:
}
 808675c:	4770      	bx	lr
 808675e:	bf00      	nop

08086760 <HAL_I2C_Init>:
  if (hi2c == NULL)
 8086760:	2800      	cmp	r0, #0
 8086762:	d050      	beq.n	8086806 <HAL_I2C_Init+0xa6>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8086764:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 8086768:	b570      	push	{r4, r5, r6, lr}
  if (hi2c->State == HAL_I2C_STATE_RESET)
 808676a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 808676e:	4604      	mov	r4, r0
 8086770:	2b00      	cmp	r3, #0
 8086772:	d043      	beq.n	80867fc <HAL_I2C_Init+0x9c>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8086774:	2124      	movs	r1, #36	; 0x24
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8086776:	68e5      	ldr	r5, [r4, #12]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8086778:	e9d4 3200 	ldrd	r3, r2, [r4]
  hi2c->State = HAL_I2C_STATE_BUSY;
 808677c:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8086780:	2d01      	cmp	r5, #1
  __HAL_I2C_DISABLE(hi2c);
 8086782:	6818      	ldr	r0, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8086784:	f022 6170 	bic.w	r1, r2, #251658240	; 0xf000000
 8086788:	68a2      	ldr	r2, [r4, #8]
  __HAL_I2C_DISABLE(hi2c);
 808678a:	f020 0001 	bic.w	r0, r0, #1
 808678e:	6018      	str	r0, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8086790:	6119      	str	r1, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8086792:	6899      	ldr	r1, [r3, #8]
 8086794:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8086798:	6099      	str	r1, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 808679a:	d02b      	beq.n	80867f4 <HAL_I2C_Init+0x94>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 808679c:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80867a0:	2d02      	cmp	r5, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80867a2:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80867a4:	d102      	bne.n	80867ac <HAL_I2C_Init+0x4c>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 80867a6:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80867aa:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80867ac:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80867b0:	685e      	ldr	r6, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80867b2:	6965      	ldr	r5, [r4, #20]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80867b4:	2100      	movs	r1, #0
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80867b6:	6922      	ldr	r2, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80867b8:	f2c0 2000 	movt	r0, #512	; 0x200
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80867bc:	432a      	orrs	r2, r5
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80867be:	4330      	orrs	r0, r6
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80867c0:	69a6      	ldr	r6, [r4, #24]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80867c2:	6058      	str	r0, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80867c4:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80867c8:	68dd      	ldr	r5, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80867ca:	e9d4 0607 	ldrd	r0, r6, [r4, #28]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80867ce:	f425 4500 	bic.w	r5, r5, #32768	; 0x8000
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80867d2:	4330      	orrs	r0, r6
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80867d4:	60dd      	str	r5, [r3, #12]
  hi2c->State = HAL_I2C_STATE_READY;
 80867d6:	2520      	movs	r5, #32
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80867d8:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80867da:	6018      	str	r0, [r3, #0]
  return HAL_OK;
 80867dc:	4608      	mov	r0, r1
  __HAL_I2C_ENABLE(hi2c);
 80867de:	681a      	ldr	r2, [r3, #0]
 80867e0:	f042 0201 	orr.w	r2, r2, #1
 80867e4:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80867e6:	6461      	str	r1, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 80867e8:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 80867ec:	6321      	str	r1, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80867ee:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 80867f2:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80867f4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80867f8:	609a      	str	r2, [r3, #8]
 80867fa:	e7d7      	b.n	80867ac <HAL_I2C_Init+0x4c>
    hi2c->Lock = HAL_UNLOCKED;
 80867fc:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8086800:	f7ff ffac 	bl	808675c <HAL_I2C_MspInit>
 8086804:	e7b6      	b.n	8086774 <HAL_I2C_Init+0x14>
    return HAL_ERROR;
 8086806:	2001      	movs	r0, #1
}
 8086808:	4770      	bx	lr
 808680a:	bf00      	nop

0808680c <HAL_I2C_MspDeInit>:
 808680c:	4770      	bx	lr
 808680e:	bf00      	nop

08086810 <HAL_I2C_DeInit>:
  if (hi2c == NULL)
 8086810:	b1b0      	cbz	r0, 8086840 <HAL_I2C_DeInit+0x30>
  __HAL_I2C_DISABLE(hi2c);
 8086812:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8086814:	2324      	movs	r3, #36	; 0x24
{
 8086816:	b510      	push	{r4, lr}
  hi2c->State = HAL_I2C_STATE_BUSY;
 8086818:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
 808681c:	4604      	mov	r4, r0
  __HAL_I2C_DISABLE(hi2c);
 808681e:	6813      	ldr	r3, [r2, #0]
 8086820:	f023 0301 	bic.w	r3, r3, #1
 8086824:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8086826:	f7ff fff1 	bl	808680c <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 808682a:	2300      	movs	r3, #0
 808682c:	6463      	str	r3, [r4, #68]	; 0x44
  return HAL_OK;
 808682e:	4618      	mov	r0, r3
  hi2c->State = HAL_I2C_STATE_RESET;
 8086830:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
 8086834:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  hi2c->PreviousState = I2C_STATE_NONE;
 8086838:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 808683a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
}
 808683e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8086840:	2001      	movs	r0, #1
}
 8086842:	4770      	bx	lr

08086844 <HAL_I2C_Mem_Write>:
{
 8086844:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8086848:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
 808684c:	b082      	sub	sp, #8
  if (hi2c->State == HAL_I2C_STATE_READY)
 808684e:	2c20      	cmp	r4, #32
{
 8086850:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
 8086854:	d13e      	bne.n	80868d4 <HAL_I2C_Mem_Write+0x90>
    if ((pData == NULL) || (Size == 0U))
 8086856:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8086858:	2c00      	cmp	r4, #0
 808685a:	d037      	beq.n	80868cc <HAL_I2C_Mem_Write+0x88>
 808685c:	f1b8 0f00 	cmp.w	r8, #0
 8086860:	d034      	beq.n	80868cc <HAL_I2C_Mem_Write+0x88>
    __HAL_LOCK(hi2c);
 8086862:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 8086866:	2c01      	cmp	r4, #1
 8086868:	d034      	beq.n	80868d4 <HAL_I2C_Mem_Write+0x90>
 808686a:	469a      	mov	sl, r3
 808686c:	2301      	movs	r3, #1
 808686e:	4691      	mov	r9, r2
 8086870:	460f      	mov	r7, r1
 8086872:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 8086876:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 8086878:	f7fe ff9a 	bl	80857b0 <HAL_GetTick>
 808687c:	4606      	mov	r6, r0
 808687e:	e004      	b.n	808688a <HAL_I2C_Mem_Write+0x46>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8086880:	f7fe ff96 	bl	80857b0 <HAL_GetTick>
 8086884:	1b80      	subs	r0, r0, r6
 8086886:	2819      	cmp	r0, #25
 8086888:	d828      	bhi.n	80868dc <HAL_I2C_Mem_Write+0x98>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 808688a:	6823      	ldr	r3, [r4, #0]
 808688c:	699d      	ldr	r5, [r3, #24]
 808688e:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 8086892:	d1f5      	bne.n	8086880 <HAL_I2C_Mem_Write+0x3c>
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8086894:	2040      	movs	r0, #64	; 0x40
    hi2c->pBuffPtr  = pData;
 8086896:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8086898:	990c      	ldr	r1, [sp, #48]	; 0x30
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 808689a:	f04f 0c21 	mov.w	ip, #33	; 0x21
    hi2c->pBuffPtr  = pData;
 808689e:	6263      	str	r3, [r4, #36]	; 0x24
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80868a0:	464a      	mov	r2, r9
    hi2c->XferISR   = NULL;
 80868a2:	6365      	str	r5, [r4, #52]	; 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80868a4:	4653      	mov	r3, sl
 80868a6:	9100      	str	r1, [sp, #0]
 80868a8:	4639      	mov	r1, r7
 80868aa:	9601      	str	r6, [sp, #4]
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80868ac:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80868b0:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80868b4:	4620      	mov	r0, r4
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80868b6:	6465      	str	r5, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 80868b8:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80868bc:	f7ff fe94 	bl	80865e8 <I2C_RequestMemoryWrite>
 80868c0:	b1b0      	cbz	r0, 80868f0 <HAL_I2C_Mem_Write+0xac>
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80868c2:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 80868c4:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80868c8:	2b04      	cmp	r3, #4
 80868ca:	d178      	bne.n	80869be <HAL_I2C_Mem_Write+0x17a>
        return HAL_ERROR;
 80868cc:	2001      	movs	r0, #1
}
 80868ce:	b002      	add	sp, #8
 80868d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return HAL_BUSY;
 80868d4:	2002      	movs	r0, #2
}
 80868d6:	b002      	add	sp, #8
 80868d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80868dc:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 80868de:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 80868e0:	2003      	movs	r0, #3
        hi2c->State = HAL_I2C_STATE_READY;
 80868e2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 80868e6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80868ea:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80868ee:	e7f2      	b.n	80868d6 <HAL_I2C_Mem_Write+0x92>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80868f0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80868f2:	f3c7 0509 	ubfx	r5, r7, #0, #10
 80868f6:	6821      	ldr	r1, [r4, #0]
 80868f8:	2bff      	cmp	r3, #255	; 0xff
 80868fa:	d84e      	bhi.n	808699a <HAL_I2C_Mem_Write+0x156>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80868fc:	f44f 471c 	mov.w	r7, #39936	; 0x9c00
      hi2c->XferSize = hi2c->XferCount;
 8086900:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086902:	684a      	ldr	r2, [r1, #4]
 8086904:	f045 7300 	orr.w	r3, r5, #33554432	; 0x2000000
 8086908:	f6cf 4700 	movt	r7, #64512	; 0xfc00
      hi2c->XferSize = hi2c->XferCount;
 808690c:	b280      	uxth	r0, r0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 808690e:	403a      	ands	r2, r7
 8086910:	b2c7      	uxtb	r7, r0
      hi2c->XferSize = hi2c->XferCount;
 8086912:	8520      	strh	r0, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086914:	4313      	orrs	r3, r2
 8086916:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 808691a:	604b      	str	r3, [r1, #4]
 808691c:	2700      	movs	r7, #0
 808691e:	f44f 481c 	mov.w	r8, #39936	; 0x9c00
 8086922:	f2c0 17ff 	movt	r7, #511	; 0x1ff
 8086926:	f6cf 4800 	movt	r8, #64512	; 0xfc00
 808692a:	432f      	orrs	r7, r5
 808692c:	e003      	b.n	8086936 <HAL_I2C_Mem_Write+0xf2>
    while (hi2c->XferCount > 0U);
 808692e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8086930:	b29b      	uxth	r3, r3
 8086932:	2b00      	cmp	r3, #0
 8086934:	d052      	beq.n	80869dc <HAL_I2C_Mem_Write+0x198>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8086936:	4632      	mov	r2, r6
 8086938:	990c      	ldr	r1, [sp, #48]	; 0x30
 808693a:	4620      	mov	r0, r4
 808693c:	f7ff fe28 	bl	8086590 <I2C_WaitOnTXISFlagUntilTimeout>
 8086940:	2800      	cmp	r0, #0
 8086942:	d139      	bne.n	80869b8 <HAL_I2C_Mem_Write+0x174>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8086944:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8086946:	6823      	ldr	r3, [r4, #0]
 8086948:	1c48      	adds	r0, r1, #1
      hi2c->XferSize--;
 808694a:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 808694c:	6260      	str	r0, [r4, #36]	; 0x24
      hi2c->XferSize--;
 808694e:	3a01      	subs	r2, #1
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8086950:	7809      	ldrb	r1, [r1, #0]
      hi2c->XferSize--;
 8086952:	b292      	uxth	r2, r2
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8086954:	6299      	str	r1, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8086956:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8086958:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 808695a:	3b01      	subs	r3, #1
 808695c:	b29b      	uxth	r3, r3
 808695e:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 8086960:	2a00      	cmp	r2, #0
 8086962:	d1e4      	bne.n	808692e <HAL_I2C_Mem_Write+0xea>
 8086964:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8086966:	b29b      	uxth	r3, r3
 8086968:	2b00      	cmp	r3, #0
 808696a:	d0e0      	beq.n	808692e <HAL_I2C_Mem_Write+0xea>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 808696c:	9600      	str	r6, [sp, #0]
 808696e:	2180      	movs	r1, #128	; 0x80
 8086970:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8086972:	4620      	mov	r0, r4
 8086974:	f7ff fda6 	bl	80864c4 <I2C_WaitOnFlagUntilTimeout>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086978:	f045 7c00 	orr.w	ip, r5, #33554432	; 0x2000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
 808697c:	f04f 0eff 	mov.w	lr, #255	; 0xff
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8086980:	b9e8      	cbnz	r0, 80869be <HAL_I2C_Mem_Write+0x17a>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8086982:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 8086984:	6822      	ldr	r2, [r4, #0]
 8086986:	4571      	cmp	r1, lr
 8086988:	d91b      	bls.n	80869c2 <HAL_I2C_Mem_Write+0x17e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 808698a:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = MAX_NBYTE_SIZE;
 808698c:	f8a4 e028 	strh.w	lr, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086990:	ea03 0308 	and.w	r3, r3, r8
 8086994:	433b      	orrs	r3, r7
 8086996:	6053      	str	r3, [r2, #4]
 8086998:	e7c9      	b.n	808692e <HAL_I2C_Mem_Write+0xea>
 808699a:	f44f 401c 	mov.w	r0, #39936	; 0x9c00
 808699e:	2200      	movs	r2, #0
 80869a0:	684b      	ldr	r3, [r1, #4]
 80869a2:	f6cf 4000 	movt	r0, #64512	; 0xfc00
 80869a6:	f2c0 12ff 	movt	r2, #511	; 0x1ff
 80869aa:	4003      	ands	r3, r0
 80869ac:	432a      	orrs	r2, r5
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80869ae:	20ff      	movs	r0, #255	; 0xff
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80869b0:	4313      	orrs	r3, r2
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80869b2:	8520      	strh	r0, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80869b4:	604b      	str	r3, [r1, #4]
 80869b6:	e7b1      	b.n	808691c <HAL_I2C_Mem_Write+0xd8>
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80869b8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80869ba:	2b04      	cmp	r3, #4
 80869bc:	d086      	beq.n	80868cc <HAL_I2C_Mem_Write+0x88>
          return HAL_TIMEOUT;
 80869be:	2003      	movs	r0, #3
 80869c0:	e789      	b.n	80868d6 <HAL_I2C_Mem_Write+0x92>
          hi2c->XferSize = hi2c->XferCount;
 80869c2:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80869c4:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = hi2c->XferCount;
 80869c6:	b289      	uxth	r1, r1
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80869c8:	ea03 0308 	and.w	r3, r3, r8
 80869cc:	b2c8      	uxtb	r0, r1
          hi2c->XferSize = hi2c->XferCount;
 80869ce:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80869d0:	ea43 030c 	orr.w	r3, r3, ip
 80869d4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80869d8:	6053      	str	r3, [r2, #4]
 80869da:	e7a8      	b.n	808692e <HAL_I2C_Mem_Write+0xea>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80869dc:	4632      	mov	r2, r6
 80869de:	990c      	ldr	r1, [sp, #48]	; 0x30
 80869e0:	4620      	mov	r0, r4
 80869e2:	f7ff fe91 	bl	8086708 <I2C_WaitOnSTOPFlagUntilTimeout>
 80869e6:	2800      	cmp	r0, #0
 80869e8:	d1e6      	bne.n	80869b8 <HAL_I2C_Mem_Write+0x174>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80869ea:	6823      	ldr	r3, [r4, #0]
 80869ec:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 80869ee:	f44f 4568 	mov.w	r5, #59392	; 0xe800
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80869f2:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 80869f4:	f6cf 6500 	movt	r5, #65024	; 0xfe00
 80869f8:	685a      	ldr	r2, [r3, #4]
 80869fa:	402a      	ands	r2, r5
 80869fc:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80869fe:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8086a02:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8086a06:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8086a0a:	e764      	b.n	80868d6 <HAL_I2C_Mem_Write+0x92>

08086a0c <HAL_I2C_Mem_Read>:
{
 8086a0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8086a10:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
 8086a14:	b082      	sub	sp, #8
  if (hi2c->State == HAL_I2C_STATE_READY)
 8086a16:	2c20      	cmp	r4, #32
{
 8086a18:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
 8086a1c:	d13e      	bne.n	8086a9c <HAL_I2C_Mem_Read+0x90>
    if ((pData == NULL) || (Size == 0U))
 8086a1e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8086a20:	2c00      	cmp	r4, #0
 8086a22:	d037      	beq.n	8086a94 <HAL_I2C_Mem_Read+0x88>
 8086a24:	f1b8 0f00 	cmp.w	r8, #0
 8086a28:	d034      	beq.n	8086a94 <HAL_I2C_Mem_Read+0x88>
    __HAL_LOCK(hi2c);
 8086a2a:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 8086a2e:	2c01      	cmp	r4, #1
 8086a30:	d034      	beq.n	8086a9c <HAL_I2C_Mem_Read+0x90>
 8086a32:	469a      	mov	sl, r3
 8086a34:	2301      	movs	r3, #1
 8086a36:	4691      	mov	r9, r2
 8086a38:	460f      	mov	r7, r1
 8086a3a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 8086a3e:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 8086a40:	f7fe feb6 	bl	80857b0 <HAL_GetTick>
 8086a44:	4606      	mov	r6, r0
 8086a46:	e004      	b.n	8086a52 <HAL_I2C_Mem_Read+0x46>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8086a48:	f7fe feb2 	bl	80857b0 <HAL_GetTick>
 8086a4c:	1b80      	subs	r0, r0, r6
 8086a4e:	2819      	cmp	r0, #25
 8086a50:	d835      	bhi.n	8086abe <HAL_I2C_Mem_Read+0xb2>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8086a52:	6823      	ldr	r3, [r4, #0]
 8086a54:	699d      	ldr	r5, [r3, #24]
 8086a56:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 8086a5a:	d1f5      	bne.n	8086a48 <HAL_I2C_Mem_Read+0x3c>
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8086a5c:	2040      	movs	r0, #64	; 0x40
    hi2c->pBuffPtr  = pData;
 8086a5e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8086a60:	990c      	ldr	r1, [sp, #48]	; 0x30
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8086a62:	f04f 0c22 	mov.w	ip, #34	; 0x22
    hi2c->pBuffPtr  = pData;
 8086a66:	6263      	str	r3, [r4, #36]	; 0x24
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8086a68:	464a      	mov	r2, r9
    hi2c->XferISR   = NULL;
 8086a6a:	6365      	str	r5, [r4, #52]	; 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8086a6c:	4653      	mov	r3, sl
 8086a6e:	9100      	str	r1, [sp, #0]
 8086a70:	4639      	mov	r1, r7
 8086a72:	9601      	str	r6, [sp, #4]
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8086a74:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8086a78:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8086a7c:	4620      	mov	r0, r4
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8086a7e:	6465      	str	r5, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8086a80:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8086a84:	f7ff fdf8 	bl	8086678 <I2C_RequestMemoryRead>
 8086a88:	b318      	cbz	r0, 8086ad2 <HAL_I2C_Mem_Read+0xc6>
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8086a8a:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8086a8c:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8086a90:	2b04      	cmp	r3, #4
 8086a92:	d112      	bne.n	8086aba <HAL_I2C_Mem_Read+0xae>
        return HAL_ERROR;
 8086a94:	2001      	movs	r0, #1
}
 8086a96:	b002      	add	sp, #8
 8086a98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return HAL_BUSY;
 8086a9c:	2002      	movs	r0, #2
}
 8086a9e:	b002      	add	sp, #8
 8086aa0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8086aa4:	4632      	mov	r2, r6
 8086aa6:	990c      	ldr	r1, [sp, #48]	; 0x30
 8086aa8:	4620      	mov	r0, r4
 8086aaa:	f7ff fe2d 	bl	8086708 <I2C_WaitOnSTOPFlagUntilTimeout>
 8086aae:	2800      	cmp	r0, #0
 8086ab0:	f000 8087 	beq.w	8086bc2 <HAL_I2C_Mem_Read+0x1b6>
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8086ab4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8086ab6:	2b04      	cmp	r3, #4
 8086ab8:	d0ec      	beq.n	8086a94 <HAL_I2C_Mem_Read+0x88>
        return HAL_TIMEOUT;
 8086aba:	2003      	movs	r0, #3
 8086abc:	e7ef      	b.n	8086a9e <HAL_I2C_Mem_Read+0x92>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8086abe:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 8086ac0:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 8086ac2:	2003      	movs	r0, #3
        hi2c->State = HAL_I2C_STATE_READY;
 8086ac4:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        __HAL_UNLOCK(hi2c);
 8086ac8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8086acc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8086ad0:	e7e5      	b.n	8086a9e <HAL_I2C_Mem_Read+0x92>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8086ad2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8086ad4:	f3c7 0509 	ubfx	r5, r7, #0, #10
 8086ad8:	6822      	ldr	r2, [r4, #0]
 8086ada:	2bff      	cmp	r3, #255	; 0xff
 8086adc:	d854      	bhi.n	8086b88 <HAL_I2C_Mem_Read+0x17c>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086ade:	f44f 4718 	mov.w	r7, #38912	; 0x9800
 8086ae2:	f44f 5110 	mov.w	r1, #9216	; 0x2400
      hi2c->XferSize = hi2c->XferCount;
 8086ae6:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086ae8:	f6cf 4700 	movt	r7, #64512	; 0xfc00
 8086aec:	6853      	ldr	r3, [r2, #4]
 8086aee:	f2c8 2100 	movt	r1, #33280	; 0x8200
      hi2c->XferSize = hi2c->XferCount;
 8086af2:	b280      	uxth	r0, r0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086af4:	403b      	ands	r3, r7
 8086af6:	4329      	orrs	r1, r5
 8086af8:	b2c7      	uxtb	r7, r0
      hi2c->XferSize = hi2c->XferCount;
 8086afa:	8520      	strh	r0, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086afc:	430b      	orrs	r3, r1
 8086afe:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 8086b02:	6053      	str	r3, [r2, #4]
 8086b04:	2700      	movs	r7, #0
 8086b06:	f44f 481c 	mov.w	r8, #39936	; 0x9c00
 8086b0a:	f2c0 17ff 	movt	r7, #511	; 0x1ff
 8086b0e:	f6cf 4800 	movt	r8, #64512	; 0xfc00
 8086b12:	432f      	orrs	r7, r5
 8086b14:	e003      	b.n	8086b1e <HAL_I2C_Mem_Read+0x112>
    while (hi2c->XferCount > 0U);
 8086b16:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8086b18:	b29b      	uxth	r3, r3
 8086b1a:	2b00      	cmp	r3, #0
 8086b1c:	d0c2      	beq.n	8086aa4 <HAL_I2C_Mem_Read+0x98>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8086b1e:	9600      	str	r6, [sp, #0]
 8086b20:	2200      	movs	r2, #0
 8086b22:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8086b24:	2104      	movs	r1, #4
 8086b26:	4620      	mov	r0, r4
 8086b28:	f7ff fccc 	bl	80864c4 <I2C_WaitOnFlagUntilTimeout>
 8086b2c:	2800      	cmp	r0, #0
 8086b2e:	d1c4      	bne.n	8086aba <HAL_I2C_Mem_Read+0xae>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 8086b30:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8086b32:	6822      	ldr	r2, [r4, #0]
 8086b34:	1c59      	adds	r1, r3, #1
 8086b36:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8086b38:	6261      	str	r1, [r4, #36]	; 0x24
 8086b3a:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
 8086b3c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8086b3e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8086b40:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8086b42:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8086b44:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8086b46:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8086b48:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8086b4a:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 8086b4c:	2a00      	cmp	r2, #0
 8086b4e:	d1e2      	bne.n	8086b16 <HAL_I2C_Mem_Read+0x10a>
 8086b50:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8086b52:	b29b      	uxth	r3, r3
 8086b54:	2b00      	cmp	r3, #0
 8086b56:	d0de      	beq.n	8086b16 <HAL_I2C_Mem_Read+0x10a>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8086b58:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8086b5a:	2180      	movs	r1, #128	; 0x80
 8086b5c:	9600      	str	r6, [sp, #0]
 8086b5e:	4620      	mov	r0, r4
 8086b60:	f7ff fcb0 	bl	80864c4 <I2C_WaitOnFlagUntilTimeout>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086b64:	f045 7300 	orr.w	r3, r5, #33554432	; 0x2000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8086b68:	f04f 0cff 	mov.w	ip, #255	; 0xff
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8086b6c:	2800      	cmp	r0, #0
 8086b6e:	d1a4      	bne.n	8086aba <HAL_I2C_Mem_Read+0xae>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8086b70:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 8086b72:	6822      	ldr	r2, [r4, #0]
 8086b74:	4561      	cmp	r1, ip
 8086b76:	d917      	bls.n	8086ba8 <HAL_I2C_Mem_Read+0x19c>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086b78:	6853      	ldr	r3, [r2, #4]
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8086b7a:	f8a4 c028 	strh.w	ip, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086b7e:	ea03 0308 	and.w	r3, r3, r8
 8086b82:	433b      	orrs	r3, r7
 8086b84:	6053      	str	r3, [r2, #4]
 8086b86:	e7c6      	b.n	8086b16 <HAL_I2C_Mem_Read+0x10a>
 8086b88:	f44f 4018 	mov.w	r0, #38912	; 0x9800
 8086b8c:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 8086b90:	6853      	ldr	r3, [r2, #4]
 8086b92:	f6cf 4000 	movt	r0, #64512	; 0xfc00
 8086b96:	f2c8 11ff 	movt	r1, #33279	; 0x81ff
 8086b9a:	4003      	ands	r3, r0
 8086b9c:	4329      	orrs	r1, r5
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8086b9e:	20ff      	movs	r0, #255	; 0xff
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086ba0:	430b      	orrs	r3, r1
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8086ba2:	8520      	strh	r0, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086ba4:	6053      	str	r3, [r2, #4]
 8086ba6:	e7ad      	b.n	8086b04 <HAL_I2C_Mem_Read+0xf8>
          hi2c->XferSize = hi2c->XferCount;
 8086ba8:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086baa:	6850      	ldr	r0, [r2, #4]
          hi2c->XferSize = hi2c->XferCount;
 8086bac:	b289      	uxth	r1, r1
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086bae:	ea00 0008 	and.w	r0, r0, r8
 8086bb2:	fa5f fc81 	uxtb.w	ip, r1
          hi2c->XferSize = hi2c->XferCount;
 8086bb6:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8086bb8:	4303      	orrs	r3, r0
 8086bba:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
 8086bbe:	6053      	str	r3, [r2, #4]
 8086bc0:	e7a9      	b.n	8086b16 <HAL_I2C_Mem_Read+0x10a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8086bc2:	6823      	ldr	r3, [r4, #0]
 8086bc4:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 8086bc6:	f44f 4568 	mov.w	r5, #59392	; 0xe800
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8086bca:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8086bcc:	f6cf 6500 	movt	r5, #65024	; 0xfe00
 8086bd0:	685a      	ldr	r2, [r3, #4]
 8086bd2:	402a      	ands	r2, r5
 8086bd4:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8086bd6:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8086bda:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8086bde:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8086be2:	e75c      	b.n	8086a9e <HAL_I2C_Mem_Read+0x92>

08086be4 <HAL_I2C_GetState>:
  return hi2c->State;
 8086be4:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
}
 8086be8:	4770      	bx	lr
 8086bea:	bf00      	nop

08086bec <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8086bec:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8086bf0:	b2db      	uxtb	r3, r3
 8086bf2:	2b20      	cmp	r3, #32
{
 8086bf4:	b470      	push	{r4, r5, r6}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8086bf6:	d11f      	bne.n	8086c38 <HAL_I2CEx_ConfigAnalogFilter+0x4c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8086bf8:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 8086bfc:	2a01      	cmp	r2, #1
 8086bfe:	d01b      	beq.n	8086c38 <HAL_I2CEx_ConfigAnalogFilter+0x4c>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8086c00:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8086c02:	2424      	movs	r4, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8086c04:	2600      	movs	r6, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
 8086c06:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 8086c0a:	6815      	ldr	r5, [r2, #0]

    return HAL_OK;
 8086c0c:	4634      	mov	r4, r6
    __HAL_I2C_DISABLE(hi2c);
 8086c0e:	f025 0501 	bic.w	r5, r5, #1
 8086c12:	6015      	str	r5, [r2, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8086c14:	6815      	ldr	r5, [r2, #0]
 8086c16:	f425 5580 	bic.w	r5, r5, #4096	; 0x1000
 8086c1a:	6015      	str	r5, [r2, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 8086c1c:	6815      	ldr	r5, [r2, #0]
 8086c1e:	4329      	orrs	r1, r5
 8086c20:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 8086c22:	6811      	ldr	r1, [r2, #0]
 8086c24:	f041 0101 	orr.w	r1, r1, #1
 8086c28:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 8086c2a:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 8086c2e:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  }
  else
  {
    return HAL_BUSY;
  }
}
 8086c32:	4620      	mov	r0, r4
 8086c34:	bc70      	pop	{r4, r5, r6}
 8086c36:	4770      	bx	lr
    return HAL_BUSY;
 8086c38:	2402      	movs	r4, #2
}
 8086c3a:	4620      	mov	r0, r4
 8086c3c:	bc70      	pop	{r4, r5, r6}
 8086c3e:	4770      	bx	lr

08086c40 <LTDC_SetConfig>:
  uint32_t tmp1 = 0;
  uint32_t tmp2 = 0;

  /* Configures the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8086c40:	01d2      	lsls	r2, r2, #7

  /* Configures the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
  tmp2 = (pLayerCfg->Alpha0 << 24);  
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8086c42:	f04f 0c00 	mov.w	ip, #0
{
 8086c46:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8086c4a:	3284      	adds	r2, #132	; 0x84
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8086c4c:	6804      	ldr	r4, [r0, #0]
 8086c4e:	6848      	ldr	r0, [r1, #4]
{
 8086c50:	b083      	sub	sp, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8086c52:	18a3      	adds	r3, r4, r2
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8086c54:	68e5      	ldr	r5, [r4, #12]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
 8086c56:	f8d1 800c 	ldr.w	r8, [r1, #12]
  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8086c5a:	f64f 07f8 	movw	r7, #63736	; 0xf8f8
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8086c5e:	f8d3 e004 	ldr.w	lr, [r3, #4]
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8086c62:	f3c5 450b 	ubfx	r5, r5, #16, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8086c66:	680e      	ldr	r6, [r1, #0]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8086c68:	f6cf 77ff 	movt	r7, #65535	; 0xffff
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8086c6c:	eb05 0a00 	add.w	sl, r5, r0
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8086c70:	f40e 4570 	and.w	r5, lr, #61440	; 0xf000
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8086c74:	9001      	str	r0, [sp, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8086c76:	f106 0b01 	add.w	fp, r6, #1
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
 8086c7a:	6888      	ldr	r0, [r1, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8086c7c:	605d      	str	r5, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8086c7e:	68e5      	ldr	r5, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
 8086c80:	f100 0901 	add.w	r9, r0, #1
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8086c84:	f8d1 e010 	ldr.w	lr, [r1, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8086c88:	f3c5 450b 	ubfx	r5, r5, #16, #12
 8086c8c:	445d      	add	r5, fp
  tmp2 = (pLayerCfg->Alpha0 << 24);  
 8086c8e:	f8d1 b018 	ldr.w	fp, [r1, #24]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8086c92:	ea45 450a 	orr.w	r5, r5, sl, lsl #16
 8086c96:	605d      	str	r5, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
 8086c98:	f8d4 a00c 	ldr.w	sl, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8086c9c:	689d      	ldr	r5, [r3, #8]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
 8086c9e:	f3ca 0a0a 	ubfx	sl, sl, #0, #11
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8086ca2:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
 8086ca6:	44c2      	add	sl, r8
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 8086ca8:	f8d1 8014 	ldr.w	r8, [r1, #20]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8086cac:	609d      	str	r5, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
 8086cae:	68e5      	ldr	r5, [r4, #12]
 8086cb0:	f3c5 050a 	ubfx	r5, r5, #0, #11
 8086cb4:	444d      	add	r5, r9
 8086cb6:	ea45 450a 	orr.w	r5, r5, sl, lsl #16
 8086cba:	609d      	str	r5, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 8086cbc:	691d      	ldr	r5, [r3, #16]
 8086cbe:	f025 0507 	bic.w	r5, r5, #7
 8086cc2:	611d      	str	r5, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8086cc4:	f8c3 e010 	str.w	lr, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8086cc8:	699d      	ldr	r5, [r3, #24]
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
 8086cca:	f891 a031 	ldrb.w	sl, [r1, #49]	; 0x31
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
 8086cce:	f891 9032 	ldrb.w	r9, [r1, #50]	; 0x32
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8086cd2:	f8c3 c018 	str.w	ip, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2); 
 8086cd6:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
 8086cda:	ea45 650b 	orr.w	r5, r5, fp, lsl #24
 8086cde:	ea45 250a 	orr.w	r5, r5, sl, lsl #8
 8086ce2:	ea45 4509 	orr.w	r5, r5, r9, lsl #16
 8086ce6:	619d      	str	r5, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 8086ce8:	695d      	ldr	r5, [r3, #20]
 8086cea:	f025 05ff 	bic.w	r5, r5, #255	; 0xff
 8086cee:	615d      	str	r5, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 8086cf0:	f8c3 8014 	str.w	r8, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8086cf4:	69dd      	ldr	r5, [r3, #28]
 8086cf6:	402f      	ands	r7, r5
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 8086cf8:	69cd      	ldr	r5, [r1, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8086cfa:	61df      	str	r7, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 8086cfc:	e9d1 0708 	ldrd	r0, r7, [r1, #32]
 8086d00:	4305      	orrs	r5, r0
 8086d02:	61dd      	str	r5, [r3, #28]

  /* Configures the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8086d04:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8086d06:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8086d0a:	629f      	str	r7, [r3, #40]	; 0x28

  if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 8086d0c:	f1be 0f00 	cmp.w	lr, #0
 8086d10:	d029      	beq.n	8086d66 <LTDC_SetConfig+0x126>
  {
    tmp = 4;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 8086d12:	f1be 0f01 	cmp.w	lr, #1
 8086d16:	d028      	beq.n	8086d6a <LTDC_SetConfig+0x12a>
  {
    tmp = 3;
  }
  else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8086d18:	f1ae 0502 	sub.w	r5, lr, #2
    (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
      (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 8086d1c:	2d02      	cmp	r5, #2
 8086d1e:	d902      	bls.n	8086d26 <LTDC_SetConfig+0xe6>
 8086d20:	f1be 0f07 	cmp.w	lr, #7
 8086d24:	d123      	bne.n	8086d6e <LTDC_SetConfig+0x12e>
        (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
  {
    tmp = 2;
 8086d26:	2502      	movs	r5, #2
    tmp = 1;
  }

  /* Configures the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 8086d28:	9801      	ldr	r0, [sp, #4]
 8086d2a:	1b80      	subs	r0, r0, r6

  /* Configures the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8086d2c:	e9d1 670a 	ldrd	r6, r7, [r1, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 8086d30:	fb05 f000 	mul.w	r0, r5, r0
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8086d34:	f44f 4178 	mov.w	r1, #63488	; 0xf800
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 8086d38:	fb06 f605 	mul.w	r6, r6, r5
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8086d3c:	6add      	ldr	r5, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 8086d3e:	3003      	adds	r0, #3
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8086d40:	f6cf 71ff 	movt	r1, #65535	; 0xffff
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8086d44:	f005 25e0 	and.w	r5, r5, #3758153728	; 0xe000e000
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 8086d48:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 8086d4c:	62dd      	str	r5, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
 8086d4e:	62d8      	str	r0, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 8086d50:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8086d52:	4001      	ands	r1, r0
 8086d54:	6319      	str	r1, [r3, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8086d56:	631f      	str	r7, [r3, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */  
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 8086d58:	58a3      	ldr	r3, [r4, r2]
 8086d5a:	f043 0301 	orr.w	r3, r3, #1
 8086d5e:	50a3      	str	r3, [r4, r2]
}
 8086d60:	b003      	add	sp, #12
 8086d62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    tmp = 4;
 8086d66:	2504      	movs	r5, #4
 8086d68:	e7de      	b.n	8086d28 <LTDC_SetConfig+0xe8>
    tmp = 3;
 8086d6a:	2503      	movs	r5, #3
 8086d6c:	e7dc      	b.n	8086d28 <LTDC_SetConfig+0xe8>
    tmp = 1;
 8086d6e:	2501      	movs	r5, #1
 8086d70:	e7da      	b.n	8086d28 <LTDC_SetConfig+0xe8>
 8086d72:	bf00      	nop

08086d74 <HAL_LTDC_MspInit>:
}
 8086d74:	4770      	bx	lr
 8086d76:	bf00      	nop

08086d78 <HAL_LTDC_Init>:
  if(hltdc == NULL)
 8086d78:	2800      	cmp	r0, #0
 8086d7a:	d074      	beq.n	8086e66 <HAL_LTDC_Init+0xee>
{
 8086d7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hltdc->State == HAL_LTDC_STATE_RESET)
 8086d7e:	f890 30a1 	ldrb.w	r3, [r0, #161]	; 0xa1
 8086d82:	4604      	mov	r4, r0
 8086d84:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8086d88:	2b00      	cmp	r3, #0
 8086d8a:	d067      	beq.n	8086e5c <HAL_LTDC_Init+0xe4>
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8086d8c:	68a6      	ldr	r6, [r4, #8]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086d8e:	2502      	movs	r5, #2
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8086d90:	f44f 4078 	mov.w	r0, #63488	; 0xf800
  tmp = (hltdc->Init.HorizontalSync << 16);
 8086d94:	6967      	ldr	r7, [r4, #20]
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086d96:	f884 50a1 	strb.w	r5, [r4, #161]	; 0xa1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 8086d9a:	2100      	movs	r1, #0
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8086d9c:	f8d4 c018 	ldr.w	ip, [r4, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8086da0:	f2cf 0000 	movt	r0, #61440	; 0xf000
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8086da4:	e9d4 3200 	ldrd	r3, r2, [r4]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8086da8:	699d      	ldr	r5, [r3, #24]
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8086daa:	4332      	orrs	r2, r6
 8086dac:	68e6      	ldr	r6, [r4, #12]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8086dae:	f025 4570 	bic.w	r5, r5, #4026531840	; 0xf0000000
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8086db2:	4332      	orrs	r2, r6
  hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8086db4:	6926      	ldr	r6, [r4, #16]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8086db6:	619d      	str	r5, [r3, #24]
  hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8086db8:	4332      	orrs	r2, r6
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8086dba:	699d      	ldr	r5, [r3, #24]
  hltdc->State = HAL_LTDC_STATE_READY;
 8086dbc:	2601      	movs	r6, #1
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8086dbe:	432a      	orrs	r2, r5
 8086dc0:	619a      	str	r2, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8086dc2:	689a      	ldr	r2, [r3, #8]
 8086dc4:	4002      	ands	r2, r0
 8086dc6:	609a      	str	r2, [r3, #8]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8086dc8:	689d      	ldr	r5, [r3, #8]
 8086dca:	ea45 4507 	orr.w	r5, r5, r7, lsl #16
  tmp = (hltdc->Init.AccumulatedHBP << 16);
 8086dce:	69e7      	ldr	r7, [r4, #28]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8086dd0:	ea45 050c 	orr.w	r5, r5, ip
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8086dd4:	f8d4 c020 	ldr.w	ip, [r4, #32]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8086dd8:	609d      	str	r5, [r3, #8]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 8086dda:	68dd      	ldr	r5, [r3, #12]
 8086ddc:	4005      	ands	r5, r0
 8086dde:	60dd      	str	r5, [r3, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8086de0:	68da      	ldr	r2, [r3, #12]
 8086de2:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
  tmp = (hltdc->Init.AccumulatedActiveW << 16);
 8086de6:	6a67      	ldr	r7, [r4, #36]	; 0x24
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8086de8:	ea42 020c 	orr.w	r2, r2, ip
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8086dec:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8086df0:	60da      	str	r2, [r3, #12]
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8086df2:	691a      	ldr	r2, [r3, #16]
 8086df4:	4002      	ands	r2, r0
 8086df6:	611a      	str	r2, [r3, #16]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8086df8:	691d      	ldr	r5, [r3, #16]
 8086dfa:	ea45 4507 	orr.w	r5, r5, r7, lsl #16
  tmp = (hltdc->Init.TotalWidth << 16);
 8086dfe:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8086e00:	ea45 050c 	orr.w	r5, r5, ip
 8086e04:	611d      	str	r5, [r3, #16]
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 8086e06:	695d      	ldr	r5, [r3, #20]
 8086e08:	4028      	ands	r0, r5
 8086e0a:	6158      	str	r0, [r3, #20]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 8086e0c:	695a      	ldr	r2, [r3, #20]
 8086e0e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8086e10:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8086e14:	4302      	orrs	r2, r0
 8086e16:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8086e18:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8);
 8086e1a:	f894 7035 	ldrb.w	r7, [r4, #53]	; 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8086e1e:	f000 407f 	and.w	r0, r0, #4278190080	; 0xff000000
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16);
 8086e22:	f894 5036 	ldrb.w	r5, [r4, #54]	; 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8086e26:	62d8      	str	r0, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8086e28:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8086e2a:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8086e2e:	4302      	orrs	r2, r0
  return HAL_OK;
 8086e30:	4608      	mov	r0, r1
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8086e32:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8086e36:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
 8086e3a:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE);
 8086e3c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8086e3e:	f042 0204 	orr.w	r2, r2, #4
 8086e42:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_FU);
 8086e44:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8086e46:	f042 0202 	orr.w	r2, r2, #2
 8086e4a:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE(hltdc);
 8086e4c:	699a      	ldr	r2, [r3, #24]
 8086e4e:	4332      	orrs	r2, r6
 8086e50:	619a      	str	r2, [r3, #24]
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 8086e52:	f8c4 10a4 	str.w	r1, [r4, #164]	; 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
 8086e56:	f884 60a1 	strb.w	r6, [r4, #161]	; 0xa1
}
 8086e5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hltdc->Lock = HAL_UNLOCKED;
 8086e5c:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
    HAL_LTDC_MspInit(hltdc);
 8086e60:	f7ff ff88 	bl	8086d74 <HAL_LTDC_MspInit>
 8086e64:	e792      	b.n	8086d8c <HAL_LTDC_Init+0x14>
    return HAL_ERROR;
 8086e66:	2001      	movs	r0, #1
}
 8086e68:	4770      	bx	lr
 8086e6a:	bf00      	nop

08086e6c <HAL_LTDC_ConfigLayer>:
  __HAL_LOCK(hltdc);
 8086e6c:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8086e70:	2b01      	cmp	r3, #1
 8086e72:	d028      	beq.n	8086ec6 <HAL_LTDC_ConfigLayer+0x5a>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086e74:	2302      	movs	r3, #2
 8086e76:	4694      	mov	ip, r2
{   
 8086e78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8086e7c:	2434      	movs	r4, #52	; 0x34
  __HAL_LOCK(hltdc);
 8086e7e:	f04f 0801 	mov.w	r8, #1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8086e82:	460d      	mov	r5, r1
 8086e84:	4606      	mov	r6, r0
 8086e86:	fb04 0402 	mla	r4, r4, r2, r0
 8086e8a:	460f      	mov	r7, r1
  __HAL_LOCK(hltdc);
 8086e8c:	f880 80a0 	strb.w	r8, [r0, #160]	; 0xa0
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086e90:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8086e94:	3438      	adds	r4, #56	; 0x38
 8086e96:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8086e98:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8086e9a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8086e9c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8086e9e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8086ea0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8086ea2:	682b      	ldr	r3, [r5, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8086ea4:	4662      	mov	r2, ip
 8086ea6:	4630      	mov	r0, r6
 8086ea8:	4639      	mov	r1, r7
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8086eaa:	6023      	str	r3, [r4, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8086eac:	f7ff fec8 	bl	8086c40 <LTDC_SetConfig>
  __HAL_UNLOCK(hltdc);
 8086eb0:	2300      	movs	r3, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8086eb2:	6832      	ldr	r2, [r6, #0]
  return HAL_OK;
 8086eb4:	4618      	mov	r0, r3
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8086eb6:	f8c2 8024 	str.w	r8, [r2, #36]	; 0x24
  hltdc->State  = HAL_LTDC_STATE_READY;
 8086eba:	f886 80a1 	strb.w	r8, [r6, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8086ebe:	f886 30a0 	strb.w	r3, [r6, #160]	; 0xa0
}
 8086ec2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(hltdc);
 8086ec6:	2002      	movs	r0, #2
}
 8086ec8:	4770      	bx	lr
 8086eca:	bf00      	nop

08086ecc <HAL_LTDC_ConfigColorKeying>:
{
 8086ecc:	4603      	mov	r3, r0
  __HAL_LOCK(hltdc);
 8086ece:	f890 00a0 	ldrb.w	r0, [r0, #160]	; 0xa0
 8086ed2:	2801      	cmp	r0, #1
 8086ed4:	d018      	beq.n	8086f08 <HAL_LTDC_ConfigColorKeying+0x3c>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086ed6:	2002      	movs	r0, #2
{
 8086ed8:	b470      	push	{r4, r5, r6}
  LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
 8086eda:	681e      	ldr	r6, [r3, #0]
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8086edc:	2501      	movs	r5, #1
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086ede:	f883 00a1 	strb.w	r0, [r3, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8086ee2:	2400      	movs	r4, #0
  LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
 8086ee4:	eb06 12c2 	add.w	r2, r6, r2, lsl #7
 8086ee8:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
 8086eec:	f000 407f 	and.w	r0, r0, #4278190080	; 0xff000000
 8086ef0:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  return HAL_OK;
 8086ef4:	4620      	mov	r0, r4
  LTDC_LAYER(hltdc, LayerIdx)->CKCR  = RGBValue;
 8086ef6:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8086efa:	6275      	str	r5, [r6, #36]	; 0x24
  hltdc->State = HAL_LTDC_STATE_READY;
 8086efc:	f883 50a1 	strb.w	r5, [r3, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8086f00:	f883 40a0 	strb.w	r4, [r3, #160]	; 0xa0
}
 8086f04:	bc70      	pop	{r4, r5, r6}
 8086f06:	4770      	bx	lr
  __HAL_LOCK(hltdc);
 8086f08:	2002      	movs	r0, #2
}
 8086f0a:	4770      	bx	lr

08086f0c <HAL_LTDC_EnableColorKeying>:
  __HAL_LOCK(hltdc);
 8086f0c:	f890 20a0 	ldrb.w	r2, [r0, #160]	; 0xa0
 8086f10:	2a01      	cmp	r2, #1
 8086f12:	d014      	beq.n	8086f3e <HAL_LTDC_EnableColorKeying+0x32>
 8086f14:	4603      	mov	r3, r0
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
 8086f16:	01c9      	lsls	r1, r1, #7
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086f18:	2002      	movs	r0, #2
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
 8086f1a:	681a      	ldr	r2, [r3, #0]
 8086f1c:	3184      	adds	r1, #132	; 0x84
{  
 8086f1e:	b470      	push	{r4, r5, r6}
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8086f20:	f883 00a1 	strb.w	r0, [r3, #161]	; 0xa1
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8086f24:	2601      	movs	r6, #1
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
 8086f26:	5854      	ldr	r4, [r2, r1]
  __HAL_UNLOCK(hltdc);
 8086f28:	2500      	movs	r5, #0
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
 8086f2a:	4304      	orrs	r4, r0
  return HAL_OK;  
 8086f2c:	4628      	mov	r0, r5
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
 8086f2e:	5054      	str	r4, [r2, r1]
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8086f30:	6256      	str	r6, [r2, #36]	; 0x24
  hltdc->State = HAL_LTDC_STATE_READY; 
 8086f32:	f883 60a1 	strb.w	r6, [r3, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8086f36:	f883 50a0 	strb.w	r5, [r3, #160]	; 0xa0
}
 8086f3a:	bc70      	pop	{r4, r5, r6}
 8086f3c:	4770      	bx	lr
  __HAL_LOCK(hltdc);
 8086f3e:	2002      	movs	r0, #2
}
 8086f40:	4770      	bx	lr
 8086f42:	bf00      	nop

08086f44 <HAL_LTDC_GetState>:
  return hltdc->State;
 8086f44:	f890 00a1 	ldrb.w	r0, [r0, #161]	; 0xa1
}
 8086f48:	4770      	bx	lr
 8086f4a:	bf00      	nop

08086f4c <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8086f4c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8086f50:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
  __HAL_RCC_PWR_CLK_ENABLE();
 8086f54:	f2c4 0202 	movt	r2, #16386	; 0x4002
  __HAL_PWR_OVERDRIVE_ENABLE();
 8086f58:	f2c4 0300 	movt	r3, #16384	; 0x4000
  __HAL_RCC_PWR_CLK_ENABLE();
 8086f5c:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8086f5e:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
{
 8086f62:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8086f64:	6411      	str	r1, [r2, #64]	; 0x40
{
 8086f66:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 8086f68:	6c12      	ldr	r2, [r2, #64]	; 0x40

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8086f6a:	461c      	mov	r4, r3
  __HAL_RCC_PWR_CLK_ENABLE();
 8086f6c:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8086f70:	9201      	str	r2, [sp, #4]
 8086f72:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 8086f74:	681a      	ldr	r2, [r3, #0]
 8086f76:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8086f7a:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8086f7c:	f7fe fc18 	bl	80857b0 <HAL_GetTick>
 8086f80:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8086f82:	e005      	b.n	8086f90 <HAL_PWREx_EnableOverDrive+0x44>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8086f84:	f7fe fc14 	bl	80857b0 <HAL_GetTick>
 8086f88:	1b40      	subs	r0, r0, r5
 8086f8a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8086f8e:	d81a      	bhi.n	8086fc6 <HAL_PWREx_EnableOverDrive+0x7a>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8086f90:	6863      	ldr	r3, [r4, #4]
 8086f92:	03da      	lsls	r2, r3, #15
 8086f94:	d5f6      	bpl.n	8086f84 <HAL_PWREx_EnableOverDrive+0x38>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8086f96:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8086f98:	f44f 45e0 	mov.w	r5, #28672	; 0x7000
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8086f9c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8086fa0:	f2c4 0500 	movt	r5, #16384	; 0x4000
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8086fa4:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
 8086fa6:	f7fe fc03 	bl	80857b0 <HAL_GetTick>
 8086faa:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8086fac:	e005      	b.n	8086fba <HAL_PWREx_EnableOverDrive+0x6e>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8086fae:	f7fe fbff 	bl	80857b0 <HAL_GetTick>
 8086fb2:	1b00      	subs	r0, r0, r4
 8086fb4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8086fb8:	d805      	bhi.n	8086fc6 <HAL_PWREx_EnableOverDrive+0x7a>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8086fba:	686b      	ldr	r3, [r5, #4]
 8086fbc:	039b      	lsls	r3, r3, #14
 8086fbe:	d5f6      	bpl.n	8086fae <HAL_PWREx_EnableOverDrive+0x62>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8086fc0:	2000      	movs	r0, #0
}
 8086fc2:	b003      	add	sp, #12
 8086fc4:	bd30      	pop	{r4, r5, pc}
      return HAL_TIMEOUT;
 8086fc6:	2003      	movs	r0, #3
}
 8086fc8:	b003      	add	sp, #12
 8086fca:	bd30      	pop	{r4, r5, pc}

08086fcc <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
 8086fcc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
 8086fd0:	6a4c      	ldr	r4, [r1, #36]	; 0x24
 8086fd2:	b114      	cbz	r4, 8086fda <QSPI_Config+0xe>
 8086fd4:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
 8086fd8:	d15a      	bne.n	8087090 <QSPI_Config+0xc4>
 8086fda:	f101 0318 	add.w	r3, r1, #24
 8086fde:	e893 1208 	ldmia.w	r3, {r3, r9, ip}
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1));
  }
      
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
 8086fe2:	b37b      	cbz	r3, 8087044 <QSPI_Config+0x78>
 8086fe4:	431c      	orrs	r4, r3
 8086fe6:	694e      	ldr	r6, [r1, #20]
 8086fe8:	6805      	ldr	r5, [r0, #0]
 8086fea:	ea44 0302 	orr.w	r3, r4, r2
 8086fee:	04b6      	lsls	r6, r6, #18
 8086ff0:	6808      	ldr	r0, [r1, #0]
 8086ff2:	6b4f      	ldr	r7, [r1, #52]	; 0x34
 8086ff4:	e9d1 840b 	ldrd	r8, r4, [r1, #44]	; 0x2c
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
 8086ff8:	f1bc 0f00 	cmp.w	ip, #0
 8086ffc:	d06b      	beq.n	80870d6 <QSPI_Config+0x10a>
 8086ffe:	ea4c 0c03 	orr.w	ip, ip, r3
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8087002:	688b      	ldr	r3, [r1, #8]
 8087004:	f8d1 e010 	ldr.w	lr, [r1, #16]
 8087008:	61eb      	str	r3, [r5, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 808700a:	f1b9 0f00 	cmp.w	r9, #0
 808700e:	f000 8088 	beq.w	8087122 <QSPI_Config+0x156>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8087012:	ea49 0000 	orr.w	r0, r9, r0
                                         cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateBytesSize |
                                         cmd->AlternateByteMode | cmd->AddressSize | cmd->AddressMode |
                                         cmd->InstructionMode | cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8087016:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 808701a:	ea40 0008 	orr.w	r0, r0, r8
 808701e:	ea40 0004 	orr.w	r0, r0, r4
 8087022:	ea40 0007 	orr.w	r0, r0, r7
 8087026:	ea4e 0300 	orr.w	r3, lr, r0
 808702a:	68c8      	ldr	r0, [r1, #12]
 808702c:	ea43 0300 	orr.w	r3, r3, r0
 8087030:	ea43 0306 	orr.w	r3, r3, r6
 8087034:	ea43 030c 	orr.w	r3, r3, ip
 8087038:	616b      	str	r3, [r5, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 808703a:	d001      	beq.n	8087040 <QSPI_Config+0x74>
                                         cmd->InstructionMode | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
 808703c:	684b      	ldr	r3, [r1, #4]
 808703e:	61ab      	str	r3, [r5, #24]
                                           cmd->AddressMode | cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
 8087040:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
 8087044:	f1bc 0f00 	cmp.w	ip, #0
 8087048:	d027      	beq.n	808709a <QSPI_Config+0xce>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 808704a:	6805      	ldr	r5, [r0, #0]
 808704c:	ea44 040c 	orr.w	r4, r4, ip
 8087050:	6888      	ldr	r0, [r1, #8]
 8087052:	694f      	ldr	r7, [r1, #20]
 8087054:	4314      	orrs	r4, r2
 8087056:	61e8      	str	r0, [r5, #28]
 8087058:	04bf      	lsls	r7, r7, #18
 808705a:	6908      	ldr	r0, [r1, #16]
 808705c:	6b4e      	ldr	r6, [r1, #52]	; 0x34
 808705e:	e9d1 3e0b 	ldrd	r3, lr, [r1, #44]	; 0x2c
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8087062:	f1b9 0f00 	cmp.w	r9, #0
 8087066:	d071      	beq.n	808714c <QSPI_Config+0x180>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8087068:	ea40 0009 	orr.w	r0, r0, r9
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 808706c:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8087070:	ea43 0300 	orr.w	r3, r3, r0
 8087074:	68c8      	ldr	r0, [r1, #12]
 8087076:	ea43 030e 	orr.w	r3, r3, lr
 808707a:	ea43 0306 	orr.w	r3, r3, r6
 808707e:	ea43 0300 	orr.w	r3, r3, r0
 8087082:	ea43 0307 	orr.w	r3, r3, r7
 8087086:	ea44 0403 	orr.w	r4, r4, r3
 808708a:	616c      	str	r4, [r5, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 808708c:	d1d6      	bne.n	808703c <QSPI_Config+0x70>
 808708e:	e7d7      	b.n	8087040 <QSPI_Config+0x74>
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1));
 8087090:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8087092:	6805      	ldr	r5, [r0, #0]
 8087094:	3b01      	subs	r3, #1
 8087096:	612b      	str	r3, [r5, #16]
 8087098:	e79f      	b.n	8086fda <QSPI_Config+0xe>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 808709a:	f1b9 0f00 	cmp.w	r9, #0
 808709e:	d031      	beq.n	8087104 <QSPI_Config+0x138>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 80870a0:	ea44 0309 	orr.w	r3, r4, r9
 80870a4:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 80870a6:	6b0d      	ldr	r5, [r1, #48]	; 0x30
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 80870a8:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 80870ac:	ea43 0302 	orr.w	r3, r3, r2
 80870b0:	6800      	ldr	r0, [r0, #0]
 80870b2:	ea43 0304 	orr.w	r3, r3, r4
 80870b6:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 80870b8:	ea43 0305 	orr.w	r3, r3, r5
 80870bc:	68cd      	ldr	r5, [r1, #12]
 80870be:	ea43 0304 	orr.w	r3, r3, r4
 80870c2:	694c      	ldr	r4, [r1, #20]
 80870c4:	ea43 0305 	orr.w	r3, r3, r5
 80870c8:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
 80870cc:	6143      	str	r3, [r0, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 80870ce:	d0b7      	beq.n	8087040 <QSPI_Config+0x74>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
 80870d0:	684b      	ldr	r3, [r1, #4]
 80870d2:	6183      	str	r3, [r0, #24]
 80870d4:	e7b4      	b.n	8087040 <QSPI_Config+0x74>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 80870d6:	f1b9 0f00 	cmp.w	r9, #0
 80870da:	d02e      	beq.n	808713a <QSPI_Config+0x16e>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 80870dc:	ea49 0000 	orr.w	r0, r9, r0
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 80870e0:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 80870e4:	ea40 0008 	orr.w	r0, r0, r8
 80870e8:	ea40 0004 	orr.w	r0, r0, r4
 80870ec:	68cc      	ldr	r4, [r1, #12]
 80870ee:	ea40 0007 	orr.w	r0, r0, r7
 80870f2:	ea40 0004 	orr.w	r0, r0, r4
 80870f6:	ea40 0006 	orr.w	r0, r0, r6
 80870fa:	ea43 0300 	orr.w	r3, r3, r0
 80870fe:	616b      	str	r3, [r5, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8087100:	d19c      	bne.n	808703c <QSPI_Config+0x70>
 8087102:	e79d      	b.n	8087040 <QSPI_Config+0x74>
        if (cmd->DataMode != QSPI_DATA_NONE)
 8087104:	2c00      	cmp	r4, #0
 8087106:	d09b      	beq.n	8087040 <QSPI_Config+0x74>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8087108:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 808710a:	6800      	ldr	r0, [r0, #0]
 808710c:	431c      	orrs	r4, r3
 808710e:	e9d1 350c 	ldrd	r3, r5, [r1, #48]	; 0x30
 8087112:	4322      	orrs	r2, r4
 8087114:	6949      	ldr	r1, [r1, #20]
 8087116:	4313      	orrs	r3, r2
 8087118:	432b      	orrs	r3, r5
 808711a:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 808711e:	6143      	str	r3, [r0, #20]
}
 8087120:	e78e      	b.n	8087040 <QSPI_Config+0x74>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8087122:	ea40 0008 	orr.w	r0, r0, r8
 8087126:	4320      	orrs	r0, r4
 8087128:	4338      	orrs	r0, r7
 808712a:	ea4e 0300 	orr.w	r3, lr, r0
 808712e:	4333      	orrs	r3, r6
 8087130:	ea43 030c 	orr.w	r3, r3, ip
 8087134:	616b      	str	r3, [r5, #20]
}
 8087136:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 808713a:	ea40 0008 	orr.w	r0, r0, r8
 808713e:	4320      	orrs	r0, r4
 8087140:	4338      	orrs	r0, r7
 8087142:	4330      	orrs	r0, r6
 8087144:	4303      	orrs	r3, r0
 8087146:	616b      	str	r3, [r5, #20]
}
 8087148:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 808714c:	4318      	orrs	r0, r3
 808714e:	ea40 030e 	orr.w	r3, r0, lr
 8087152:	4333      	orrs	r3, r6
 8087154:	433b      	orrs	r3, r7
 8087156:	431c      	orrs	r4, r3
 8087158:	616c      	str	r4, [r5, #20]
}
 808715a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 808715e:	bf00      	nop

08087160 <QSPI_WaitFlagStateUntilTimeout>:
{
 8087160:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8087164:	9d08      	ldr	r5, [sp, #32]
 8087166:	4680      	mov	r8, r0
 8087168:	460f      	mov	r7, r1
 808716a:	4616      	mov	r6, r2
 808716c:	4699      	mov	r9, r3
  while((FlagStatus)(__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 808716e:	f8d8 4000 	ldr.w	r4, [r8]
 8087172:	e001      	b.n	8087178 <QSPI_WaitFlagStateUntilTimeout+0x18>
    if (Timeout != HAL_MAX_DELAY)
 8087174:	1c6b      	adds	r3, r5, #1
 8087176:	d109      	bne.n	808718c <QSPI_WaitFlagStateUntilTimeout+0x2c>
  while((FlagStatus)(__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8087178:	68a0      	ldr	r0, [r4, #8]
 808717a:	4238      	tst	r0, r7
 808717c:	bf14      	ite	ne
 808717e:	2001      	movne	r0, #1
 8087180:	2000      	moveq	r0, #0
 8087182:	42b0      	cmp	r0, r6
 8087184:	d1f6      	bne.n	8087174 <QSPI_WaitFlagStateUntilTimeout+0x14>
  return HAL_OK;
 8087186:	2000      	movs	r0, #0
}
 8087188:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
 808718c:	b12d      	cbz	r5, 808719a <QSPI_WaitFlagStateUntilTimeout+0x3a>
 808718e:	f7fe fb0f 	bl	80857b0 <HAL_GetTick>
 8087192:	eba0 0009 	sub.w	r0, r0, r9
 8087196:	42a8      	cmp	r0, r5
 8087198:	d9e9      	bls.n	808716e <QSPI_WaitFlagStateUntilTimeout+0xe>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 808719a:	2304      	movs	r3, #4
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 808719c:	2001      	movs	r0, #1
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 808719e:	f888 3041 	strb.w	r3, [r8, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80871a2:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 80871a6:	4303      	orrs	r3, r0
 80871a8:	f8c8 3044 	str.w	r3, [r8, #68]	; 0x44
 80871ac:	e7ec      	b.n	8087188 <QSPI_WaitFlagStateUntilTimeout+0x28>
 80871ae:	bf00      	nop

080871b0 <HAL_QSPI_MspInit>:
}
 80871b0:	4770      	bx	lr
 80871b2:	bf00      	nop

080871b4 <HAL_QSPI_Init>:
{
 80871b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80871b6:	4604      	mov	r4, r0
 80871b8:	b083      	sub	sp, #12
  uint32_t tickstart = HAL_GetTick();
 80871ba:	f7fe faf9 	bl	80857b0 <HAL_GetTick>
  if(hqspi == NULL)
 80871be:	2c00      	cmp	r4, #0
 80871c0:	d04b      	beq.n	808725a <HAL_QSPI_Init+0xa6>
  __HAL_LOCK(hqspi);
 80871c2:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80871c6:	2b01      	cmp	r3, #1
 80871c8:	d054      	beq.n	8087274 <HAL_QSPI_Init+0xc0>
 80871ca:	2301      	movs	r3, #1
 80871cc:	4605      	mov	r5, r0
 80871ce:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_RESET)
 80871d2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80871d6:	f002 03ff 	and.w	r3, r2, #255	; 0xff
 80871da:	2a00      	cmp	r2, #0
 80871dc:	d040      	beq.n	8087260 <HAL_QSPI_Init+0xac>
 80871de:	6ca7      	ldr	r7, [r4, #72]	; 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1) << 8));
 80871e0:	6826      	ldr	r6, [r4, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80871e2:	462b      	mov	r3, r5
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1) << 8));
 80871e4:	68a1      	ldr	r1, [r4, #8]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80871e6:	2200      	movs	r2, #0
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1) << 8));
 80871e8:	6835      	ldr	r5, [r6, #0]
 80871ea:	1e48      	subs	r0, r1, #1
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80871ec:	2120      	movs	r1, #32
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1) << 8));
 80871ee:	f425 55f8 	bic.w	r5, r5, #7936	; 0x1f00
 80871f2:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80871f6:	4620      	mov	r0, r4
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1) << 8));
 80871f8:	6035      	str	r5, [r6, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80871fa:	9700      	str	r7, [sp, #0]
 80871fc:	f7ff ffb0 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
  if(status == HAL_OK)
 8087200:	bb30      	cbnz	r0, 8087250 <HAL_QSPI_Init+0x9c>
    MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
 8087202:	69e1      	ldr	r1, [r4, #28]
 8087204:	f64f 762f 	movw	r6, #65327	; 0xff2f
 8087208:	68e3      	ldr	r3, [r4, #12]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
 808720a:	f64f 05fe 	movw	r5, #63742	; 0xf8fe
    MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
 808720e:	6a22      	ldr	r2, [r4, #32]
 8087210:	f2c0 06ff 	movt	r6, #255	; 0xff
 8087214:	430b      	orrs	r3, r1
 8087216:	6821      	ldr	r1, [r4, #0]
 8087218:	6867      	ldr	r7, [r4, #4]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
 808721a:	f6cf 75e0 	movt	r5, #65504	; 0xffe0
    MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
 808721e:	4313      	orrs	r3, r2
 8087220:	680a      	ldr	r2, [r1, #0]
 8087222:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 8087226:	4016      	ands	r6, r2
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
 8087228:	6962      	ldr	r2, [r4, #20]
    MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
 808722a:	4333      	orrs	r3, r6
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
 808722c:	69a6      	ldr	r6, [r4, #24]
    MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
 808722e:	600b      	str	r3, [r1, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
 8087230:	ea42 0306 	orr.w	r3, r2, r6
 8087234:	684f      	ldr	r7, [r1, #4]
    hqspi->State = HAL_QSPI_STATE_READY;
 8087236:	2201      	movs	r2, #1
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
 8087238:	6926      	ldr	r6, [r4, #16]
 808723a:	403d      	ands	r5, r7
 808723c:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8087240:	432b      	orrs	r3, r5
 8087242:	604b      	str	r3, [r1, #4]
    __HAL_QSPI_ENABLE(hqspi);
 8087244:	680b      	ldr	r3, [r1, #0]
 8087246:	4313      	orrs	r3, r2
 8087248:	600b      	str	r3, [r1, #0]
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;  
 808724a:	6460      	str	r0, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
 808724c:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 8087250:	2300      	movs	r3, #0
 8087252:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 8087256:	b003      	add	sp, #12
 8087258:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_ERROR;
 808725a:	2001      	movs	r0, #1
}
 808725c:	b003      	add	sp, #12
 808725e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hqspi->Lock = HAL_UNLOCKED;
 8087260:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_QSPI_MspInit(hqspi);
 8087264:	4620      	mov	r0, r4
 8087266:	f7ff ffa3 	bl	80871b0 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
 808726a:	f241 3388 	movw	r3, #5000	; 0x1388
 808726e:	461f      	mov	r7, r3
 8087270:	64a3      	str	r3, [r4, #72]	; 0x48
 8087272:	e7b5      	b.n	80871e0 <HAL_QSPI_Init+0x2c>
  __HAL_LOCK(hqspi);
 8087274:	2002      	movs	r0, #2
}
 8087276:	b003      	add	sp, #12
 8087278:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808727a:	bf00      	nop

0808727c <HAL_QSPI_MspDeInit>:
 808727c:	4770      	bx	lr
 808727e:	bf00      	nop

08087280 <HAL_QSPI_DeInit>:
  if(hqspi == NULL)
 8087280:	b1c8      	cbz	r0, 80872b6 <HAL_QSPI_DeInit+0x36>
  __HAL_LOCK(hqspi);
 8087282:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8087286:	2b01      	cmp	r3, #1
{
 8087288:	b510      	push	{r4, lr}
 808728a:	4604      	mov	r4, r0
  __HAL_LOCK(hqspi);
 808728c:	d011      	beq.n	80872b2 <HAL_QSPI_DeInit+0x32>
  __HAL_QSPI_DISABLE(hqspi);
 808728e:	6802      	ldr	r2, [r0, #0]
  __HAL_LOCK(hqspi);
 8087290:	2301      	movs	r3, #1
 8087292:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  __HAL_QSPI_DISABLE(hqspi);
 8087296:	6813      	ldr	r3, [r2, #0]
 8087298:	f023 0301 	bic.w	r3, r3, #1
 808729c:	6013      	str	r3, [r2, #0]
  HAL_QSPI_MspDeInit(hqspi);
 808729e:	f7ff ffed 	bl	808727c <HAL_QSPI_MspDeInit>
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80872a2:	2300      	movs	r3, #0
 80872a4:	6463      	str	r3, [r4, #68]	; 0x44
  return HAL_OK;
 80872a6:	4618      	mov	r0, r3
  hqspi->State = HAL_QSPI_STATE_RESET;
 80872a8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 80872ac:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 80872b0:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hqspi);
 80872b2:	2002      	movs	r0, #2
}
 80872b4:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80872b6:	2001      	movs	r0, #1
}
 80872b8:	4770      	bx	lr
 80872ba:	bf00      	nop

080872bc <HAL_QSPI_Command>:
{
 80872bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80872c0:	4604      	mov	r4, r0
 80872c2:	b082      	sub	sp, #8
 80872c4:	4689      	mov	r9, r1
 80872c6:	4690      	mov	r8, r2
  uint32_t tickstart = HAL_GetTick();
 80872c8:	f7fe fa72 	bl	80857b0 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 80872cc:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80872d0:	2b01      	cmp	r3, #1
 80872d2:	d00f      	beq.n	80872f4 <HAL_QSPI_Command+0x38>
 80872d4:	2301      	movs	r3, #1
 80872d6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 80872da:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
 80872de:	b2ed      	uxtb	r5, r5
 80872e0:	429d      	cmp	r5, r3
 80872e2:	d00c      	beq.n	80872fe <HAL_QSPI_Command+0x42>
    status = HAL_BUSY;   
 80872e4:	2602      	movs	r6, #2
  __HAL_UNLOCK(hqspi);
 80872e6:	2300      	movs	r3, #0
}
 80872e8:	4630      	mov	r0, r6
  __HAL_UNLOCK(hqspi);
 80872ea:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 80872ee:	b002      	add	sp, #8
 80872f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __HAL_LOCK(hqspi);
 80872f4:	2602      	movs	r6, #2
}
 80872f6:	4630      	mov	r0, r6
 80872f8:	b002      	add	sp, #8
 80872fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80872fe:	2200      	movs	r2, #0
    hqspi->State = HAL_QSPI_STATE_BUSY;   
 8087300:	f04f 0a02 	mov.w	sl, #2
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8087304:	f8cd 8000 	str.w	r8, [sp]
 8087308:	4603      	mov	r3, r0
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 808730a:	6462      	str	r2, [r4, #68]	; 0x44
 808730c:	4607      	mov	r7, r0
    hqspi->State = HAL_QSPI_STATE_BUSY;   
 808730e:	f884 a041 	strb.w	sl, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8087312:	2120      	movs	r1, #32
 8087314:	4620      	mov	r0, r4
 8087316:	f7ff ff23 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 808731a:	4606      	mov	r6, r0
 808731c:	2800      	cmp	r0, #0
 808731e:	d1e2      	bne.n	80872e6 <HAL_QSPI_Command+0x2a>
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 8087320:	4602      	mov	r2, r0
 8087322:	4649      	mov	r1, r9
 8087324:	4620      	mov	r0, r4
 8087326:	f7ff fe51 	bl	8086fcc <QSPI_Config>
      if (cmd->DataMode == QSPI_DATA_NONE)
 808732a:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 808732e:	b113      	cbz	r3, 8087336 <HAL_QSPI_Command+0x7a>
        hqspi->State = HAL_QSPI_STATE_READY;   
 8087330:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 8087334:	e7d7      	b.n	80872e6 <HAL_QSPI_Command+0x2a>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
 8087336:	f8cd 8000 	str.w	r8, [sp]
 808733a:	463b      	mov	r3, r7
 808733c:	462a      	mov	r2, r5
 808733e:	4651      	mov	r1, sl
 8087340:	4620      	mov	r0, r4
 8087342:	f7ff ff0d 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 8087346:	4606      	mov	r6, r0
 8087348:	2800      	cmp	r0, #0
 808734a:	d1cc      	bne.n	80872e6 <HAL_QSPI_Command+0x2a>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 808734c:	6823      	ldr	r3, [r4, #0]
 808734e:	f8c3 a00c 	str.w	sl, [r3, #12]
          hqspi->State = HAL_QSPI_STATE_READY;   
 8087352:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 8087356:	e7c6      	b.n	80872e6 <HAL_QSPI_Command+0x2a>

08087358 <HAL_QSPI_AutoPolling>:
{
 8087358:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 808735c:	4604      	mov	r4, r0
 808735e:	b083      	sub	sp, #12
 8087360:	4698      	mov	r8, r3
 8087362:	4689      	mov	r9, r1
 8087364:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
 8087366:	f7fe fa23 	bl	80857b0 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 808736a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 808736e:	2b01      	cmp	r3, #1
 8087370:	d00e      	beq.n	8087390 <HAL_QSPI_AutoPolling+0x38>
 8087372:	2301      	movs	r3, #1
 8087374:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 8087378:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
 808737c:	b2ed      	uxtb	r5, r5
 808737e:	429d      	cmp	r5, r3
 8087380:	d00a      	beq.n	8087398 <HAL_QSPI_AutoPolling+0x40>
    status = HAL_BUSY;   
 8087382:	2002      	movs	r0, #2
  __HAL_UNLOCK(hqspi);
 8087384:	2300      	movs	r3, #0
 8087386:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 808738a:	b003      	add	sp, #12
 808738c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  __HAL_LOCK(hqspi);
 8087390:	2002      	movs	r0, #2
}
 8087392:	b003      	add	sp, #12
 8087394:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
 8087398:	2142      	movs	r1, #66	; 0x42
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 808739a:	2200      	movs	r2, #0
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 808739c:	f8cd 8000 	str.w	r8, [sp]
 80873a0:	4607      	mov	r7, r0
 80873a2:	4603      	mov	r3, r0
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80873a4:	6462      	str	r2, [r4, #68]	; 0x44
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 80873a6:	4620      	mov	r0, r4
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
 80873a8:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 80873ac:	2120      	movs	r1, #32
 80873ae:	f7ff fed7 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 80873b2:	2800      	cmp	r0, #0
 80873b4:	d1e6      	bne.n	8087384 <HAL_QSPI_AutoPolling+0x2c>
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
 80873b6:	6823      	ldr	r3, [r4, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 80873b8:	4649      	mov	r1, r9
      cmd->NbData = cfg->StatusBytesSize;
 80873ba:	f8d6 c00c 	ldr.w	ip, [r6, #12]
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
 80873be:	e9d6 2000 	ldrd	r2, r0, [r6]
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
 80873c2:	629a      	str	r2, [r3, #40]	; 0x28
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
 80873c4:	68b2      	ldr	r2, [r6, #8]
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
 80873c6:	6258      	str	r0, [r3, #36]	; 0x24
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
 80873c8:	6930      	ldr	r0, [r6, #16]
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
 80873ca:	62da      	str	r2, [r3, #44]	; 0x2c
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
 80873cc:	681a      	ldr	r2, [r3, #0]
 80873ce:	f440 0080 	orr.w	r0, r0, #4194304	; 0x400000
 80873d2:	f422 0640 	bic.w	r6, r2, #12582912	; 0xc00000
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 80873d6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
 80873da:	4306      	orrs	r6, r0
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 80873dc:	4620      	mov	r0, r4
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
 80873de:	601e      	str	r6, [r3, #0]
      cmd->NbData = cfg->StatusBytesSize;
 80873e0:	f8c9 c028 	str.w	ip, [r9, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 80873e4:	f7ff fdf2 	bl	8086fcc <QSPI_Config>
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
 80873e8:	f8cd 8000 	str.w	r8, [sp]
 80873ec:	463b      	mov	r3, r7
 80873ee:	462a      	mov	r2, r5
 80873f0:	2108      	movs	r1, #8
 80873f2:	4620      	mov	r0, r4
 80873f4:	f7ff feb4 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 80873f8:	2800      	cmp	r0, #0
 80873fa:	d1c3      	bne.n	8087384 <HAL_QSPI_AutoPolling+0x2c>
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
 80873fc:	6823      	ldr	r3, [r4, #0]
 80873fe:	2208      	movs	r2, #8
 8087400:	60da      	str	r2, [r3, #12]
        hqspi->State = HAL_QSPI_STATE_READY;
 8087402:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 8087406:	e7bd      	b.n	8087384 <HAL_QSPI_AutoPolling+0x2c>

08087408 <HAL_QSPI_MemoryMapped>:
{
 8087408:	b5f0      	push	{r4, r5, r6, r7, lr}
 808740a:	4604      	mov	r4, r0
 808740c:	b083      	sub	sp, #12
 808740e:	4616      	mov	r6, r2
 8087410:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
 8087412:	f7fe f9cd 	bl	80857b0 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 8087416:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 808741a:	2a01      	cmp	r2, #1
 808741c:	d00d      	beq.n	808743a <HAL_QSPI_MemoryMapped+0x32>
 808741e:	2201      	movs	r2, #1
 8087420:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 8087424:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8087428:	2a01      	cmp	r2, #1
 808742a:	d00a      	beq.n	8087442 <HAL_QSPI_MemoryMapped+0x3a>
    status = HAL_BUSY;   
 808742c:	2502      	movs	r5, #2
  __HAL_UNLOCK(hqspi);
 808742e:	2300      	movs	r3, #0
}
 8087430:	4628      	mov	r0, r5
  __HAL_UNLOCK(hqspi);
 8087432:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 8087436:	b003      	add	sp, #12
 8087438:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(hqspi);
 808743a:	2502      	movs	r5, #2
}
 808743c:	4628      	mov	r0, r5
 808743e:	b003      	add	sp, #12
 8087440:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8087442:	6ca5      	ldr	r5, [r4, #72]	; 0x48
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8087444:	2200      	movs	r2, #0
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
 8087446:	2182      	movs	r1, #130	; 0x82
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8087448:	4603      	mov	r3, r0
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 808744a:	6462      	str	r2, [r4, #68]	; 0x44
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 808744c:	4620      	mov	r0, r4
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
 808744e:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8087452:	2120      	movs	r1, #32
 8087454:	9500      	str	r5, [sp, #0]
 8087456:	f7ff fe83 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 808745a:	4605      	mov	r5, r0
 808745c:	2800      	cmp	r0, #0
 808745e:	d1e6      	bne.n	808742e <HAL_QSPI_MemoryMapped+0x26>
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
 8087460:	6822      	ldr	r2, [r4, #0]
 8087462:	6871      	ldr	r1, [r6, #4]
 8087464:	6813      	ldr	r3, [r2, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
 8087466:	2908      	cmp	r1, #8
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
 8087468:	f023 0308 	bic.w	r3, r3, #8
 808746c:	ea43 0301 	orr.w	r3, r3, r1
 8087470:	6013      	str	r3, [r2, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
 8087472:	d107      	bne.n	8087484 <HAL_QSPI_MemoryMapped+0x7c>
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
 8087474:	6831      	ldr	r1, [r6, #0]
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
 8087476:	2310      	movs	r3, #16
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
 8087478:	6311      	str	r1, [r2, #48]	; 0x30
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
 808747a:	60d3      	str	r3, [r2, #12]
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
 808747c:	6813      	ldr	r3, [r2, #0]
 808747e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8087482:	6013      	str	r3, [r2, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
 8087484:	4639      	mov	r1, r7
 8087486:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
 808748a:	4620      	mov	r0, r4
 808748c:	f7ff fd9e 	bl	8086fcc <QSPI_Config>
 8087490:	e7cd      	b.n	808742e <HAL_QSPI_MemoryMapped+0x26>
 8087492:	bf00      	nop

08087494 <HAL_QSPI_Abort>:
{
 8087494:	b5f0      	push	{r4, r5, r6, r7, lr}
 8087496:	4604      	mov	r4, r0
 8087498:	b083      	sub	sp, #12
  uint32_t tickstart = HAL_GetTick();
 808749a:	f7fe f989 	bl	80857b0 <HAL_GetTick>
 808749e:	4606      	mov	r6, r0
  if ((hqspi->State & 0x2) != 0)
 80874a0:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 80874a4:	f010 0002 	ands.w	r0, r0, #2
 80874a8:	d013      	beq.n	80874d2 <HAL_QSPI_Abort+0x3e>
    __HAL_UNLOCK(hqspi);
 80874aa:	2300      	movs	r3, #0
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
 80874ac:	6825      	ldr	r5, [r4, #0]
    __HAL_UNLOCK(hqspi);
 80874ae:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
 80874b2:	682b      	ldr	r3, [r5, #0]
 80874b4:	075b      	lsls	r3, r3, #29
 80874b6:	d420      	bmi.n	80874fa <HAL_QSPI_Abort+0x66>
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 80874b8:	6828      	ldr	r0, [r5, #0]
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
 80874ba:	4633      	mov	r3, r6
 80874bc:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 80874be:	2201      	movs	r2, #1
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 80874c0:	f040 0002 	orr.w	r0, r0, #2
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
 80874c4:	2102      	movs	r1, #2
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
 80874c6:	6028      	str	r0, [r5, #0]
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
 80874c8:	4620      	mov	r0, r4
 80874ca:	9700      	str	r7, [sp, #0]
 80874cc:	f7ff fe48 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
    if(status == HAL_OK)
 80874d0:	b108      	cbz	r0, 80874d6 <HAL_QSPI_Abort+0x42>
}
 80874d2:	b003      	add	sp, #12
 80874d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80874d6:	6821      	ldr	r1, [r4, #0]
 80874d8:	2702      	movs	r7, #2
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80874da:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 80874dc:	4602      	mov	r2, r0
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80874de:	60cf      	str	r7, [r1, #12]
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80874e0:	4633      	mov	r3, r6
 80874e2:	2120      	movs	r1, #32
 80874e4:	9500      	str	r5, [sp, #0]
 80874e6:	4620      	mov	r0, r4
 80874e8:	f7ff fe3a 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 80874ec:	2800      	cmp	r0, #0
 80874ee:	d1f0      	bne.n	80874d2 <HAL_QSPI_Abort+0x3e>
      hqspi->State = HAL_QSPI_STATE_READY;
 80874f0:	2301      	movs	r3, #1
 80874f2:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
}
 80874f6:	b003      	add	sp, #12
 80874f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
 80874fa:	682b      	ldr	r3, [r5, #0]
      status = HAL_DMA_Abort(hqspi->hdma);
 80874fc:	6be0      	ldr	r0, [r4, #60]	; 0x3c
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
 80874fe:	f023 0304 	bic.w	r3, r3, #4
 8087502:	602b      	str	r3, [r5, #0]
      status = HAL_DMA_Abort(hqspi->hdma);
 8087504:	f7fe fb02 	bl	8085b0c <HAL_DMA_Abort>
      if(status != HAL_OK)
 8087508:	b908      	cbnz	r0, 808750e <HAL_QSPI_Abort+0x7a>
 808750a:	6825      	ldr	r5, [r4, #0]
 808750c:	e7d4      	b.n	80874b8 <HAL_QSPI_Abort+0x24>
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
 808750e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8087510:	6825      	ldr	r5, [r4, #0]
 8087512:	f043 0304 	orr.w	r3, r3, #4
 8087516:	6463      	str	r3, [r4, #68]	; 0x44
 8087518:	e7ce      	b.n	80874b8 <HAL_QSPI_Abort+0x24>
 808751a:	bf00      	nop

0808751c <HAL_QSPI_Transmit>:
{
 808751c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8087520:	4604      	mov	r4, r0
 8087522:	b082      	sub	sp, #8
 8087524:	4688      	mov	r8, r1
 8087526:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 8087528:	f7fe f942 	bl	80857b0 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 808752c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8087530:	2b01      	cmp	r3, #1
 8087532:	d044      	beq.n	80875be <HAL_QSPI_Transmit+0xa2>
 8087534:	2301      	movs	r3, #1
 8087536:	4606      	mov	r6, r0
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
 8087538:	6825      	ldr	r5, [r4, #0]
  __HAL_LOCK(hqspi);
 808753a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 808753e:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 8087542:	b2c0      	uxtb	r0, r0
 8087544:	4298      	cmp	r0, r3
 8087546:	d006      	beq.n	8087556 <HAL_QSPI_Transmit+0x3a>
    status = HAL_BUSY;
 8087548:	2002      	movs	r0, #2
  __HAL_UNLOCK(hqspi);
 808754a:	2300      	movs	r3, #0
 808754c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 8087550:	b002      	add	sp, #8
 8087552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8087556:	2300      	movs	r3, #0
 8087558:	6463      	str	r3, [r4, #68]	; 0x44
    if(pData != NULL )
 808755a:	f1b8 0f00 	cmp.w	r8, #0
 808755e:	d029      	beq.n	80875b4 <HAL_QSPI_Transmit+0x98>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
 8087560:	2312      	movs	r3, #18
 8087562:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
 8087566:	692b      	ldr	r3, [r5, #16]
 8087568:	3301      	adds	r3, #1
 808756a:	62e3      	str	r3, [r4, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
 808756c:	692b      	ldr	r3, [r5, #16]
      hqspi->pTxBuffPtr = pData;
 808756e:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
 8087572:	3301      	adds	r3, #1
 8087574:	62a3      	str	r3, [r4, #40]	; 0x28
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 8087576:	696b      	ldr	r3, [r5, #20]
 8087578:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 808757c:	616b      	str	r3, [r5, #20]
      while(hqspi->TxXferCount > 0)
 808757e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8087580:	b95b      	cbnz	r3, 808759a <HAL_QSPI_Transmit+0x7e>
 8087582:	e020      	b.n	80875c6 <HAL_QSPI_Transmit+0xaa>
        *(__IO uint8_t *)data_reg = *hqspi->pTxBuffPtr++;
 8087584:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8087586:	1c5a      	adds	r2, r3, #1
 8087588:	6262      	str	r2, [r4, #36]	; 0x24
 808758a:	781b      	ldrb	r3, [r3, #0]
 808758c:	f885 3020 	strb.w	r3, [r5, #32]
        hqspi->TxXferCount--;
 8087590:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8087592:	3b01      	subs	r3, #1
 8087594:	62e3      	str	r3, [r4, #44]	; 0x2c
      while(hqspi->TxXferCount > 0)
 8087596:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8087598:	b1ab      	cbz	r3, 80875c6 <HAL_QSPI_Transmit+0xaa>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
 808759a:	9700      	str	r7, [sp, #0]
 808759c:	4633      	mov	r3, r6
 808759e:	2201      	movs	r2, #1
 80875a0:	2104      	movs	r1, #4
 80875a2:	4620      	mov	r0, r4
 80875a4:	f7ff fddc 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
 80875a8:	2800      	cmp	r0, #0
 80875aa:	d0eb      	beq.n	8087584 <HAL_QSPI_Transmit+0x68>
      hqspi->State = HAL_QSPI_STATE_READY;    
 80875ac:	2301      	movs	r3, #1
 80875ae:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80875b2:	e7ca      	b.n	808754a <HAL_QSPI_Transmit+0x2e>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
 80875b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80875b6:	f043 0308 	orr.w	r3, r3, #8
 80875ba:	6463      	str	r3, [r4, #68]	; 0x44
 80875bc:	e7c5      	b.n	808754a <HAL_QSPI_Transmit+0x2e>
  __HAL_LOCK(hqspi);
 80875be:	2002      	movs	r0, #2
}
 80875c0:	b002      	add	sp, #8
 80875c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
 80875c6:	9700      	str	r7, [sp, #0]
 80875c8:	4633      	mov	r3, r6
 80875ca:	2201      	movs	r2, #1
 80875cc:	2102      	movs	r1, #2
 80875ce:	4620      	mov	r0, r4
 80875d0:	f7ff fdc6 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 80875d4:	2800      	cmp	r0, #0
 80875d6:	d1e9      	bne.n	80875ac <HAL_QSPI_Transmit+0x90>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80875d8:	6823      	ldr	r3, [r4, #0]
 80875da:	2202      	movs	r2, #2
          status = HAL_QSPI_Abort(hqspi);
 80875dc:	4620      	mov	r0, r4
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80875de:	60da      	str	r2, [r3, #12]
          status = HAL_QSPI_Abort(hqspi);
 80875e0:	f7ff ff58 	bl	8087494 <HAL_QSPI_Abort>
 80875e4:	e7e2      	b.n	80875ac <HAL_QSPI_Transmit+0x90>
 80875e6:	bf00      	nop

080875e8 <HAL_QSPI_Receive>:
{
 80875e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80875ec:	4604      	mov	r4, r0
 80875ee:	b082      	sub	sp, #8
 80875f0:	4617      	mov	r7, r2
 80875f2:	4688      	mov	r8, r1
  uint32_t tickstart = HAL_GetTick();
 80875f4:	f7fe f8dc 	bl	80857b0 <HAL_GetTick>
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
 80875f8:	6825      	ldr	r5, [r4, #0]
 80875fa:	69aa      	ldr	r2, [r5, #24]
  __HAL_LOCK(hqspi);
 80875fc:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8087600:	2b01      	cmp	r3, #1
 8087602:	d046      	beq.n	8087692 <HAL_QSPI_Receive+0xaa>
 8087604:	2301      	movs	r3, #1
 8087606:	4606      	mov	r6, r0
 8087608:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 808760c:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 8087610:	b2c0      	uxtb	r0, r0
 8087612:	4298      	cmp	r0, r3
 8087614:	d006      	beq.n	8087624 <HAL_QSPI_Receive+0x3c>
    status = HAL_BUSY;
 8087616:	2002      	movs	r0, #2
  __HAL_UNLOCK(hqspi);
 8087618:	2300      	movs	r3, #0
 808761a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 808761e:	b002      	add	sp, #8
 8087620:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8087624:	2300      	movs	r3, #0
 8087626:	6463      	str	r3, [r4, #68]	; 0x44
    if(pData != NULL )
 8087628:	f1b8 0f00 	cmp.w	r8, #0
 808762c:	d02c      	beq.n	8087688 <HAL_QSPI_Receive+0xa0>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
 808762e:	2322      	movs	r3, #34	; 0x22
 8087630:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
 8087634:	692b      	ldr	r3, [r5, #16]
 8087636:	3301      	adds	r3, #1
 8087638:	63a3      	str	r3, [r4, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
 808763a:	692b      	ldr	r3, [r5, #16]
      hqspi->pRxBuffPtr = pData;
 808763c:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
 8087640:	3301      	adds	r3, #1
 8087642:	6363      	str	r3, [r4, #52]	; 0x34
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 8087644:	696b      	ldr	r3, [r5, #20]
 8087646:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 808764a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 808764e:	616b      	str	r3, [r5, #20]
      WRITE_REG(hqspi->Instance->AR, addr_reg);
 8087650:	61aa      	str	r2, [r5, #24]
      while(hqspi->RxXferCount > 0)
 8087652:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8087654:	b95b      	cbnz	r3, 808766e <HAL_QSPI_Receive+0x86>
 8087656:	e020      	b.n	808769a <HAL_QSPI_Receive+0xb2>
        *hqspi->pRxBuffPtr++ = *(__IO uint8_t *)data_reg;
 8087658:	6b23      	ldr	r3, [r4, #48]	; 0x30
 808765a:	1c5a      	adds	r2, r3, #1
 808765c:	6322      	str	r2, [r4, #48]	; 0x30
 808765e:	f895 2020 	ldrb.w	r2, [r5, #32]
 8087662:	701a      	strb	r2, [r3, #0]
        hqspi->RxXferCount--;
 8087664:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8087666:	3b01      	subs	r3, #1
 8087668:	63a3      	str	r3, [r4, #56]	; 0x38
      while(hqspi->RxXferCount > 0)
 808766a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 808766c:	b1ab      	cbz	r3, 808769a <HAL_QSPI_Receive+0xb2>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
 808766e:	9700      	str	r7, [sp, #0]
 8087670:	4633      	mov	r3, r6
 8087672:	2201      	movs	r2, #1
 8087674:	2106      	movs	r1, #6
 8087676:	4620      	mov	r0, r4
 8087678:	f7ff fd72 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
        if  (status != HAL_OK)
 808767c:	2800      	cmp	r0, #0
 808767e:	d0eb      	beq.n	8087658 <HAL_QSPI_Receive+0x70>
      hqspi->State = HAL_QSPI_STATE_READY;    
 8087680:	2301      	movs	r3, #1
 8087682:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8087686:	e7c7      	b.n	8087618 <HAL_QSPI_Receive+0x30>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
 8087688:	6c63      	ldr	r3, [r4, #68]	; 0x44
 808768a:	f043 0308 	orr.w	r3, r3, #8
 808768e:	6463      	str	r3, [r4, #68]	; 0x44
 8087690:	e7c2      	b.n	8087618 <HAL_QSPI_Receive+0x30>
  __HAL_LOCK(hqspi);
 8087692:	2002      	movs	r0, #2
}
 8087694:	b002      	add	sp, #8
 8087696:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
 808769a:	9700      	str	r7, [sp, #0]
 808769c:	4633      	mov	r3, r6
 808769e:	2201      	movs	r2, #1
 80876a0:	2102      	movs	r1, #2
 80876a2:	4620      	mov	r0, r4
 80876a4:	f7ff fd5c 	bl	8087160 <QSPI_WaitFlagStateUntilTimeout>
        if  (status == HAL_OK)
 80876a8:	2800      	cmp	r0, #0
 80876aa:	d1e9      	bne.n	8087680 <HAL_QSPI_Receive+0x98>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80876ac:	6823      	ldr	r3, [r4, #0]
 80876ae:	2202      	movs	r2, #2
         status = HAL_QSPI_Abort(hqspi);
 80876b0:	4620      	mov	r0, r4
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80876b2:	60da      	str	r2, [r3, #12]
         status = HAL_QSPI_Abort(hqspi);
 80876b4:	f7ff feee 	bl	8087494 <HAL_QSPI_Abort>
 80876b8:	e7e2      	b.n	8087680 <HAL_QSPI_Receive+0x98>
 80876ba:	bf00      	nop

080876bc <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80876bc:	2800      	cmp	r0, #0
 80876be:	f000 816b 	beq.w	8087998 <HAL_RCC_OscConfig+0x2dc>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80876c2:	6803      	ldr	r3, [r0, #0]
{
 80876c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80876c8:	07dd      	lsls	r5, r3, #31
{
 80876ca:	b082      	sub	sp, #8
 80876cc:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80876ce:	d541      	bpl.n	8087754 <HAL_RCC_OscConfig+0x98>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80876d0:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 80876d4:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80876d8:	688a      	ldr	r2, [r1, #8]
 80876da:	f002 020c 	and.w	r2, r2, #12
 80876de:	2a04      	cmp	r2, #4
 80876e0:	f000 812c 	beq.w	808793c <HAL_RCC_OscConfig+0x280>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80876e4:	688a      	ldr	r2, [r1, #8]
 80876e6:	f002 020c 	and.w	r2, r2, #12
 80876ea:	2a08      	cmp	r2, #8
 80876ec:	f000 8122 	beq.w	8087934 <HAL_RCC_OscConfig+0x278>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80876f0:	6863      	ldr	r3, [r4, #4]
 80876f2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80876f6:	d013      	beq.n	8087720 <HAL_RCC_OscConfig+0x64>
 80876f8:	2b00      	cmp	r3, #0
 80876fa:	f000 814f 	beq.w	808799c <HAL_RCC_OscConfig+0x2e0>
 80876fe:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8087702:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087706:	f2c4 0302 	movt	r3, #16386	; 0x4002
 808770a:	681a      	ldr	r2, [r3, #0]
 808770c:	f000 8198 	beq.w	8087a40 <HAL_RCC_OscConfig+0x384>
 8087710:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8087714:	601a      	str	r2, [r3, #0]
 8087716:	681a      	ldr	r2, [r3, #0]
 8087718:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 808771c:	601a      	str	r2, [r3, #0]
 808771e:	e007      	b.n	8087730 <HAL_RCC_OscConfig+0x74>
 8087720:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087724:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087728:	681a      	ldr	r2, [r3, #0]
 808772a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 808772e:	601a      	str	r2, [r3, #0]
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8087730:	f44f 5560 	mov.w	r5, #14336	; 0x3800
        tickstart = HAL_GetTick();
 8087734:	f7fe f83c 	bl	80857b0 <HAL_GetTick>
 8087738:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 808773a:	f2c4 0502 	movt	r5, #16386	; 0x4002
 808773e:	e005      	b.n	808774c <HAL_RCC_OscConfig+0x90>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8087740:	f7fe f836 	bl	80857b0 <HAL_GetTick>
 8087744:	1b80      	subs	r0, r0, r6
 8087746:	2864      	cmp	r0, #100	; 0x64
 8087748:	f200 8116 	bhi.w	8087978 <HAL_RCC_OscConfig+0x2bc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 808774c:	682b      	ldr	r3, [r5, #0]
 808774e:	039a      	lsls	r2, r3, #14
 8087750:	d5f6      	bpl.n	8087740 <HAL_RCC_OscConfig+0x84>
 8087752:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8087754:	079f      	lsls	r7, r3, #30
 8087756:	d44f      	bmi.n	80877f8 <HAL_RCC_OscConfig+0x13c>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8087758:	071a      	lsls	r2, r3, #28
 808775a:	d51a      	bpl.n	8087792 <HAL_RCC_OscConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 808775c:	6963      	ldr	r3, [r4, #20]
 808775e:	2b00      	cmp	r3, #0
 8087760:	f000 80d2 	beq.w	8087908 <HAL_RCC_OscConfig+0x24c>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8087764:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087768:	f2c4 0302 	movt	r3, #16386	; 0x4002
 808776c:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 808776e:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
 8087770:	f042 0201 	orr.w	r2, r2, #1
 8087774:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 8087776:	f7fe f81b 	bl	80857b0 <HAL_GetTick>
 808777a:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 808777c:	e005      	b.n	808778a <HAL_RCC_OscConfig+0xce>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 808777e:	f7fe f817 	bl	80857b0 <HAL_GetTick>
 8087782:	1b80      	subs	r0, r0, r6
 8087784:	2802      	cmp	r0, #2
 8087786:	f200 80f7 	bhi.w	8087978 <HAL_RCC_OscConfig+0x2bc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 808778a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 808778c:	079b      	lsls	r3, r3, #30
 808778e:	d5f6      	bpl.n	808777e <HAL_RCC_OscConfig+0xc2>
 8087790:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8087792:	075d      	lsls	r5, r3, #29
 8087794:	f140 8084 	bpl.w	80878a0 <HAL_RCC_OscConfig+0x1e4>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8087798:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 808779c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80877a0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80877a2:	00d0      	lsls	r0, r2, #3
 80877a4:	f100 8114 	bmi.w	80879d0 <HAL_RCC_OscConfig+0x314>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 80877a8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
 80877aa:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 80877ac:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80877b0:	641a      	str	r2, [r3, #64]	; 0x40
 80877b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80877b4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80877b8:	9301      	str	r3, [sp, #4]
 80877ba:	9b01      	ldr	r3, [sp, #4]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80877bc:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80877c0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80877c4:	681a      	ldr	r2, [r3, #0]
 80877c6:	05d1      	lsls	r1, r2, #23
 80877c8:	f140 80c5 	bpl.w	8087956 <HAL_RCC_OscConfig+0x29a>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80877cc:	68a3      	ldr	r3, [r4, #8]
 80877ce:	2b01      	cmp	r3, #1
 80877d0:	d042      	beq.n	8087858 <HAL_RCC_OscConfig+0x19c>
 80877d2:	2b00      	cmp	r3, #0
 80877d4:	f000 80fe 	beq.w	80879d4 <HAL_RCC_OscConfig+0x318>
 80877d8:	2b05      	cmp	r3, #5
 80877da:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80877de:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80877e2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80877e4:	f000 8134 	beq.w	8087a50 <HAL_RCC_OscConfig+0x394>
 80877e8:	f022 0201 	bic.w	r2, r2, #1
 80877ec:	671a      	str	r2, [r3, #112]	; 0x70
 80877ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80877f0:	f022 0204 	bic.w	r2, r2, #4
 80877f4:	671a      	str	r2, [r3, #112]	; 0x70
 80877f6:	e037      	b.n	8087868 <HAL_RCC_OscConfig+0x1ac>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 80877f8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80877fc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087800:	6891      	ldr	r1, [r2, #8]
 8087802:	f011 0f0c 	tst.w	r1, #12
 8087806:	d071      	beq.n	80878ec <HAL_RCC_OscConfig+0x230>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8087808:	6891      	ldr	r1, [r2, #8]
 808780a:	f001 010c 	and.w	r1, r1, #12
 808780e:	2908      	cmp	r1, #8
 8087810:	d069      	beq.n	80878e6 <HAL_RCC_OscConfig+0x22a>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8087812:	68e3      	ldr	r3, [r4, #12]
 8087814:	2b00      	cmp	r3, #0
 8087816:	f000 80fc 	beq.w	8087a12 <HAL_RCC_OscConfig+0x356>
        __HAL_RCC_HSI_ENABLE();
 808781a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 808781e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087822:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8087824:	461d      	mov	r5, r3
        __HAL_RCC_HSI_ENABLE();
 8087826:	f042 0201 	orr.w	r2, r2, #1
 808782a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 808782c:	f7fd ffc0 	bl	80857b0 <HAL_GetTick>
 8087830:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8087832:	e005      	b.n	8087840 <HAL_RCC_OscConfig+0x184>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8087834:	f7fd ffbc 	bl	80857b0 <HAL_GetTick>
 8087838:	1b80      	subs	r0, r0, r6
 808783a:	2802      	cmp	r0, #2
 808783c:	f200 809c 	bhi.w	8087978 <HAL_RCC_OscConfig+0x2bc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8087840:	682b      	ldr	r3, [r5, #0]
 8087842:	0798      	lsls	r0, r3, #30
 8087844:	d5f6      	bpl.n	8087834 <HAL_RCC_OscConfig+0x178>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8087846:	682b      	ldr	r3, [r5, #0]
 8087848:	6922      	ldr	r2, [r4, #16]
 808784a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 808784e:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8087852:	602b      	str	r3, [r5, #0]
 8087854:	6823      	ldr	r3, [r4, #0]
 8087856:	e77f      	b.n	8087758 <HAL_RCC_OscConfig+0x9c>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8087858:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 808785c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087860:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8087862:	f042 0201 	orr.w	r2, r2, #1
 8087866:	671a      	str	r2, [r3, #112]	; 0x70
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8087868:	f44f 5660 	mov.w	r6, #14336	; 0x3800
      tickstart = HAL_GetTick();
 808786c:	f7fd ffa0 	bl	80857b0 <HAL_GetTick>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8087870:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8087874:	4680      	mov	r8, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8087876:	f2c4 0602 	movt	r6, #16386	; 0x4002
 808787a:	e005      	b.n	8087888 <HAL_RCC_OscConfig+0x1cc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 808787c:	f7fd ff98 	bl	80857b0 <HAL_GetTick>
 8087880:	eba0 0008 	sub.w	r0, r0, r8
 8087884:	42b8      	cmp	r0, r7
 8087886:	d877      	bhi.n	8087978 <HAL_RCC_OscConfig+0x2bc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8087888:	6f33      	ldr	r3, [r6, #112]	; 0x70
 808788a:	079b      	lsls	r3, r3, #30
 808788c:	d5f6      	bpl.n	808787c <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 808788e:	b13d      	cbz	r5, 80878a0 <HAL_RCC_OscConfig+0x1e4>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8087890:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087894:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087898:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 808789a:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 808789e:	641a      	str	r2, [r3, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80878a0:	69a2      	ldr	r2, [r4, #24]
 80878a2:	b1e2      	cbz	r2, 80878de <HAL_RCC_OscConfig+0x222>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80878a4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80878a8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80878ac:	6899      	ldr	r1, [r3, #8]
 80878ae:	f001 010c 	and.w	r1, r1, #12
 80878b2:	2908      	cmp	r1, #8
 80878b4:	d024      	beq.n	8087900 <HAL_RCC_OscConfig+0x244>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80878b6:	2a02      	cmp	r2, #2
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80878b8:	681a      	ldr	r2, [r3, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80878ba:	f000 80d1 	beq.w	8087a60 <HAL_RCC_OscConfig+0x3a4>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80878be:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80878c2:	461c      	mov	r4, r3
        __HAL_RCC_PLL_DISABLE();
 80878c4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80878c6:	f7fd ff73 	bl	80857b0 <HAL_GetTick>
 80878ca:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80878cc:	e004      	b.n	80878d8 <HAL_RCC_OscConfig+0x21c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80878ce:	f7fd ff6f 	bl	80857b0 <HAL_GetTick>
 80878d2:	1b40      	subs	r0, r0, r5
 80878d4:	2802      	cmp	r0, #2
 80878d6:	d84f      	bhi.n	8087978 <HAL_RCC_OscConfig+0x2bc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80878d8:	6823      	ldr	r3, [r4, #0]
 80878da:	019b      	lsls	r3, r3, #6
 80878dc:	d4f7      	bmi.n	80878ce <HAL_RCC_OscConfig+0x212>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80878de:	2000      	movs	r0, #0
}
 80878e0:	b002      	add	sp, #8
 80878e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80878e6:	6852      	ldr	r2, [r2, #4]
 80878e8:	0256      	lsls	r6, r2, #9
 80878ea:	d492      	bmi.n	8087812 <HAL_RCC_OscConfig+0x156>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80878ec:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80878f0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80878f4:	6812      	ldr	r2, [r2, #0]
 80878f6:	0795      	lsls	r5, r2, #30
 80878f8:	d542      	bpl.n	8087980 <HAL_RCC_OscConfig+0x2c4>
 80878fa:	68e2      	ldr	r2, [r4, #12]
 80878fc:	2a01      	cmp	r2, #1
 80878fe:	d03f      	beq.n	8087980 <HAL_RCC_OscConfig+0x2c4>
    return HAL_ERROR;
 8087900:	2001      	movs	r0, #1
}
 8087902:	b002      	add	sp, #8
 8087904:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8087908:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 808790c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087910:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8087912:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
 8087914:	f022 0201 	bic.w	r2, r2, #1
 8087918:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 808791a:	f7fd ff49 	bl	80857b0 <HAL_GetTick>
 808791e:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8087920:	e004      	b.n	808792c <HAL_RCC_OscConfig+0x270>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8087922:	f7fd ff45 	bl	80857b0 <HAL_GetTick>
 8087926:	1b80      	subs	r0, r0, r6
 8087928:	2802      	cmp	r0, #2
 808792a:	d825      	bhi.n	8087978 <HAL_RCC_OscConfig+0x2bc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 808792c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 808792e:	079f      	lsls	r7, r3, #30
 8087930:	d4f7      	bmi.n	8087922 <HAL_RCC_OscConfig+0x266>
 8087932:	e72d      	b.n	8087790 <HAL_RCC_OscConfig+0xd4>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8087934:	684a      	ldr	r2, [r1, #4]
 8087936:	0250      	lsls	r0, r2, #9
 8087938:	f57f aeda 	bpl.w	80876f0 <HAL_RCC_OscConfig+0x34>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 808793c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8087940:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087944:	6812      	ldr	r2, [r2, #0]
 8087946:	0391      	lsls	r1, r2, #14
 8087948:	f57f af04 	bpl.w	8087754 <HAL_RCC_OscConfig+0x98>
 808794c:	6862      	ldr	r2, [r4, #4]
 808794e:	2a00      	cmp	r2, #0
 8087950:	f47f af00 	bne.w	8087754 <HAL_RCC_OscConfig+0x98>
 8087954:	e7d4      	b.n	8087900 <HAL_RCC_OscConfig+0x244>
      PWR->CR1 |= PWR_CR1_DBP;
 8087956:	681a      	ldr	r2, [r3, #0]
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8087958:	461e      	mov	r6, r3
      PWR->CR1 |= PWR_CR1_DBP;
 808795a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 808795e:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8087960:	f7fd ff26 	bl	80857b0 <HAL_GetTick>
 8087964:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8087966:	6833      	ldr	r3, [r6, #0]
 8087968:	05da      	lsls	r2, r3, #23
 808796a:	f53f af2f 	bmi.w	80877cc <HAL_RCC_OscConfig+0x110>
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 808796e:	f7fd ff1f 	bl	80857b0 <HAL_GetTick>
 8087972:	1bc0      	subs	r0, r0, r7
 8087974:	2864      	cmp	r0, #100	; 0x64
 8087976:	d9f6      	bls.n	8087966 <HAL_RCC_OscConfig+0x2aa>
            return HAL_TIMEOUT;
 8087978:	2003      	movs	r0, #3
}
 808797a:	b002      	add	sp, #8
 808797c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8087980:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087984:	6920      	ldr	r0, [r4, #16]
 8087986:	f2c4 0102 	movt	r1, #16386	; 0x4002
 808798a:	680a      	ldr	r2, [r1, #0]
 808798c:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8087990:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 8087994:	600a      	str	r2, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8087996:	e6df      	b.n	8087758 <HAL_RCC_OscConfig+0x9c>
    return HAL_ERROR;
 8087998:	2001      	movs	r0, #1
}
 808799a:	4770      	bx	lr
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 808799c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80879a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80879a4:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80879a6:	461d      	mov	r5, r3
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80879a8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80879ac:	601a      	str	r2, [r3, #0]
 80879ae:	681a      	ldr	r2, [r3, #0]
 80879b0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80879b4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80879b6:	f7fd fefb 	bl	80857b0 <HAL_GetTick>
 80879ba:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80879bc:	e004      	b.n	80879c8 <HAL_RCC_OscConfig+0x30c>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80879be:	f7fd fef7 	bl	80857b0 <HAL_GetTick>
 80879c2:	1b80      	subs	r0, r0, r6
 80879c4:	2864      	cmp	r0, #100	; 0x64
 80879c6:	d8d7      	bhi.n	8087978 <HAL_RCC_OscConfig+0x2bc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80879c8:	682b      	ldr	r3, [r5, #0]
 80879ca:	039b      	lsls	r3, r3, #14
 80879cc:	d4f7      	bmi.n	80879be <HAL_RCC_OscConfig+0x302>
 80879ce:	e6c0      	b.n	8087752 <HAL_RCC_OscConfig+0x96>
  FlagStatus pwrclkchanged = RESET;
 80879d0:	2500      	movs	r5, #0
 80879d2:	e6f3      	b.n	80877bc <HAL_RCC_OscConfig+0x100>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80879d4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80879d8:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80879dc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80879e0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80879e2:	461e      	mov	r6, r3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80879e4:	f022 0201 	bic.w	r2, r2, #1
 80879e8:	671a      	str	r2, [r3, #112]	; 0x70
 80879ea:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80879ec:	f022 0204 	bic.w	r2, r2, #4
 80879f0:	671a      	str	r2, [r3, #112]	; 0x70
      tickstart = HAL_GetTick();
 80879f2:	f7fd fedd 	bl	80857b0 <HAL_GetTick>
 80879f6:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80879f8:	e004      	b.n	8087a04 <HAL_RCC_OscConfig+0x348>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80879fa:	f7fd fed9 	bl	80857b0 <HAL_GetTick>
 80879fe:	1bc0      	subs	r0, r0, r7
 8087a00:	4540      	cmp	r0, r8
 8087a02:	d8b9      	bhi.n	8087978 <HAL_RCC_OscConfig+0x2bc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8087a04:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8087a06:	0798      	lsls	r0, r3, #30
 8087a08:	d4f7      	bmi.n	80879fa <HAL_RCC_OscConfig+0x33e>
    if(pwrclkchanged == SET)
 8087a0a:	2d00      	cmp	r5, #0
 8087a0c:	f43f af48 	beq.w	80878a0 <HAL_RCC_OscConfig+0x1e4>
 8087a10:	e73e      	b.n	8087890 <HAL_RCC_OscConfig+0x1d4>
        __HAL_RCC_HSI_DISABLE();
 8087a12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087a16:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087a1a:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8087a1c:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
 8087a1e:	f022 0201 	bic.w	r2, r2, #1
 8087a22:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8087a24:	f7fd fec4 	bl	80857b0 <HAL_GetTick>
 8087a28:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8087a2a:	e004      	b.n	8087a36 <HAL_RCC_OscConfig+0x37a>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8087a2c:	f7fd fec0 	bl	80857b0 <HAL_GetTick>
 8087a30:	1b80      	subs	r0, r0, r6
 8087a32:	2802      	cmp	r0, #2
 8087a34:	d8a0      	bhi.n	8087978 <HAL_RCC_OscConfig+0x2bc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8087a36:	682b      	ldr	r3, [r5, #0]
 8087a38:	0799      	lsls	r1, r3, #30
 8087a3a:	d4f7      	bmi.n	8087a2c <HAL_RCC_OscConfig+0x370>
 8087a3c:	6823      	ldr	r3, [r4, #0]
 8087a3e:	e68b      	b.n	8087758 <HAL_RCC_OscConfig+0x9c>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8087a40:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8087a44:	601a      	str	r2, [r3, #0]
 8087a46:	681a      	ldr	r2, [r3, #0]
 8087a48:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8087a4c:	601a      	str	r2, [r3, #0]
 8087a4e:	e66f      	b.n	8087730 <HAL_RCC_OscConfig+0x74>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8087a50:	f042 0204 	orr.w	r2, r2, #4
 8087a54:	671a      	str	r2, [r3, #112]	; 0x70
 8087a56:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8087a58:	f042 0201 	orr.w	r2, r2, #1
 8087a5c:	671a      	str	r2, [r3, #112]	; 0x70
 8087a5e:	e703      	b.n	8087868 <HAL_RCC_OscConfig+0x1ac>
        __HAL_RCC_PLL_DISABLE();
 8087a60:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8087a64:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
 8087a66:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8087a68:	f7fd fea2 	bl	80857b0 <HAL_GetTick>
 8087a6c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8087a6e:	e005      	b.n	8087a7c <HAL_RCC_OscConfig+0x3c0>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8087a70:	f7fd fe9e 	bl	80857b0 <HAL_GetTick>
 8087a74:	1b80      	subs	r0, r0, r6
 8087a76:	2802      	cmp	r0, #2
 8087a78:	f63f af7e 	bhi.w	8087978 <HAL_RCC_OscConfig+0x2bc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8087a7c:	682b      	ldr	r3, [r5, #0]
 8087a7e:	0199      	lsls	r1, r3, #6
 8087a80:	d4f6      	bmi.n	8087a70 <HAL_RCC_OscConfig+0x3b4>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8087a82:	6a22      	ldr	r2, [r4, #32]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8087a84:	f44f 5660 	mov.w	r6, #14336	; 0x3800
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8087a88:	69e3      	ldr	r3, [r4, #28]
 8087a8a:	6a60      	ldr	r0, [r4, #36]	; 0x24
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8087a8c:	f2c4 0602 	movt	r6, #16386	; 0x4002
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8087a90:	4313      	orrs	r3, r2
 8087a92:	e9d4 210a 	ldrd	r2, r1, [r4, #40]	; 0x28
 8087a96:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8087a9a:	0852      	lsrs	r2, r2, #1
 8087a9c:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8087aa0:	3a01      	subs	r2, #1
 8087aa2:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8087aa6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8087aaa:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8087aac:	682b      	ldr	r3, [r5, #0]
 8087aae:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8087ab2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8087ab4:	f7fd fe7c 	bl	80857b0 <HAL_GetTick>
 8087ab8:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8087aba:	e005      	b.n	8087ac8 <HAL_RCC_OscConfig+0x40c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8087abc:	f7fd fe78 	bl	80857b0 <HAL_GetTick>
 8087ac0:	1b00      	subs	r0, r0, r4
 8087ac2:	2802      	cmp	r0, #2
 8087ac4:	f63f af58 	bhi.w	8087978 <HAL_RCC_OscConfig+0x2bc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8087ac8:	6833      	ldr	r3, [r6, #0]
 8087aca:	019a      	lsls	r2, r3, #6
 8087acc:	d5f6      	bpl.n	8087abc <HAL_RCC_OscConfig+0x400>
 8087ace:	e706      	b.n	80878de <HAL_RCC_OscConfig+0x222>

08087ad0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8087ad0:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087ad4:	f2c4 0102 	movt	r1, #16386	; 0x4002
{
 8087ad8:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8087ada:	688b      	ldr	r3, [r1, #8]
 8087adc:	f003 030c 	and.w	r3, r3, #12
 8087ae0:	2b04      	cmp	r3, #4
 8087ae2:	d024      	beq.n	8087b2e <HAL_RCC_GetSysClockFreq+0x5e>
 8087ae4:	2b08      	cmp	r3, #8
 8087ae6:	d11d      	bne.n	8087b24 <HAL_RCC_GetSysClockFreq+0x54>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8087ae8:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8087aea:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8087aec:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8087af0:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8087af2:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 8087af6:	d11f      	bne.n	8087b38 <HAL_RCC_GetSysClockFreq+0x68>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8087af8:	f44f 5010 	mov.w	r0, #9216	; 0x2400
 8087afc:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8087b00:	f2c0 00f4 	movt	r0, #244	; 0xf4
 8087b04:	fba1 0100 	umull	r0, r1, r1, r0
 8087b08:	f7f8 fb42 	bl	8080190 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 8087b0c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087b10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087b14:	685b      	ldr	r3, [r3, #4]
 8087b16:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8087b1a:	3301      	adds	r3, #1
 8087b1c:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 8087b1e:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8087b22:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
 8087b24:	f44f 5010 	mov.w	r0, #9216	; 0x2400
 8087b28:	f2c0 00f4 	movt	r0, #244	; 0xf4
}
 8087b2c:	bd08      	pop	{r3, pc}
      sysclockfreq = HSE_VALUE;
 8087b2e:	f647 0040 	movw	r0, #30784	; 0x7840
 8087b32:	f2c0 107d 	movt	r0, #381	; 0x17d
}
 8087b36:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8087b38:	f647 0040 	movw	r0, #30784	; 0x7840
 8087b3c:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8087b40:	2300      	movs	r3, #0
 8087b42:	f2c0 107d 	movt	r0, #381	; 0x17d
 8087b46:	fba1 0100 	umull	r0, r1, r1, r0
 8087b4a:	f7f8 fb21 	bl	8080190 <__aeabi_uldivmod>
 8087b4e:	e7dd      	b.n	8087b0c <HAL_RCC_GetSysClockFreq+0x3c>

08087b50 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8087b50:	b190      	cbz	r0, 8087b78 <HAL_RCC_ClockConfig+0x28>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8087b52:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8087b56:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087b5a:	681a      	ldr	r2, [r3, #0]
 8087b5c:	f002 020f 	and.w	r2, r2, #15
 8087b60:	428a      	cmp	r2, r1
 8087b62:	d20b      	bcs.n	8087b7c <HAL_RCC_ClockConfig+0x2c>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8087b64:	681a      	ldr	r2, [r3, #0]
 8087b66:	f022 020f 	bic.w	r2, r2, #15
 8087b6a:	430a      	orrs	r2, r1
 8087b6c:	601a      	str	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8087b6e:	681b      	ldr	r3, [r3, #0]
 8087b70:	f003 030f 	and.w	r3, r3, #15
 8087b74:	428b      	cmp	r3, r1
 8087b76:	d001      	beq.n	8087b7c <HAL_RCC_ClockConfig+0x2c>
    return HAL_ERROR;
 8087b78:	2001      	movs	r0, #1
}
 8087b7a:	4770      	bx	lr
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8087b7c:	6803      	ldr	r3, [r0, #0]
{
 8087b7e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8087b82:	079d      	lsls	r5, r3, #30
 8087b84:	d51d      	bpl.n	8087bc2 <HAL_RCC_ClockConfig+0x72>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8087b86:	075c      	lsls	r4, r3, #29
 8087b88:	d507      	bpl.n	8087b9a <HAL_RCC_ClockConfig+0x4a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8087b8a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8087b8e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087b92:	6894      	ldr	r4, [r2, #8]
 8087b94:	f444 54e0 	orr.w	r4, r4, #7168	; 0x1c00
 8087b98:	6094      	str	r4, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8087b9a:	071a      	lsls	r2, r3, #28
 8087b9c:	d507      	bpl.n	8087bae <HAL_RCC_ClockConfig+0x5e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8087b9e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8087ba2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087ba6:	6894      	ldr	r4, [r2, #8]
 8087ba8:	f444 4460 	orr.w	r4, r4, #57344	; 0xe000
 8087bac:	6094      	str	r4, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8087bae:	f44f 5460 	mov.w	r4, #14336	; 0x3800
 8087bb2:	6885      	ldr	r5, [r0, #8]
 8087bb4:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8087bb8:	68a2      	ldr	r2, [r4, #8]
 8087bba:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8087bbe:	432a      	orrs	r2, r5
 8087bc0:	60a2      	str	r2, [r4, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8087bc2:	07df      	lsls	r7, r3, #31
 8087bc4:	4604      	mov	r4, r0
 8087bc6:	460d      	mov	r5, r1
 8087bc8:	d527      	bpl.n	8087c1a <HAL_RCC_ClockConfig+0xca>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8087bca:	6842      	ldr	r2, [r0, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8087bcc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8087bd0:	2a01      	cmp	r2, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8087bd2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087bd6:	681b      	ldr	r3, [r3, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8087bd8:	d06b      	beq.n	8087cb2 <HAL_RCC_ClockConfig+0x162>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8087bda:	2a02      	cmp	r2, #2
 8087bdc:	d06e      	beq.n	8087cbc <HAL_RCC_ClockConfig+0x16c>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8087bde:	0799      	lsls	r1, r3, #30
 8087be0:	d52e      	bpl.n	8087c40 <HAL_RCC_ClockConfig+0xf0>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8087be2:	f44f 5160 	mov.w	r1, #14336	; 0x3800
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8087be6:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8087bea:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087bee:	688b      	ldr	r3, [r1, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8087bf0:	460e      	mov	r6, r1
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8087bf2:	f023 0303 	bic.w	r3, r3, #3
 8087bf6:	4313      	orrs	r3, r2
 8087bf8:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8087bfa:	f7fd fdd9 	bl	80857b0 <HAL_GetTick>
 8087bfe:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8087c00:	e004      	b.n	8087c0c <HAL_RCC_ClockConfig+0xbc>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8087c02:	f7fd fdd5 	bl	80857b0 <HAL_GetTick>
 8087c06:	1bc0      	subs	r0, r0, r7
 8087c08:	4540      	cmp	r0, r8
 8087c0a:	d855      	bhi.n	8087cb8 <HAL_RCC_ClockConfig+0x168>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8087c0c:	68b3      	ldr	r3, [r6, #8]
 8087c0e:	6862      	ldr	r2, [r4, #4]
 8087c10:	f003 030c 	and.w	r3, r3, #12
 8087c14:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8087c18:	d1f3      	bne.n	8087c02 <HAL_RCC_ClockConfig+0xb2>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8087c1a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8087c1e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087c22:	681a      	ldr	r2, [r3, #0]
 8087c24:	f002 020f 	and.w	r2, r2, #15
 8087c28:	42aa      	cmp	r2, r5
 8087c2a:	d90c      	bls.n	8087c46 <HAL_RCC_ClockConfig+0xf6>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8087c2c:	681a      	ldr	r2, [r3, #0]
 8087c2e:	f022 020f 	bic.w	r2, r2, #15
 8087c32:	432a      	orrs	r2, r5
 8087c34:	601a      	str	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8087c36:	681b      	ldr	r3, [r3, #0]
 8087c38:	f003 030f 	and.w	r3, r3, #15
 8087c3c:	42ab      	cmp	r3, r5
 8087c3e:	d002      	beq.n	8087c46 <HAL_RCC_ClockConfig+0xf6>
    return HAL_ERROR;
 8087c40:	2001      	movs	r0, #1
}
 8087c42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8087c46:	6823      	ldr	r3, [r4, #0]
 8087c48:	075a      	lsls	r2, r3, #29
 8087c4a:	d509      	bpl.n	8087c60 <HAL_RCC_ClockConfig+0x110>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8087c4c:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087c50:	68e0      	ldr	r0, [r4, #12]
 8087c52:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087c56:	688a      	ldr	r2, [r1, #8]
 8087c58:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8087c5c:	4302      	orrs	r2, r0
 8087c5e:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8087c60:	071b      	lsls	r3, r3, #28
 8087c62:	d41a      	bmi.n	8087c9a <HAL_RCC_ClockConfig+0x14a>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8087c64:	f7ff ff34 	bl	8087ad0 <HAL_RCC_GetSysClockFreq>
 8087c68:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8087c6c:	f649 41fc 	movw	r1, #40188	; 0x9cfc
 8087c70:	f24b 3374 	movw	r3, #45940	; 0xb374
 8087c74:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087c78:	f6c0 0109 	movt	r1, #2057	; 0x809
 8087c7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8087c80:	6892      	ldr	r2, [r2, #8]
 8087c82:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8087c86:	5c8a      	ldrb	r2, [r1, r2]
 8087c88:	fa20 f202 	lsr.w	r2, r0, r2
  HAL_InitTick (TICK_INT_PRIORITY);
 8087c8c:	200f      	movs	r0, #15
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8087c8e:	601a      	str	r2, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8087c90:	f002 fdae 	bl	808a7f0 <HAL_InitTick>
  return HAL_OK;
 8087c94:	2000      	movs	r0, #0
}
 8087c96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8087c9a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8087c9e:	6921      	ldr	r1, [r4, #16]
 8087ca0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087ca4:	6893      	ldr	r3, [r2, #8]
 8087ca6:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8087caa:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8087cae:	6093      	str	r3, [r2, #8]
 8087cb0:	e7d8      	b.n	8087c64 <HAL_RCC_ClockConfig+0x114>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8087cb2:	039e      	lsls	r6, r3, #14
 8087cb4:	d495      	bmi.n	8087be2 <HAL_RCC_ClockConfig+0x92>
 8087cb6:	e7c3      	b.n	8087c40 <HAL_RCC_ClockConfig+0xf0>
        return HAL_TIMEOUT;
 8087cb8:	2003      	movs	r0, #3
 8087cba:	e7ec      	b.n	8087c96 <HAL_RCC_ClockConfig+0x146>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8087cbc:	0198      	lsls	r0, r3, #6
 8087cbe:	d490      	bmi.n	8087be2 <HAL_RCC_ClockConfig+0x92>
 8087cc0:	e7be      	b.n	8087c40 <HAL_RCC_ClockConfig+0xf0>
 8087cc2:	bf00      	nop

08087cc4 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8087cc4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087cc8:	f649 520c 	movw	r2, #40204	; 0x9d0c
  return SystemCoreClock;
 8087ccc:	f24b 3174 	movw	r1, #45940	; 0xb374
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8087cd0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087cd4:	f6c0 0209 	movt	r2, #2057	; 0x809
  return SystemCoreClock;
 8087cd8:	f2c2 0100 	movt	r1, #8192	; 0x2000
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8087cdc:	689b      	ldr	r3, [r3, #8]
 8087cde:	6808      	ldr	r0, [r1, #0]
 8087ce0:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8087ce4:	5cd3      	ldrb	r3, [r2, r3]
}
 8087ce6:	40d8      	lsrs	r0, r3
 8087ce8:	4770      	bx	lr
 8087cea:	bf00      	nop

08087cec <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8087cec:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8087cf0:	f649 520c 	movw	r2, #40204	; 0x9d0c
  return SystemCoreClock;
 8087cf4:	f24b 3174 	movw	r1, #45940	; 0xb374
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8087cf8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8087cfc:	f6c0 0209 	movt	r2, #2057	; 0x809
  return SystemCoreClock;
 8087d00:	f2c2 0100 	movt	r1, #8192	; 0x2000
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8087d04:	689b      	ldr	r3, [r3, #8]
 8087d06:	6808      	ldr	r0, [r1, #0]
 8087d08:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8087d0c:	5cd3      	ldrb	r3, [r2, r3]
}
 8087d0e:	40d8      	lsrs	r0, r3
 8087d10:	4770      	bx	lr
 8087d12:	bf00      	nop

08087d14 <HAL_RCC_GetClockConfig>:
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8087d14:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8087d18:	220f      	movs	r2, #15
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8087d1a:	f2c4 0302 	movt	r3, #16386	; 0x4002
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8087d1e:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8087d20:	689a      	ldr	r2, [r3, #8]
 8087d22:	f002 0203 	and.w	r2, r2, #3
 8087d26:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8087d28:	689a      	ldr	r2, [r3, #8]
 8087d2a:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8087d2e:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 8087d30:	689a      	ldr	r2, [r3, #8]
 8087d32:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 8087d36:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8087d38:	689b      	ldr	r3, [r3, #8]
{
 8087d3a:	b410      	push	{r4}
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8087d3c:	08db      	lsrs	r3, r3, #3

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8087d3e:	f44f 5470 	mov.w	r4, #15360	; 0x3c00
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8087d42:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8087d46:	f2c4 0402 	movt	r4, #16386	; 0x4002
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8087d4a:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8087d4c:	6823      	ldr	r3, [r4, #0]
}
 8087d4e:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8087d52:	f003 030f 	and.w	r3, r3, #15
 8087d56:	600b      	str	r3, [r1, #0]
}
 8087d58:	4770      	bx	lr
 8087d5a:	bf00      	nop

08087d5c <HAL_RCCEx_PeriphCLKConfig>:
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8087d5c:	6803      	ldr	r3, [r0, #0]
{
 8087d5e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8087d62:	f013 0601 	ands.w	r6, r3, #1
{
 8087d66:	b083      	sub	sp, #12
 8087d68:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8087d6a:	d00e      	beq.n	8087d8a <HAL_RCCEx_PeriphCLKConfig+0x2e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    
    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8087d6c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8087d70:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087d74:	6891      	ldr	r1, [r2, #8]
 8087d76:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 8087d7a:	6091      	str	r1, [r2, #8]
 8087d7c:	6b46      	ldr	r6, [r0, #52]	; 0x34
 8087d7e:	6891      	ldr	r1, [r2, #8]
 8087d80:	4331      	orrs	r1, r6
    
    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8087d82:	fab6 f686 	clz	r6, r6
 8087d86:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8087d88:	6091      	str	r1, [r2, #8]
      plli2sused = 1; 
    }
  }
  
  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8087d8a:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
 8087d8e:	d013      	beq.n	8087db8 <HAL_RCCEx_PeriphCLKConfig+0x5c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
    
    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8087d90:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087d94:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8087d96:	f2c4 0102 	movt	r1, #16386	; 0x4002
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8087d9a:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8087d9e:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8087da2:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8087da6:	ea42 0205 	orr.w	r2, r2, r5
 8087daa:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8087dae:	f000 8200 	beq.w	80881b2 <HAL_RCCEx_PeriphCLKConfig+0x456>
    {
      plli2sused = 1; 
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8087db2:	fab5 f585 	clz	r5, r5
 8087db6:	096d      	lsrs	r5, r5, #5
      pllsaiused = 1; 
    }
  }
  
  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8087db8:	02d9      	lsls	r1, r3, #11
 8087dba:	d513      	bpl.n	8087de4 <HAL_RCCEx_PeriphCLKConfig+0x88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
    
    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8087dbc:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087dc0:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8087dc2:	f2c4 0102 	movt	r1, #16386	; 0x4002
    
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8087dc6:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8087dca:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8087dce:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8087dd2:	ea42 0200 	orr.w	r2, r2, r0
 8087dd6:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8087dda:	f000 81e8 	beq.w	80881ae <HAL_RCCEx_PeriphCLKConfig+0x452>
      plli2sused = 1; 
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1; 
 8087dde:	2800      	cmp	r0, #0
 8087de0:	bf08      	it	eq
 8087de2:	2501      	moveq	r5, #1
  }
  
  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {    
      plli2sused = 1; 
 8087de4:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8087de8:	bf18      	it	ne
 8087dea:	2601      	movne	r6, #1
  }  
  
  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8087dec:	069a      	lsls	r2, r3, #26
 8087dee:	f100 8187 	bmi.w	8088100 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8087df2:	06d9      	lsls	r1, r3, #27
 8087df4:	d50f      	bpl.n	8087e16 <HAL_RCCEx_PeriphCLKConfig+0xba>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    
    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8087df6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8087dfa:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8087dfe:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8087e02:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 8087e06:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8087e0a:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8087e0e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8087e10:	4301      	orrs	r1, r0
 8087e12:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }
  
  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8087e16:	045a      	lsls	r2, r3, #17
 8087e18:	d50b      	bpl.n	8087e32 <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8087e1a:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087e1e:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8087e20:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087e24:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087e28:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8087e2c:	4302      	orrs	r2, r0
 8087e2e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8087e32:	041f      	lsls	r7, r3, #16
 8087e34:	d50b      	bpl.n	8087e4e <HAL_RCCEx_PeriphCLKConfig+0xf2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8087e36:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087e3a:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8087e3c:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087e40:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087e44:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8087e48:	4302      	orrs	r2, r0
 8087e4a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8087e4e:	03d8      	lsls	r0, r3, #15
 8087e50:	d50b      	bpl.n	8087e6a <HAL_RCCEx_PeriphCLKConfig+0x10e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8087e52:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087e56:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8087e58:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087e5c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087e60:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8087e64:	4302      	orrs	r2, r0
 8087e66:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
    
  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8087e6a:	0399      	lsls	r1, r3, #14
 8087e6c:	d50b      	bpl.n	8087e86 <HAL_RCCEx_PeriphCLKConfig+0x12a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    
    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8087e6e:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087e72:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8087e74:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087e78:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087e7c:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8087e80:	4302      	orrs	r2, r0
 8087e82:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8087e86:	065a      	lsls	r2, r3, #25
 8087e88:	d50b      	bpl.n	8087ea2 <HAL_RCCEx_PeriphCLKConfig+0x146>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8087e8a:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087e8e:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8087e90:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087e94:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087e98:	f022 0203 	bic.w	r2, r2, #3
 8087e9c:	4302      	orrs	r2, r0
 8087e9e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8087ea2:	061f      	lsls	r7, r3, #24
 8087ea4:	d50b      	bpl.n	8087ebe <HAL_RCCEx_PeriphCLKConfig+0x162>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8087ea6:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087eaa:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8087eac:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087eb0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087eb4:	f022 020c 	bic.w	r2, r2, #12
 8087eb8:	4302      	orrs	r2, r0
 8087eba:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8087ebe:	05d8      	lsls	r0, r3, #23
 8087ec0:	d50b      	bpl.n	8087eda <HAL_RCCEx_PeriphCLKConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8087ec2:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087ec6:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8087ec8:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087ecc:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087ed0:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8087ed4:	4302      	orrs	r2, r0
 8087ed6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8087eda:	0599      	lsls	r1, r3, #22
 8087edc:	d50b      	bpl.n	8087ef6 <HAL_RCCEx_PeriphCLKConfig+0x19a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    
    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8087ede:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087ee2:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8087ee4:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087ee8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087eec:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8087ef0:	4302      	orrs	r2, r0
 8087ef2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8087ef6:	055a      	lsls	r2, r3, #21
 8087ef8:	d50b      	bpl.n	8087f12 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    
    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8087efa:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087efe:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8087f00:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087f04:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087f08:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8087f0c:	4302      	orrs	r2, r0
 8087f0e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8087f12:	051f      	lsls	r7, r3, #20
 8087f14:	d50b      	bpl.n	8087f2e <HAL_RCCEx_PeriphCLKConfig+0x1d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
    
    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8087f16:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087f1a:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8087f1c:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087f20:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087f24:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8087f28:	4302      	orrs	r2, r0
 8087f2a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8087f2e:	04d8      	lsls	r0, r3, #19
 8087f30:	d50b      	bpl.n	8087f4a <HAL_RCCEx_PeriphCLKConfig+0x1ee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
    
    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8087f32:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087f36:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8087f38:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087f3c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087f40:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8087f44:	4302      	orrs	r2, r0
 8087f46:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8087f4a:	0499      	lsls	r1, r3, #18
 8087f4c:	d50b      	bpl.n	8087f66 <HAL_RCCEx_PeriphCLKConfig+0x20a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
    
    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8087f4e:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087f52:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8087f54:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087f58:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087f5c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8087f60:	4302      	orrs	r2, r0
 8087f62:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8087f66:	025a      	lsls	r2, r3, #9
 8087f68:	d50b      	bpl.n	8087f82 <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8087f6a:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087f6e:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8087f70:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087f74:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087f78:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8087f7c:	4302      	orrs	r2, r0
 8087f7e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8087f82:	029f      	lsls	r7, r3, #10
 8087f84:	d50f      	bpl.n	8087fa6 <HAL_RCCEx_PeriphCLKConfig+0x24a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));
    
    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8087f86:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087f8a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8087f8c:	f2c4 0102 	movt	r1, #16386	; 0x4002

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1; 
 8087f90:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8087f94:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
      pllsaiused = 1; 
 8087f98:	bf08      	it	eq
 8087f9a:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8087f9c:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
 8087fa0:	4302      	orrs	r2, r0
 8087fa2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1; 
 8087fa6:	f013 0f08 	tst.w	r3, #8
 8087faa:	bf18      	it	ne
 8087fac:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8087fae:	0358      	lsls	r0, r3, #13
 8087fb0:	d50b      	bpl.n	8087fca <HAL_RCCEx_PeriphCLKConfig+0x26e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    
    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8087fb2:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087fb6:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8087fb8:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087fbc:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087fc0:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8087fc4:	4302      	orrs	r2, r0
 8087fc6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }
  
  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8087fca:	0219      	lsls	r1, r3, #8
 8087fcc:	d40b      	bmi.n	8087fe6 <HAL_RCCEx_PeriphCLKConfig+0x28a>
  }  
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8087fce:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8087fd2:	d019      	beq.n	8088008 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
 8087fd4:	07f2      	lsls	r2, r6, #31
 8087fd6:	d417      	bmi.n	8088008 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
    }
  } 
  
  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8087fd8:	2d01      	cmp	r5, #1
 8087fda:	f000 80ed 	beq.w	80881b8 <HAL_RCCEx_PeriphCLKConfig+0x45c>
        /* return in case of Timeout detected */        
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8087fde:	2000      	movs	r0, #0
}
 8087fe0:	b003      	add	sp, #12
 8087fe2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8087fe6:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 8087fea:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8087fee:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8087ff2:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8087ff6:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8087ffa:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8087ffe:	ea42 0200 	orr.w	r2, r2, r0
 8088002:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8088006:	d1e5      	bne.n	8087fd4 <HAL_RCCEx_PeriphCLKConfig+0x278>
    __HAL_RCC_PLLI2S_DISABLE();  
 8088008:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 808800c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8088010:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8088012:	461e      	mov	r6, r3
    __HAL_RCC_PLLI2S_DISABLE();  
 8088014:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8088018:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 808801a:	f7fd fbc9 	bl	80857b0 <HAL_GetTick>
 808801e:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8088020:	e004      	b.n	808802c <HAL_RCCEx_PeriphCLKConfig+0x2d0>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8088022:	f7fd fbc5 	bl	80857b0 <HAL_GetTick>
 8088026:	1bc0      	subs	r0, r0, r7
 8088028:	2864      	cmp	r0, #100	; 0x64
 808802a:	d865      	bhi.n	80880f8 <HAL_RCCEx_PeriphCLKConfig+0x39c>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 808802c:	6833      	ldr	r3, [r6, #0]
 808802e:	011b      	lsls	r3, r3, #4
 8088030:	d4f7      	bmi.n	8088022 <HAL_RCCEx_PeriphCLKConfig+0x2c6>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8088032:	6823      	ldr	r3, [r4, #0]
 8088034:	07df      	lsls	r7, r3, #31
 8088036:	d512      	bpl.n	808805e <HAL_RCCEx_PeriphCLKConfig+0x302>
 8088038:	6b62      	ldr	r2, [r4, #52]	; 0x34
 808803a:	b982      	cbnz	r2, 808805e <HAL_RCCEx_PeriphCLKConfig+0x302>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 808803c:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8088040:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8088044:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8088048:	6860      	ldr	r0, [r4, #4]
 808804a:	f007 6770 	and.w	r7, r7, #251658240	; 0xf000000
 808804e:	68a1      	ldr	r1, [r4, #8]
 8088050:	433a      	orrs	r2, r7
 8088052:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8088056:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 808805a:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 808805e:	031e      	lsls	r6, r3, #12
 8088060:	f100 8137 	bmi.w	80882d2 <HAL_RCCEx_PeriphCLKConfig+0x576>
 8088064:	02d8      	lsls	r0, r3, #11
 8088066:	d504      	bpl.n	8088072 <HAL_RCCEx_PeriphCLKConfig+0x316>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S))) 
 8088068:	6c22      	ldr	r2, [r4, #64]	; 0x40
 808806a:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 808806e:	f000 8135 	beq.w	80882dc <HAL_RCCEx_PeriphCLKConfig+0x580>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8088072:	01d9      	lsls	r1, r3, #7
 8088074:	d514      	bpl.n	80880a0 <HAL_RCCEx_PeriphCLKConfig+0x344>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8088076:	f44f 5660 	mov.w	r6, #14336	; 0x3800
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 808807a:	6860      	ldr	r0, [r4, #4]
 808807c:	6921      	ldr	r1, [r4, #16]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 808807e:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8088082:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8088086:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 808808a:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 808808e:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 8088092:	433a      	orrs	r2, r7
 8088094:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8088098:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 808809c:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 80880a0:	019a      	lsls	r2, r3, #6
 80880a2:	d510      	bpl.n	80880c6 <HAL_RCCEx_PeriphCLKConfig+0x36a>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 80880a4:	6923      	ldr	r3, [r4, #16]
 80880a6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80880aa:	6861      	ldr	r1, [r4, #4]
 80880ac:	041b      	lsls	r3, r3, #16
 80880ae:	68e0      	ldr	r0, [r4, #12]
 80880b0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80880b4:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 80880b8:	68a1      	ldr	r1, [r4, #8]
 80880ba:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 80880be:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 80880c2:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 80880c6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80880ca:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80880ce:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80880d0:	461e      	mov	r6, r3
    __HAL_RCC_PLLI2S_ENABLE();
 80880d2:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80880d6:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80880d8:	f7fd fb6a 	bl	80857b0 <HAL_GetTick>
 80880dc:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80880de:	e004      	b.n	80880ea <HAL_RCCEx_PeriphCLKConfig+0x38e>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 80880e0:	f7fd fb66 	bl	80857b0 <HAL_GetTick>
 80880e4:	1bc0      	subs	r0, r0, r7
 80880e6:	2864      	cmp	r0, #100	; 0x64
 80880e8:	d806      	bhi.n	80880f8 <HAL_RCCEx_PeriphCLKConfig+0x39c>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80880ea:	6833      	ldr	r3, [r6, #0]
 80880ec:	011b      	lsls	r3, r3, #4
 80880ee:	d5f7      	bpl.n	80880e0 <HAL_RCCEx_PeriphCLKConfig+0x384>
  if(pllsaiused == 1)
 80880f0:	2d01      	cmp	r5, #1
 80880f2:	f47f af74 	bne.w	8087fde <HAL_RCCEx_PeriphCLKConfig+0x282>
 80880f6:	e05f      	b.n	80881b8 <HAL_RCCEx_PeriphCLKConfig+0x45c>
        return HAL_TIMEOUT;
 80880f8:	2003      	movs	r0, #3
}
 80880fa:	b003      	add	sp, #12
 80880fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8088100:	f44f 5260 	mov.w	r2, #14336	; 0x3800
    PWR->CR1 |= PWR_CR1_DBP;
 8088104:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    __HAL_RCC_PWR_CLK_ENABLE();
 8088108:	f2c4 0202 	movt	r2, #16386	; 0x4002
    PWR->CR1 |= PWR_CR1_DBP;
 808810c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    __HAL_RCC_PWR_CLK_ENABLE();
 8088110:	6c11      	ldr	r1, [r2, #64]	; 0x40
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8088112:	461f      	mov	r7, r3
    __HAL_RCC_PWR_CLK_ENABLE();
 8088114:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8088118:	6411      	str	r1, [r2, #64]	; 0x40
 808811a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 808811c:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8088120:	9201      	str	r2, [sp, #4]
 8088122:	9a01      	ldr	r2, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8088124:	681a      	ldr	r2, [r3, #0]
 8088126:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 808812a:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 808812c:	f7fd fb40 	bl	80857b0 <HAL_GetTick>
 8088130:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8088132:	e005      	b.n	8088140 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8088134:	f7fd fb3c 	bl	80857b0 <HAL_GetTick>
 8088138:	eba0 0008 	sub.w	r0, r0, r8
 808813c:	2864      	cmp	r0, #100	; 0x64
 808813e:	d8db      	bhi.n	80880f8 <HAL_RCCEx_PeriphCLKConfig+0x39c>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8088140:	683b      	ldr	r3, [r7, #0]
 8088142:	05db      	lsls	r3, r3, #23
 8088144:	d5f6      	bpl.n	8088134 <HAL_RCCEx_PeriphCLKConfig+0x3d8>
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8088146:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808814a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 808814c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8088150:	f403 7040 	and.w	r0, r3, #768	; 0x300
 8088154:	6f11      	ldr	r1, [r2, #112]	; 0x70
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8088156:	f411 7140 	ands.w	r1, r1, #768	; 0x300
 808815a:	d011      	beq.n	8088180 <HAL_RCCEx_PeriphCLKConfig+0x424>
 808815c:	4288      	cmp	r0, r1
 808815e:	d00f      	beq.n	8088180 <HAL_RCCEx_PeriphCLKConfig+0x424>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8088160:	6f11      	ldr	r1, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8088162:	6f17      	ldr	r7, [r2, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8088164:	f421 7140 	bic.w	r1, r1, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8088168:	f447 3780 	orr.w	r7, r7, #65536	; 0x10000
 808816c:	6717      	str	r7, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 808816e:	6f17      	ldr	r7, [r2, #112]	; 0x70
 8088170:	f427 3780 	bic.w	r7, r7, #65536	; 0x10000
 8088174:	6717      	str	r7, [r2, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 8088176:	6711      	str	r1, [r2, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8088178:	6f11      	ldr	r1, [r2, #112]	; 0x70
 808817a:	07cf      	lsls	r7, r1, #31
 808817c:	f100 80e1 	bmi.w	8088342 <HAL_RCCEx_PeriphCLKConfig+0x5e6>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8088180:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
 8088184:	f000 80c9 	beq.w	808831a <HAL_RCCEx_PeriphCLKConfig+0x5be>
 8088188:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808818c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8088190:	6891      	ldr	r1, [r2, #8]
 8088192:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8088196:	6091      	str	r1, [r2, #8]
 8088198:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808819c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80881a0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80881a4:	6f11      	ldr	r1, [r2, #112]	; 0x70
 80881a6:	430b      	orrs	r3, r1
 80881a8:	6713      	str	r3, [r2, #112]	; 0x70
 80881aa:	6823      	ldr	r3, [r4, #0]
 80881ac:	e621      	b.n	8087df2 <HAL_RCCEx_PeriphCLKConfig+0x96>
      plli2sused = 1; 
 80881ae:	2601      	movs	r6, #1
 80881b0:	e618      	b.n	8087de4 <HAL_RCCEx_PeriphCLKConfig+0x88>
  uint32_t pllsaiused = 0;
 80881b2:	2500      	movs	r5, #0
      plli2sused = 1; 
 80881b4:	2601      	movs	r6, #1
 80881b6:	e5ff      	b.n	8087db8 <HAL_RCCEx_PeriphCLKConfig+0x5c>
    __HAL_RCC_PLLSAI_DISABLE(); 
 80881b8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80881bc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80881c0:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80881c2:	461d      	mov	r5, r3
    __HAL_RCC_PLLSAI_DISABLE(); 
 80881c4:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 80881c8:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80881ca:	f7fd faf1 	bl	80857b0 <HAL_GetTick>
 80881ce:	4606      	mov	r6, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80881d0:	e004      	b.n	80881dc <HAL_RCCEx_PeriphCLKConfig+0x480>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 80881d2:	f7fd faed 	bl	80857b0 <HAL_GetTick>
 80881d6:	1b80      	subs	r0, r0, r6
 80881d8:	2864      	cmp	r0, #100	; 0x64
 80881da:	d88d      	bhi.n	80880f8 <HAL_RCCEx_PeriphCLKConfig+0x39c>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80881dc:	682b      	ldr	r3, [r5, #0]
 80881de:	009f      	lsls	r7, r3, #2
 80881e0:	d4f7      	bmi.n	80881d2 <HAL_RCCEx_PeriphCLKConfig+0x476>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80881e2:	6823      	ldr	r3, [r4, #0]
 80881e4:	031d      	lsls	r5, r3, #12
 80881e6:	f100 80a7 	bmi.w	8088338 <HAL_RCCEx_PeriphCLKConfig+0x5dc>
 80881ea:	02d8      	lsls	r0, r3, #11
 80881ec:	d520      	bpl.n	8088230 <HAL_RCCEx_PeriphCLKConfig+0x4d4>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 80881ee:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80881f0:	b9f2      	cbnz	r2, 8088230 <HAL_RCCEx_PeriphCLKConfig+0x4d4>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80881f2:	f44f 5160 	mov.w	r1, #14336	; 0x3800
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 80881f6:	6965      	ldr	r5, [r4, #20]
 80881f8:	69a0      	ldr	r0, [r4, #24]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80881fa:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80881fe:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8088202:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8088206:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 808820a:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 808820e:	4332      	orrs	r2, r6
 8088210:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 8088214:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8088218:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 808821c:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 8088220:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8088222:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 8088226:	3801      	subs	r0, #1
 8088228:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 808822c:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8088230:	0299      	lsls	r1, r3, #10
 8088232:	d518      	bpl.n	8088266 <HAL_RCCEx_PeriphCLKConfig+0x50a>
 8088234:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8088236:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 808823a:	d114      	bne.n	8088266 <HAL_RCCEx_PeriphCLKConfig+0x50a>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 808823c:	f44f 5160 	mov.w	r1, #14336	; 0x3800
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8088240:	6965      	ldr	r5, [r4, #20]
 8088242:	6a20      	ldr	r0, [r4, #32]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8088244:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8088248:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 808824c:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8088250:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8088254:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 8088258:	4332      	orrs	r2, r6
 808825a:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 808825e:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8088262:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8088266:	071a      	lsls	r2, r3, #28
 8088268:	d51c      	bpl.n	80882a4 <HAL_RCCEx_PeriphCLKConfig+0x548>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 808826a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 808826e:	6965      	ldr	r5, [r4, #20]
 8088270:	69e0      	ldr	r0, [r4, #28]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8088272:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8088276:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 808827a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 808827e:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8088282:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8088286:	430b      	orrs	r3, r1
 8088288:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 808828c:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
 8088290:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8088294:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8088298:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 808829a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 808829e:	430b      	orrs	r3, r1
 80882a0:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 80882a4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80882a8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80882ac:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80882ae:	461c      	mov	r4, r3
    __HAL_RCC_PLLSAI_ENABLE();
 80882b0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80882b4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80882b6:	f7fd fa7b 	bl	80857b0 <HAL_GetTick>
 80882ba:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80882bc:	e005      	b.n	80882ca <HAL_RCCEx_PeriphCLKConfig+0x56e>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 80882be:	f7fd fa77 	bl	80857b0 <HAL_GetTick>
 80882c2:	1b40      	subs	r0, r0, r5
 80882c4:	2864      	cmp	r0, #100	; 0x64
 80882c6:	f63f af17 	bhi.w	80880f8 <HAL_RCCEx_PeriphCLKConfig+0x39c>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80882ca:	6823      	ldr	r3, [r4, #0]
 80882cc:	009b      	lsls	r3, r3, #2
 80882ce:	d5f6      	bpl.n	80882be <HAL_RCCEx_PeriphCLKConfig+0x562>
 80882d0:	e685      	b.n	8087fde <HAL_RCCEx_PeriphCLKConfig+0x282>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 80882d2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80882d4:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 80882d8:	f47f aec4 	bne.w	8088064 <HAL_RCCEx_PeriphCLKConfig+0x308>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 80882dc:	f44f 5660 	mov.w	r6, #14336	; 0x3800
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 80882e0:	6860      	ldr	r0, [r4, #4]
 80882e2:	68e1      	ldr	r1, [r4, #12]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 80882e4:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80882e8:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80882ec:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 80882f0:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80882f4:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 80882f8:	433a      	orrs	r2, r7
 80882fa:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 80882fe:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8088302:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);   
 8088306:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
 808830a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 808830c:	f021 011f 	bic.w	r1, r1, #31
 8088310:	3a01      	subs	r2, #1
 8088312:	430a      	orrs	r2, r1
 8088314:	f8c6 208c 	str.w	r2, [r6, #140]	; 0x8c
 8088318:	e6ab      	b.n	8088072 <HAL_RCCEx_PeriphCLKConfig+0x316>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 808831a:	f44f 5060 	mov.w	r0, #14336	; 0x3800
 808831e:	f64f 41ff 	movw	r1, #64767	; 0xfcff
 8088322:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8088326:	f6c0 71ff 	movt	r1, #4095	; 0xfff
 808832a:	6882      	ldr	r2, [r0, #8]
 808832c:	4019      	ands	r1, r3
 808832e:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8088332:	430a      	orrs	r2, r1
 8088334:	6082      	str	r2, [r0, #8]
 8088336:	e72f      	b.n	8088198 <HAL_RCCEx_PeriphCLKConfig+0x43c>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8088338:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 808833a:	2a00      	cmp	r2, #0
 808833c:	f43f af59 	beq.w	80881f2 <HAL_RCCEx_PeriphCLKConfig+0x496>
 8088340:	e753      	b.n	80881ea <HAL_RCCEx_PeriphCLKConfig+0x48e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8088342:	4617      	mov	r7, r2
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8088344:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8088348:	f7fd fa32 	bl	80857b0 <HAL_GetTick>
 808834c:	4681      	mov	r9, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 808834e:	e006      	b.n	808835e <HAL_RCCEx_PeriphCLKConfig+0x602>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8088350:	f7fd fa2e 	bl	80857b0 <HAL_GetTick>
 8088354:	eba0 0009 	sub.w	r0, r0, r9
 8088358:	4540      	cmp	r0, r8
 808835a:	f63f aecd 	bhi.w	80880f8 <HAL_RCCEx_PeriphCLKConfig+0x39c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 808835e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8088360:	0798      	lsls	r0, r3, #30
 8088362:	d5f5      	bpl.n	8088350 <HAL_RCCEx_PeriphCLKConfig+0x5f4>
 8088364:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8088366:	f403 7040 	and.w	r0, r3, #768	; 0x300
 808836a:	e709      	b.n	8088180 <HAL_RCCEx_PeriphCLKConfig+0x424>

0808836c <HAL_RCCEx_GetPeriphCLKConfig>:
                                        RCC_PERIPHCLK_USART6   | RCC_PERIPHCLK_UART7    |\
                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\
                                        RCC_PERIPHCLK_CLK48    | RCC_PERIPHCLK_SDMMC2   |\
                                        RCC_PERIPHCLK_DFSDM1   | RCC_PERIPHCLK_DFSDM1_AUDIO;
#else  
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\
 808836c:	f64f 72f1 	movw	r2, #65521	; 0xfff1
                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\
                                        RCC_PERIPHCLK_CLK48;
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */ 
  
  /* Get the PLLI2S Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
 8088370:	f44f 5360 	mov.w	r3, #14336	; 0x3800
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\
 8088374:	f2c0 02ff 	movt	r2, #255	; 0xff
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
 8088378:	f2c4 0302 	movt	r3, #16386	; 0x4002
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\
 808837c:	6002      	str	r2, [r0, #0]
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
 808837e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8088382:	f3c2 1288 	ubfx	r2, r2, #6, #9
 8088386:	6042      	str	r2, [r0, #4]
  PeriphClkInit->PLLI2S.PLLI2SP = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8088388:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 808838c:	f3c2 4201 	ubfx	r2, r2, #16, #2
 8088390:	6102      	str	r2, [r0, #16]
  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8088392:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8088396:	f3c2 6203 	ubfx	r2, r2, #24, #4
 808839a:	60c2      	str	r2, [r0, #12]
  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 808839c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 80883a0:	f3c2 7202 	ubfx	r2, r2, #28, #3
 80883a4:	6082      	str	r2, [r0, #8]
  
  /* Get the PLLSAI Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);
 80883a6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80883aa:	f3c2 1288 	ubfx	r2, r2, #6, #9
 80883ae:	6142      	str	r2, [r0, #20]
  PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80883b0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80883b4:	f3c2 4201 	ubfx	r2, r2, #16, #2
 80883b8:	6202      	str	r2, [r0, #32]
  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos); 
 80883ba:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80883be:	f3c2 6203 	ubfx	r2, r2, #24, #4
 80883c2:	6182      	str	r2, [r0, #24]
  PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos); 
 80883c4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80883c8:	f3c2 7202 	ubfx	r2, r2, #28, #3
 80883cc:	61c2      	str	r2, [r0, #28]
  
  /* Get the PLLSAI/PLLI2S division factors -------------------------------------------*/
  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) >> RCC_DCKCFGR1_PLLI2SDIVQ_Pos);
 80883ce:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80883d2:	f002 021f 	and.w	r2, r2, #31
 80883d6:	6242      	str	r2, [r0, #36]	; 0x24
  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> RCC_DCKCFGR1_PLLSAIDIVQ_Pos);
 80883d8:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80883dc:	f3c2 2204 	ubfx	r2, r2, #8, #5
 80883e0:	6282      	str	r2, [r0, #40]	; 0x28
  PeriphClkInit->PLLSAIDivR = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVR) >> RCC_DCKCFGR1_PLLSAIDIVR_Pos);
 80883e2:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80883e6:	f3c2 4201 	ubfx	r2, r2, #16, #2
 80883ea:	62c2      	str	r2, [r0, #44]	; 0x2c

  /* Get the SAI1 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();
 80883ec:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80883f0:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 80883f4:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Get the SAI2 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();
 80883f6:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80883fa:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
 80883fe:	6402      	str	r2, [r0, #64]	; 0x40
  
  /* Get the I2S clock configuration ------------------------------------------*/
  PeriphClkInit->I2sClockSelection = __HAL_RCC_GET_I2SCLKSOURCE();
 8088400:	689a      	ldr	r2, [r3, #8]
 8088402:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
 8088406:	6342      	str	r2, [r0, #52]	; 0x34
  
  /* Get the I2C1 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
 8088408:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 808840c:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8088410:	6642      	str	r2, [r0, #100]	; 0x64
  
  /* Get the I2C2 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();
 8088412:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088416:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 808841a:	6682      	str	r2, [r0, #104]	; 0x68
  
  /* Get the I2C3 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();
 808841c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088420:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 8088424:	66c2      	str	r2, [r0, #108]	; 0x6c
  
  /* Get the I2C4 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c4ClockSelection = __HAL_RCC_GET_I2C4_SOURCE();
 8088426:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 808842a:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
 808842e:	6702      	str	r2, [r0, #112]	; 0x70
  
  /* Get the USART1 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
 8088430:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088434:	f002 0203 	and.w	r2, r2, #3
 8088438:	6442      	str	r2, [r0, #68]	; 0x44
  
  /* Get the USART2 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
 808843a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 808843e:	f002 020c 	and.w	r2, r2, #12
 8088442:	6482      	str	r2, [r0, #72]	; 0x48
  
  /* Get the USART3 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
 8088444:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088448:	f002 0230 	and.w	r2, r2, #48	; 0x30
 808844c:	64c2      	str	r2, [r0, #76]	; 0x4c
  
  /* Get the UART4 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();
 808844e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088452:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 8088456:	6502      	str	r2, [r0, #80]	; 0x50
  
  /* Get the UART5 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();
 8088458:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 808845c:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8088460:	6542      	str	r2, [r0, #84]	; 0x54
  
  /* Get the USART6 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();
 8088462:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088466:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 808846a:	6582      	str	r2, [r0, #88]	; 0x58
  
  /* Get the UART7 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();
 808846c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088470:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8088474:	65c2      	str	r2, [r0, #92]	; 0x5c
  
  /* Get the UART8 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();
 8088476:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 808847a:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 808847e:	6602      	str	r2, [r0, #96]	; 0x60
  
  /* Get the LPTIM1 clock configuration ------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();
 8088480:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088484:	f002 7240 	and.w	r2, r2, #50331648	; 0x3000000
 8088488:	6742      	str	r2, [r0, #116]	; 0x74
  
  /* Get the CEC clock configuration -----------------------------------------------*/
  PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
 808848a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 808848e:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 8088492:	6782      	str	r2, [r0, #120]	; 0x78
  
  /* Get the CK48 clock configuration -----------------------------------------------*/
  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();
 8088494:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8088498:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 808849c:	67c2      	str	r2, [r0, #124]	; 0x7c

  /* Get the SDMMC1 clock configuration -----------------------------------------------*/
  PeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();
 808849e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80884a2:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 80884a6:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
  /* Get the DFSDM AUDIO clock configuration -----------------------------------------------*/
  PeriphClkInit->Dfsdm1AudioClockSelection = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();  
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /* Get the RTC Clock configuration -----------------------------------------------*/
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
 80884aa:	6899      	ldr	r1, [r3, #8]
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
 80884ac:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
 80884ae:	f401 11f8 	and.w	r1, r1, #2031616	; 0x1f0000
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
 80884b2:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80884b6:	430a      	orrs	r2, r1
 80884b8:	6302      	str	r2, [r0, #48]	; 0x30
  
  /* Get the TIM Prescaler configuration --------------------------------------------*/
  if ((RCC->DCKCFGR1 & RCC_DCKCFGR1_TIMPRE) == RESET)
 80884ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80884be:	f013 7380 	ands.w	r3, r3, #16777216	; 0x1000000
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
 80884c2:	bf18      	it	ne
 80884c4:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 80884c8:	6383      	str	r3, [r0, #56]	; 0x38
  }
}
 80884ca:	4770      	bx	lr

080884cc <HAL_RCCEx_GetPeriphCLKFreq>:
  /* This variable is used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
  /* This variable is used to store the SAI clock source */
  uint32_t saiclocksource = 0;
  
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 80884cc:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 80884d0:	d013      	beq.n	80884fa <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
        break;
      }
    }
  }
  
  if (PeriphClk == RCC_PERIPHCLK_SAI2)
 80884d2:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 80884d6:	d10e      	bne.n	80884f6 <HAL_RCCEx_GetPeriphCLKFreq+0x2a>
  {
    saiclocksource = RCC->DCKCFGR1;   
 80884d8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80884dc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80884e0:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
 80884e4:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
    switch (saiclocksource)
 80884e8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80884ec:	d03d      	beq.n	808856a <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
 80884ee:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80884f2:	d010      	beq.n	8088516 <HAL_RCCEx_GetPeriphCLKFreq+0x4a>
 80884f4:	b1a3      	cbz	r3, 8088520 <HAL_RCCEx_GetPeriphCLKFreq+0x54>
    default :
      {
        break;
      }
    }
  }
 80884f6:	2000      	movs	r0, #0
 80884f8:	4770      	bx	lr
    saiclocksource = RCC->DCKCFGR1;   
 80884fa:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80884fe:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8088502:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
 8088506:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
    switch (saiclocksource)
 808850a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 808850e:	d02c      	beq.n	808856a <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
 8088510:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8088514:	d1ee      	bne.n	80884f4 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
        frequency = EXTERNAL_CLOCK_VALUE;
 8088516:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 808851a:	f2c0 00bb 	movt	r0, #187	; 0xbb
  
  return frequency;
}
 808851e:	4770      	bx	lr
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8088520:	6853      	ldr	r3, [r2, #4]
 8088522:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8088526:	6853      	ldr	r3, [r2, #4]
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8088528:	d144      	bne.n	80885b4 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 808852a:	f44f 5010 	mov.w	r0, #9216	; 0x2400
 808852e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8088532:	f2c0 00f4 	movt	r0, #244	; 0xf4
 8088536:	fbb0 f0f3 	udiv	r0, r0, r3
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 808853a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 808853e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8088542:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 8088546:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 808854a:	f3c2 6203 	ubfx	r2, r2, #24, #4
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 808854e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 8088552:	f3c1 1188 	ubfx	r1, r1, #6, #9
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 8088556:	f3c3 2304 	ubfx	r3, r3, #8, #5
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 808855a:	fb00 f001 	mul.w	r0, r0, r1
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 808855e:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 8088560:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg); 
 8088564:	fbb0 f0f3 	udiv	r0, r0, r3
        break;       
 8088568:	4770      	bx	lr
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 808856a:	6853      	ldr	r3, [r2, #4]
 808856c:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8088570:	6853      	ldr	r3, [r2, #4]
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8088572:	d128      	bne.n	80885c6 <HAL_RCCEx_GetPeriphCLKFreq+0xfa>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8088574:	f44f 5010 	mov.w	r0, #9216	; 0x2400
 8088578:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 808857c:	f2c0 00f4 	movt	r0, #244	; 0xf4
 8088580:	fbb0 f0f3 	udiv	r0, r0, r3
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 8088584:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8088588:	f2c4 0302 	movt	r3, #16386	; 0x4002
 808858c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8088590:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 8088594:	f3c2 6203 	ubfx	r2, r2, #24, #4
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1); 
 8088598:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 808859c:	f3c1 1188 	ubfx	r1, r1, #6, #9
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1); 
 80885a0:	f003 031f 	and.w	r3, r3, #31
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 80885a4:	fb00 f001 	mul.w	r0, r0, r1
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1); 
 80885a8:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 80885aa:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg);
 80885ae:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 80885b2:	4770      	bx	lr
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 80885b4:	f647 0040 	movw	r0, #30784	; 0x7840
 80885b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80885bc:	f2c0 107d 	movt	r0, #381	; 0x17d
 80885c0:	fbb0 f0f3 	udiv	r0, r0, r3
 80885c4:	e7b9      	b.n	808853a <HAL_RCCEx_GetPeriphCLKFreq+0x6e>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 80885c6:	f647 0040 	movw	r0, #30784	; 0x7840
 80885ca:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80885ce:	f2c0 107d 	movt	r0, #381	; 0x17d
 80885d2:	fbb0 f0f3 	udiv	r0, r0, r3
 80885d6:	e7d5      	b.n	8088584 <HAL_RCCEx_GetPeriphCLKFreq+0xb8>

080885d8 <HAL_RNG_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{ 
  /* Check the RNG handle allocation */
  if(hrng == NULL)
 80885d8:	b1a0      	cbz	r0, 8088604 <HAL_RNG_Init+0x2c>
  {
    return HAL_ERROR;
  }

  if(hrng->State == HAL_RNG_STATE_RESET)
 80885da:	7a43      	ldrb	r3, [r0, #9]
{ 
 80885dc:	b510      	push	{r4, lr}
  if(hrng->State == HAL_RNG_STATE_RESET)
 80885de:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80885e2:	4604      	mov	r4, r0
 80885e4:	b153      	cbz	r3, 80885fc <HAL_RNG_Init+0x24>
  
  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 80885e6:	6822      	ldr	r2, [r4, #0]
  hrng->State = HAL_RNG_STATE_BUSY;
 80885e8:	2302      	movs	r3, #2

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 80885ea:	2101      	movs	r1, #1

  /* Return function status */
  return HAL_OK;
 80885ec:	2000      	movs	r0, #0
  hrng->State = HAL_RNG_STATE_BUSY;
 80885ee:	7263      	strb	r3, [r4, #9]
  __HAL_RNG_ENABLE(hrng);
 80885f0:	6813      	ldr	r3, [r2, #0]
 80885f2:	f043 0304 	orr.w	r3, r3, #4
 80885f6:	6013      	str	r3, [r2, #0]
  hrng->State = HAL_RNG_STATE_READY;
 80885f8:	7261      	strb	r1, [r4, #9]
}
 80885fa:	bd10      	pop	{r4, pc}
    hrng->Lock = HAL_UNLOCKED;
 80885fc:	7202      	strb	r2, [r0, #8]
    HAL_RNG_MspInit(hrng);
 80885fe:	f7fc fb61 	bl	8084cc4 <HAL_RNG_MspInit>
 8088602:	e7f0      	b.n	80885e6 <HAL_RNG_Init+0xe>
    return HAL_ERROR;
 8088604:	2001      	movs	r0, #1
}
 8088606:	4770      	bx	lr

08088608 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 8088608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart = 0U;    
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng); 
 808860a:	7a03      	ldrb	r3, [r0, #8]
 808860c:	2b01      	cmp	r3, #1
 808860e:	d009      	beq.n	8088624 <HAL_RNG_GenerateRandomNumber+0x1c>
 8088610:	4604      	mov	r4, r0
 8088612:	2001      	movs	r0, #1
 8088614:	460e      	mov	r6, r1
  
  /* Check RNG peripheral state */
  if(hrng->State == HAL_RNG_STATE_READY)
 8088616:	7a63      	ldrb	r3, [r4, #9]
  __HAL_LOCK(hrng); 
 8088618:	7220      	strb	r0, [r4, #8]
  if(hrng->State == HAL_RNG_STATE_READY)
 808861a:	4283      	cmp	r3, r0
 808861c:	d004      	beq.n	8088628 <HAL_RNG_GenerateRandomNumber+0x20>
  {
    status = HAL_ERROR;
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 808861e:	2300      	movs	r3, #0
 8088620:	7223      	strb	r3, [r4, #8]
  
  return status;
}
 8088622:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrng); 
 8088624:	2002      	movs	r0, #2
}
 8088626:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;  
 8088628:	2302      	movs	r3, #2
 808862a:	7263      	strb	r3, [r4, #9]
    tickstart = HAL_GetTick();
 808862c:	f7fd f8c0 	bl	80857b0 <HAL_GetTick>
 8088630:	4607      	mov	r7, r0
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8088632:	e004      	b.n	808863e <HAL_RNG_GenerateRandomNumber+0x36>
      if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 8088634:	f7fd f8bc 	bl	80857b0 <HAL_GetTick>
 8088638:	1bc0      	subs	r0, r0, r7
 808863a:	2802      	cmp	r0, #2
 808863c:	d80b      	bhi.n	8088656 <HAL_RNG_GenerateRandomNumber+0x4e>
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 808863e:	6822      	ldr	r2, [r4, #0]
 8088640:	6855      	ldr	r5, [r2, #4]
 8088642:	f015 0501 	ands.w	r5, r5, #1
 8088646:	d0f5      	beq.n	8088634 <HAL_RNG_GenerateRandomNumber+0x2c>
    hrng->RandomNumber = hrng->Instance->DR;
 8088648:	6893      	ldr	r3, [r2, #8]
    hrng->State = HAL_RNG_STATE_READY;
 808864a:	2201      	movs	r2, #1
  HAL_StatusTypeDef status = HAL_OK;
 808864c:	2000      	movs	r0, #0
    hrng->RandomNumber = hrng->Instance->DR;
 808864e:	6063      	str	r3, [r4, #4]
    *random32bit = hrng->RandomNumber;
 8088650:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
 8088652:	7262      	strb	r2, [r4, #9]
 8088654:	e7e3      	b.n	808861e <HAL_RNG_GenerateRandomNumber+0x16>
        hrng->State = HAL_RNG_STATE_ERROR;
 8088656:	2304      	movs	r3, #4
        __HAL_UNLOCK(hrng);
 8088658:	7225      	strb	r5, [r4, #8]
        return HAL_TIMEOUT;
 808865a:	2003      	movs	r0, #3
        hrng->State = HAL_RNG_STATE_ERROR;
 808865c:	7263      	strb	r3, [r4, #9]
}
 808865e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08088660 <HAL_SAI_MspInit>:
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_MspInit could be implemented in the user file
   */
}
 8088660:	4770      	bx	lr
 8088662:	bf00      	nop

08088664 <HAL_SAI_Init>:
  if(hsai == NULL)
 8088664:	2800      	cmp	r0, #0
 8088666:	f000 8115 	beq.w	8088894 <HAL_SAI_Init+0x230>
{
 808866a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hsai->State == HAL_SAI_STATE_RESET)
 808866c:	f890 307d 	ldrb.w	r3, [r0, #125]	; 0x7d
 8088670:	4604      	mov	r4, r0
 8088672:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8088676:	2b00      	cmp	r3, #0
 8088678:	f000 8107 	beq.w	808888a <HAL_SAI_Init+0x226>
  *                the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 808867c:	f24b 3174 	movw	r1, #45940	; 0xb374
  hsai->State = HAL_SAI_STATE_BUSY;
 8088680:	2202      	movs	r2, #2
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088682:	f64e 401b 	movw	r0, #60443	; 0xec1b
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 8088686:	6823      	ldr	r3, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088688:	f2c2 0100 	movt	r1, #8192	; 0x2000
  hsai->State = HAL_SAI_STATE_BUSY;
 808868c:	f884 207d 	strb.w	r2, [r4, #125]	; 0x7d
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088690:	f2c9 50cb 	movt	r0, #38347	; 0x95cb
 8088694:	680a      	ldr	r2, [r1, #0]
  __HAL_SAI_DISABLE(hsai);
 8088696:	6819      	ldr	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088698:	fba0 0202 	umull	r0, r2, r0, r2
  __HAL_SAI_DISABLE(hsai);
 808869c:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80886a0:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
 80886a2:	6019      	str	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80886a4:	0092      	lsls	r2, r2, #2
 80886a6:	e002      	b.n	80886ae <HAL_SAI_Init+0x4a>
      /* Update error code */
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
      status = HAL_TIMEOUT;
      break;
    }
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 80886a8:	6819      	ldr	r1, [r3, #0]
 80886aa:	03c8      	lsls	r0, r1, #15
 80886ac:	d508      	bpl.n	80886c0 <HAL_SAI_Init+0x5c>
    if (count-- == 0)
 80886ae:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
 80886b2:	d2f9      	bcs.n	80886a8 <HAL_SAI_Init+0x44>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 80886b4:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 80886b8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80886bc:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
  switch(hsai->Init.SynchroExt)
 80886c0:	68e2      	ldr	r2, [r4, #12]
 80886c2:	2a01      	cmp	r2, #1
 80886c4:	f000 80be 	beq.w	8088844 <HAL_SAI_Init+0x1e0>
  uint32_t tmpregisterGCR = 0;
 80886c8:	2a02      	cmp	r2, #2
  switch(hsai->Init.Synchro)
 80886ca:	68a2      	ldr	r2, [r4, #8]
  uint32_t tmpregisterGCR = 0;
 80886cc:	bf0c      	ite	eq
 80886ce:	2120      	moveq	r1, #32
 80886d0:	2100      	movne	r1, #0
  switch(hsai->Init.Synchro)
 80886d2:	2a02      	cmp	r2, #2
 80886d4:	f000 80bb 	beq.w	808884e <HAL_SAI_Init+0x1ea>
 80886d8:	2a03      	cmp	r2, #3
 80886da:	f000 80e6 	beq.w	80888aa <HAL_SAI_Init+0x246>
  uint32_t syncen_bits = 0;
 80886de:	2a01      	cmp	r2, #1
  if((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 80886e0:	f645 0204 	movw	r2, #22532	; 0x5804
 80886e4:	69e6      	ldr	r6, [r4, #28]
 80886e6:	f2c4 0201 	movt	r2, #16385	; 0x4001
  uint32_t syncen_bits = 0;
 80886ea:	bf0c      	ite	eq
 80886ec:	f44f 6580 	moveq.w	r5, #1024	; 0x400
 80886f0:	2500      	movne	r5, #0
  if((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 80886f2:	4293      	cmp	r3, r2
 80886f4:	f000 80b5 	beq.w	8088862 <HAL_SAI_Init+0x1fe>
 80886f8:	f645 0024 	movw	r0, #22564	; 0x5824
 80886fc:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8088700:	1a18      	subs	r0, r3, r0
 8088702:	fab0 f080 	clz	r0, r0
 8088706:	0940      	lsrs	r0, r0, #5
 8088708:	2800      	cmp	r0, #0
 808870a:	f040 80aa 	bne.w	8088862 <HAL_SAI_Init+0x1fe>
    SAI2->GCR = tmpregisterGCR;
 808870e:	f44f 42b8 	mov.w	r2, #23552	; 0x5c00
 8088712:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8088716:	6011      	str	r1, [r2, #0]
  if(hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 8088718:	2e00      	cmp	r6, #0
 808871a:	f000 80a8 	beq.w	808886e <HAL_SAI_Init+0x20a>
    if((hsai->Instance == SAI2_Block_A ) || (hsai->Instance == SAI2_Block_B ))
 808871e:	f645 4204 	movw	r2, #23556	; 0x5c04
 8088722:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8088726:	4293      	cmp	r3, r2
 8088728:	f000 80c4 	beq.w	80888b4 <HAL_SAI_Init+0x250>
 808872c:	f645 4224 	movw	r2, #23588	; 0x5c24
 8088730:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8088734:	4293      	cmp	r3, r2
 8088736:	f000 80bd 	beq.w	80888b4 <HAL_SAI_Init+0x250>
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 808873a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 808873e:	69e1      	ldr	r1, [r4, #28]
    hsai->Init.Mckdiv = tmpval / 10;
 8088740:	f64c 42cd 	movw	r2, #52429	; 0xcccd
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 8088744:	0249      	lsls	r1, r1, #9
 8088746:	0040      	lsls	r0, r0, #1
    hsai->Init.Mckdiv = tmpval / 10;
 8088748:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 808874c:	fbb0 f0f1 	udiv	r0, r0, r1
    hsai->Init.Mckdiv = tmpval / 10;
 8088750:	fba2 1200 	umull	r1, r2, r2, r0
 8088754:	08d6      	lsrs	r6, r2, #3
    if((tmpval % 10) > 8)
 8088756:	eb06 0286 	add.w	r2, r6, r6, lsl #2
    hsai->Init.Mckdiv = tmpval / 10;
 808875a:	6226      	str	r6, [r4, #32]
    if((tmpval % 10) > 8)
 808875c:	eba0 0042 	sub.w	r0, r0, r2, lsl #1
 8088760:	2809      	cmp	r0, #9
 8088762:	f000 8099 	beq.w	8088898 <HAL_SAI_Init+0x234>
  if((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088766:	6862      	ldr	r2, [r4, #4]
 8088768:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 808876a:	f032 0002 	bics.w	r0, r2, #2
 808876e:	f040 8085 	bne.w	808887c <HAL_SAI_Init+0x218>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
 8088772:	2901      	cmp	r1, #1
 8088774:	bf14      	ite	ne
 8088776:	f44f 7e00 	movne.w	lr, #512	; 0x200
 808877a:	f04f 0e00 	moveq.w	lr, #0
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 808877e:	6b27      	ldr	r7, [r4, #48]	; 0x30
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 8088780:	f24c 0010 	movw	r0, #49168	; 0xc010
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8088784:	6961      	ldr	r1, [r4, #20]
 8088786:	433a      	orrs	r2, r7
 8088788:	6b67      	ldr	r7, [r4, #52]	; 0x34
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 808878a:	f6cf 7005 	movt	r0, #65285	; 0xff05
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 808878e:	f8d4 c018 	ldr.w	ip, [r4, #24]
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8088792:	433a      	orrs	r2, r7
                        hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 8088794:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8088796:	433a      	orrs	r2, r7
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8088798:	6a67      	ldr	r7, [r4, #36]	; 0x24
 808879a:	433a      	orrs	r2, r7
 808879c:	6927      	ldr	r7, [r4, #16]
 808879e:	433a      	orrs	r2, r7
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 80887a0:	681f      	ldr	r7, [r3, #0]
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80887a2:	430a      	orrs	r2, r1
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 80887a4:	4038      	ands	r0, r7
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80887a6:	f641 77f0 	movw	r7, #8176	; 0x1ff0
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 80887aa:	6018      	str	r0, [r3, #0]
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80887ac:	432a      	orrs	r2, r5
 80887ae:	681d      	ldr	r5, [r3, #0]
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80887b0:	f6cf 77ff 	movt	r7, #65535	; 0xffff
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 80887b4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80887b8:	432a      	orrs	r2, r5
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80887ba:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 80887bc:	f6cf 70f8 	movt	r0, #65528	; 0xfff8
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80887c0:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80887c4:	ea4c 0105 	orr.w	r1, ip, r5
 80887c8:	f8d4 c02c 	ldr.w	ip, [r4, #44]	; 0x2c
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 80887cc:	f24f 0520 	movw	r5, #61472	; 0xf020
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80887d0:	ea42 020e 	orr.w	r2, r2, lr
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80887d4:	ea41 010c 	orr.w	r1, r1, ip
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 80887d8:	f8d4 c04c 	ldr.w	ip, [r4, #76]	; 0x4c
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 80887dc:	601a      	str	r2, [r3, #0]
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80887de:	685e      	ldr	r6, [r3, #4]
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 80887e0:	6d22      	ldr	r2, [r4, #80]	; 0x50
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80887e2:	4037      	ands	r7, r6
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 80887e4:	6ca6      	ldr	r6, [r4, #72]	; 0x48
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 80887e6:	605f      	str	r7, [r3, #4]
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 80887e8:	4332      	orrs	r2, r6
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80887ea:	685f      	ldr	r7, [r3, #4]
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 80887ec:	2600      	movs	r6, #0
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 80887ee:	ea42 020c 	orr.w	r2, r2, ip
  hsai->State= HAL_SAI_STATE_READY;
 80887f2:	f04f 0c01 	mov.w	ip, #1
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80887f6:	4339      	orrs	r1, r7
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 80887f8:	6c27      	ldr	r7, [r4, #64]	; 0x40
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80887fa:	6059      	str	r1, [r3, #4]
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 80887fc:	3f01      	subs	r7, #1
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 80887fe:	6899      	ldr	r1, [r3, #8]
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8088800:	433a      	orrs	r2, r7
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8088802:	4008      	ands	r0, r1
                          ((hsai->FrameInit.ActiveFrameLength - 1) << 8));
 8088804:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8088806:	1e4f      	subs	r7, r1, #1
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8088808:	6d61      	ldr	r1, [r4, #84]	; 0x54
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 808880a:	6098      	str	r0, [r3, #8]
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 808880c:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8088810:	689f      	ldr	r7, [r3, #8]
                          | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 8088812:	6e20      	ldr	r0, [r4, #96]	; 0x60
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8088814:	433a      	orrs	r2, r7
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8088816:	6da7      	ldr	r7, [r4, #88]	; 0x58
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8088818:	609a      	str	r2, [r3, #8]
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 808881a:	4339      	orrs	r1, r7
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 808881c:	68df      	ldr	r7, [r3, #12]
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 808881e:	ea41 4200 	orr.w	r2, r1, r0, lsl #16
  return HAL_OK;
 8088822:	4630      	mov	r0, r6
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8088824:	403d      	ands	r5, r7
 8088826:	60dd      	str	r5, [r3, #12]
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 8088828:	68dd      	ldr	r5, [r3, #12]
                          | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 808882a:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 808882c:	3901      	subs	r1, #1
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 808882e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8088832:	432a      	orrs	r2, r5
 8088834:	60da      	str	r2, [r3, #12]
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8088836:	f8c4 6080 	str.w	r6, [r4, #128]	; 0x80
  __HAL_UNLOCK(hsai);
 808883a:	f884 607c 	strb.w	r6, [r4, #124]	; 0x7c
  hsai->State= HAL_SAI_STATE_READY;
 808883e:	f884 c07d 	strb.w	ip, [r4, #125]	; 0x7d
}
 8088842:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch(hsai->Init.Synchro)
 8088844:	68a2      	ldr	r2, [r4, #8]
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
 8088846:	2110      	movs	r1, #16
  switch(hsai->Init.Synchro)
 8088848:	2a02      	cmp	r2, #2
 808884a:	f47f af45 	bne.w	80886d8 <HAL_SAI_Init+0x74>
        syncen_bits = SAI_xCR1_SYNCEN_1;
 808884e:	f44f 6500 	mov.w	r5, #2048	; 0x800
  if((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 8088852:	f645 0204 	movw	r2, #22532	; 0x5804
 8088856:	69e6      	ldr	r6, [r4, #28]
 8088858:	f2c4 0201 	movt	r2, #16385	; 0x4001
 808885c:	4293      	cmp	r3, r2
 808885e:	f47f af4b 	bne.w	80886f8 <HAL_SAI_Init+0x94>
    SAI1->GCR = tmpregisterGCR;
 8088862:	f44f 42b0 	mov.w	r2, #22528	; 0x5800
 8088866:	f2c4 0201 	movt	r2, #16385	; 0x4001
 808886a:	6011      	str	r1, [r2, #0]
  if(hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 808886c:	b9be      	cbnz	r6, 808889e <HAL_SAI_Init+0x23a>
  if((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 808886e:	6862      	ldr	r2, [r4, #4]
 8088870:	6a26      	ldr	r6, [r4, #32]
 8088872:	f032 0002 	bics.w	r0, r2, #2
 8088876:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8088878:	f43f af7b 	beq.w	8088772 <HAL_SAI_Init+0x10e>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0 : SAI_xCR1_CKSTR;
 808887c:	2901      	cmp	r1, #1
 808887e:	bf14      	ite	ne
 8088880:	f04f 0e00 	movne.w	lr, #0
 8088884:	f44f 7e00 	moveq.w	lr, #512	; 0x200
 8088888:	e779      	b.n	808877e <HAL_SAI_Init+0x11a>
    hsai->Lock = HAL_UNLOCKED;
 808888a:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
    HAL_SAI_MspInit(hsai);
 808888e:	f7ff fee7 	bl	8088660 <HAL_SAI_MspInit>
 8088892:	e6f3      	b.n	808867c <HAL_SAI_Init+0x18>
    return HAL_ERROR;
 8088894:	2001      	movs	r0, #1
}
 8088896:	4770      	bx	lr
      hsai->Init.Mckdiv+= 1;
 8088898:	3601      	adds	r6, #1
 808889a:	6226      	str	r6, [r4, #32]
 808889c:	e763      	b.n	8088766 <HAL_SAI_Init+0x102>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 808889e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80888a2:	f7ff fe13 	bl	80884cc <HAL_RCCEx_GetPeriphCLKFreq>
 80888a6:	6823      	ldr	r3, [r4, #0]
 80888a8:	e739      	b.n	808871e <HAL_SAI_Init+0xba>
        tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 80888aa:	f041 0101 	orr.w	r1, r1, #1
        syncen_bits = SAI_xCR1_SYNCEN_1;
 80888ae:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80888b2:	e7ce      	b.n	8088852 <HAL_SAI_Init+0x1ee>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
 80888b4:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80888b8:	f7ff fe08 	bl	80884cc <HAL_RCCEx_GetPeriphCLKFreq>
 80888bc:	6823      	ldr	r3, [r4, #0]
 80888be:	e73c      	b.n	808873a <HAL_SAI_Init+0xd6>

080888c0 <HAL_SAI_MspDeInit>:
 80888c0:	4770      	bx	lr
 80888c2:	bf00      	nop

080888c4 <HAL_SAI_DeInit>:
  if(hsai == NULL)
 80888c4:	2800      	cmp	r0, #0
 80888c6:	d037      	beq.n	8088938 <HAL_SAI_DeInit+0x74>
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80888c8:	f24b 3174 	movw	r1, #45940	; 0xb374
  hsai->Instance->IMR = 0;
 80888cc:	6802      	ldr	r2, [r0, #0]
{
 80888ce:	b538      	push	{r3, r4, r5, lr}
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80888d0:	f2c2 0100 	movt	r1, #8192	; 0x2000
  hsai->State = HAL_SAI_STATE_BUSY;
 80888d4:	2302      	movs	r3, #2
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80888d6:	f64e 441b 	movw	r4, #60443	; 0xec1b
  hsai->Instance->IMR = 0;
 80888da:	2500      	movs	r5, #0
  hsai->State = HAL_SAI_STATE_BUSY;
 80888dc:	f880 307d 	strb.w	r3, [r0, #125]	; 0x7d
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80888e0:	f2c9 54cb 	movt	r4, #38347	; 0x95cb
 80888e4:	680b      	ldr	r3, [r1, #0]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 80888e6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  hsai->Instance->IMR = 0;
 80888ea:	6115      	str	r5, [r2, #16]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80888ec:	fba4 4303 	umull	r4, r3, r4, r3
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 80888f0:	6191      	str	r1, [r2, #24]
  __HAL_SAI_DISABLE(hsai);
 80888f2:	6811      	ldr	r1, [r2, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80888f4:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 80888f6:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80888fa:	009b      	lsls	r3, r3, #2
  __HAL_SAI_DISABLE(hsai);
 80888fc:	6011      	str	r1, [r2, #0]
 80888fe:	e002      	b.n	8088906 <HAL_SAI_DeInit+0x42>
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8088900:	6811      	ldr	r1, [r2, #0]
 8088902:	03c9      	lsls	r1, r1, #15
 8088904:	d508      	bpl.n	8088918 <HAL_SAI_DeInit+0x54>
    if (count-- == 0)
 8088906:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 808890a:	d2f9      	bcs.n	8088900 <HAL_SAI_DeInit+0x3c>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 808890c:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8088910:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8088914:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 8088918:	6853      	ldr	r3, [r2, #4]
 808891a:	4604      	mov	r4, r0
 808891c:	f043 0308 	orr.w	r3, r3, #8
 8088920:	6053      	str	r3, [r2, #4]
  HAL_SAI_MspDeInit(hsai);
 8088922:	f7ff ffcd 	bl	80888c0 <HAL_SAI_MspDeInit>
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8088926:	2300      	movs	r3, #0
 8088928:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  return HAL_OK;
 808892c:	4618      	mov	r0, r3
  hsai->State = HAL_SAI_STATE_RESET;
 808892e:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
  __HAL_UNLOCK(hsai);
 8088932:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
 8088936:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8088938:	2001      	movs	r0, #1
}
 808893a:	4770      	bx	lr

0808893c <HAL_SAI_DMAPause>:
  __HAL_LOCK(hsai);
 808893c:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
 8088940:	2a01      	cmp	r2, #1
 8088942:	d00d      	beq.n	8088960 <HAL_SAI_DMAPause+0x24>
 8088944:	4603      	mov	r3, r0
  __HAL_UNLOCK(hsai);
 8088946:	2100      	movs	r1, #0
{
 8088948:	b410      	push	{r4}
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 808894a:	6804      	ldr	r4, [r0, #0]
  return HAL_OK;
 808894c:	4608      	mov	r0, r1
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 808894e:	6822      	ldr	r2, [r4, #0]
 8088950:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8088954:	6022      	str	r2, [r4, #0]
  __HAL_UNLOCK(hsai);
 8088956:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c
}
 808895a:	f85d 4b04 	ldr.w	r4, [sp], #4
 808895e:	4770      	bx	lr
  __HAL_LOCK(hsai);
 8088960:	2002      	movs	r0, #2
}
 8088962:	4770      	bx	lr

08088964 <HAL_SAI_DMAResume>:
  __HAL_LOCK(hsai);
 8088964:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 8088968:	2b01      	cmp	r3, #1
 808896a:	d013      	beq.n	8088994 <HAL_SAI_DMAResume+0x30>
  hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 808896c:	6803      	ldr	r3, [r0, #0]
  __HAL_LOCK(hsai);
 808896e:	2101      	movs	r1, #1
  hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 8088970:	681a      	ldr	r2, [r3, #0]
  __HAL_LOCK(hsai);
 8088972:	f880 107c 	strb.w	r1, [r0, #124]	; 0x7c
  hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 8088976:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 808897a:	601a      	str	r2, [r3, #0]
  if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
 808897c:	681a      	ldr	r2, [r3, #0]
 808897e:	03d2      	lsls	r2, r2, #15
 8088980:	d403      	bmi.n	808898a <HAL_SAI_DMAResume+0x26>
    __HAL_SAI_ENABLE(hsai);
 8088982:	681a      	ldr	r2, [r3, #0]
 8088984:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8088988:	601a      	str	r2, [r3, #0]
  __HAL_UNLOCK(hsai);
 808898a:	2300      	movs	r3, #0
 808898c:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
  return HAL_OK;
 8088990:	4618      	mov	r0, r3
 8088992:	4770      	bx	lr
  __HAL_LOCK(hsai);
 8088994:	2002      	movs	r0, #2
}
 8088996:	4770      	bx	lr

08088998 <HAL_SAI_DMAStop>:
  __HAL_LOCK(hsai);
 8088998:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 808899c:	2b01      	cmp	r3, #1
{
 808899e:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hsai);
 80889a0:	d05f      	beq.n	8088a62 <HAL_SAI_DMAStop+0xca>
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 80889a2:	6802      	ldr	r2, [r0, #0]
 80889a4:	4604      	mov	r4, r0
  __HAL_LOCK(hsai);
 80889a6:	2501      	movs	r5, #1
  if((hsai->hdmatx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_TX))
 80889a8:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 80889aa:	6813      	ldr	r3, [r2, #0]
  __HAL_LOCK(hsai);
 80889ac:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 80889b0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80889b4:	6013      	str	r3, [r2, #0]
  if((hsai->hdmatx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_TX))
 80889b6:	b118      	cbz	r0, 80889c0 <HAL_SAI_DMAStop+0x28>
 80889b8:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 80889bc:	2b12      	cmp	r3, #18
 80889be:	d041      	beq.n	8088a44 <HAL_SAI_DMAStop+0xac>
  HAL_StatusTypeDef status = HAL_OK;
 80889c0:	2500      	movs	r5, #0
  if((hsai->hdmarx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_RX))
 80889c2:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80889c4:	b118      	cbz	r0, 80889ce <HAL_SAI_DMAStop+0x36>
 80889c6:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 80889ca:	2b22      	cmp	r3, #34	; 0x22
 80889cc:	d02a      	beq.n	8088a24 <HAL_SAI_DMAStop+0x8c>
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80889ce:	f24b 3074 	movw	r0, #45940	; 0xb374
 80889d2:	f64e 461b 	movw	r6, #60443	; 0xec1b
  __HAL_SAI_DISABLE(hsai);
 80889d6:	6821      	ldr	r1, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80889d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80889dc:	f2c9 56cb 	movt	r6, #38347	; 0x95cb
  __HAL_SAI_DISABLE(hsai);
 80889e0:	680a      	ldr	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80889e2:	6803      	ldr	r3, [r0, #0]
  __HAL_SAI_DISABLE(hsai);
 80889e4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80889e8:	fba6 0303 	umull	r0, r3, r6, r3
  __HAL_SAI_DISABLE(hsai);
 80889ec:	600a      	str	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 80889ee:	0b1b      	lsrs	r3, r3, #12
 80889f0:	009b      	lsls	r3, r3, #2
 80889f2:	e002      	b.n	80889fa <HAL_SAI_DMAStop+0x62>
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 80889f4:	680a      	ldr	r2, [r1, #0]
 80889f6:	03d2      	lsls	r2, r2, #15
 80889f8:	d508      	bpl.n	8088a0c <HAL_SAI_DMAStop+0x74>
    if (count-- == 0)
 80889fa:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 80889fe:	d2f9      	bcs.n	80889f4 <HAL_SAI_DMAStop+0x5c>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8088a00:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8088a04:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8088a08:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 8088a0c:	684b      	ldr	r3, [r1, #4]
  hsai->State = HAL_SAI_STATE_READY;
 8088a0e:	2001      	movs	r0, #1
  __HAL_UNLOCK(hsai);
 8088a10:	2200      	movs	r2, #0
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 8088a12:	f043 0308 	orr.w	r3, r3, #8
 8088a16:	604b      	str	r3, [r1, #4]
  hsai->State = HAL_SAI_STATE_READY;
 8088a18:	f884 007d 	strb.w	r0, [r4, #125]	; 0x7d
}
 8088a1c:	4628      	mov	r0, r5
  __HAL_UNLOCK(hsai);
 8088a1e:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
}
 8088a22:	bd70      	pop	{r4, r5, r6, pc}
    if(HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
 8088a24:	f7fd f872 	bl	8085b0c <HAL_DMA_Abort>
 8088a28:	2800      	cmp	r0, #0
 8088a2a:	d0d0      	beq.n	80889ce <HAL_SAI_DMAStop+0x36>
      if(hsai->hdmarx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 8088a2c:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8088a2e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8088a30:	2b80      	cmp	r3, #128	; 0x80
 8088a32:	d0cc      	beq.n	80889ce <HAL_SAI_DMAStop+0x36>
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8088a34:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        status = HAL_ERROR;
 8088a38:	2501      	movs	r5, #1
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8088a3a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8088a3e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 8088a42:	e7c4      	b.n	80889ce <HAL_SAI_DMAStop+0x36>
    if(HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
 8088a44:	f7fd f862 	bl	8085b0c <HAL_DMA_Abort>
 8088a48:	2800      	cmp	r0, #0
 8088a4a:	d0b9      	beq.n	80889c0 <HAL_SAI_DMAStop+0x28>
      if(hsai->hdmatx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 8088a4c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8088a4e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8088a50:	2b80      	cmp	r3, #128	; 0x80
 8088a52:	d0b5      	beq.n	80889c0 <HAL_SAI_DMAStop+0x28>
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8088a54:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8088a58:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8088a5c:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 8088a60:	e7af      	b.n	80889c2 <HAL_SAI_DMAStop+0x2a>
  __HAL_LOCK(hsai);
 8088a62:	2502      	movs	r5, #2
}
 8088a64:	4628      	mov	r0, r5
 8088a66:	bd70      	pop	{r4, r5, r6, pc}

08088a68 <HAL_SAI_Transmit_DMA>:
  if((pData == NULL) || (Size == 0))
 8088a68:	2900      	cmp	r1, #0
 8088a6a:	d058      	beq.n	8088b1e <HAL_SAI_Transmit_DMA+0xb6>
{
 8088a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if((pData == NULL) || (Size == 0))
 8088a6e:	fab2 f582 	clz	r5, r2
 8088a72:	096d      	lsrs	r5, r5, #5
 8088a74:	2d00      	cmp	r5, #0
 8088a76:	d150      	bne.n	8088b1a <HAL_SAI_Transmit_DMA+0xb2>
  if(hsai->State == HAL_SAI_STATE_READY)
 8088a78:	f890 607d 	ldrb.w	r6, [r0, #125]	; 0x7d
 8088a7c:	b2f6      	uxtb	r6, r6
 8088a7e:	2e01      	cmp	r6, #1
 8088a80:	d149      	bne.n	8088b16 <HAL_SAI_Transmit_DMA+0xae>
    __HAL_LOCK(hsai);
 8088a82:	f890 407c 	ldrb.w	r4, [r0, #124]	; 0x7c
 8088a86:	2c01      	cmp	r4, #1
 8088a88:	d045      	beq.n	8088b16 <HAL_SAI_Transmit_DMA+0xae>
 8088a8a:	4604      	mov	r4, r0
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8088a8c:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
    __HAL_LOCK(hsai);
 8088a90:	f880 607c 	strb.w	r6, [r0, #124]	; 0x7c
 8088a94:	4613      	mov	r3, r2
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 8088a96:	2012      	movs	r0, #18
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 8088a98:	f648 4261 	movw	r2, #35937	; 0x8c61
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 8088a9c:	f648 4e09 	movw	lr, #35849	; 0x8c09
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 8088aa0:	f648 4cd1 	movw	ip, #36049	; 0x8cd1
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 8088aa4:	f884 007d 	strb.w	r0, [r4, #125]	; 0x7d
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 8088aa8:	f6c0 0208 	movt	r2, #2056	; 0x808
    if(HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 8088aac:	6827      	ldr	r7, [r4, #0]
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 8088aae:	f6c0 0e08 	movt	lr, #2056	; 0x808
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 8088ab2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 8088ab4:	f6c0 0c08 	movt	ip, #2056	; 0x808
    hsai->pBuffPtr = pData;
 8088ab8:	6661      	str	r1, [r4, #100]	; 0x64
    hsai->XferSize = Size;
 8088aba:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
    hsai->XferCount = Size;
 8088abe:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 8088ac2:	6402      	str	r2, [r0, #64]	; 0x40
    if(HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 8088ac4:	f107 021c 	add.w	r2, r7, #28
    hsai->hdmatx->XferAbortCallback = NULL;
 8088ac8:	6505      	str	r5, [r0, #80]	; 0x50
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 8088aca:	f8c0 e03c 	str.w	lr, [r0, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 8088ace:	f8c0 c04c 	str.w	ip, [r0, #76]	; 0x4c
    if(HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 8088ad2:	f7fc ffd5 	bl	8085a80 <HAL_DMA_Start_IT>
 8088ad6:	bb20      	cbnz	r0, 8088b22 <HAL_SAI_Transmit_DMA+0xba>
    if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
 8088ad8:	6823      	ldr	r3, [r4, #0]
 8088ada:	681a      	ldr	r2, [r3, #0]
 8088adc:	03d2      	lsls	r2, r2, #15
 8088ade:	d403      	bmi.n	8088ae8 <HAL_SAI_Transmit_DMA+0x80>
      __HAL_SAI_ENABLE(hsai);
 8088ae0:	681a      	ldr	r2, [r3, #0]
 8088ae2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8088ae6:	601a      	str	r2, [r3, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088ae8:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8088aea:	6862      	ldr	r2, [r4, #4]
 8088aec:	2908      	cmp	r1, #8
 8088aee:	d01c      	beq.n	8088b2a <HAL_SAI_Transmit_DMA+0xc2>
 8088af0:	2101      	movs	r1, #1
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088af2:	3a02      	subs	r2, #2
    __HAL_UNLOCK(hsai);
 8088af4:	2500      	movs	r5, #0
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088af6:	2a01      	cmp	r2, #1
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8088af8:	691a      	ldr	r2, [r3, #16]
    tmpIT|= SAI_IT_AFSDET | SAI_IT_LFSDET;
 8088afa:	bf94      	ite	ls
 8088afc:	f041 0160 	orrls.w	r1, r1, #96	; 0x60
    tmpIT|= SAI_IT_WCKCFG;
 8088b00:	f041 0104 	orrhi.w	r1, r1, #4
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8088b04:	430a      	orrs	r2, r1
 8088b06:	611a      	str	r2, [r3, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 8088b08:	681a      	ldr	r2, [r3, #0]
 8088b0a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8088b0e:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
 8088b10:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
}
 8088b14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8088b16:	2002      	movs	r0, #2
}
 8088b18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 8088b1a:	2001      	movs	r0, #1
}
 8088b1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 8088b1e:	2001      	movs	r0, #1
}
 8088b20:	4770      	bx	lr
      __HAL_UNLOCK(hsai);
 8088b22:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
      return  HAL_ERROR;
 8088b26:	4630      	mov	r0, r6
}
 8088b28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8088b2a:	f022 0102 	bic.w	r1, r2, #2
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088b2e:	2901      	cmp	r1, #1
 8088b30:	bf0c      	ite	eq
 8088b32:	2111      	moveq	r1, #17
 8088b34:	2101      	movne	r1, #1
 8088b36:	e7dc      	b.n	8088af2 <HAL_SAI_Transmit_DMA+0x8a>

08088b38 <HAL_SAI_Receive_DMA>:
  if((pData == NULL) || (Size == 0))
 8088b38:	2900      	cmp	r1, #0
 8088b3a:	d058      	beq.n	8088bee <HAL_SAI_Receive_DMA+0xb6>
{
 8088b3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if((pData == NULL) || (Size == 0))
 8088b3e:	fab2 f582 	clz	r5, r2
 8088b42:	096d      	lsrs	r5, r5, #5
 8088b44:	2d00      	cmp	r5, #0
 8088b46:	d150      	bne.n	8088bea <HAL_SAI_Receive_DMA+0xb2>
  if(hsai->State == HAL_SAI_STATE_READY)
 8088b48:	f890 607d 	ldrb.w	r6, [r0, #125]	; 0x7d
 8088b4c:	b2f6      	uxtb	r6, r6
 8088b4e:	2e01      	cmp	r6, #1
 8088b50:	d149      	bne.n	8088be6 <HAL_SAI_Receive_DMA+0xae>
    __HAL_LOCK(hsai);
 8088b52:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 8088b56:	2b01      	cmp	r3, #1
 8088b58:	d045      	beq.n	8088be6 <HAL_SAI_Receive_DMA+0xae>
 8088b5a:	4604      	mov	r4, r0
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 8088b5c:	f648 4ec5 	movw	lr, #36037	; 0x8cc5
    hsai->State = HAL_SAI_STATE_BUSY_RX;
 8088b60:	2022      	movs	r0, #34	; 0x22
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 8088b62:	f648 4c6d 	movw	ip, #35949	; 0x8c6d
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 8088b66:	f648 47d1 	movw	r7, #36049	; 0x8cd1
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8088b6a:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    hsai->pBuffPtr = pData;
 8088b6e:	6661      	str	r1, [r4, #100]	; 0x64
 8088b70:	4613      	mov	r3, r2
    hsai->State = HAL_SAI_STATE_BUSY_RX;
 8088b72:	f884 007d 	strb.w	r0, [r4, #125]	; 0x7d
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 8088b76:	f6c0 0e08 	movt	lr, #2056	; 0x808
 8088b7a:	6f20      	ldr	r0, [r4, #112]	; 0x70
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 8088b7c:	f6c0 0c08 	movt	ip, #2056	; 0x808
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 8088b80:	f6c0 0708 	movt	r7, #2056	; 0x808
    if(HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
 8088b84:	460a      	mov	r2, r1
 8088b86:	6821      	ldr	r1, [r4, #0]
    __HAL_LOCK(hsai);
 8088b88:	f884 607c 	strb.w	r6, [r4, #124]	; 0x7c
    hsai->XferSize = Size;
 8088b8c:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
    if(HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
 8088b90:	311c      	adds	r1, #28
    hsai->XferCount = Size;
 8088b92:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 8088b96:	f8c0 e040 	str.w	lr, [r0, #64]	; 0x40
    hsai->hdmarx->XferAbortCallback = NULL;
 8088b9a:	6505      	str	r5, [r0, #80]	; 0x50
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 8088b9c:	f8c0 c03c 	str.w	ip, [r0, #60]	; 0x3c
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 8088ba0:	64c7      	str	r7, [r0, #76]	; 0x4c
    if(HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
 8088ba2:	f7fc ff6d 	bl	8085a80 <HAL_DMA_Start_IT>
 8088ba6:	bb20      	cbnz	r0, 8088bf2 <HAL_SAI_Receive_DMA+0xba>
    if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
 8088ba8:	6823      	ldr	r3, [r4, #0]
 8088baa:	681a      	ldr	r2, [r3, #0]
 8088bac:	03d2      	lsls	r2, r2, #15
 8088bae:	d403      	bmi.n	8088bb8 <HAL_SAI_Receive_DMA+0x80>
      __HAL_SAI_ENABLE(hsai);
 8088bb0:	681a      	ldr	r2, [r3, #0]
 8088bb2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8088bb6:	601a      	str	r2, [r3, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088bb8:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8088bba:	6862      	ldr	r2, [r4, #4]
 8088bbc:	2908      	cmp	r1, #8
 8088bbe:	d01c      	beq.n	8088bfa <HAL_SAI_Receive_DMA+0xc2>
 8088bc0:	2101      	movs	r1, #1
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088bc2:	3a02      	subs	r2, #2
    __HAL_UNLOCK(hsai);
 8088bc4:	2500      	movs	r5, #0
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088bc6:	2a01      	cmp	r2, #1
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8088bc8:	691a      	ldr	r2, [r3, #16]
    tmpIT|= SAI_IT_AFSDET | SAI_IT_LFSDET;
 8088bca:	bf94      	ite	ls
 8088bcc:	f041 0160 	orrls.w	r1, r1, #96	; 0x60
    tmpIT|= SAI_IT_WCKCFG;
 8088bd0:	f041 0104 	orrhi.w	r1, r1, #4
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8088bd4:	430a      	orrs	r2, r1
 8088bd6:	611a      	str	r2, [r3, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 8088bd8:	681a      	ldr	r2, [r3, #0]
 8088bda:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8088bde:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
 8088be0:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
}
 8088be4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8088be6:	2002      	movs	r0, #2
}
 8088be8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 8088bea:	2001      	movs	r0, #1
}
 8088bec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 8088bee:	2001      	movs	r0, #1
}
 8088bf0:	4770      	bx	lr
      __HAL_UNLOCK(hsai);
 8088bf2:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
      return  HAL_ERROR;
 8088bf6:	4630      	mov	r0, r6
}
 8088bf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8088bfa:	f022 0102 	bic.w	r1, r2, #2
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088bfe:	2901      	cmp	r1, #1
 8088c00:	bf0c      	ite	eq
 8088c02:	2111      	moveq	r1, #17
 8088c04:	2101      	movne	r1, #1
 8088c06:	e7dc      	b.n	8088bc2 <HAL_SAI_Receive_DMA+0x8a>

08088c08 <SAI_DMATxCplt>:
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
  SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef* )hdma)->Parent;

  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8088c08:	6803      	ldr	r3, [r0, #0]
  SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef* )hdma)->Parent;
 8088c0a:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8088c0c:	681b      	ldr	r3, [r3, #0]
 8088c0e:	f413 7380 	ands.w	r3, r3, #256	; 0x100
{
 8088c12:	b510      	push	{r4, lr}
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8088c14:	d119      	bne.n	8088c4a <SAI_DMATxCplt+0x42>
  {
    hsai->XferCount = 0;
    
    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8088c16:	6802      	ldr	r2, [r0, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088c18:	6b04      	ldr	r4, [r0, #48]	; 0x30
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8088c1a:	6811      	ldr	r1, [r2, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088c1c:	2c08      	cmp	r4, #8
    hsai->XferCount = 0;
 8088c1e:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8088c22:	f421 3100 	bic.w	r1, r1, #131072	; 0x20000
 8088c26:	6843      	ldr	r3, [r0, #4]
 8088c28:	6011      	str	r1, [r2, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088c2a:	d011      	beq.n	8088c50 <SAI_DMATxCplt+0x48>
 8088c2c:	2101      	movs	r1, #1
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088c2e:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
    
    hsai->State= HAL_SAI_STATE_READY;
 8088c30:	2401      	movs	r4, #1
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088c32:	2b01      	cmp	r3, #1
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8088c34:	6913      	ldr	r3, [r2, #16]
    tmpIT|= SAI_IT_AFSDET | SAI_IT_LFSDET;
 8088c36:	bf94      	ite	ls
 8088c38:	f041 0160 	orrls.w	r1, r1, #96	; 0x60
    tmpIT|= SAI_IT_WCKCFG;
 8088c3c:	f041 0104 	orrhi.w	r1, r1, #4
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8088c40:	ea23 0301 	bic.w	r3, r3, r1
 8088c44:	6113      	str	r3, [r2, #16]
    hsai->State= HAL_SAI_STATE_READY;
 8088c46:	f880 407d 	strb.w	r4, [r0, #125]	; 0x7d
  }
  HAL_SAI_TxCpltCallback(hsai);
 8088c4a:	f7f9 fe1b 	bl	8082884 <HAL_SAI_TxCpltCallback>
}
 8088c4e:	bd10      	pop	{r4, pc}
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8088c50:	f023 0102 	bic.w	r1, r3, #2
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088c54:	2901      	cmp	r1, #1
 8088c56:	bf0c      	ite	eq
 8088c58:	2111      	moveq	r1, #17
 8088c5a:	2101      	movne	r1, #1
 8088c5c:	e7e7      	b.n	8088c2e <SAI_DMATxCplt+0x26>
 8088c5e:	bf00      	nop

08088c60 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8088c60:	b508      	push	{r3, lr}
  SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_SAI_TxHalfCpltCallback(hsai);
 8088c62:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8088c64:	f7f9 fe12 	bl	808288c <HAL_SAI_TxHalfCpltCallback>
}
 8088c68:	bd08      	pop	{r3, pc}
 8088c6a:	bf00      	nop

08088c6c <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
 8088c6c:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8088c6e:	6803      	ldr	r3, [r0, #0]
  SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8088c70:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8088c72:	681b      	ldr	r3, [r3, #0]
 8088c74:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8088c78:	d119      	bne.n	8088cae <SAI_DMARxCplt+0x42>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8088c7a:	6802      	ldr	r2, [r0, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088c7c:	6b05      	ldr	r5, [r0, #48]	; 0x30
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8088c7e:	6814      	ldr	r4, [r2, #0]
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088c80:	2d08      	cmp	r5, #8
 8088c82:	6841      	ldr	r1, [r0, #4]
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8088c84:	f424 3400 	bic.w	r4, r4, #131072	; 0x20000
 8088c88:	6014      	str	r4, [r2, #0]
    hsai->XferCount = 0;
 8088c8a:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088c8e:	d011      	beq.n	8088cb4 <SAI_DMARxCplt+0x48>
 8088c90:	2301      	movs	r3, #1
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088c92:	3902      	subs	r1, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
    
    hsai->State = HAL_SAI_STATE_READY;
 8088c94:	2401      	movs	r4, #1
  if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8088c96:	2901      	cmp	r1, #1
    tmpIT|= SAI_IT_AFSDET | SAI_IT_LFSDET;
 8088c98:	bf94      	ite	ls
 8088c9a:	f043 0160 	orrls.w	r1, r3, #96	; 0x60
    tmpIT|= SAI_IT_WCKCFG;
 8088c9e:	f043 0104 	orrhi.w	r1, r3, #4
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 8088ca2:	6913      	ldr	r3, [r2, #16]
 8088ca4:	ea23 0301 	bic.w	r3, r3, r1
 8088ca8:	6113      	str	r3, [r2, #16]
    hsai->State = HAL_SAI_STATE_READY;
 8088caa:	f880 407d 	strb.w	r4, [r0, #125]	; 0x7d
  }
  HAL_SAI_RxCpltCallback(hsai);
 8088cae:	f7f9 ffe1 	bl	8082c74 <HAL_SAI_RxCpltCallback>
}
 8088cb2:	bd38      	pop	{r3, r4, r5, pc}
    ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 8088cb4:	f021 0302 	bic.w	r3, r1, #2
  if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8088cb8:	2b01      	cmp	r3, #1
 8088cba:	bf0c      	ite	eq
 8088cbc:	2311      	moveq	r3, #17
 8088cbe:	2301      	movne	r3, #1
 8088cc0:	e7e7      	b.n	8088c92 <SAI_DMARxCplt+0x26>
 8088cc2:	bf00      	nop

08088cc4 <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8088cc4:	b508      	push	{r3, lr}
  SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_SAI_RxHalfCpltCallback(hsai);
 8088cc6:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8088cc8:	f7f9 ffd8 	bl	8082c7c <HAL_SAI_RxHalfCpltCallback>
}
 8088ccc:	bd08      	pop	{r3, pc}
 8088cce:	bf00      	nop

08088cd0 <SAI_DMAError>:
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
  SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8088cd0:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 8088cd2:	b538      	push	{r3, r4, r5, lr}

  /* Set SAI error code */
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8088cd4:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80

  if((hsai->hdmatx->ErrorCode == HAL_DMA_ERROR_TE) || (hsai->hdmarx->ErrorCode == HAL_DMA_ERROR_TE))
 8088cd8:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8088cda:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8088cde:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  if((hsai->hdmatx->ErrorCode == HAL_DMA_ERROR_TE) || (hsai->hdmarx->ErrorCode == HAL_DMA_ERROR_TE))
 8088ce2:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8088ce4:	2b01      	cmp	r3, #1
 8088ce6:	d006      	beq.n	8088cf6 <SAI_DMAError+0x26>
 8088ce8:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8088cea:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8088cec:	2b01      	cmp	r3, #1
 8088cee:	d002      	beq.n	8088cf6 <SAI_DMAError+0x26>

    /* Initialize XferCount */
    hsai->XferCount = 0U;
  }
  /* SAI error Callback */ 
  HAL_SAI_ErrorCallback(hsai);
 8088cf0:	f7f9 ffc8 	bl	8082c84 <HAL_SAI_ErrorCallback>
}
 8088cf4:	bd38      	pop	{r3, r4, r5, pc}
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8088cf6:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088cf8:	f24b 3474 	movw	r4, #45940	; 0xb374
 8088cfc:	f64e 451b 	movw	r5, #60443	; 0xec1b
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8088d00:	680a      	ldr	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088d02:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8088d06:	f2c9 55cb 	movt	r5, #38347	; 0x95cb
 8088d0a:	6823      	ldr	r3, [r4, #0]
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8088d0c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088d10:	fba5 4303 	umull	r4, r3, r5, r3
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8088d14:	600a      	str	r2, [r1, #0]
  __HAL_SAI_DISABLE(hsai);
 8088d16:	680a      	ldr	r2, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088d18:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8088d1a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8088d1e:	009b      	lsls	r3, r3, #2
  __HAL_SAI_DISABLE(hsai);
 8088d20:	600a      	str	r2, [r1, #0]
 8088d22:	e002      	b.n	8088d2a <SAI_DMAError+0x5a>
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8088d24:	680a      	ldr	r2, [r1, #0]
 8088d26:	03d2      	lsls	r2, r2, #15
 8088d28:	d508      	bpl.n	8088d3c <SAI_DMAError+0x6c>
    if (count-- == 0)
 8088d2a:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 8088d2e:	d2f9      	bcs.n	8088d24 <SAI_DMAError+0x54>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8088d30:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8088d34:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8088d38:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_READY;
 8088d3c:	2201      	movs	r2, #1
    hsai->XferCount = 0U;
 8088d3e:	2300      	movs	r3, #0
    hsai->State = HAL_SAI_STATE_READY;
 8088d40:	f880 207d 	strb.w	r2, [r0, #125]	; 0x7d
    hsai->XferCount = 0U;
 8088d44:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
  HAL_SAI_ErrorCallback(hsai);
 8088d48:	f7f9 ff9c 	bl	8082c84 <HAL_SAI_ErrorCallback>
}
 8088d4c:	bd38      	pop	{r3, r4, r5, pc}
 8088d4e:	bf00      	nop

08088d50 <HAL_SAI_GetState>:
  return hsai->State;
 8088d50:	f890 007d 	ldrb.w	r0, [r0, #125]	; 0x7d
}
 8088d54:	4770      	bx	lr
 8088d56:	bf00      	nop

08088d58 <SD_FindSCR>:
  * @param  hsd Pointer to SD handle
  * @param  pSCR pointer to the buffer that will contain the SCR value  
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8088d58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8088d5c:	4605      	mov	r5, r0
 8088d5e:	b089      	sub	sp, #36	; 0x24
 8088d60:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  uint32_t tickstart = HAL_GetTick();
 8088d62:	f7fc fd25 	bl	80857b0 <HAL_GetTick>
  uint32_t index = 0;
  uint32_t tempscr[2] = {0, 0};
 8088d66:	2300      	movs	r3, #0
  uint32_t tickstart = HAL_GetTick();
 8088d68:	4606      	mov	r6, r0
  
  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8);
 8088d6a:	2108      	movs	r1, #8
 8088d6c:	6828      	ldr	r0, [r5, #0]
  uint32_t tempscr[2] = {0, 0};
 8088d6e:	e9cd 3300 	strd	r3, r3, [sp]
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8);
 8088d72:	f002 fbed 	bl	808b550 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_OK)
 8088d76:	4604      	mov	r4, r0
 8088d78:	b118      	cbz	r0, 8088d82 <SD_FindSCR+0x2a>
    *(pSCR) = ((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
      ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24);
  }

  return HAL_SD_ERROR_NONE;
}
 8088d7a:	4620      	mov	r0, r4
 8088d7c:	b009      	add	sp, #36	; 0x24
 8088d7e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16));
 8088d82:	6d29      	ldr	r1, [r5, #80]	; 0x50
 8088d84:	6828      	ldr	r0, [r5, #0]
 8088d86:	0409      	lsls	r1, r1, #16
 8088d88:	f002 fd08 	bl	808b79c <SDMMC_CmdAppCommand>
  if(errorstate != HAL_OK)
 8088d8c:	4604      	mov	r4, r0
 8088d8e:	2800      	cmp	r0, #0
 8088d90:	d1f3      	bne.n	8088d7a <SD_FindSCR+0x22>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8088d92:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 8;
 8088d96:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
 8088d98:	2130      	movs	r1, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8088d9a:	9006      	str	r0, [sp, #24]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8088d9c:	9202      	str	r2, [sp, #8]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8088d9e:	2202      	movs	r2, #2
  config.DataLength    = 8;
 8088da0:	9303      	str	r3, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 8088da2:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
 8088da4:	9104      	str	r1, [sp, #16]
  SDMMC_ConfigData(hsd->Instance, &config);
 8088da6:	a902      	add	r1, sp, #8
 8088da8:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8088daa:	9205      	str	r2, [sp, #20]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 8088dac:	9307      	str	r3, [sp, #28]
  SDMMC_ConfigData(hsd->Instance, &config);
 8088dae:	f002 fbb9 	bl	808b524 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 8088db2:	6828      	ldr	r0, [r5, #0]
 8088db4:	f002 fd2a 	bl	808b80c <SDMMC_CmdSendSCR>
  if(errorstate != HAL_OK)
 8088db8:	4604      	mov	r4, r0
 8088dba:	2800      	cmp	r0, #0
 8088dbc:	d1dd      	bne.n	8088d7a <SD_FindSCR+0x22>
  uint32_t index = 0;
 8088dbe:	4681      	mov	r9, r0
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND))
 8088dc0:	f240 482a 	movw	r8, #1066	; 0x42a
 8088dc4:	e004      	b.n	8088dd0 <SD_FindSCR+0x78>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8088dc6:	f7fc fcf3 	bl	80857b0 <HAL_GetTick>
 8088dca:	1b80      	subs	r0, r0, r6
 8088dcc:	3001      	adds	r0, #1
 8088dce:	d023      	beq.n	8088e18 <SD_FindSCR+0xc0>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND))
 8088dd0:	6828      	ldr	r0, [r5, #0]
 8088dd2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8088dd4:	ea13 0f08 	tst.w	r3, r8
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL))
 8088dd8:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND))
 8088dda:	d10b      	bne.n	8088df4 <SD_FindSCR+0x9c>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL))
 8088ddc:	029b      	lsls	r3, r3, #10
 8088dde:	d5f2      	bpl.n	8088dc6 <SD_FindSCR+0x6e>
      *(tempscr + index) = SDMMC_ReadFIFO(hsd->Instance);
 8088de0:	f002 fb82 	bl	808b4e8 <SDMMC_ReadFIFO>
 8088de4:	ab08      	add	r3, sp, #32
 8088de6:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 8088dea:	f109 0901 	add.w	r9, r9, #1
 8088dee:	f843 0c20 	str.w	r0, [r3, #-32]
 8088df2:	e7e8      	b.n	8088dc6 <SD_FindSCR+0x6e>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8088df4:	0719      	lsls	r1, r3, #28
 8088df6:	d412      	bmi.n	8088e1e <SD_FindSCR+0xc6>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8088df8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8088dfa:	079a      	lsls	r2, r3, #30
 8088dfc:	d412      	bmi.n	8088e24 <SD_FindSCR+0xcc>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 8088dfe:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8088e00:	069b      	lsls	r3, r3, #26
 8088e02:	d412      	bmi.n	8088e2a <SD_FindSCR+0xd2>
 8088e04:	9a00      	ldr	r2, [sp, #0]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088e06:	f240 51ff 	movw	r1, #1535	; 0x5ff
 8088e0a:	9b01      	ldr	r3, [sp, #4]
 8088e0c:	ba12      	rev	r2, r2
 8088e0e:	6381      	str	r1, [r0, #56]	; 0x38
 8088e10:	ba1b      	rev	r3, r3
    *(pSCR) = ((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8088e12:	e9c7 3200 	strd	r3, r2, [r7]
  return HAL_SD_ERROR_NONE;
 8088e16:	e7b0      	b.n	8088d7a <SD_FindSCR+0x22>
      return HAL_SD_ERROR_TIMEOUT;
 8088e18:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8088e1c:	e7ad      	b.n	8088d7a <SD_FindSCR+0x22>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 8088e1e:	2408      	movs	r4, #8
 8088e20:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8088e22:	e7aa      	b.n	8088d7a <SD_FindSCR+0x22>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 8088e24:	2402      	movs	r4, #2
 8088e26:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8088e28:	e7a7      	b.n	8088d7a <SD_FindSCR+0x22>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 8088e2a:	2420      	movs	r4, #32
 8088e2c:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
 8088e2e:	e7a4      	b.n	8088d7a <SD_FindSCR+0x22>

08088e30 <HAL_SD_MspInit>:
}
 8088e30:	4770      	bx	lr
 8088e32:	bf00      	nop

08088e34 <HAL_SD_ReadBlocks>:
{
 8088e34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8088e38:	460d      	mov	r5, r1
 8088e3a:	b086      	sub	sp, #24
 8088e3c:	4604      	mov	r4, r0
 8088e3e:	4616      	mov	r6, r2
 8088e40:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
 8088e42:	f7fc fcb5 	bl	80857b0 <HAL_GetTick>
  if(NULL == pData)
 8088e46:	b375      	cbz	r5, 8088ea6 <HAL_SD_ReadBlocks+0x72>
 8088e48:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
 8088e4a:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 8088e4e:	b2c0      	uxtb	r0, r0
 8088e50:	2801      	cmp	r0, #1
 8088e52:	d007      	beq.n	8088e64 <HAL_SD_ReadBlocks+0x30>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8088e54:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 8088e56:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8088e58:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8088e5c:	63a3      	str	r3, [r4, #56]	; 0x38
}
 8088e5e:	b006      	add	sp, #24
 8088e60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8088e64:	19f3      	adds	r3, r6, r7
 8088e66:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8088e68:	2100      	movs	r1, #0
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8088e6a:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8088e6c:	63a1      	str	r1, [r4, #56]	; 0x38
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8088e6e:	d822      	bhi.n	8088eb6 <HAL_SD_ReadBlocks+0x82>
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8088e70:	6c63      	ldr	r3, [r4, #68]	; 0x44
    hsd->State = HAL_SD_STATE_BUSY;
 8088e72:	2203      	movs	r2, #3
    hsd->Instance->DCTRL = 0;
 8088e74:	6820      	ldr	r0, [r4, #0]
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8088e76:	2b01      	cmp	r3, #1
    hsd->State = HAL_SD_STATE_BUSY;
 8088e78:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hsd->Instance->DCTRL = 0;
 8088e7c:	62c1      	str	r1, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8088e7e:	f44f 7100 	mov.w	r1, #512	; 0x200
      BlockAdd *= 512;
 8088e82:	bf18      	it	ne
 8088e84:	0276      	lslne	r6, r6, #9
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8088e86:	f002 fb63 	bl	808b550 <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 8088e8a:	4603      	mov	r3, r0
 8088e8c:	b1d0      	cbz	r0, 8088ec4 <HAL_SD_ReadBlocks+0x90>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);      
 8088e8e:	6822      	ldr	r2, [r4, #0]
 8088e90:	f240 50ff 	movw	r0, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 8088e94:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);      
 8088e96:	6390      	str	r0, [r2, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 8088e98:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      return HAL_ERROR;
 8088e9a:	4608      	mov	r0, r1
      hsd->ErrorCode |= errorstate;
 8088e9c:	4313      	orrs	r3, r2
 8088e9e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8088ea0:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      return HAL_ERROR;
 8088ea4:	e7db      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8088ea6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 8088ea8:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8088eaa:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8088eae:	63a3      	str	r3, [r4, #56]	; 0x38
}
 8088eb0:	b006      	add	sp, #24
 8088eb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8088eb6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8088eb8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8088ebc:	63a3      	str	r3, [r4, #56]	; 0x38
}
 8088ebe:	b006      	add	sp, #24
 8088ec0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8088ec4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 8088ec8:	0278      	lsls	r0, r7, #9
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8088eca:	2290      	movs	r2, #144	; 0x90
    config.DPSM          = SDMMC_DPSM_ENABLE;
 8088ecc:	f04f 0a01 	mov.w	sl, #1
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8088ed0:	f04f 0902 	mov.w	r9, #2
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8088ed4:	9100      	str	r1, [sp, #0]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 8088ed6:	9001      	str	r0, [sp, #4]
    SDMMC_ConfigData(hsd->Instance, &config);
 8088ed8:	4669      	mov	r1, sp
 8088eda:	6820      	ldr	r0, [r4, #0]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8088edc:	9304      	str	r3, [sp, #16]
    config.DPSM          = SDMMC_DPSM_ENABLE;
 8088ede:	f8cd a014 	str.w	sl, [sp, #20]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8088ee2:	e9cd 2902 	strd	r2, r9, [sp, #8]
    SDMMC_ConfigData(hsd->Instance, &config);
 8088ee6:	f002 fb1d 	bl	808b524 <SDMMC_ConfigData>
    if(NumberOfBlocks > 1)
 8088eea:	4557      	cmp	r7, sl
 8088eec:	d933      	bls.n	8088f56 <HAL_SD_ReadBlocks+0x122>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
 8088eee:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
 8088ef2:	4631      	mov	r1, r6
 8088ef4:	6820      	ldr	r0, [r4, #0]
 8088ef6:	f002 fb4f 	bl	808b598 <SDMMC_CmdReadMultiBlock>
 8088efa:	4602      	mov	r2, r0
 8088efc:	6823      	ldr	r3, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 8088efe:	b152      	cbz	r2, 8088f16 <HAL_SD_ReadBlocks+0xe2>
 8088f00:	e01e      	b.n	8088f40 <HAL_SD_ReadBlocks+0x10c>
      if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
 8088f02:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8088f04:	b37b      	cbz	r3, 8088f66 <HAL_SD_ReadBlocks+0x132>
 8088f06:	f7fc fc53 	bl	80857b0 <HAL_GetTick>
 8088f0a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8088f0c:	eba0 0008 	sub.w	r0, r0, r8
 8088f10:	4298      	cmp	r0, r3
 8088f12:	d228      	bcs.n	8088f66 <HAL_SD_ReadBlocks+0x132>
 8088f14:	6823      	ldr	r3, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8088f16:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8088f18:	f412 7f95 	tst.w	r2, #298	; 0x12a
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 8088f1c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8088f1e:	d12f      	bne.n	8088f80 <HAL_SD_ReadBlocks+0x14c>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 8088f20:	0412      	lsls	r2, r2, #16
 8088f22:	d5ee      	bpl.n	8088f02 <HAL_SD_ReadBlocks+0xce>
 8088f24:	1f2e      	subs	r6, r5, #4
 8088f26:	f105 091c 	add.w	r9, r5, #28
 8088f2a:	e000      	b.n	8088f2e <HAL_SD_ReadBlocks+0xfa>
 8088f2c:	6823      	ldr	r3, [r4, #0]
          *(tempbuff + count) = SDMMC_ReadFIFO(hsd->Instance);
 8088f2e:	4618      	mov	r0, r3
 8088f30:	f002 fada 	bl	808b4e8 <SDMMC_ReadFIFO>
 8088f34:	f846 0f04 	str.w	r0, [r6, #4]!
        for(count = 0U; count < 8U; count++)
 8088f38:	454e      	cmp	r6, r9
 8088f3a:	d1f7      	bne.n	8088f2c <HAL_SD_ReadBlocks+0xf8>
        tempbuff += 8U;
 8088f3c:	3520      	adds	r5, #32
 8088f3e:	e7e0      	b.n	8088f02 <HAL_SD_ReadBlocks+0xce>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088f40:	f240 50ff 	movw	r0, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 8088f44:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088f46:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
 8088f48:	4608      	mov	r0, r1
      hsd->ErrorCode |= errorstate;
 8088f4a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8088f4c:	431a      	orrs	r2, r3
 8088f4e:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8088f50:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      return HAL_ERROR;
 8088f54:	e783      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 8088f56:	f8c4 a030 	str.w	sl, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
 8088f5a:	4631      	mov	r1, r6
 8088f5c:	6820      	ldr	r0, [r4, #0]
 8088f5e:	f002 fb09 	bl	808b574 <SDMMC_CmdReadSingleBlock>
 8088f62:	4602      	mov	r2, r0
 8088f64:	e7ca      	b.n	8088efc <HAL_SD_ReadBlocks+0xc8>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088f66:	6823      	ldr	r3, [r4, #0]
 8088f68:	f240 51ff 	movw	r1, #1535	; 0x5ff
        hsd->State= HAL_SD_STATE_READY;
 8088f6c:	2201      	movs	r2, #1
        return HAL_TIMEOUT;
 8088f6e:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088f70:	6399      	str	r1, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 8088f72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8088f74:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8088f78:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 8088f7a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        return HAL_TIMEOUT;
 8088f7e:	e76e      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8088f80:	05d6      	lsls	r6, r2, #23
 8088f82:	d50b      	bpl.n	8088f9c <HAL_SD_ReadBlocks+0x168>
 8088f84:	2f01      	cmp	r7, #1
 8088f86:	d909      	bls.n	8088f9c <HAL_SD_ReadBlocks+0x168>
      if(hsd->SdCard.CardType != CARD_SECURED)
 8088f88:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8088f8a:	2a03      	cmp	r2, #3
 8088f8c:	d006      	beq.n	8088f9c <HAL_SD_ReadBlocks+0x168>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8088f8e:	4618      	mov	r0, r3
 8088f90:	f002 fb70 	bl	808b674 <SDMMC_CmdStopTransfer>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088f94:	6823      	ldr	r3, [r4, #0]
        if(errorstate != HAL_SD_ERROR_NONE)
 8088f96:	4601      	mov	r1, r0
 8088f98:	2800      	cmp	r0, #0
 8088f9a:	d156      	bne.n	808904a <HAL_SD_ReadBlocks+0x216>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8088f9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8088f9e:	0710      	lsls	r0, r2, #28
 8088fa0:	d422      	bmi.n	8088fe8 <HAL_SD_ReadBlocks+0x1b4>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8088fa2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8088fa4:	0791      	lsls	r1, r2, #30
 8088fa6:	d42b      	bmi.n	8089000 <HAL_SD_ReadBlocks+0x1cc>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 8088fa8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8088faa:	0692      	lsls	r2, r2, #26
 8088fac:	d50f      	bpl.n	8088fce <HAL_SD_ReadBlocks+0x19a>
 8088fae:	e033      	b.n	8089018 <HAL_SD_ReadBlocks+0x1e4>
      *tempbuff = SDMMC_ReadFIFO(hsd->Instance);
 8088fb0:	f002 fa9a 	bl	808b4e8 <SDMMC_ReadFIFO>
      if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
 8088fb4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
      *tempbuff = SDMMC_ReadFIFO(hsd->Instance);
 8088fb6:	f845 0b04 	str.w	r0, [r5], #4
      if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
 8088fba:	2b00      	cmp	r3, #0
 8088fbc:	d038      	beq.n	8089030 <HAL_SD_ReadBlocks+0x1fc>
 8088fbe:	f7fc fbf7 	bl	80857b0 <HAL_GetTick>
 8088fc2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8088fc4:	eba0 0008 	sub.w	r0, r0, r8
 8088fc8:	4298      	cmp	r0, r3
 8088fca:	d231      	bcs.n	8089030 <HAL_SD_ReadBlocks+0x1fc>
 8088fcc:	6823      	ldr	r3, [r4, #0]
    while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL)))
 8088fce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
      *tempbuff = SDMMC_ReadFIFO(hsd->Instance);
 8088fd0:	4618      	mov	r0, r3
    while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL)))
 8088fd2:	f412 1200 	ands.w	r2, r2, #2097152	; 0x200000
 8088fd6:	d1eb      	bne.n	8088fb0 <HAL_SD_ReadBlocks+0x17c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088fd8:	f240 55ff 	movw	r5, #1535	; 0x5ff
    hsd->State = HAL_SD_STATE_READY;
 8088fdc:	2101      	movs	r1, #1
    return HAL_OK;
 8088fde:	4610      	mov	r0, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088fe0:	639d      	str	r5, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8088fe2:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    return HAL_OK;
 8088fe6:	e73a      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088fe8:	f240 51ff 	movw	r1, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 8088fec:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8088fee:	6399      	str	r1, [r3, #56]	; 0x38
      return HAL_ERROR;
 8088ff0:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 8088ff2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8088ff4:	f043 0308 	orr.w	r3, r3, #8
 8088ff8:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8088ffa:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      return HAL_ERROR;
 8088ffe:	e72e      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089000:	f240 51ff 	movw	r1, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 8089004:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089006:	6399      	str	r1, [r3, #56]	; 0x38
      return HAL_ERROR;
 8089008:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 808900a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 808900c:	f043 0302 	orr.w	r3, r3, #2
 8089010:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8089012:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      return HAL_ERROR;
 8089016:	e722      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089018:	f240 51ff 	movw	r1, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 808901c:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 808901e:	6399      	str	r1, [r3, #56]	; 0x38
      return HAL_ERROR;
 8089020:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 8089022:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8089024:	f043 0320 	orr.w	r3, r3, #32
 8089028:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 808902a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      return HAL_ERROR;
 808902e:	e716      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);        
 8089030:	6823      	ldr	r3, [r4, #0]
 8089032:	f240 51ff 	movw	r1, #1535	; 0x5ff
        hsd->State= HAL_SD_STATE_READY;
 8089036:	2201      	movs	r2, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);        
 8089038:	6399      	str	r1, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 808903a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        return HAL_ERROR;
 808903c:	4610      	mov	r0, r2
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 808903e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8089042:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 8089044:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        return HAL_ERROR;
 8089048:	e709      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 808904a:	f240 50ff 	movw	r0, #1535	; 0x5ff
          hsd->State = HAL_SD_STATE_READY;
 808904e:	2201      	movs	r2, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089050:	6398      	str	r0, [r3, #56]	; 0x38
          return HAL_ERROR;
 8089052:	4610      	mov	r0, r2
          hsd->ErrorCode |= errorstate;
 8089054:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8089056:	430b      	orrs	r3, r1
 8089058:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 808905a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
          return HAL_ERROR;
 808905e:	e6fe      	b.n	8088e5e <HAL_SD_ReadBlocks+0x2a>

08089060 <HAL_SD_WriteBlocks>:
{
 8089060:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8089064:	460d      	mov	r5, r1
 8089066:	b086      	sub	sp, #24
 8089068:	4604      	mov	r4, r0
 808906a:	4690      	mov	r8, r2
 808906c:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
 808906e:	f7fc fb9f 	bl	80857b0 <HAL_GetTick>
  if(NULL == pData)
 8089072:	2d00      	cmp	r5, #0
 8089074:	d03d      	beq.n	80890f2 <HAL_SD_WriteBlocks+0x92>
 8089076:	4607      	mov	r7, r0
  if(hsd->State == HAL_SD_STATE_READY)
 8089078:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 808907c:	b2c0      	uxtb	r0, r0
 808907e:	2801      	cmp	r0, #1
 8089080:	d007      	beq.n	8089092 <HAL_SD_WriteBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8089082:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 8089084:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8089086:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 808908a:	63a3      	str	r3, [r4, #56]	; 0x38
}
 808908c:	b006      	add	sp, #24
 808908e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8089092:	eb08 0306 	add.w	r3, r8, r6
 8089096:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8089098:	2100      	movs	r1, #0
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 808909a:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 808909c:	63a1      	str	r1, [r4, #56]	; 0x38
    if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 808909e:	d830      	bhi.n	8089102 <HAL_SD_WriteBlocks+0xa2>
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 80890a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
    hsd->State = HAL_SD_STATE_BUSY;
 80890a2:	2203      	movs	r2, #3
    hsd->Instance->DCTRL = 0;
 80890a4:	6820      	ldr	r0, [r4, #0]
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 80890a6:	2b01      	cmp	r3, #1
    hsd->State = HAL_SD_STATE_BUSY;
 80890a8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hsd->Instance->DCTRL = 0;
 80890ac:	62c1      	str	r1, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80890ae:	f44f 7100 	mov.w	r1, #512	; 0x200
      BlockAdd *= 512;
 80890b2:	bf18      	it	ne
 80890b4:	ea4f 2848 	movne.w	r8, r8, lsl #9
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80890b8:	f002 fa4a 	bl	808b550 <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 80890bc:	4603      	mov	r3, r0
 80890be:	bb38      	cbnz	r0, 8089110 <HAL_SD_WriteBlocks+0xb0>
    if(NumberOfBlocks > 1U)
 80890c0:	2e01      	cmp	r6, #1
 80890c2:	6820      	ldr	r0, [r4, #0]
 80890c4:	d930      	bls.n	8089128 <HAL_SD_WriteBlocks+0xc8>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 80890c6:	2320      	movs	r3, #32
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
 80890c8:	4641      	mov	r1, r8
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 80890ca:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
 80890cc:	f002 fa88 	bl	808b5e0 <SDMMC_CmdWriteMultiBlock>
 80890d0:	4680      	mov	r8, r0
 80890d2:	6820      	ldr	r0, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 80890d4:	f1b8 0f00 	cmp.w	r8, #0
 80890d8:	d02d      	beq.n	8089136 <HAL_SD_WriteBlocks+0xd6>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 80890da:	f240 53ff 	movw	r3, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 80890de:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 80890e0:	6383      	str	r3, [r0, #56]	; 0x38
      return HAL_ERROR;
 80890e2:	4610      	mov	r0, r2
      hsd->ErrorCode |= errorstate;
 80890e4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80890e6:	ea43 0308 	orr.w	r3, r3, r8
 80890ea:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80890ec:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      return HAL_ERROR;
 80890f0:	e7cc      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80890f2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 80890f4:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80890f6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80890fa:	63a3      	str	r3, [r4, #56]	; 0x38
}
 80890fc:	b006      	add	sp, #24
 80890fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8089102:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8089104:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8089108:	63a3      	str	r3, [r4, #56]	; 0x38
}
 808910a:	b006      	add	sp, #24
 808910c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 8089110:	6822      	ldr	r2, [r4, #0]
 8089112:	f240 50ff 	movw	r0, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 8089116:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 8089118:	6390      	str	r0, [r2, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 808911a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      return HAL_ERROR;
 808911c:	4608      	mov	r0, r1
      hsd->ErrorCode |= errorstate;
 808911e:	4313      	orrs	r3, r2
 8089120:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8089122:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      return HAL_ERROR;
 8089126:	e7b1      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 8089128:	2310      	movs	r3, #16
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
 808912a:	4641      	mov	r1, r8
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 808912c:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
 808912e:	f002 fa45 	bl	808b5bc <SDMMC_CmdWriteSingleBlock>
 8089132:	4680      	mov	r8, r0
 8089134:	e7cd      	b.n	80890d2 <HAL_SD_WriteBlocks+0x72>
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 8089136:	0271      	lsls	r1, r6, #9
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8089138:	2290      	movs	r2, #144	; 0x90
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 808913a:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    config.DPSM          = SDMMC_DPSM_ENABLE;
 808913e:	2301      	movs	r3, #1
        if ((int)tempbuff >= (0x20050000-8))
 8089140:	f64f 79f7 	movw	r9, #65527	; 0xfff7
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 8089144:	f8cd 800c 	str.w	r8, [sp, #12]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8089148:	f8cd 8010 	str.w	r8, [sp, #16]
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 808914c:	f8cd c000 	str.w	ip, [sp]
        if ((int)tempbuff >= (0x20050000-8))
 8089150:	f2c2 0904 	movt	r9, #8196	; 0x2004
    config.DPSM          = SDMMC_DPSM_ENABLE;
 8089154:	9305      	str	r3, [sp, #20]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8089156:	e9cd 1201 	strd	r1, r2, [sp, #4]
    SDMMC_ConfigData(hsd->Instance, &config);
 808915a:	4669      	mov	r1, sp
 808915c:	f002 f9e2 	bl	808b524 <SDMMC_ConfigData>
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8089160:	e00a      	b.n	8089178 <HAL_SD_WriteBlocks+0x118>
      if (supercount>config.DataLength)
 8089162:	9b01      	ldr	r3, [sp, #4]
 8089164:	4543      	cmp	r3, r8
 8089166:	d31f      	bcc.n	80891a8 <HAL_SD_WriteBlocks+0x148>
      if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
 8089168:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 808916a:	b1fb      	cbz	r3, 80891ac <HAL_SD_WriteBlocks+0x14c>
 808916c:	f7fc fb20 	bl	80857b0 <HAL_GetTick>
 8089170:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8089172:	1bc0      	subs	r0, r0, r7
 8089174:	4298      	cmp	r0, r3
 8089176:	d219      	bcs.n	80891ac <HAL_SD_WriteBlocks+0x14c>
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8089178:	6823      	ldr	r3, [r4, #0]
 808917a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 808917c:	f412 7f8d 	tst.w	r2, #282	; 0x11a
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE))
 8089180:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8089182:	d11e      	bne.n	80891c2 <HAL_SD_WriteBlocks+0x162>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE))
 8089184:	0452      	lsls	r2, r2, #17
 8089186:	d5ec      	bpl.n	8089162 <HAL_SD_WriteBlocks+0x102>
 8089188:	f105 0a20 	add.w	sl, r5, #32
 808918c:	e000      	b.n	8089190 <HAL_SD_WriteBlocks+0x130>
 808918e:	6823      	ldr	r3, [r4, #0]
          SDMMC_WriteFIFO(hsd->Instance, (tempbuff + count));
 8089190:	4629      	mov	r1, r5
 8089192:	3504      	adds	r5, #4
 8089194:	4618      	mov	r0, r3
 8089196:	f002 f9ab 	bl	808b4f0 <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
 808919a:	45aa      	cmp	sl, r5
 808919c:	d1f7      	bne.n	808918e <HAL_SD_WriteBlocks+0x12e>
        if ((int)tempbuff >= (0x20050000-8))
 808919e:	45ca      	cmp	sl, r9
        tempbuff += 8U;
 80891a0:	4655      	mov	r5, sl
        supercount +=8;
 80891a2:	f108 0808 	add.w	r8, r8, #8
        if ((int)tempbuff >= (0x20050000-8))
 80891a6:	dddc      	ble.n	8089162 <HAL_SD_WriteBlocks+0x102>
        	return HAL_OK;
 80891a8:	2000      	movs	r0, #0
 80891aa:	e76f      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 80891ac:	6822      	ldr	r2, [r4, #0]
 80891ae:	f240 51ff 	movw	r1, #1535	; 0x5ff
        hsd->State = HAL_SD_STATE_READY;
 80891b2:	2301      	movs	r3, #1
        return HAL_TIMEOUT;
 80891b4:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 80891b6:	6391      	str	r1, [r2, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 80891b8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80891ba:	63a2      	str	r2, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 80891bc:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        return HAL_TIMEOUT;
 80891c0:	e764      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 80891c2:	05d0      	lsls	r0, r2, #23
 80891c4:	d50b      	bpl.n	80891de <HAL_SD_WriteBlocks+0x17e>
 80891c6:	2e01      	cmp	r6, #1
 80891c8:	d909      	bls.n	80891de <HAL_SD_WriteBlocks+0x17e>
      if(hsd->SdCard.CardType != CARD_SECURED)
 80891ca:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80891cc:	2a03      	cmp	r2, #3
 80891ce:	d006      	beq.n	80891de <HAL_SD_WriteBlocks+0x17e>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 80891d0:	4618      	mov	r0, r3
 80891d2:	f002 fa4f 	bl	808b674 <SDMMC_CmdStopTransfer>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 80891d6:	6823      	ldr	r3, [r4, #0]
        if(errorstate != HAL_SD_ERROR_NONE)
 80891d8:	4601      	mov	r1, r0
 80891da:	2800      	cmp	r0, #0
 80891dc:	d135      	bne.n	808924a <HAL_SD_WriteBlocks+0x1ea>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 80891de:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80891e0:	0711      	lsls	r1, r2, #28
 80891e2:	d412      	bmi.n	808920a <HAL_SD_WriteBlocks+0x1aa>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 80891e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80891e6:	0792      	lsls	r2, r2, #30
 80891e8:	d41b      	bmi.n	8089222 <HAL_SD_WriteBlocks+0x1c2>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
 80891ea:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80891ec:	f012 0210 	ands.w	r2, r2, #16
 80891f0:	d023      	beq.n	808923a <HAL_SD_WriteBlocks+0x1da>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80891f2:	f240 51ff 	movw	r1, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 80891f6:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80891f8:	6399      	str	r1, [r3, #56]	; 0x38
      return HAL_ERROR;
 80891fa:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 80891fc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80891fe:	f043 0310 	orr.w	r3, r3, #16
 8089202:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8089204:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      return HAL_ERROR;
 8089208:	e740      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 808920a:	f240 51ff 	movw	r1, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 808920e:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089210:	6399      	str	r1, [r3, #56]	; 0x38
      return HAL_ERROR;
 8089212:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 8089214:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8089216:	f043 0308 	orr.w	r3, r3, #8
 808921a:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 808921c:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      return HAL_ERROR;
 8089220:	e734      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089222:	f240 51ff 	movw	r1, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 8089226:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089228:	6399      	str	r1, [r3, #56]	; 0x38
      return HAL_ERROR;
 808922a:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;      
 808922c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 808922e:	f043 0302 	orr.w	r3, r3, #2
 8089232:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8089234:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      return HAL_ERROR;
 8089238:	e728      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 808923a:	f240 55ff 	movw	r5, #1535	; 0x5ff
    hsd->State = HAL_SD_STATE_READY;
 808923e:	2101      	movs	r1, #1
    return HAL_OK;
 8089240:	4610      	mov	r0, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089242:	639d      	str	r5, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8089244:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    return HAL_OK;
 8089248:	e720      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 808924a:	f240 50ff 	movw	r0, #1535	; 0x5ff
          hsd->State = HAL_SD_STATE_READY;
 808924e:	2201      	movs	r2, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 8089250:	6398      	str	r0, [r3, #56]	; 0x38
          return HAL_ERROR;
 8089252:	4610      	mov	r0, r2
          hsd->ErrorCode |= errorstate;
 8089254:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8089256:	430b      	orrs	r3, r1
 8089258:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 808925a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
          return HAL_ERROR;
 808925e:	e715      	b.n	808908c <HAL_SD_WriteBlocks+0x2c>

08089260 <HAL_SD_Erase>:
{
 8089260:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(hsd->State == HAL_SD_STATE_READY)
 8089262:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
{
 8089266:	b083      	sub	sp, #12
  if(hsd->State == HAL_SD_STATE_READY)
 8089268:	b2e4      	uxtb	r4, r4
 808926a:	2c01      	cmp	r4, #1
 808926c:	d121      	bne.n	80892b2 <HAL_SD_Erase+0x52>
 808926e:	460e      	mov	r6, r1
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8089270:	2100      	movs	r1, #0
 8089272:	4605      	mov	r5, r0
    if(BlockEndAdd < BlockStartAdd)
 8089274:	42b2      	cmp	r2, r6
    hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8089276:	6381      	str	r1, [r0, #56]	; 0x38
    if(BlockEndAdd < BlockStartAdd)
 8089278:	d314      	bcc.n	80892a4 <HAL_SD_Erase+0x44>
    if(BlockEndAdd > (hsd->SdCard.LogBlockNbr))
 808927a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 808927c:	4293      	cmp	r3, r2
 808927e:	d31b      	bcc.n	80892b8 <HAL_SD_Erase+0x58>
    if(((hsd->SdCard.Class) & SDMMC_CCCC_ERASE) == 0U)
 8089280:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
    hsd->State = HAL_SD_STATE_BUSY;
 8089282:	2703      	movs	r7, #3
 8089284:	682b      	ldr	r3, [r5, #0]
    if(((hsd->SdCard.Class) & SDMMC_CCCC_ERASE) == 0U)
 8089286:	0680      	lsls	r0, r0, #26
    hsd->State = HAL_SD_STATE_BUSY;
 8089288:	f885 7034 	strb.w	r7, [r5, #52]	; 0x34
    if(((hsd->SdCard.Class) & SDMMC_CCCC_ERASE) == 0U)
 808928c:	d41b      	bmi.n	80892c6 <HAL_SD_Erase+0x66>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 808928e:	f240 52ff 	movw	r2, #1535	; 0x5ff
      return HAL_ERROR;
 8089292:	4620      	mov	r0, r4
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8089294:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8089296:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8089298:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 808929c:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 808929e:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
      return HAL_ERROR;
 80892a2:	e004      	b.n	80892ae <HAL_SD_Erase+0x4e>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80892a4:	6b83      	ldr	r3, [r0, #56]	; 0x38
      return HAL_ERROR;
 80892a6:	4620      	mov	r0, r4
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80892a8:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80892ac:	63ab      	str	r3, [r5, #56]	; 0x38
}
 80892ae:	b003      	add	sp, #12
 80892b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 80892b2:	2002      	movs	r0, #2
}
 80892b4:	b003      	add	sp, #12
 80892b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 80892b8:	6b83      	ldr	r3, [r0, #56]	; 0x38
      return HAL_ERROR;
 80892ba:	4620      	mov	r0, r4
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 80892bc:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80892c0:	63ab      	str	r3, [r5, #56]	; 0x38
}
 80892c2:	b003      	add	sp, #12
 80892c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 80892c6:	4618      	mov	r0, r3
 80892c8:	9201      	str	r2, [sp, #4]
 80892ca:	f002 f921 	bl	808b510 <SDMMC_GetResponse>
 80892ce:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 80892d2:	9a01      	ldr	r2, [sp, #4]
 80892d4:	d11a      	bne.n	808930c <HAL_SD_Erase+0xac>
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 80892d6:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80892d8:	2b01      	cmp	r3, #1
 80892da:	d003      	beq.n	80892e4 <HAL_SD_Erase+0x84>
    if(hsd->SdCard.CardType != CARD_SECURED)
 80892dc:	2b03      	cmp	r3, #3
 80892de:	d028      	beq.n	8089332 <HAL_SD_Erase+0xd2>
      BlockStartAdd *= 512U;
 80892e0:	0276      	lsls	r6, r6, #9
      BlockEndAdd   *= 512U;
 80892e2:	0252      	lsls	r2, r2, #9
      errorstate = SDMMC_CmdSDEraseStartAdd(hsd->Instance, BlockStartAdd);
 80892e4:	4631      	mov	r1, r6
 80892e6:	6828      	ldr	r0, [r5, #0]
 80892e8:	9201      	str	r2, [sp, #4]
 80892ea:	f002 f98b 	bl	808b604 <SDMMC_CmdSDEraseStartAdd>
      if(errorstate != HAL_SD_ERROR_NONE)
 80892ee:	9a01      	ldr	r2, [sp, #4]
 80892f0:	4603      	mov	r3, r0
 80892f2:	b1b8      	cbz	r0, 8089324 <HAL_SD_Erase+0xc4>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS); 
 80892f4:	682a      	ldr	r2, [r5, #0]
 80892f6:	f240 50ff 	movw	r0, #1535	; 0x5ff
      hsd->State = HAL_SD_STATE_READY;
 80892fa:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS); 
 80892fc:	6390      	str	r0, [r2, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 80892fe:	6baa      	ldr	r2, [r5, #56]	; 0x38
      return HAL_ERROR;
 8089300:	4608      	mov	r0, r1
      hsd->ErrorCode |= errorstate;
 8089302:	4313      	orrs	r3, r2
 8089304:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8089306:	f885 1034 	strb.w	r1, [r5, #52]	; 0x34
      return HAL_ERROR;
 808930a:	e7d0      	b.n	80892ae <HAL_SD_Erase+0x4e>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 808930c:	682b      	ldr	r3, [r5, #0]
 808930e:	f240 52ff 	movw	r2, #1535	; 0x5ff
      return HAL_ERROR;
 8089312:	4620      	mov	r0, r4
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 8089314:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8089316:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8089318:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 808931c:	63ab      	str	r3, [r5, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 808931e:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
      return HAL_ERROR;
 8089322:	e7c4      	b.n	80892ae <HAL_SD_Erase+0x4e>
      errorstate = SDMMC_CmdSDEraseEndAdd(hsd->Instance, BlockEndAdd);
 8089324:	4611      	mov	r1, r2
 8089326:	6828      	ldr	r0, [r5, #0]
 8089328:	f002 f97e 	bl	808b628 <SDMMC_CmdSDEraseEndAdd>
      if(errorstate != HAL_SD_ERROR_NONE)
 808932c:	4603      	mov	r3, r0
 808932e:	2800      	cmp	r0, #0
 8089330:	d1e0      	bne.n	80892f4 <HAL_SD_Erase+0x94>
    errorstate = SDMMC_CmdErase(hsd->Instance);
 8089332:	6828      	ldr	r0, [r5, #0]
 8089334:	f002 f98a 	bl	808b64c <SDMMC_CmdErase>
    if(errorstate != HAL_SD_ERROR_NONE)
 8089338:	4603      	mov	r3, r0
 808933a:	2800      	cmp	r0, #0
 808933c:	d1da      	bne.n	80892f4 <HAL_SD_Erase+0x94>
    hsd->State = HAL_SD_STATE_READY;
 808933e:	2201      	movs	r2, #1
 8089340:	f885 2034 	strb.w	r2, [r5, #52]	; 0x34
    return HAL_OK;
 8089344:	e7b3      	b.n	80892ae <HAL_SD_Erase+0x4e>
 8089346:	bf00      	nop

08089348 <HAL_SD_GetCardCSD>:
  tmp = (hsd->CSD[0] & 0xFF000000U) >> 24;
 8089348:	6e43      	ldr	r3, [r0, #100]	; 0x64
  pCSD->CSDStruct      = (uint8_t)((tmp & 0xC0) >> 6);
 808934a:	0f9a      	lsrs	r2, r3, #30
{
 808934c:	b5f0      	push	{r4, r5, r6, r7, lr}
  pCSD->CSDStruct      = (uint8_t)((tmp & 0xC0) >> 6);
 808934e:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((tmp & 0x3C) >> 2);
 8089350:	f3c3 6783 	ubfx	r7, r3, #26, #4
  pCSD->Reserved1      = tmp & 0x03;
 8089354:	f3c3 6501 	ubfx	r5, r3, #24, #2
  pCSD->TAAC = (uint8_t)tmp;
 8089358:	f3c3 4407 	ubfx	r4, r3, #16, #8
  pCSD->NSAC = (uint8_t)tmp;
 808935c:	f3c3 2207 	ubfx	r2, r3, #8, #8
  pCSD->MaxBusClkFrec = (uint8_t)tmp;
 8089360:	b2db      	uxtb	r3, r3
  pCSD->SysSpecVersion = (uint8_t)((tmp & 0x3C) >> 2);
 8089362:	704f      	strb	r7, [r1, #1]
  pCSD->Reserved2       = 0; /*!< Reserved */
 8089364:	2600      	movs	r6, #0
  pCSD->Reserved1      = tmp & 0x03;
 8089366:	708d      	strb	r5, [r1, #2]
  pCSD->TAAC = (uint8_t)tmp;
 8089368:	70cc      	strb	r4, [r1, #3]
  pCSD->NSAC = (uint8_t)tmp;
 808936a:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)tmp;
 808936c:	714b      	strb	r3, [r1, #5]
  tmp = (hsd->CSD[1] & 0xFF000000U) >> 24;
 808936e:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8089370:	0e1d      	lsrs	r5, r3, #24
  pCSD->CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4);
 8089372:	f3c3 5403 	ubfx	r4, r3, #20, #4
  tmp = (hsd->CSD[1] & 0x0000FF00U) >> 8;
 8089376:	f3c3 2207 	ubfx	r2, r3, #8, #8
  pCSD->CardComdClasses = (uint16_t)(tmp << 4);
 808937a:	012d      	lsls	r5, r5, #4
  pCSD->PartBlockRead   = (uint8_t)((tmp & 0x80) >> 7);
 808937c:	ea4f 1cd2 	mov.w	ip, r2, lsr #7
  pCSD->CardComdClasses = (uint16_t)(tmp << 4);
 8089380:	80cd      	strh	r5, [r1, #6]
  pCSD->RdBlockLen       = (uint8_t)(tmp & 0x0F);
 8089382:	f3c3 4503 	ubfx	r5, r3, #16, #4
  pCSD->CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4);
 8089386:	88cf      	ldrh	r7, [r1, #6]
 8089388:	433c      	orrs	r4, r7
  pCSD->WrBlockMisalign = (uint8_t)((tmp & 0x40) >> 6);
 808938a:	f3c2 1780 	ubfx	r7, r2, #6, #1
  pCSD->CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4);
 808938e:	80cc      	strh	r4, [r1, #6]
  pCSD->DSRImpl         = (uint8_t)((tmp & 0x10) >> 4);
 8089390:	f3c2 1400 	ubfx	r4, r2, #4, #1
  pCSD->RdBlockLen       = (uint8_t)(tmp & 0x0F);
 8089394:	720d      	strb	r5, [r1, #8]
  pCSD->RdBlockMisalign = (uint8_t)((tmp & 0x20) >> 5);
 8089396:	f3c2 1540 	ubfx	r5, r2, #5, #1
  pCSD->PartBlockRead   = (uint8_t)((tmp & 0x80) >> 7);
 808939a:	f881 c009 	strb.w	ip, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((tmp & 0x40) >> 6);
 808939e:	728f      	strb	r7, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((tmp & 0x20) >> 5);
 80893a0:	72cd      	strb	r5, [r1, #11]
  pCSD->DSRImpl         = (uint8_t)((tmp & 0x10) >> 4);
 80893a2:	730c      	strb	r4, [r1, #12]
  pCSD->Reserved2       = 0; /*!< Reserved */
 80893a4:	734e      	strb	r6, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 80893a6:	6c44      	ldr	r4, [r0, #68]	; 0x44
 80893a8:	2c00      	cmp	r4, #0
 80893aa:	f040 8088 	bne.w	80894be <HAL_SD_GetCardCSD+0x176>
    pCSD->DeviceSize = (tmp & 0x03) << 10;
 80893ae:	0292      	lsls	r2, r2, #10
    tmp = (uint8_t)((hsd->CSD[2] & 0xFF000000U) >> 24);
 80893b0:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    pCSD->DeviceSize |= (tmp) << 2;
 80893b2:	009b      	lsls	r3, r3, #2
    hsd->SdCard.BlockSize = 1 << (pCSD->RdBlockLen);
 80893b4:	2501      	movs	r5, #1
    pCSD->DeviceSize = (tmp & 0x03) << 10;
 80893b6:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
    pCSD->DeviceSizeMul      = (tmp & 0x03) << 1;
 80893ba:	0be6      	lsrs	r6, r4, #15
    pCSD->DeviceSize |= (tmp) << 2;
 80893bc:	f403 737f 	and.w	r3, r3, #1020	; 0x3fc
    pCSD->MaxRdCurrentVDDMax = (tmp & 0x07);
 80893c0:	f3c4 6c02 	ubfx	ip, r4, #24, #3
    pCSD->DeviceSize = (tmp & 0x03) << 10;
 80893c4:	610a      	str	r2, [r1, #16]
    pCSD->DeviceSizeMul      = (tmp & 0x03) << 1;
 80893c6:	f006 0606 	and.w	r6, r6, #6
    pCSD->DeviceSize |= (tmp) << 2;
 80893ca:	690a      	ldr	r2, [r1, #16]
    pCSD->MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
 80893cc:	f3c4 5742 	ubfx	r7, r4, #21, #3
    pCSD->MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
 80893d0:	f3c4 6ec2 	ubfx	lr, r4, #27, #3
    pCSD->DeviceSize |= (tmp) << 2;
 80893d4:	431a      	orrs	r2, r3
 80893d6:	610a      	str	r2, [r1, #16]
    pCSD->MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
 80893d8:	f3c4 4282 	ubfx	r2, r4, #18, #3
    pCSD->DeviceSize |= (tmp & 0xC0) >> 6;
 80893dc:	690b      	ldr	r3, [r1, #16]
 80893de:	ea43 7394 	orr.w	r3, r3, r4, lsr #30
 80893e2:	610b      	str	r3, [r1, #16]
 80893e4:	f3c4 2307 	ubfx	r3, r4, #8, #8
    pCSD->MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
 80893e8:	f881 e014 	strb.w	lr, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (tmp & 0x07);
 80893ec:	f881 c015 	strb.w	ip, [r1, #21]
    pCSD->DeviceSizeMul |= (tmp & 0x80) >> 7;
 80893f0:	f3c4 3cc0 	ubfx	ip, r4, #15, #1
    pCSD->MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
 80893f4:	758f      	strb	r7, [r1, #22]
    hsd->SdCard.LogBlockSize = 512;
 80893f6:	f44f 7700 	mov.w	r7, #512	; 0x200
    pCSD->MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
 80893fa:	75ca      	strb	r2, [r1, #23]
    pCSD->DeviceSizeMul      = (tmp & 0x03) << 1;
 80893fc:	760e      	strb	r6, [r1, #24]
    pCSD->DeviceSizeMul |= (tmp & 0x80) >> 7;
 80893fe:	7e0a      	ldrb	r2, [r1, #24]
 8089400:	ea42 020c 	orr.w	r2, r2, ip
 8089404:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1) ;
 8089406:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockNbr *= (1 << (pCSD->DeviceSizeMul + 2));
 8089408:	7e0e      	ldrb	r6, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1) ;
 808940a:	442a      	add	r2, r5
    hsd->SdCard.BlockNbr *= (1 << (pCSD->DeviceSizeMul + 2));
 808940c:	3602      	adds	r6, #2
 808940e:	40b2      	lsls	r2, r6
 8089410:	6542      	str	r2, [r0, #84]	; 0x54
    hsd->SdCard.BlockSize = 1 << (pCSD->RdBlockLen);
 8089412:	7a0e      	ldrb	r6, [r1, #8]
    hsd->SdCard.LogBlockSize = 512;
 8089414:	6607      	str	r7, [r0, #96]	; 0x60
    hsd->SdCard.BlockSize = 1 << (pCSD->RdBlockLen);
 8089416:	40b5      	lsls	r5, r6
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512); 
 8089418:	0a6e      	lsrs	r6, r5, #9
    hsd->SdCard.BlockSize = 1 << (pCSD->RdBlockLen);
 808941a:	6585      	str	r5, [r0, #88]	; 0x58
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512); 
 808941c:	fb02 f206 	mul.w	r2, r2, r6
 8089420:	65c2      	str	r2, [r0, #92]	; 0x5c
  pCSD->EraseGrMul  = (tmp & 0x3F) << 1;
 8089422:	005d      	lsls	r5, r3, #1
  pCSD->EraseGrSize = (tmp & 0x40) >> 6;
 8089424:	f3c3 1280 	ubfx	r2, r3, #6, #1
  pCSD->EraseGrMul     |= (tmp & 0x80) >> 7;
 8089428:	f3c4 17c0 	ubfx	r7, r4, #7, #1
  pCSD->WrProtectGrSize = (tmp & 0x7F);
 808942c:	f004 037f 	and.w	r3, r4, #127	; 0x7f
  pCSD->EraseGrMul  = (tmp & 0x3F) << 1;
 8089430:	f005 047e 	and.w	r4, r5, #126	; 0x7e
  pCSD->EraseGrSize = (tmp & 0x40) >> 6;
 8089434:	764a      	strb	r2, [r1, #25]
  pCSD->Reserved3           = 0;
 8089436:	2500      	movs	r5, #0
  pCSD->EraseGrMul  = (tmp & 0x3F) << 1;
 8089438:	768c      	strb	r4, [r1, #26]
  pCSD->EraseGrMul     |= (tmp & 0x80) >> 7;
 808943a:	7e8a      	ldrb	r2, [r1, #26]
  return HAL_OK;
 808943c:	462e      	mov	r6, r5
  pCSD->EraseGrMul     |= (tmp & 0x80) >> 7;
 808943e:	433a      	orrs	r2, r7
  pCSD->Reserved4 = 1;
 8089440:	2701      	movs	r7, #1
  pCSD->EraseGrMul     |= (tmp & 0x80) >> 7;
 8089442:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (tmp & 0x7F);
 8089444:	76cb      	strb	r3, [r1, #27]
  tmp = (uint8_t)((hsd->CSD[3] & 0xFF000000U) >> 24);
 8089446:	6f03      	ldr	r3, [r0, #112]	; 0x70
  pCSD->WrProtectGrEnable = (tmp & 0x80) >> 7;
 8089448:	0fda      	lsrs	r2, r3, #31
  pCSD->ManDeflECC        = (tmp & 0x60) >> 5;
 808944a:	f3c3 7041 	ubfx	r0, r3, #29, #2
  pCSD->MaxWrBlockLen     = (tmp & 0x03) << 2;
 808944e:	0d9c      	lsrs	r4, r3, #22
  pCSD->WriteBlockPaPartial = (tmp & 0x20) >> 5;
 8089450:	f3c3 5c40 	ubfx	ip, r3, #21, #1
  pCSD->WrProtectGrEnable = (tmp & 0x80) >> 7;
 8089454:	770a      	strb	r2, [r1, #28]
  pCSD->WrSpeedFact       = (tmp & 0x1C) >> 2;
 8089456:	f3c3 6282 	ubfx	r2, r3, #26, #3
  pCSD->MaxWrBlockLen     = (tmp & 0x03) << 2;
 808945a:	f004 040c 	and.w	r4, r4, #12
  pCSD->ManDeflECC        = (tmp & 0x60) >> 5;
 808945e:	7748      	strb	r0, [r1, #29]
  pCSD->WrSpeedFact       = (tmp & 0x1C) >> 2;
 8089460:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen      |= (tmp & 0xC0) >> 6;
 8089462:	f3c3 5081 	ubfx	r0, r3, #22, #2
  pCSD->MaxWrBlockLen     = (tmp & 0x03) << 2;
 8089466:	77cc      	strb	r4, [r1, #31]
  pCSD->ContentProtectAppli = (tmp & 0x01);
 8089468:	f3c3 4400 	ubfx	r4, r3, #16, #1
  pCSD->MaxWrBlockLen      |= (tmp & 0xC0) >> 6;
 808946c:	7fca      	ldrb	r2, [r1, #31]
 808946e:	4302      	orrs	r2, r0
  pCSD->FileFormatGrouop = (tmp & 0x80) >> 7;
 8089470:	f3c3 30c0 	ubfx	r0, r3, #15, #1
  pCSD->MaxWrBlockLen      |= (tmp & 0xC0) >> 6;
 8089474:	77ca      	strb	r2, [r1, #31]
  pCSD->CopyFlag         = (tmp & 0x40) >> 6;
 8089476:	f3c3 3280 	ubfx	r2, r3, #14, #1
  pCSD->WriteBlockPaPartial = (tmp & 0x20) >> 5;
 808947a:	f881 c020 	strb.w	ip, [r1, #32]
  pCSD->Reserved3           = 0;
 808947e:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
  pCSD->PermWrProtect    = (tmp & 0x20) >> 5;
 8089482:	f3c3 3540 	ubfx	r5, r3, #13, #1
  pCSD->ContentProtectAppli = (tmp & 0x01);
 8089486:	f881 4022 	strb.w	r4, [r1, #34]	; 0x22
  pCSD->TempWrProtect    = (tmp & 0x10) >> 4;
 808948a:	f3c3 3400 	ubfx	r4, r3, #12, #1
  pCSD->FileFormatGrouop = (tmp & 0x80) >> 7;
 808948e:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
  pCSD->FileFormat       = (tmp & 0x0C) >> 2;
 8089492:	f3c3 2081 	ubfx	r0, r3, #10, #2
  pCSD->CopyFlag         = (tmp & 0x40) >> 6;
 8089496:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->ECC              = (tmp & 0x03);
 808949a:	f3c3 2201 	ubfx	r2, r3, #8, #2
  pCSD->CSD_CRC   = (tmp & 0xFE) >> 1;
 808949e:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->PermWrProtect    = (tmp & 0x20) >> 5;
 80894a2:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
  pCSD->TempWrProtect    = (tmp & 0x10) >> 4;
 80894a6:	f881 4026 	strb.w	r4, [r1, #38]	; 0x26
  pCSD->FileFormat       = (tmp & 0x0C) >> 2;
 80894aa:	f881 0027 	strb.w	r0, [r1, #39]	; 0x27
}
 80894ae:	4630      	mov	r0, r6
  pCSD->ECC              = (tmp & 0x03);
 80894b0:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC   = (tmp & 0xFE) >> 1;
 80894b4:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
 80894b8:	f881 702a 	strb.w	r7, [r1, #42]	; 0x2a
}
 80894bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 80894be:	2c01      	cmp	r4, #1
 80894c0:	d00d      	beq.n	80894de <HAL_SD_GetCardCSD+0x196>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);   
 80894c2:	6803      	ldr	r3, [r0, #0]
 80894c4:	f240 51ff 	movw	r1, #1535	; 0x5ff
    hsd->State = HAL_SD_STATE_READY;
 80894c8:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);   
 80894ca:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80894cc:	6b83      	ldr	r3, [r0, #56]	; 0x38
    return HAL_ERROR;
 80894ce:	4616      	mov	r6, r2
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80894d0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80894d4:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80894d6:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
}
 80894da:	4630      	mov	r0, r6
 80894dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pCSD->DeviceSize = (tmp & 0x3F) << 16;
 80894de:	041a      	lsls	r2, r3, #16
    tmp = (uint8_t)((hsd->CSD[2] & 0xFF000000U) >> 24);
 80894e0:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize = 512;
 80894e2:	f44f 7600 	mov.w	r6, #512	; 0x200
    pCSD->DeviceSize = (tmp & 0x3F) << 16;
 80894e6:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
    tmp = (uint8_t)((hsd->CSD[2] & 0xFF000000U) >> 24);
 80894ea:	0e23      	lsrs	r3, r4, #24
    pCSD->DeviceSize = (tmp & 0x3F) << 16;
 80894ec:	610a      	str	r2, [r1, #16]
    pCSD->DeviceSize |= (tmp);
 80894ee:	f3c4 4207 	ubfx	r2, r4, #16, #8
    pCSD->DeviceSize |= (tmp << 8);
 80894f2:	690d      	ldr	r5, [r1, #16]
 80894f4:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
 80894f8:	f3c4 2307 	ubfx	r3, r4, #8, #8
 80894fc:	610d      	str	r5, [r1, #16]
    pCSD->DeviceSize |= (tmp);
 80894fe:	690d      	ldr	r5, [r1, #16]
 8089500:	432a      	orrs	r2, r5
 8089502:	610a      	str	r2, [r1, #16]
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr = (((uint64_t)pCSD->DeviceSize + 1) * 1024);
 8089504:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize = 512;
 8089506:	6586      	str	r6, [r0, #88]	; 0x58
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr = (((uint64_t)pCSD->DeviceSize + 1) * 1024);
 8089508:	3201      	adds	r2, #1
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize = 512;
 808950a:	6606      	str	r6, [r0, #96]	; 0x60
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr = (((uint64_t)pCSD->DeviceSize + 1) * 1024);
 808950c:	0292      	lsls	r2, r2, #10
 808950e:	6542      	str	r2, [r0, #84]	; 0x54
 8089510:	65c2      	str	r2, [r0, #92]	; 0x5c
 8089512:	e786      	b.n	8089422 <HAL_SD_GetCardCSD+0xda>

08089514 <HAL_SD_InitCard>:
{
 8089514:	b570      	push	{r4, r5, r6, lr}
 8089516:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8089518:	2500      	movs	r5, #0
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 808951a:	2176      	movs	r1, #118	; 0x76
{
 808951c:	4604      	mov	r4, r0
  SDMMC_Init(hsd->Instance, Init);
 808951e:	aa0a      	add	r2, sp, #40	; 0x28
 8089520:	6806      	ldr	r6, [r0, #0]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
 8089522:	950a      	str	r5, [sp, #40]	; 0x28
  SDMMC_Init(hsd->Instance, Init);
 8089524:	ab07      	add	r3, sp, #28
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 8089526:	9509      	str	r5, [sp, #36]	; 0x24
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 8089528:	e9cd 510b 	strd	r5, r1, [sp, #44]	; 0x2c
  SDMMC_Init(hsd->Instance, Init);
 808952c:	ca07      	ldmia	r2, {r0, r1, r2}
  Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
 808952e:	e9cd 5507 	strd	r5, r5, [sp, #28]
  SDMMC_Init(hsd->Instance, Init);
 8089532:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8089536:	4630      	mov	r0, r6
 8089538:	cb0e      	ldmia	r3, {r1, r2, r3}
 808953a:	f001 ffb7 	bl	808b4ac <SDMMC_Init>
  __HAL_SD_DISABLE(hsd); 
 808953e:	6823      	ldr	r3, [r4, #0]
 8089540:	685a      	ldr	r2, [r3, #4]
  SDMMC_PowerState_ON(hsd->Instance);
 8089542:	4618      	mov	r0, r3
  __HAL_SD_DISABLE(hsd); 
 8089544:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8089548:	605a      	str	r2, [r3, #4]
  SDMMC_PowerState_ON(hsd->Instance);
 808954a:	f001 ffd7 	bl	808b4fc <SDMMC_PowerState_ON>
  __HAL_SD_ENABLE(hsd);
 808954e:	6822      	ldr	r2, [r4, #0]
  HAL_Delay(2);
 8089550:	2002      	movs	r0, #2
  __HAL_SD_ENABLE(hsd);
 8089552:	6853      	ldr	r3, [r2, #4]
 8089554:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8089558:	6053      	str	r3, [r2, #4]
  HAL_Delay(2);
 808955a:	f7fc f92f 	bl	80857bc <HAL_Delay>
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 808955e:	6820      	ldr	r0, [r4, #0]
  __IO uint32_t count = 0;
 8089560:	9506      	str	r5, [sp, #24]
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8089562:	f002 f8af 	bl	808b6c4 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 8089566:	4605      	mov	r5, r0
 8089568:	b138      	cbz	r0, 808957a <HAL_SD_InitCard+0x66>
    hsd->State = HAL_SD_STATE_READY;
 808956a:	2001      	movs	r0, #1
 808956c:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 8089570:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8089572:	431d      	orrs	r5, r3
 8089574:	63a5      	str	r5, [r4, #56]	; 0x38
}
 8089576:	b018      	add	sp, #96	; 0x60
 8089578:	bd70      	pop	{r4, r5, r6, pc}
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 808957a:	6820      	ldr	r0, [r4, #0]
 808957c:	f002 f8d0 	bl	808b720 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 8089580:	2800      	cmp	r0, #0
 8089582:	d04b      	beq.n	808961c <HAL_SD_InitCard+0x108>
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 8089584:	f64f 76ff 	movw	r6, #65535	; 0xffff
    hsd->SdCard.CardVersion = CARD_V1_X;
 8089588:	64a5      	str	r5, [r4, #72]	; 0x48
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 808958a:	9b06      	ldr	r3, [sp, #24]
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 808958c:	2100      	movs	r1, #0
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 808958e:	1c5a      	adds	r2, r3, #1
 8089590:	42b3      	cmp	r3, r6
 8089592:	9206      	str	r2, [sp, #24]
 8089594:	f000 80b5 	beq.w	8089702 <HAL_SD_InitCard+0x1ee>
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8089598:	6820      	ldr	r0, [r4, #0]
 808959a:	f002 f8ff 	bl	808b79c <SDMMC_CmdAppCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 808959e:	2800      	cmp	r0, #0
 80895a0:	f040 80b2 	bne.w	8089708 <HAL_SD_InitCard+0x1f4>
      errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_STD_CAPACITY);
 80895a4:	4601      	mov	r1, r0
 80895a6:	6820      	ldr	r0, [r4, #0]
 80895a8:	f002 f90a 	bl	808b7c0 <SDMMC_CmdAppOperCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 80895ac:	2800      	cmp	r0, #0
 80895ae:	f040 80ab 	bne.w	8089708 <HAL_SD_InitCard+0x1f4>
      response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80895b2:	4601      	mov	r1, r0
 80895b4:	6820      	ldr	r0, [r4, #0]
 80895b6:	f001 ffab 	bl	808b510 <SDMMC_GetResponse>
    while(validvoltage == 0)
 80895ba:	2800      	cmp	r0, #0
 80895bc:	dae5      	bge.n	808958a <HAL_SD_InitCard+0x76>
    hsd->SdCard.CardType = CARD_SDSC;
 80895be:	2300      	movs	r3, #0
 80895c0:	6463      	str	r3, [r4, #68]	; 0x44
  uint16_t sd_rca = 1;
 80895c2:	2301      	movs	r3, #1
  if(SDMMC_GetPowerState(hsd->Instance) == 0) 
 80895c4:	6820      	ldr	r0, [r4, #0]
  uint16_t sd_rca = 1;
 80895c6:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0) 
 80895ca:	f001 ff9d 	bl	808b508 <SDMMC_GetPowerState>
 80895ce:	2800      	cmp	r0, #0
 80895d0:	f000 8094 	beq.w	80896fc <HAL_SD_InitCard+0x1e8>
  if(hsd->SdCard.CardType != CARD_SECURED) 
 80895d4:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80895d6:	6823      	ldr	r3, [r4, #0]
 80895d8:	2a03      	cmp	r2, #3
 80895da:	d142      	bne.n	8089662 <HAL_SD_InitCard+0x14e>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20);
 80895dc:	4618      	mov	r0, r3
 80895de:	2104      	movs	r1, #4
 80895e0:	f001 ff96 	bl	808b510 <SDMMC_GetResponse>
  HAL_SD_GetCardCSD(hsd, &CSD);
 80895e4:	a90d      	add	r1, sp, #52	; 0x34
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20);
 80895e6:	0d03      	lsrs	r3, r0, #20
  HAL_SD_GetCardCSD(hsd, &CSD);
 80895e8:	4620      	mov	r0, r4
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20);
 80895ea:	64e3      	str	r3, [r4, #76]	; 0x4c
  HAL_SD_GetCardCSD(hsd, &CSD);
 80895ec:	f7ff feac 	bl	8089348 <HAL_SD_GetCardCSD>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16));
 80895f0:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80895f2:	2300      	movs	r3, #0
 80895f4:	6820      	ldr	r0, [r4, #0]
 80895f6:	0412      	lsls	r2, r2, #16
 80895f8:	f002 f852 	bl	808b6a0 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 80895fc:	4605      	mov	r5, r0
 80895fe:	2800      	cmp	r0, #0
 8089600:	d1b3      	bne.n	808956a <HAL_SD_InitCard+0x56>
  SDMMC_Init(hsd->Instance, hsd->Init);
 8089602:	1d23      	adds	r3, r4, #4
 8089604:	f854 6b10 	ldr.w	r6, [r4], #16
 8089608:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 808960c:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8089610:	4630      	mov	r0, r6
 8089612:	cb0e      	ldmia	r3, {r1, r2, r3}
 8089614:	f001 ff4a 	bl	808b4ac <SDMMC_Init>
  return HAL_OK;
 8089618:	4628      	mov	r0, r5
 808961a:	e7ac      	b.n	8089576 <HAL_SD_InitCard+0x62>
    hsd->SdCard.CardVersion = CARD_V2_X;
 808961c:	2301      	movs	r3, #1
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 808961e:	f64f 76ff 	movw	r6, #65535	; 0xffff
    hsd->SdCard.CardVersion = CARD_V2_X;
 8089622:	64a3      	str	r3, [r4, #72]	; 0x48
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 8089624:	9b06      	ldr	r3, [sp, #24]
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8089626:	2100      	movs	r1, #0
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 8089628:	1c5a      	adds	r2, r3, #1
 808962a:	42b3      	cmp	r3, r6
 808962c:	9206      	str	r2, [sp, #24]
 808962e:	d068      	beq.n	8089702 <HAL_SD_InitCard+0x1ee>
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8089630:	6820      	ldr	r0, [r4, #0]
 8089632:	f002 f8b3 	bl	808b79c <SDMMC_CmdAppCommand>
      errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_HIGH_CAPACITY);
 8089636:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
      if(errorstate != HAL_SD_ERROR_NONE)
 808963a:	4605      	mov	r5, r0
 808963c:	2800      	cmp	r0, #0
 808963e:	d194      	bne.n	808956a <HAL_SD_InitCard+0x56>
      errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_HIGH_CAPACITY);
 8089640:	6820      	ldr	r0, [r4, #0]
 8089642:	f002 f8bd 	bl	808b7c0 <SDMMC_CmdAppOperCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 8089646:	4605      	mov	r5, r0
 8089648:	2800      	cmp	r0, #0
 808964a:	d18e      	bne.n	808956a <HAL_SD_InitCard+0x56>
      response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 808964c:	4601      	mov	r1, r0
 808964e:	6820      	ldr	r0, [r4, #0]
 8089650:	f001 ff5e 	bl	808b510 <SDMMC_GetResponse>
    while(validvoltage == 0)
 8089654:	2800      	cmp	r0, #0
 8089656:	dae5      	bge.n	8089624 <HAL_SD_InitCard+0x110>
    if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8089658:	0043      	lsls	r3, r0, #1
 808965a:	d5b0      	bpl.n	80895be <HAL_SD_InitCard+0xaa>
      hsd->SdCard.CardType = CARD_SDHC_SDXC;
 808965c:	2301      	movs	r3, #1
 808965e:	6463      	str	r3, [r4, #68]	; 0x44
 8089660:	e7af      	b.n	80895c2 <HAL_SD_InitCard+0xae>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 8089662:	4618      	mov	r0, r3
 8089664:	f002 f8e6 	bl	808b834 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 8089668:	4605      	mov	r5, r0
 808966a:	2800      	cmp	r0, #0
 808966c:	f47f af7d 	bne.w	808956a <HAL_SD_InitCard+0x56>
      hsd->CID[0] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8089670:	4601      	mov	r1, r0
 8089672:	6820      	ldr	r0, [r4, #0]
 8089674:	f001 ff4c 	bl	808b510 <SDMMC_GetResponse>
      hsd->CID[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8089678:	2104      	movs	r1, #4
      hsd->CID[0] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 808967a:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 808967c:	6820      	ldr	r0, [r4, #0]
 808967e:	f001 ff47 	bl	808b510 <SDMMC_GetResponse>
      hsd->CID[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8089682:	2108      	movs	r1, #8
      hsd->CID[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8089684:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8089686:	6820      	ldr	r0, [r4, #0]
 8089688:	f001 ff42 	bl	808b510 <SDMMC_GetResponse>
      hsd->CID[3] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 808968c:	210c      	movs	r1, #12
      hsd->CID[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 808968e:	67e0      	str	r0, [r4, #124]	; 0x7c
      hsd->CID[3] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8089690:	6820      	ldr	r0, [r4, #0]
 8089692:	f001 ff3d 	bl	808b510 <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED) 
 8089696:	6c63      	ldr	r3, [r4, #68]	; 0x44
      hsd->CID[3] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8089698:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
  if(hsd->SdCard.CardType != CARD_SECURED) 
 808969c:	2b03      	cmp	r3, #3
 808969e:	d036      	beq.n	808970e <HAL_SD_InitCard+0x1fa>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 80896a0:	f10d 0116 	add.w	r1, sp, #22
 80896a4:	6820      	ldr	r0, [r4, #0]
 80896a6:	f002 f8e7 	bl	808b878 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 80896aa:	4605      	mov	r5, r0
 80896ac:	2800      	cmp	r0, #0
 80896ae:	f47f af5c 	bne.w	808956a <HAL_SD_InitCard+0x56>
  if(hsd->SdCard.CardType != CARD_SECURED) 
 80896b2:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80896b4:	6823      	ldr	r3, [r4, #0]
 80896b6:	2a03      	cmp	r2, #3
 80896b8:	d090      	beq.n	80895dc <HAL_SD_InitCard+0xc8>
    hsd->SdCard.RelCardAdd = sd_rca;
 80896ba:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80896be:	4618      	mov	r0, r3
    hsd->SdCard.RelCardAdd = sd_rca;
 80896c0:	6521      	str	r1, [r4, #80]	; 0x50
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80896c2:	0409      	lsls	r1, r1, #16
 80896c4:	f002 f8c8 	bl	808b858 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 80896c8:	4605      	mov	r5, r0
 80896ca:	2800      	cmp	r0, #0
 80896cc:	f47f af4d 	bne.w	808956a <HAL_SD_InitCard+0x56>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80896d0:	4601      	mov	r1, r0
 80896d2:	6820      	ldr	r0, [r4, #0]
 80896d4:	f001 ff1c 	bl	808b510 <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80896d8:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80896da:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80896dc:	6820      	ldr	r0, [r4, #0]
 80896de:	f001 ff17 	bl	808b510 <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80896e2:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80896e4:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80896e6:	6820      	ldr	r0, [r4, #0]
 80896e8:	f001 ff12 	bl	808b510 <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80896ec:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80896ee:	66e0      	str	r0, [r4, #108]	; 0x6c
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80896f0:	6820      	ldr	r0, [r4, #0]
 80896f2:	f001 ff0d 	bl	808b510 <SDMMC_GetResponse>
 80896f6:	6823      	ldr	r3, [r4, #0]
 80896f8:	6720      	str	r0, [r4, #112]	; 0x70
 80896fa:	e76f      	b.n	80895dc <HAL_SD_InitCard+0xc8>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 80896fc:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 8089700:	e733      	b.n	808956a <HAL_SD_InitCard+0x56>
        return HAL_SD_ERROR_INVALID_VOLTRANGE;
 8089702:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
 8089706:	e730      	b.n	808956a <HAL_SD_InitCard+0x56>
        return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8089708:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 808970c:	e72d      	b.n	808956a <HAL_SD_InitCard+0x56>
 808970e:	6823      	ldr	r3, [r4, #0]
 8089710:	e764      	b.n	80895dc <HAL_SD_InitCard+0xc8>
 8089712:	bf00      	nop

08089714 <HAL_SD_Init>:
  if(hsd == NULL)
 8089714:	b1c0      	cbz	r0, 8089748 <HAL_SD_Init+0x34>
  if(hsd->State == HAL_SD_STATE_RESET)
 8089716:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
{
 808971a:	b510      	push	{r4, lr}
  if(hsd->State == HAL_SD_STATE_RESET)
 808971c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8089720:	4604      	mov	r4, r0
 8089722:	b16b      	cbz	r3, 8089740 <HAL_SD_Init+0x2c>
  hsd->State = HAL_SD_STATE_BUSY;
 8089724:	2303      	movs	r3, #3
  HAL_SD_InitCard(hsd);
 8089726:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
 8089728:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  HAL_SD_InitCard(hsd);
 808972c:	f7ff fef2 	bl	8089514 <HAL_SD_InitCard>
  hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8089730:	2300      	movs	r3, #0
  hsd->State = HAL_SD_STATE_READY;
 8089732:	2201      	movs	r2, #1
  hsd->ErrorCode = HAL_DMA_ERROR_NONE;
 8089734:	63a3      	str	r3, [r4, #56]	; 0x38
  return HAL_OK;
 8089736:	4618      	mov	r0, r3
  hsd->Context = SD_CONTEXT_NONE;
 8089738:	6323      	str	r3, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 808973a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
}
 808973e:	bd10      	pop	{r4, pc}
    hsd->Lock = HAL_UNLOCKED;
 8089740:	7702      	strb	r2, [r0, #28]
    HAL_SD_MspInit(hsd);
 8089742:	f7ff fb75 	bl	8088e30 <HAL_SD_MspInit>
 8089746:	e7ed      	b.n	8089724 <HAL_SD_Init+0x10>
    return HAL_ERROR;
 8089748:	2001      	movs	r0, #1
}
 808974a:	4770      	bx	lr

0808974c <HAL_SD_GetCardInfo>:
{
 808974c:	4603      	mov	r3, r0
}
 808974e:	2000      	movs	r0, #0
{
 8089750:	b430      	push	{r4, r5}
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 8089752:	e9d3 2511 	ldrd	r2, r5, [r3, #68]	; 0x44
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 8089756:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 8089758:	600a      	str	r2, [r1, #0]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 808975a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 808975c:	604d      	str	r5, [r1, #4]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 808975e:	6d5d      	ldr	r5, [r3, #84]	; 0x54
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 8089760:	608c      	str	r4, [r1, #8]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 8089762:	6d9c      	ldr	r4, [r3, #88]	; 0x58
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 8089764:	60ca      	str	r2, [r1, #12]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 8089766:	e9d3 2317 	ldrd	r2, r3, [r3, #92]	; 0x5c
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 808976a:	e9c1 5404 	strd	r5, r4, [r1, #16]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 808976e:	e9c1 2306 	strd	r2, r3, [r1, #24]
}
 8089772:	bc30      	pop	{r4, r5}
 8089774:	4770      	bx	lr
 8089776:	bf00      	nop

08089778 <HAL_SD_ConfigWideBusOperation>:
  if(hsd->SdCard.CardType != CARD_SECURED) 
 8089778:	6c42      	ldr	r2, [r0, #68]	; 0x44
  hsd->State = HAL_SD_STATE_BUSY;
 808977a:	2303      	movs	r3, #3
  if(hsd->SdCard.CardType != CARD_SECURED) 
 808977c:	2a03      	cmp	r2, #3
{
 808977e:	b5f0      	push	{r4, r5, r6, r7, lr}
  hsd->State = HAL_SD_STATE_BUSY;
 8089780:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
{
 8089784:	b08b      	sub	sp, #44	; 0x2c
 8089786:	4604      	mov	r4, r0
 8089788:	460e      	mov	r6, r1
 808978a:	6803      	ldr	r3, [r0, #0]
  if(hsd->SdCard.CardType != CARD_SECURED) 
 808978c:	d029      	beq.n	80897e2 <HAL_SD_ConfigWideBusOperation+0x6a>
    if(WideMode == SDMMC_BUS_WIDE_8B)
 808978e:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8089792:	d026      	beq.n	80897e2 <HAL_SD_ConfigWideBusOperation+0x6a>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 8089794:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8089798:	d052      	beq.n	8089840 <HAL_SD_ConfigWideBusOperation+0xc8>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 808979a:	2900      	cmp	r1, #0
 808979c:	d031      	beq.n	8089802 <HAL_SD_ConfigWideBusOperation+0x8a>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 808979e:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80897a0:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80897a4:	6382      	str	r2, [r0, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80897a6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 80897a8:	bb15      	cbnz	r5, 80897f0 <HAL_SD_ConfigWideBusOperation+0x78>
    Init.ClockDiv            = hsd->Init.ClockDiv;
 80897aa:	69a2      	ldr	r2, [r4, #24]
    SDMMC_Init(hsd->Instance, Init);
 80897ac:	af04      	add	r7, sp, #16
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 80897ae:	6961      	ldr	r1, [r4, #20]
    Init.ClockDiv            = hsd->Init.ClockDiv;
 80897b0:	9209      	str	r2, [sp, #36]	; 0x24
    SDMMC_Init(hsd->Instance, Init);
 80897b2:	aa0a      	add	r2, sp, #40	; 0x28
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 80897b4:	e9cd 6107 	strd	r6, r1, [sp, #28]
    Init.ClockEdge           = hsd->Init.ClockEdge;
 80897b8:	6866      	ldr	r6, [r4, #4]
    SDMMC_Init(hsd->Instance, Init);
 80897ba:	e912 0007 	ldmdb	r2, {r0, r1, r2}
    Init.ClockEdge           = hsd->Init.ClockEdge;
 80897be:	9604      	str	r6, [sp, #16]
    Init.ClockBypass         = hsd->Init.ClockBypass;
 80897c0:	68a6      	ldr	r6, [r4, #8]
    SDMMC_Init(hsd->Instance, Init);
 80897c2:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 80897c6:	68e2      	ldr	r2, [r4, #12]
    SDMMC_Init(hsd->Instance, Init);
 80897c8:	4618      	mov	r0, r3
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 80897ca:	e9cd 6205 	strd	r6, r2, [sp, #20]
    SDMMC_Init(hsd->Instance, Init);
 80897ce:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 80897d2:	f001 fe6b 	bl	808b4ac <SDMMC_Init>
  return HAL_OK;
 80897d6:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
 80897d8:	2301      	movs	r3, #1
 80897da:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 80897de:	b00b      	add	sp, #44	; 0x2c
 80897e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80897e2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80897e4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80897e8:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80897ea:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 80897ec:	2d00      	cmp	r5, #0
 80897ee:	d0dc      	beq.n	80897aa <HAL_SD_ConfigWideBusOperation+0x32>
    hsd->State = HAL_SD_STATE_READY;
 80897f0:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80897f2:	f240 51ff 	movw	r1, #1535	; 0x5ff
    return HAL_ERROR;
 80897f6:	4610      	mov	r0, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80897f8:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80897fa:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
}
 80897fe:	b00b      	add	sp, #44	; 0x2c
 8089800:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8089802:	4618      	mov	r0, r3
  uint32_t scr[2] = {0, 0};
 8089804:	e9cd 1104 	strd	r1, r1, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8089808:	f001 fe82 	bl	808b510 <SDMMC_GetResponse>
 808980c:	0181      	lsls	r1, r0, #6
 808980e:	d420      	bmi.n	8089852 <HAL_SD_ConfigWideBusOperation+0xda>
  errorstate = SD_FindSCR(hsd, scr);
 8089810:	a904      	add	r1, sp, #16
 8089812:	4620      	mov	r0, r4
 8089814:	f7ff faa0 	bl	8088d58 <SD_FindSCR>
  if(errorstate != HAL_OK)
 8089818:	b968      	cbnz	r0, 8089836 <HAL_SD_ConfigWideBusOperation+0xbe>
  if((scr[1] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 808981a:	9a05      	ldr	r2, [sp, #20]
 808981c:	6823      	ldr	r3, [r4, #0]
 808981e:	03d2      	lsls	r2, r2, #15
 8089820:	d531      	bpl.n	8089886 <HAL_SD_ConfigWideBusOperation+0x10e>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16));
 8089822:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8089824:	4618      	mov	r0, r3
 8089826:	0409      	lsls	r1, r1, #16
 8089828:	f001 ffb8 	bl	808b79c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_OK)
 808982c:	b918      	cbnz	r0, 8089836 <HAL_SD_ConfigWideBusOperation+0xbe>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0);
 808982e:	4601      	mov	r1, r0
 8089830:	6820      	ldr	r0, [r4, #0]
 8089832:	f001 ffd9 	bl	808b7e8 <SDMMC_CmdBusWidth>
 8089836:	6823      	ldr	r3, [r4, #0]
      hsd->ErrorCode |= errorstate;
 8089838:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 808983a:	4310      	orrs	r0, r2
 808983c:	63a0      	str	r0, [r4, #56]	; 0x38
 808983e:	e7d4      	b.n	80897ea <HAL_SD_ConfigWideBusOperation+0x72>
  uint32_t scr[2] = {0, 0};
 8089840:	2200      	movs	r2, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8089842:	4618      	mov	r0, r3
 8089844:	4611      	mov	r1, r2
  uint32_t scr[2] = {0, 0};
 8089846:	e9cd 2204 	strd	r2, r2, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 808984a:	f001 fe61 	bl	808b510 <SDMMC_GetResponse>
 808984e:	0185      	lsls	r5, r0, #6
 8089850:	d503      	bpl.n	808985a <HAL_SD_ConfigWideBusOperation+0xe2>
 8089852:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8089854:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8089858:	e7ee      	b.n	8089838 <HAL_SD_ConfigWideBusOperation+0xc0>
  errorstate = SD_FindSCR(hsd, scr);
 808985a:	a904      	add	r1, sp, #16
 808985c:	4620      	mov	r0, r4
 808985e:	f7ff fa7b 	bl	8088d58 <SD_FindSCR>
  if(errorstate != HAL_OK)
 8089862:	2800      	cmp	r0, #0
 8089864:	d1e7      	bne.n	8089836 <HAL_SD_ConfigWideBusOperation+0xbe>
  if((scr[1] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8089866:	9a05      	ldr	r2, [sp, #20]
 8089868:	6823      	ldr	r3, [r4, #0]
 808986a:	0350      	lsls	r0, r2, #13
 808986c:	d50b      	bpl.n	8089886 <HAL_SD_ConfigWideBusOperation+0x10e>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16));
 808986e:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8089870:	4618      	mov	r0, r3
 8089872:	0409      	lsls	r1, r1, #16
 8089874:	f001 ff92 	bl	808b79c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_OK)
 8089878:	2800      	cmp	r0, #0
 808987a:	d1dc      	bne.n	8089836 <HAL_SD_ConfigWideBusOperation+0xbe>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2);
 808987c:	2102      	movs	r1, #2
 808987e:	6820      	ldr	r0, [r4, #0]
 8089880:	f001 ffb2 	bl	808b7e8 <SDMMC_CmdBusWidth>
 8089884:	e7d7      	b.n	8089836 <HAL_SD_ConfigWideBusOperation+0xbe>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8089886:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 808988a:	e7d5      	b.n	8089838 <HAL_SD_ConfigWideBusOperation+0xc0>

0808988c <HAL_SDRAM_MspInit>:
  UNUSED(hsdram);
 
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
 808988c:	4770      	bx	lr
 808988e:	bf00      	nop

08089890 <HAL_SDRAM_Init>:
  if(hsdram == NULL)
 8089890:	b1e8      	cbz	r0, 80898ce <HAL_SDRAM_Init+0x3e>
{   
 8089892:	b538      	push	{r3, r4, r5, lr}
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 8089894:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8089898:	4604      	mov	r4, r0
 808989a:	460d      	mov	r5, r1
 808989c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80898a0:	b183      	cbz	r3, 80898c4 <HAL_SDRAM_Init+0x34>
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80898a2:	2302      	movs	r3, #2
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 80898a4:	1d21      	adds	r1, r4, #4
 80898a6:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80898a8:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 80898ac:	f001 fc4a 	bl	808b144 <FMC_SDRAM_Init>
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 80898b0:	4629      	mov	r1, r5
 80898b2:	e9d4 0200 	ldrd	r0, r2, [r4]
 80898b6:	f001 fc87 	bl	808b1c8 <FMC_SDRAM_Timing_Init>
  hsdram->State = HAL_SDRAM_STATE_READY;
 80898ba:	2301      	movs	r3, #1
  return HAL_OK;
 80898bc:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 80898be:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 80898c2:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
 80898c4:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
 80898c8:	f7ff ffe0 	bl	808988c <HAL_SDRAM_MspInit>
 80898cc:	e7e9      	b.n	80898a2 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
 80898ce:	2001      	movs	r0, #1
}
 80898d0:	4770      	bx	lr
 80898d2:	bf00      	nop

080898d4 <HAL_SDRAM_Read_32b>:
  * @param  pDstBuffer Pointer to destination buffer  
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
{
 80898d4:	b430      	push	{r4, r5}
  __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
  
  /* Process Locked */
  __HAL_LOCK(hsdram);
 80898d6:	f890 402d 	ldrb.w	r4, [r0, #45]	; 0x2d
 80898da:	2c01      	cmp	r4, #1
 80898dc:	d01a      	beq.n	8089914 <HAL_SDRAM_Read_32b+0x40>
  
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80898de:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
  __HAL_LOCK(hsdram);
 80898e2:	2401      	movs	r4, #1
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80898e4:	2d02      	cmp	r5, #2
  __HAL_LOCK(hsdram);
 80898e6:	f880 402d 	strb.w	r4, [r0, #45]	; 0x2d
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80898ea:	d013      	beq.n	8089914 <HAL_SDRAM_Read_32b+0x40>
  {
    return HAL_BUSY;
  }
  else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
 80898ec:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
 80898f0:	2d05      	cmp	r5, #5
 80898f2:	d00c      	beq.n	808990e <HAL_SDRAM_Read_32b+0x3a>
  {
    return  HAL_ERROR; 
  }  
  
  /* Read data from source */
  for(; BufferSize != 0; BufferSize--)
 80898f4:	b12b      	cbz	r3, 8089902 <HAL_SDRAM_Read_32b+0x2e>
  {
    *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
 80898f6:	f851 4b04 	ldr.w	r4, [r1], #4
  for(; BufferSize != 0; BufferSize--)
 80898fa:	3b01      	subs	r3, #1
    *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
 80898fc:	f842 4b04 	str.w	r4, [r2], #4
  for(; BufferSize != 0; BufferSize--)
 8089900:	d1f9      	bne.n	80898f6 <HAL_SDRAM_Read_32b+0x22>
    pDstBuffer++;
    pSdramAddress++;               
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hsdram);       
 8089902:	2300      	movs	r3, #0
  
  return HAL_OK; 
}
 8089904:	bc30      	pop	{r4, r5}
  __HAL_UNLOCK(hsdram);       
 8089906:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
  return HAL_OK; 
 808990a:	4618      	mov	r0, r3
}
 808990c:	4770      	bx	lr
    return  HAL_ERROR; 
 808990e:	4620      	mov	r0, r4
}
 8089910:	bc30      	pop	{r4, r5}
 8089912:	4770      	bx	lr
  __HAL_LOCK(hsdram);
 8089914:	2002      	movs	r0, #2
}
 8089916:	bc30      	pop	{r4, r5}
 8089918:	4770      	bx	lr
 808991a:	bf00      	nop

0808991c <HAL_SDRAM_Write_32b>:
  * @param  pSrcBuffer Pointer to source buffer to write  
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
{
 808991c:	b430      	push	{r4, r5}
  __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
  uint32_t tmp = 0;
  
  /* Process Locked */
  __HAL_LOCK(hsdram);
 808991e:	f890 402d 	ldrb.w	r4, [r0, #45]	; 0x2d
 8089922:	2c01      	cmp	r4, #1
 8089924:	d01a      	beq.n	808995c <HAL_SDRAM_Write_32b+0x40>
  
  /* Check the SDRAM controller state */
  tmp = hsdram->State;
 8089926:	f890 402c 	ldrb.w	r4, [r0, #44]	; 0x2c
  __HAL_LOCK(hsdram);
 808992a:	2501      	movs	r5, #1
  tmp = hsdram->State;
 808992c:	b2e4      	uxtb	r4, r4
  __HAL_LOCK(hsdram);
 808992e:	f880 502d 	strb.w	r5, [r0, #45]	; 0x2d
  
  if(tmp == HAL_SDRAM_STATE_BUSY)
 8089932:	2c02      	cmp	r4, #2
 8089934:	d012      	beq.n	808995c <HAL_SDRAM_Write_32b+0x40>
  {
    return HAL_BUSY;
  }
  else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
 8089936:	3c04      	subs	r4, #4
 8089938:	42ac      	cmp	r4, r5
 808993a:	d90c      	bls.n	8089956 <HAL_SDRAM_Write_32b+0x3a>
  {
    return  HAL_ERROR; 
  }
  
  /* Write data to memory */
  for(; BufferSize != 0; BufferSize--)
 808993c:	b12b      	cbz	r3, 808994a <HAL_SDRAM_Write_32b+0x2e>
  {
    *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
 808993e:	f852 4b04 	ldr.w	r4, [r2], #4
  for(; BufferSize != 0; BufferSize--)
 8089942:	3b01      	subs	r3, #1
    *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
 8089944:	f841 4b04 	str.w	r4, [r1], #4
  for(; BufferSize != 0; BufferSize--)
 8089948:	d1f9      	bne.n	808993e <HAL_SDRAM_Write_32b+0x22>
    pSrcBuffer++;
    pSdramAddress++;          
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hsdram);    
 808994a:	2300      	movs	r3, #0
  
  return HAL_OK;  
}
 808994c:	bc30      	pop	{r4, r5}
  __HAL_UNLOCK(hsdram);    
 808994e:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
  return HAL_OK;  
 8089952:	4618      	mov	r0, r3
}
 8089954:	4770      	bx	lr
    return  HAL_ERROR; 
 8089956:	4628      	mov	r0, r5
}
 8089958:	bc30      	pop	{r4, r5}
 808995a:	4770      	bx	lr
  __HAL_LOCK(hsdram);
 808995c:	2002      	movs	r0, #2
}
 808995e:	bc30      	pop	{r4, r5}
 8089960:	4770      	bx	lr
 8089962:	bf00      	nop

08089964 <HAL_SDRAM_Read_DMA>:
  * @param  pDstBuffer Pointer to destination buffer  
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
{
 8089964:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp = 0;
    
  /* Process Locked */
  __HAL_LOCK(hsdram);
 8089966:	f890 402d 	ldrb.w	r4, [r0, #45]	; 0x2d
 808996a:	2c01      	cmp	r4, #1
 808996c:	d01e      	beq.n	80899ac <HAL_SDRAM_Read_DMA+0x48>
  
  /* Check the SDRAM controller state */  
  tmp = hsdram->State;
 808996e:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
  __HAL_LOCK(hsdram);
 8089972:	2401      	movs	r4, #1
  tmp = hsdram->State;
 8089974:	b2ed      	uxtb	r5, r5
  __HAL_LOCK(hsdram);
 8089976:	f880 402d 	strb.w	r4, [r0, #45]	; 0x2d
  
  if(tmp == HAL_SDRAM_STATE_BUSY)
 808997a:	2d02      	cmp	r5, #2
 808997c:	d016      	beq.n	80899ac <HAL_SDRAM_Read_DMA+0x48>
  {
    return HAL_BUSY;
  }
  else if(tmp == HAL_SDRAM_STATE_PRECHARGED)
 808997e:	2d05      	cmp	r5, #5
 8089980:	d012      	beq.n	80899a8 <HAL_SDRAM_Read_DMA+0x44>
 8089982:	4604      	mov	r4, r0
    return  HAL_ERROR; 
  }  
  
  /* Configure DMA user callbacks */
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
  hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
 8089984:	f640 66c9 	movw	r6, #3785	; 0xec9
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
 8089988:	f640 60b9 	movw	r0, #3769	; 0xeb9
 808998c:	6b25      	ldr	r5, [r4, #48]	; 0x30
  hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
 808998e:	f6c0 0609 	movt	r6, #2057	; 0x809
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
 8089992:	f6c0 0009 	movt	r0, #2057	; 0x809
  hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
 8089996:	64ee      	str	r6, [r5, #76]	; 0x4c
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
 8089998:	63e8      	str	r0, [r5, #60]	; 0x3c
  
  /* Enable the DMA Stream */
  HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
 808999a:	4628      	mov	r0, r5
 808999c:	f7fc f870 	bl	8085a80 <HAL_DMA_Start_IT>
  
  /* Process Unlocked */
  __HAL_UNLOCK(hsdram);  
 80899a0:	2000      	movs	r0, #0
 80899a2:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
  
  return HAL_OK; 
}
 80899a6:	bd70      	pop	{r4, r5, r6, pc}
    return  HAL_ERROR; 
 80899a8:	4620      	mov	r0, r4
}
 80899aa:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hsdram);
 80899ac:	2002      	movs	r0, #2
}
 80899ae:	bd70      	pop	{r4, r5, r6, pc}

080899b0 <HAL_SDRAM_Write_DMA>:
  * @param  pSrcBuffer Pointer to source buffer to write  
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
{
 80899b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmp = 0;
  
  /* Process Locked */
  __HAL_LOCK(hsdram);
 80899b2:	f890 402d 	ldrb.w	r4, [r0, #45]	; 0x2d
 80899b6:	2c01      	cmp	r4, #1
 80899b8:	d022      	beq.n	8089a00 <HAL_SDRAM_Write_DMA+0x50>
  
  /* Check the SDRAM controller state */  
  tmp = hsdram->State;
 80899ba:	f890 402c 	ldrb.w	r4, [r0, #44]	; 0x2c
  __HAL_LOCK(hsdram);
 80899be:	2501      	movs	r5, #1
  tmp = hsdram->State;
 80899c0:	b2e4      	uxtb	r4, r4
  __HAL_LOCK(hsdram);
 80899c2:	f880 502d 	strb.w	r5, [r0, #45]	; 0x2d
  
  if(tmp == HAL_SDRAM_STATE_BUSY)
 80899c6:	2c02      	cmp	r4, #2
 80899c8:	d01a      	beq.n	8089a00 <HAL_SDRAM_Write_DMA+0x50>
  {
    return HAL_BUSY;
  }
  else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
 80899ca:	3c04      	subs	r4, #4
 80899cc:	42ac      	cmp	r4, r5
 80899ce:	d915      	bls.n	80899fc <HAL_SDRAM_Write_DMA+0x4c>
 80899d0:	4604      	mov	r4, r0
    return  HAL_ERROR; 
  }  
  
  /* Configure DMA user callbacks */
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
  hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
 80899d2:	f640 67c9 	movw	r7, #3785	; 0xec9
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
 80899d6:	f640 60b9 	movw	r0, #3769	; 0xeb9
 80899da:	4615      	mov	r5, r2
 80899dc:	6b26      	ldr	r6, [r4, #48]	; 0x30
  hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
 80899de:	f6c0 0709 	movt	r7, #2057	; 0x809
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
 80899e2:	f6c0 0009 	movt	r0, #2057	; 0x809
 80899e6:	460a      	mov	r2, r1
  hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
 80899e8:	64f7      	str	r7, [r6, #76]	; 0x4c
  
  /* Enable the DMA Stream */
  HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
 80899ea:	4629      	mov	r1, r5
  hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
 80899ec:	63f0      	str	r0, [r6, #60]	; 0x3c
  HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
 80899ee:	4630      	mov	r0, r6
 80899f0:	f7fc f846 	bl	8085a80 <HAL_DMA_Start_IT>
  
  /* Process Unlocked */
  __HAL_UNLOCK(hsdram);
 80899f4:	2000      	movs	r0, #0
 80899f6:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
  
  return HAL_OK;
}
 80899fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR; 
 80899fc:	4628      	mov	r0, r5
}
 80899fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hsdram);
 8089a00:	2002      	movs	r0, #2
}
 8089a02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08089a04 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8089a04:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8089a06:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8089a0a:	b2db      	uxtb	r3, r3
 8089a0c:	2b02      	cmp	r3, #2
 8089a0e:	d010      	beq.n	8089a32 <HAL_SDRAM_SendCommand+0x2e>
 8089a10:	4604      	mov	r4, r0
  {
    return HAL_BUSY;
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8089a12:	2302      	movs	r3, #2
 8089a14:	460d      	mov	r5, r1
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8089a16:	6800      	ldr	r0, [r0, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8089a18:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8089a1c:	f001 fc28 	bl	808b270 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8089a20:	682b      	ldr	r3, [r5, #0]
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  
  return HAL_OK;  
 8089a22:	2000      	movs	r0, #0
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8089a24:	2b02      	cmp	r3, #2
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 8089a26:	bf0c      	ite	eq
 8089a28:	2305      	moveq	r3, #5
    hsdram->State = HAL_SDRAM_STATE_READY;
 8089a2a:	2301      	movne	r3, #1
 8089a2c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8089a30:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
 8089a32:	4618      	mov	r0, r3
}
 8089a34:	bd38      	pop	{r3, r4, r5, pc}
 8089a36:	bf00      	nop

08089a38 <HAL_SDRAM_ProgramRefreshRate>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8089a38:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8089a3c:	b2db      	uxtb	r3, r3
 8089a3e:	2b02      	cmp	r3, #2
 8089a40:	d00c      	beq.n	8089a5c <HAL_SDRAM_ProgramRefreshRate+0x24>
  {
    return HAL_BUSY;
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8089a42:	2302      	movs	r3, #2
{
 8089a44:	b510      	push	{r4, lr}
 8089a46:	4604      	mov	r4, r0
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 8089a48:	6800      	ldr	r0, [r0, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8089a4a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 8089a4e:	f001 fc25 	bl	808b29c <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8089a52:	2301      	movs	r3, #1
  
  return HAL_OK;   
 8089a54:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 8089a56:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 8089a5a:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
 8089a5c:	4618      	mov	r0, r3
}
 8089a5e:	4770      	bx	lr

08089a60 <SPI_WaitFifoStateUntilTimeout.part.1>:
  * @param State flag state to check
  * @param Timeout Timeout duration
  * @param Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
 8089a60:	4603      	mov	r3, r0
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089a62:	e9d0 2000 	ldrd	r2, r0, [r0]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8089a66:	6851      	ldr	r1, [r2, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089a68:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8089a6c:	f021 01e0 	bic.w	r1, r1, #224	; 0xe0
 8089a70:	6051      	str	r1, [r2, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089a72:	d014      	beq.n	8089a9e <SPI_WaitFifoStateUntilTimeout.part.1+0x3e>
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089a74:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8089a76:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 8089a7a:	d108      	bne.n	8089a8e <SPI_WaitFifoStateUntilTimeout.part.1+0x2e>
        {
          SPI_RESET_CRC(hspi);
 8089a7c:	6811      	ldr	r1, [r2, #0]
 8089a7e:	f64d 70ff 	movw	r0, #57343	; 0xdfff
 8089a82:	4001      	ands	r1, r0
 8089a84:	6011      	str	r1, [r2, #0]
 8089a86:	6811      	ldr	r1, [r2, #0]
 8089a88:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8089a8c:	6011      	str	r1, [r2, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8089a8e:	2101      	movs	r1, #1

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8089a90:	2200      	movs	r2, #0
      }
    }
  }

  return HAL_OK;
}
 8089a92:	2003      	movs	r0, #3
        hspi->State = HAL_SPI_STATE_READY;
 8089a94:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
        __HAL_UNLOCK(hspi);
 8089a98:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
}
 8089a9c:	4770      	bx	lr
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089a9e:	6899      	ldr	r1, [r3, #8]
 8089aa0:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8089aa4:	d002      	beq.n	8089aac <SPI_WaitFifoStateUntilTimeout.part.1+0x4c>
 8089aa6:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8089aaa:	d1e3      	bne.n	8089a74 <SPI_WaitFifoStateUntilTimeout.part.1+0x14>
          __HAL_SPI_DISABLE(hspi);
 8089aac:	6811      	ldr	r1, [r2, #0]
 8089aae:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8089ab2:	6011      	str	r1, [r2, #0]
 8089ab4:	e7de      	b.n	8089a74 <SPI_WaitFifoStateUntilTimeout.part.1+0x14>
 8089ab6:	bf00      	nop

08089ab8 <SPI_WaitFlagStateUntilTimeout>:
{
 8089ab8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8089abc:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8089ac0:	4680      	mov	r8, r0
 8089ac2:	460f      	mov	r7, r1
 8089ac4:	4616      	mov	r6, r2
 8089ac6:	461d      	mov	r5, r3
  while ((hspi->Instance->SR & Flag) != State)
 8089ac8:	f8d8 4000 	ldr.w	r4, [r8]
 8089acc:	e001      	b.n	8089ad2 <SPI_WaitFlagStateUntilTimeout+0x1a>
    if (Timeout != HAL_MAX_DELAY)
 8089ace:	1c6b      	adds	r3, r5, #1
 8089ad0:	d106      	bne.n	8089ae0 <SPI_WaitFlagStateUntilTimeout+0x28>
  while ((hspi->Instance->SR & Flag) != State)
 8089ad2:	68a0      	ldr	r0, [r4, #8]
 8089ad4:	4038      	ands	r0, r7
 8089ad6:	42b0      	cmp	r0, r6
 8089ad8:	d1f9      	bne.n	8089ace <SPI_WaitFlagStateUntilTimeout+0x16>
}
 8089ada:	2000      	movs	r0, #0
 8089adc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8089ae0:	b12d      	cbz	r5, 8089aee <SPI_WaitFlagStateUntilTimeout+0x36>
 8089ae2:	f7fb fe65 	bl	80857b0 <HAL_GetTick>
 8089ae6:	eba0 0009 	sub.w	r0, r0, r9
 8089aea:	42a8      	cmp	r0, r5
 8089aec:	d3ec      	bcc.n	8089ac8 <SPI_WaitFlagStateUntilTimeout+0x10>
 8089aee:	4640      	mov	r0, r8
}
 8089af0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8089af4:	f7ff bfb4 	b.w	8089a60 <SPI_WaitFifoStateUntilTimeout.part.1>

08089af8 <SPI_WaitFifoStateUntilTimeout>:
  * @param Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8089af8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8089afc:	b082      	sub	sp, #8
 8089afe:	4606      	mov	r6, r0
 8089b00:	460c      	mov	r4, r1
 8089b02:	4615      	mov	r5, r2
 8089b04:	461f      	mov	r7, r3
 8089b06:	f8dd 8020 	ldr.w	r8, [sp, #32]
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 8089b0a:	6832      	ldr	r2, [r6, #0]
 8089b0c:	e00b      	b.n	8089b26 <SPI_WaitFifoStateUntilTimeout+0x2e>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8089b0e:	f5b4 6fc0 	cmp.w	r4, #1536	; 0x600
 8089b12:	d106      	bne.n	8089b22 <SPI_WaitFifoStateUntilTimeout+0x2a>
 8089b14:	b92d      	cbnz	r5, 8089b22 <SPI_WaitFifoStateUntilTimeout+0x2a>
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8089b16:	7b11      	ldrb	r1, [r2, #12]
 8089b18:	b2c9      	uxtb	r1, r1
 8089b1a:	f88d 1007 	strb.w	r1, [sp, #7]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8089b1e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    }

    if (Timeout != HAL_MAX_DELAY)
 8089b22:	1c7b      	adds	r3, r7, #1
 8089b24:	d107      	bne.n	8089b36 <SPI_WaitFifoStateUntilTimeout+0x3e>
  while ((hspi->Instance->SR & Fifo) != State)
 8089b26:	6890      	ldr	r0, [r2, #8]
 8089b28:	4020      	ands	r0, r4
 8089b2a:	42a8      	cmp	r0, r5
 8089b2c:	d1ef      	bne.n	8089b0e <SPI_WaitFifoStateUntilTimeout+0x16>
      }
    }
  }

  return HAL_OK;
}
 8089b2e:	2000      	movs	r0, #0
 8089b30:	b002      	add	sp, #8
 8089b32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((Timeout == 0) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8089b36:	b12f      	cbz	r7, 8089b44 <SPI_WaitFifoStateUntilTimeout+0x4c>
 8089b38:	f7fb fe3a 	bl	80857b0 <HAL_GetTick>
 8089b3c:	eba0 0008 	sub.w	r0, r0, r8
 8089b40:	42b8      	cmp	r0, r7
 8089b42:	d3e2      	bcc.n	8089b0a <SPI_WaitFifoStateUntilTimeout+0x12>
 8089b44:	4630      	mov	r0, r6
}
 8089b46:	b002      	add	sp, #8
 8089b48:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8089b4c:	f7ff bf88 	b.w	8089a60 <SPI_WaitFifoStateUntilTimeout.part.1>

08089b50 <SPI_EndRxTxTransaction>:
  * @param hspi SPI handle
  * @param Timeout Timeout duration
  * @param Tickstart tick start value
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8089b50:	b570      	push	{r4, r5, r6, lr}
 8089b52:	460d      	mov	r5, r1
 8089b54:	b082      	sub	sp, #8
 8089b56:	4616      	mov	r6, r2
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8089b58:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 8089b5c:	2200      	movs	r2, #0
 8089b5e:	462b      	mov	r3, r5
 8089b60:	9600      	str	r6, [sp, #0]
{
 8089b62:	4604      	mov	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8089b64:	f7ff ffc8 	bl	8089af8 <SPI_WaitFifoStateUntilTimeout>
 8089b68:	b980      	cbnz	r0, 8089b8c <SPI_EndRxTxTransaction+0x3c>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8089b6a:	4602      	mov	r2, r0
 8089b6c:	9600      	str	r6, [sp, #0]
 8089b6e:	462b      	mov	r3, r5
 8089b70:	2180      	movs	r1, #128	; 0x80
 8089b72:	4620      	mov	r0, r4
 8089b74:	f7ff ffa0 	bl	8089ab8 <SPI_WaitFlagStateUntilTimeout>
 8089b78:	b940      	cbnz	r0, 8089b8c <SPI_EndRxTxTransaction+0x3c>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8089b7a:	4602      	mov	r2, r0
 8089b7c:	9600      	str	r6, [sp, #0]
 8089b7e:	462b      	mov	r3, r5
 8089b80:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8089b84:	4620      	mov	r0, r4
 8089b86:	f7ff ffb7 	bl	8089af8 <SPI_WaitFifoStateUntilTimeout>
 8089b8a:	b120      	cbz	r0, 8089b96 <SPI_EndRxTxTransaction+0x46>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8089b8c:	6e23      	ldr	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 8089b8e:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8089b90:	f043 0320 	orr.w	r3, r3, #32
 8089b94:	6623      	str	r3, [r4, #96]	; 0x60
  }
  return HAL_OK;
}
 8089b96:	b002      	add	sp, #8
 8089b98:	bd70      	pop	{r4, r5, r6, pc}
 8089b9a:	bf00      	nop

08089b9c <SPI_EndRxTransaction>:
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089b9c:	6843      	ldr	r3, [r0, #4]
 8089b9e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
{
 8089ba2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8089ba4:	4604      	mov	r4, r0
 8089ba6:	b083      	sub	sp, #12
 8089ba8:	460e      	mov	r6, r1
 8089baa:	4617      	mov	r7, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089bac:	d028      	beq.n	8089c00 <SPI_EndRxTransaction+0x64>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8089bae:	9700      	str	r7, [sp, #0]
 8089bb0:	4633      	mov	r3, r6
 8089bb2:	2200      	movs	r2, #0
 8089bb4:	2180      	movs	r1, #128	; 0x80
 8089bb6:	4620      	mov	r0, r4
 8089bb8:	f7ff ff7e 	bl	8089ab8 <SPI_WaitFlagStateUntilTimeout>
 8089bbc:	4605      	mov	r5, r0
 8089bbe:	b9b8      	cbnz	r0, 8089bf0 <SPI_EndRxTransaction+0x54>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089bc0:	6863      	ldr	r3, [r4, #4]
 8089bc2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8089bc6:	d002      	beq.n	8089bce <SPI_EndRxTransaction+0x32>
}
 8089bc8:	4628      	mov	r0, r5
 8089bca:	b003      	add	sp, #12
 8089bcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089bce:	68a3      	ldr	r3, [r4, #8]
 8089bd0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8089bd4:	d002      	beq.n	8089bdc <SPI_EndRxTransaction+0x40>
 8089bd6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8089bda:	d1f5      	bne.n	8089bc8 <SPI_EndRxTransaction+0x2c>
    if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8089bdc:	9700      	str	r7, [sp, #0]
 8089bde:	4633      	mov	r3, r6
 8089be0:	2200      	movs	r2, #0
 8089be2:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8089be6:	4620      	mov	r0, r4
 8089be8:	f7ff ff86 	bl	8089af8 <SPI_WaitFifoStateUntilTimeout>
 8089bec:	2800      	cmp	r0, #0
 8089bee:	d0eb      	beq.n	8089bc8 <SPI_EndRxTransaction+0x2c>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8089bf0:	6e23      	ldr	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 8089bf2:	2503      	movs	r5, #3
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8089bf4:	f043 0320 	orr.w	r3, r3, #32
}
 8089bf8:	4628      	mov	r0, r5
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8089bfa:	6623      	str	r3, [r4, #96]	; 0x60
}
 8089bfc:	b003      	add	sp, #12
 8089bfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089c00:	6883      	ldr	r3, [r0, #8]
 8089c02:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8089c06:	d002      	beq.n	8089c0e <SPI_EndRxTransaction+0x72>
 8089c08:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8089c0c:	d1cf      	bne.n	8089bae <SPI_EndRxTransaction+0x12>
    __HAL_SPI_DISABLE(hspi);
 8089c0e:	6822      	ldr	r2, [r4, #0]
 8089c10:	6813      	ldr	r3, [r2, #0]
 8089c12:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8089c16:	6013      	str	r3, [r2, #0]
 8089c18:	e7c9      	b.n	8089bae <SPI_EndRxTransaction+0x12>
 8089c1a:	bf00      	nop

08089c1c <HAL_SPI_MspInit>:
}
 8089c1c:	4770      	bx	lr
 8089c1e:	bf00      	nop

08089c20 <HAL_SPI_Init>:
  if (hspi == NULL)
 8089c20:	2800      	cmp	r0, #0
 8089c22:	d069      	beq.n	8089cf8 <HAL_SPI_Init+0xd8>
{
 8089c24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (hspi->State == HAL_SPI_STATE_RESET)
 8089c26:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8089c2a:	4604      	mov	r4, r0
 8089c2c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8089c30:	2b00      	cmp	r3, #0
 8089c32:	d05c      	beq.n	8089cee <HAL_SPI_Init+0xce>
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8089c34:	68e2      	ldr	r2, [r4, #12]
  hspi->State = HAL_SPI_STATE_BUSY;
 8089c36:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8089c38:	6821      	ldr	r1, [r4, #0]
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8089c3a:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  hspi->State = HAL_SPI_STATE_BUSY;
 8089c3e:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8089c42:	f422 6000 	bic.w	r0, r2, #2048	; 0x800
  __HAL_SPI_DISABLE(hspi);
 8089c46:	680b      	ldr	r3, [r1, #0]
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8089c48:	bf94      	ite	ls
 8089c4a:	f44f 5c80 	movls.w	ip, #4096	; 0x1000
 8089c4e:	f04f 0c00 	movhi.w	ip, #0
  __HAL_SPI_DISABLE(hspi);
 8089c52:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8089c56:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 8089c5a:	600b      	str	r3, [r1, #0]
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8089c5c:	d143      	bne.n	8089ce6 <HAL_SPI_Init+0xc6>
 8089c5e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8089c60:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8089c62:	b920      	cbnz	r0, 8089c6e <HAL_SPI_Init+0x4e>
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8089c64:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8089c68:	d948      	bls.n	8089cfc <HAL_SPI_Init+0xdc>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8089c6a:	2002      	movs	r0, #2
 8089c6c:	6320      	str	r0, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8089c6e:	6927      	ldr	r7, [r4, #16]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8089c70:	2802      	cmp	r0, #2
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8089c72:	e9d4 3601 	ldrd	r3, r6, [r4, #4]
 8089c76:	ea43 0306 	orr.w	r3, r3, r6
 8089c7a:	69e6      	ldr	r6, [r4, #28]
 8089c7c:	ea43 0307 	orr.w	r3, r3, r7
 8089c80:	6967      	ldr	r7, [r4, #20]
 8089c82:	ea43 0307 	orr.w	r3, r3, r7
 8089c86:	69a7      	ldr	r7, [r4, #24]
 8089c88:	ea43 0306 	orr.w	r3, r3, r6
 8089c8c:	6a26      	ldr	r6, [r4, #32]
 8089c8e:	f407 7e00 	and.w	lr, r7, #512	; 0x200
 8089c92:	ea43 0306 	orr.w	r3, r3, r6
 8089c96:	ea43 030e 	orr.w	r3, r3, lr
 8089c9a:	ea43 0305 	orr.w	r3, r3, r5
 8089c9e:	600b      	str	r3, [r1, #0]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8089ca0:	d103      	bne.n	8089caa <HAL_SPI_Init+0x8a>
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 8089ca2:	680b      	ldr	r3, [r1, #0]
 8089ca4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8089ca8:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8089caa:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8089cac:	0c3f      	lsrs	r7, r7, #16
 8089cae:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089cb0:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8089cb4:	ea42 0200 	orr.w	r2, r2, r0
 8089cb8:	f007 0704 	and.w	r7, r7, #4
 8089cbc:	ea42 0203 	orr.w	r2, r2, r3
 8089cc0:	ea42 0207 	orr.w	r2, r2, r7
 8089cc4:	ea42 020c 	orr.w	r2, r2, ip
 8089cc8:	604a      	str	r2, [r1, #4]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089cca:	d101      	bne.n	8089cd0 <HAL_SPI_Init+0xb0>
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 8089ccc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8089cce:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8089cd0:	69cb      	ldr	r3, [r1, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8089cd2:	2200      	movs	r2, #0
  hspi->State     = HAL_SPI_STATE_READY;
 8089cd4:	2501      	movs	r5, #1
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8089cd6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  return HAL_OK;
 8089cda:	4610      	mov	r0, r2
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8089cdc:	61cb      	str	r3, [r1, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8089cde:	6622      	str	r2, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8089ce0:	f884 505d 	strb.w	r5, [r4, #93]	; 0x5d
}
 8089ce4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8089ce6:	2300      	movs	r3, #0
 8089ce8:	461d      	mov	r5, r3
 8089cea:	62a3      	str	r3, [r4, #40]	; 0x28
 8089cec:	e7b8      	b.n	8089c60 <HAL_SPI_Init+0x40>
    hspi->Lock = HAL_UNLOCKED;
 8089cee:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 8089cf2:	f7ff ff93 	bl	8089c1c <HAL_SPI_MspInit>
 8089cf6:	e79d      	b.n	8089c34 <HAL_SPI_Init+0x14>
    return HAL_ERROR;
 8089cf8:	2001      	movs	r0, #1
}
 8089cfa:	4770      	bx	lr
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8089cfc:	2301      	movs	r3, #1
 8089cfe:	4618      	mov	r0, r3
 8089d00:	6323      	str	r3, [r4, #48]	; 0x30
 8089d02:	e7b4      	b.n	8089c6e <HAL_SPI_Init+0x4e>

08089d04 <HAL_SPI_MspDeInit>:
 8089d04:	4770      	bx	lr
 8089d06:	bf00      	nop

08089d08 <HAL_SPI_DeInit>:
  if (hspi == NULL)
 8089d08:	b198      	cbz	r0, 8089d32 <HAL_SPI_DeInit+0x2a>
  __HAL_SPI_DISABLE(hspi);
 8089d0a:	6802      	ldr	r2, [r0, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 8089d0c:	2302      	movs	r3, #2
{
 8089d0e:	b510      	push	{r4, lr}
  hspi->State = HAL_SPI_STATE_BUSY;
 8089d10:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
 8089d14:	4604      	mov	r4, r0
  __HAL_SPI_DISABLE(hspi);
 8089d16:	6813      	ldr	r3, [r2, #0]
 8089d18:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8089d1c:	6013      	str	r3, [r2, #0]
  HAL_SPI_MspDeInit(hspi);
 8089d1e:	f7ff fff1 	bl	8089d04 <HAL_SPI_MspDeInit>
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8089d22:	2300      	movs	r3, #0
 8089d24:	6623      	str	r3, [r4, #96]	; 0x60
  return HAL_OK;
 8089d26:	4618      	mov	r0, r3
  hspi->State = HAL_SPI_STATE_RESET;
 8089d28:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8089d2c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 8089d30:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8089d32:	2001      	movs	r0, #1
}
 8089d34:	4770      	bx	lr
 8089d36:	bf00      	nop

08089d38 <HAL_SPI_Transmit>:
{
 8089d38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8089d3c:	461e      	mov	r6, r3
  __HAL_LOCK(hspi);
 8089d3e:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
{
 8089d42:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 8089d44:	2b01      	cmp	r3, #1
 8089d46:	d07a      	beq.n	8089e3e <HAL_SPI_Transmit+0x106>
 8089d48:	2301      	movs	r3, #1
 8089d4a:	4604      	mov	r4, r0
 8089d4c:	460d      	mov	r5, r1
 8089d4e:	4690      	mov	r8, r2
 8089d50:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
  tickstart = HAL_GetTick();
 8089d54:	f7fb fd2c 	bl	80857b0 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 8089d58:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  tickstart = HAL_GetTick();
 8089d5c:	4607      	mov	r7, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8089d5e:	2b01      	cmp	r3, #1
 8089d60:	d009      	beq.n	8089d76 <HAL_SPI_Transmit+0x3e>
    errorcode = HAL_BUSY;
 8089d62:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8089d64:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8089d66:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8089d68:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8089d6c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 8089d70:	b002      	add	sp, #8
 8089d72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8089d76:	2d00      	cmp	r5, #0
 8089d78:	d065      	beq.n	8089e46 <HAL_SPI_Transmit+0x10e>
 8089d7a:	fab8 f388 	clz	r3, r8
 8089d7e:	095b      	lsrs	r3, r3, #5
 8089d80:	2b00      	cmp	r3, #0
 8089d82:	d160      	bne.n	8089e46 <HAL_SPI_Transmit+0x10e>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089d84:	68a1      	ldr	r1, [r4, #8]
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8089d86:	2203      	movs	r2, #3
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8089d88:	63a5      	str	r5, [r4, #56]	; 0x38
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089d8a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8089d8e:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  hspi->TxXferSize  = Size;
 8089d92:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8089d96:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8089d98:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxXferCount = Size;
 8089d9a:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 8089d9e:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
 8089da2:	6822      	ldr	r2, [r4, #0]
  hspi->RxXferCount = 0U;
 8089da4:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  hspi->RxISR       = NULL;
 8089da8:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8089dac:	d103      	bne.n	8089db6 <HAL_SPI_Transmit+0x7e>
    SPI_1LINE_TX(hspi);
 8089dae:	6813      	ldr	r3, [r2, #0]
 8089db0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8089db4:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089db6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8089db8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8089dbc:	d108      	bne.n	8089dd0 <HAL_SPI_Transmit+0x98>
    SPI_RESET_CRC(hspi);
 8089dbe:	6813      	ldr	r3, [r2, #0]
 8089dc0:	f64d 71ff 	movw	r1, #57343	; 0xdfff
 8089dc4:	400b      	ands	r3, r1
 8089dc6:	6013      	str	r3, [r2, #0]
 8089dc8:	6813      	ldr	r3, [r2, #0]
 8089dca:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8089dce:	6013      	str	r3, [r2, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8089dd0:	6813      	ldr	r3, [r2, #0]
 8089dd2:	065b      	lsls	r3, r3, #25
 8089dd4:	d403      	bmi.n	8089dde <HAL_SPI_Transmit+0xa6>
    __HAL_SPI_ENABLE(hspi);
 8089dd6:	6813      	ldr	r3, [r2, #0]
 8089dd8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8089ddc:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8089dde:	68e3      	ldr	r3, [r4, #12]
 8089de0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8089de4:	d938      	bls.n	8089e58 <HAL_SPI_Transmit+0x120>
    while (hspi->TxXferCount > 0U)
 8089de6:	8fe0      	ldrh	r0, [r4, #62]	; 0x3e
 8089de8:	b280      	uxth	r0, r0
 8089dea:	b170      	cbz	r0, 8089e0a <HAL_SPI_Transmit+0xd2>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8089dec:	6823      	ldr	r3, [r4, #0]
 8089dee:	689a      	ldr	r2, [r3, #8]
 8089df0:	0790      	lsls	r0, r2, #30
 8089df2:	d555      	bpl.n	8089ea0 <HAL_SPI_Transmit+0x168>
        hspi->Instance->DR = *((uint16_t *)pData);
 8089df4:	f835 2b02 	ldrh.w	r2, [r5], #2
 8089df8:	60da      	str	r2, [r3, #12]
        hspi->TxXferCount--;
 8089dfa:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8089dfc:	3b01      	subs	r3, #1
 8089dfe:	b29b      	uxth	r3, r3
 8089e00:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8089e02:	8fe0      	ldrh	r0, [r4, #62]	; 0x3e
 8089e04:	b280      	uxth	r0, r0
 8089e06:	2800      	cmp	r0, #0
 8089e08:	d1f0      	bne.n	8089dec <HAL_SPI_Transmit+0xb4>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089e0a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8089e0c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8089e10:	d050      	beq.n	8089eb4 <HAL_SPI_Transmit+0x17c>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8089e12:	463a      	mov	r2, r7
 8089e14:	4631      	mov	r1, r6
 8089e16:	4620      	mov	r0, r4
 8089e18:	f7ff fe9a 	bl	8089b50 <SPI_EndRxTxTransaction>
 8089e1c:	b108      	cbz	r0, 8089e22 <HAL_SPI_Transmit+0xea>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8089e1e:	2320      	movs	r3, #32
 8089e20:	6623      	str	r3, [r4, #96]	; 0x60
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8089e22:	68a3      	ldr	r3, [r4, #8]
 8089e24:	b933      	cbnz	r3, 8089e34 <HAL_SPI_Transmit+0xfc>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8089e26:	6822      	ldr	r2, [r4, #0]
 8089e28:	9301      	str	r3, [sp, #4]
 8089e2a:	68d3      	ldr	r3, [r2, #12]
 8089e2c:	9301      	str	r3, [sp, #4]
 8089e2e:	6893      	ldr	r3, [r2, #8]
 8089e30:	9301      	str	r3, [sp, #4]
 8089e32:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8089e34:	6e20      	ldr	r0, [r4, #96]	; 0x60
    errorcode = HAL_BUSY;
 8089e36:	3000      	adds	r0, #0
 8089e38:	bf18      	it	ne
 8089e3a:	2001      	movne	r0, #1
error:
 8089e3c:	e792      	b.n	8089d64 <HAL_SPI_Transmit+0x2c>
  __HAL_LOCK(hspi);
 8089e3e:	2002      	movs	r0, #2
}
 8089e40:	b002      	add	sp, #8
 8089e42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    errorcode = HAL_ERROR;
 8089e46:	2001      	movs	r0, #1
 8089e48:	e78c      	b.n	8089d64 <HAL_SPI_Transmit+0x2c>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 8089e4a:	782a      	ldrb	r2, [r5, #0]
 8089e4c:	3501      	adds	r5, #1
 8089e4e:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 8089e50:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8089e52:	3b01      	subs	r3, #1
 8089e54:	b29b      	uxth	r3, r3
 8089e56:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8089e58:	8fe0      	ldrh	r0, [r4, #62]	; 0x3e
 8089e5a:	b280      	uxth	r0, r0
 8089e5c:	2800      	cmp	r0, #0
 8089e5e:	d0d4      	beq.n	8089e0a <HAL_SPI_Transmit+0xd2>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8089e60:	6823      	ldr	r3, [r4, #0]
 8089e62:	689a      	ldr	r2, [r3, #8]
 8089e64:	0792      	lsls	r2, r2, #30
 8089e66:	d511      	bpl.n	8089e8c <HAL_SPI_Transmit+0x154>
        if (hspi->TxXferCount > 1U)
 8089e68:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8089e6a:	2a01      	cmp	r2, #1
 8089e6c:	d9ed      	bls.n	8089e4a <HAL_SPI_Transmit+0x112>
          hspi->Instance->DR = *((uint16_t *)pData);
 8089e6e:	f835 2b02 	ldrh.w	r2, [r5], #2
 8089e72:	60da      	str	r2, [r3, #12]
          hspi->TxXferCount -= 2U;
 8089e74:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8089e76:	3b02      	subs	r3, #2
 8089e78:	b29b      	uxth	r3, r3
 8089e7a:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8089e7c:	8fe0      	ldrh	r0, [r4, #62]	; 0x3e
 8089e7e:	b280      	uxth	r0, r0
 8089e80:	2800      	cmp	r0, #0
 8089e82:	d0c2      	beq.n	8089e0a <HAL_SPI_Transmit+0xd2>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8089e84:	6823      	ldr	r3, [r4, #0]
 8089e86:	689a      	ldr	r2, [r3, #8]
 8089e88:	0792      	lsls	r2, r2, #30
 8089e8a:	d4ed      	bmi.n	8089e68 <HAL_SPI_Transmit+0x130>
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8089e8c:	b136      	cbz	r6, 8089e9c <HAL_SPI_Transmit+0x164>
 8089e8e:	1c73      	adds	r3, r6, #1
 8089e90:	d0e2      	beq.n	8089e58 <HAL_SPI_Transmit+0x120>
 8089e92:	f7fb fc8d 	bl	80857b0 <HAL_GetTick>
 8089e96:	1bc0      	subs	r0, r0, r7
 8089e98:	42b0      	cmp	r0, r6
 8089e9a:	d3dd      	bcc.n	8089e58 <HAL_SPI_Transmit+0x120>
          errorcode = HAL_TIMEOUT;
 8089e9c:	2003      	movs	r0, #3
 8089e9e:	e761      	b.n	8089d64 <HAL_SPI_Transmit+0x2c>
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8089ea0:	2e00      	cmp	r6, #0
 8089ea2:	d0fb      	beq.n	8089e9c <HAL_SPI_Transmit+0x164>
 8089ea4:	1c71      	adds	r1, r6, #1
 8089ea6:	d09e      	beq.n	8089de6 <HAL_SPI_Transmit+0xae>
 8089ea8:	f7fb fc82 	bl	80857b0 <HAL_GetTick>
 8089eac:	1bc0      	subs	r0, r0, r7
 8089eae:	42b0      	cmp	r0, r6
 8089eb0:	d399      	bcc.n	8089de6 <HAL_SPI_Transmit+0xae>
 8089eb2:	e7f3      	b.n	8089e9c <HAL_SPI_Transmit+0x164>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8089eb4:	6822      	ldr	r2, [r4, #0]
 8089eb6:	6813      	ldr	r3, [r2, #0]
 8089eb8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8089ebc:	6013      	str	r3, [r2, #0]
 8089ebe:	e7a8      	b.n	8089e12 <HAL_SPI_Transmit+0xda>

08089ec0 <HAL_SPI_TransmitReceive>:
{
 8089ec0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8089ec4:	4604      	mov	r4, r0
 8089ec6:	4616      	mov	r6, r2
 8089ec8:	b085      	sub	sp, #20
  __IO uint16_t tmpreg = 0U;
 8089eca:	2000      	movs	r0, #0
  __HAL_LOCK(hspi);
 8089ecc:	f894 205c 	ldrb.w	r2, [r4, #92]	; 0x5c
  __IO uint16_t tmpreg = 0U;
 8089ed0:	f8ad 000e 	strh.w	r0, [sp, #14]
  __HAL_LOCK(hspi);
 8089ed4:	2a01      	cmp	r2, #1
{
 8089ed6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  __HAL_LOCK(hspi);
 8089ed8:	f000 80ef 	beq.w	808a0ba <HAL_SPI_TransmitReceive+0x1fa>
 8089edc:	4699      	mov	r9, r3
 8089ede:	2301      	movs	r3, #1
 8089ee0:	460f      	mov	r7, r1
 8089ee2:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  tickstart = HAL_GetTick();
 8089ee6:	f7fb fc63 	bl	80857b0 <HAL_GetTick>
  tmp  = hspi->State;
 8089eea:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
  tickstart = HAL_GetTick();
 8089eee:	4680      	mov	r8, r0
  tmp1 = hspi->Init.Mode;
 8089ef0:	6861      	ldr	r1, [r4, #4]
  tmp  = hspi->State;
 8089ef2:	b2d2      	uxtb	r2, r2
  if (!((tmp == HAL_SPI_STATE_READY) || \
 8089ef4:	2a01      	cmp	r2, #1
 8089ef6:	d012      	beq.n	8089f1e <HAL_SPI_TransmitReceive+0x5e>
 8089ef8:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
 8089efc:	d00a      	beq.n	8089f14 <HAL_SPI_TransmitReceive+0x54>
    errorcode = HAL_BUSY;
 8089efe:	2602      	movs	r6, #2
  hspi->State = HAL_SPI_STATE_READY;
 8089f00:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8089f02:	2300      	movs	r3, #0
}
 8089f04:	4630      	mov	r0, r6
  hspi->State = HAL_SPI_STATE_READY;
 8089f06:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8089f0a:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 8089f0e:	b005      	add	sp, #20
 8089f10:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 8089f14:	68a3      	ldr	r3, [r4, #8]
 8089f16:	2b00      	cmp	r3, #0
 8089f18:	d1f1      	bne.n	8089efe <HAL_SPI_TransmitReceive+0x3e>
 8089f1a:	2a04      	cmp	r2, #4
 8089f1c:	d1ef      	bne.n	8089efe <HAL_SPI_TransmitReceive+0x3e>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8089f1e:	f1b9 0f00 	cmp.w	r9, #0
 8089f22:	bf18      	it	ne
 8089f24:	2e00      	cmpne	r6, #0
 8089f26:	f000 80c6 	beq.w	808a0b6 <HAL_SPI_TransmitReceive+0x1f6>
 8089f2a:	2f00      	cmp	r7, #0
 8089f2c:	f000 80c3 	beq.w	808a0b6 <HAL_SPI_TransmitReceive+0x1f6>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8089f30:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 8089f34:	2b04      	cmp	r3, #4
 8089f36:	d002      	beq.n	8089f3e <HAL_SPI_TransmitReceive+0x7e>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8089f38:	2305      	movs	r3, #5
 8089f3a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089f3e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8089f40:	2300      	movs	r3, #0
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8089f42:	6426      	str	r6, [r4, #64]	; 0x40
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089f44:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8089f48:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->RxXferSize  = Size;
 8089f4a:	f8a4 9044 	strh.w	r9, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 8089f4e:	f8a4 9046 	strh.w	r9, [r4, #70]	; 0x46
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8089f52:	63a7      	str	r7, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8089f54:	f8a4 903c 	strh.w	r9, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8089f58:	f8a4 903e 	strh.w	r9, [r4, #62]	; 0x3e
  hspi->TxISR       = NULL;
 8089f5c:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
 8089f60:	6823      	ldr	r3, [r4, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8089f62:	f000 80e8 	beq.w	808a136 <HAL_SPI_TransmitReceive+0x276>
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
 8089f66:	68e2      	ldr	r2, [r4, #12]
 8089f68:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8089f6c:	d869      	bhi.n	808a042 <HAL_SPI_TransmitReceive+0x182>
 8089f6e:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 8089f72:	2a01      	cmp	r2, #1
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8089f74:	685a      	ldr	r2, [r3, #4]
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1))
 8089f76:	f240 8119 	bls.w	808a1ac <HAL_SPI_TransmitReceive+0x2ec>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8089f7a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8089f7e:	605a      	str	r2, [r3, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8089f80:	681a      	ldr	r2, [r3, #0]
 8089f82:	0650      	lsls	r0, r2, #25
 8089f84:	d403      	bmi.n	8089f8e <HAL_SPI_TransmitReceive+0xce>
    __HAL_SPI_ENABLE(hspi);
 8089f86:	681a      	ldr	r2, [r3, #0]
 8089f88:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8089f8c:	601a      	str	r2, [r3, #0]
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 8089f8e:	2900      	cmp	r1, #0
 8089f90:	f000 80f4 	beq.w	808a17c <HAL_SPI_TransmitReceive+0x2bc>
 8089f94:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8089f96:	b292      	uxth	r2, r2
 8089f98:	2a01      	cmp	r2, #1
 8089f9a:	f000 80ef 	beq.w	808a17c <HAL_SPI_TransmitReceive+0x2bc>
        txallowed = 1U;
 8089f9e:	f04f 0901 	mov.w	r9, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8089fa2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8089fa4:	b29b      	uxth	r3, r3
 8089fa6:	b923      	cbnz	r3, 8089fb2 <HAL_SPI_TransmitReceive+0xf2>
 8089fa8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8089fac:	b29b      	uxth	r3, r3
 8089fae:	2b00      	cmp	r3, #0
 8089fb0:	d063      	beq.n	808a07a <HAL_SPI_TransmitReceive+0x1ba>
      if (txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 8089fb2:	f1b9 0f00 	cmp.w	r9, #0
 8089fb6:	d01e      	beq.n	8089ff6 <HAL_SPI_TransmitReceive+0x136>
 8089fb8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8089fba:	b29b      	uxth	r3, r3
 8089fbc:	b1db      	cbz	r3, 8089ff6 <HAL_SPI_TransmitReceive+0x136>
 8089fbe:	6823      	ldr	r3, [r4, #0]
 8089fc0:	689a      	ldr	r2, [r3, #8]
 8089fc2:	0791      	lsls	r1, r2, #30
 8089fc4:	d517      	bpl.n	8089ff6 <HAL_SPI_TransmitReceive+0x136>
        if (hspi->TxXferCount > 1U)
 8089fc6:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8089fc8:	2a01      	cmp	r2, #1
 8089fca:	f240 80e7 	bls.w	808a19c <HAL_SPI_TransmitReceive+0x2dc>
          hspi->Instance->DR = *((uint16_t *)pTxData);
 8089fce:	f837 2b02 	ldrh.w	r2, [r7], #2
 8089fd2:	60da      	str	r2, [r3, #12]
          hspi->TxXferCount -= 2U;
 8089fd4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8089fd6:	3b02      	subs	r3, #2
 8089fd8:	b29b      	uxth	r3, r3
 8089fda:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8089fdc:	f8b4 903e 	ldrh.w	r9, [r4, #62]	; 0x3e
 8089fe0:	fa1f f389 	uxth.w	r3, r9
 8089fe4:	2b00      	cmp	r3, #0
 8089fe6:	f040 80bc 	bne.w	808a162 <HAL_SPI_TransmitReceive+0x2a2>
 8089fea:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8089fec:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8089ff0:	f000 80e4 	beq.w	808a1bc <HAL_SPI_TransmitReceive+0x2fc>
        txallowed = 0U;
 8089ff4:	4699      	mov	r9, r3
      if ((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 8089ff6:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8089ffa:	b29b      	uxth	r3, r3
 8089ffc:	b1c3      	cbz	r3, 808a030 <HAL_SPI_TransmitReceive+0x170>
 8089ffe:	6822      	ldr	r2, [r4, #0]
 808a000:	6893      	ldr	r3, [r2, #8]
 808a002:	07d9      	lsls	r1, r3, #31
 808a004:	d514      	bpl.n	808a030 <HAL_SPI_TransmitReceive+0x170>
        if (hspi->RxXferCount > 1U)
 808a006:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a00a:	2b01      	cmp	r3, #1
 808a00c:	f240 809d 	bls.w	808a14a <HAL_SPI_TransmitReceive+0x28a>
          *((uint16_t *)pRxData) = hspi->Instance->DR;
 808a010:	68d3      	ldr	r3, [r2, #12]
 808a012:	f826 3b02 	strh.w	r3, [r6], #2
          hspi->RxXferCount -= 2U;
 808a016:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a01a:	3b02      	subs	r3, #2
 808a01c:	b29b      	uxth	r3, r3
 808a01e:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 808a022:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a026:	2b01      	cmp	r3, #1
 808a028:	f240 80a1 	bls.w	808a16e <HAL_SPI_TransmitReceive+0x2ae>
        txallowed = 1U;
 808a02c:	f04f 0901 	mov.w	r9, #1
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
 808a030:	1c6b      	adds	r3, r5, #1
 808a032:	d0b6      	beq.n	8089fa2 <HAL_SPI_TransmitReceive+0xe2>
 808a034:	f7fb fbbc 	bl	80857b0 <HAL_GetTick>
 808a038:	eba0 0008 	sub.w	r0, r0, r8
 808a03c:	42a8      	cmp	r0, r5
 808a03e:	d3b0      	bcc.n	8089fa2 <HAL_SPI_TransmitReceive+0xe2>
 808a040:	e077      	b.n	808a132 <HAL_SPI_TransmitReceive+0x272>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 808a042:	685a      	ldr	r2, [r3, #4]
 808a044:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 808a048:	605a      	str	r2, [r3, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 808a04a:	681a      	ldr	r2, [r3, #0]
 808a04c:	0652      	lsls	r2, r2, #25
 808a04e:	d403      	bmi.n	808a058 <HAL_SPI_TransmitReceive+0x198>
    __HAL_SPI_ENABLE(hspi);
 808a050:	681a      	ldr	r2, [r3, #0]
 808a052:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 808a056:	601a      	str	r2, [r3, #0]
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 808a058:	2900      	cmp	r1, #0
 808a05a:	f000 8097 	beq.w	808a18c <HAL_SPI_TransmitReceive+0x2cc>
 808a05e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 808a060:	b292      	uxth	r2, r2
 808a062:	2a01      	cmp	r2, #1
 808a064:	f000 8092 	beq.w	808a18c <HAL_SPI_TransmitReceive+0x2cc>
        txallowed = 1U;
 808a068:	f04f 0901 	mov.w	r9, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 808a06c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 808a06e:	b29b      	uxth	r3, r3
 808a070:	bb43      	cbnz	r3, 808a0c4 <HAL_SPI_TransmitReceive+0x204>
 808a072:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a076:	b29b      	uxth	r3, r3
 808a078:	bb23      	cbnz	r3, 808a0c4 <HAL_SPI_TransmitReceive+0x204>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 808a07a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 808a07c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 808a080:	f000 80bf 	beq.w	808a202 <HAL_SPI_TransmitReceive+0x342>
 808a084:	6823      	ldr	r3, [r4, #0]
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 808a086:	689e      	ldr	r6, [r3, #8]
 808a088:	f016 0610 	ands.w	r6, r6, #16
 808a08c:	d007      	beq.n	808a09e <HAL_SPI_TransmitReceive+0x1de>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a08e:	6e22      	ldr	r2, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 808a090:	f64f 71ef 	movw	r1, #65519	; 0xffef
    errorcode = HAL_ERROR;
 808a094:	2601      	movs	r6, #1
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a096:	f042 0202 	orr.w	r2, r2, #2
 808a09a:	6622      	str	r2, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 808a09c:	6099      	str	r1, [r3, #8]
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 808a09e:	4642      	mov	r2, r8
 808a0a0:	4629      	mov	r1, r5
 808a0a2:	4620      	mov	r0, r4
 808a0a4:	f7ff fd54 	bl	8089b50 <SPI_EndRxTxTransaction>
 808a0a8:	b108      	cbz	r0, 808a0ae <HAL_SPI_TransmitReceive+0x1ee>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 808a0aa:	2320      	movs	r3, #32
 808a0ac:	6623      	str	r3, [r4, #96]	; 0x60
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 808a0ae:	6e23      	ldr	r3, [r4, #96]	; 0x60
 808a0b0:	2b00      	cmp	r3, #0
 808a0b2:	f43f af25 	beq.w	8089f00 <HAL_SPI_TransmitReceive+0x40>
    errorcode = HAL_ERROR;
 808a0b6:	2601      	movs	r6, #1
 808a0b8:	e722      	b.n	8089f00 <HAL_SPI_TransmitReceive+0x40>
  __HAL_LOCK(hspi);
 808a0ba:	2602      	movs	r6, #2
}
 808a0bc:	4630      	mov	r0, r6
 808a0be:	b005      	add	sp, #20
 808a0c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 808a0c4:	f1b9 0f00 	cmp.w	r9, #0
 808a0c8:	d018      	beq.n	808a0fc <HAL_SPI_TransmitReceive+0x23c>
 808a0ca:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 808a0cc:	b29b      	uxth	r3, r3
 808a0ce:	b1ab      	cbz	r3, 808a0fc <HAL_SPI_TransmitReceive+0x23c>
 808a0d0:	6822      	ldr	r2, [r4, #0]
 808a0d2:	6893      	ldr	r3, [r2, #8]
 808a0d4:	079b      	lsls	r3, r3, #30
 808a0d6:	d511      	bpl.n	808a0fc <HAL_SPI_TransmitReceive+0x23c>
        hspi->Instance->DR = *((uint16_t *)pTxData);
 808a0d8:	f837 3b02 	ldrh.w	r3, [r7], #2
 808a0dc:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 808a0de:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 808a0e0:	3b01      	subs	r3, #1
 808a0e2:	b29b      	uxth	r3, r3
 808a0e4:	87e3      	strh	r3, [r4, #62]	; 0x3e
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 808a0e6:	f8b4 903e 	ldrh.w	r9, [r4, #62]	; 0x3e
 808a0ea:	fa1f f389 	uxth.w	r3, r9
 808a0ee:	2b00      	cmp	r3, #0
 808a0f0:	d13a      	bne.n	808a168 <HAL_SPI_TransmitReceive+0x2a8>
 808a0f2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 808a0f4:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 808a0f8:	d072      	beq.n	808a1e0 <HAL_SPI_TransmitReceive+0x320>
        txallowed = 0U;
 808a0fa:	4699      	mov	r9, r3
      if ((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 808a0fc:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a100:	b29b      	uxth	r3, r3
 808a102:	b173      	cbz	r3, 808a122 <HAL_SPI_TransmitReceive+0x262>
 808a104:	6823      	ldr	r3, [r4, #0]
 808a106:	689a      	ldr	r2, [r3, #8]
 808a108:	07d2      	lsls	r2, r2, #31
 808a10a:	d50a      	bpl.n	808a122 <HAL_SPI_TransmitReceive+0x262>
        *((uint16_t *)pRxData) = hspi->Instance->DR;
 808a10c:	68db      	ldr	r3, [r3, #12]
        txallowed = 1U;
 808a10e:	f04f 0901 	mov.w	r9, #1
        *((uint16_t *)pRxData) = hspi->Instance->DR;
 808a112:	f826 3b02 	strh.w	r3, [r6], #2
        hspi->RxXferCount--;
 808a116:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a11a:	3b01      	subs	r3, #1
 808a11c:	b29b      	uxth	r3, r3
 808a11e:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
 808a122:	1c68      	adds	r0, r5, #1
 808a124:	d0a2      	beq.n	808a06c <HAL_SPI_TransmitReceive+0x1ac>
 808a126:	f7fb fb43 	bl	80857b0 <HAL_GetTick>
 808a12a:	eba0 0008 	sub.w	r0, r0, r8
 808a12e:	42a8      	cmp	r0, r5
 808a130:	d39c      	bcc.n	808a06c <HAL_SPI_TransmitReceive+0x1ac>
        errorcode = HAL_TIMEOUT;
 808a132:	2603      	movs	r6, #3
 808a134:	e6e4      	b.n	8089f00 <HAL_SPI_TransmitReceive+0x40>
    SPI_RESET_CRC(hspi);
 808a136:	681a      	ldr	r2, [r3, #0]
 808a138:	f64d 70ff 	movw	r0, #57343	; 0xdfff
 808a13c:	4002      	ands	r2, r0
 808a13e:	601a      	str	r2, [r3, #0]
 808a140:	681a      	ldr	r2, [r3, #0]
 808a142:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 808a146:	601a      	str	r2, [r3, #0]
 808a148:	e70d      	b.n	8089f66 <HAL_SPI_TransmitReceive+0xa6>
          (*pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 808a14a:	7b13      	ldrb	r3, [r2, #12]
        txallowed = 1U;
 808a14c:	f04f 0901 	mov.w	r9, #1
          (*pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 808a150:	7033      	strb	r3, [r6, #0]
 808a152:	444e      	add	r6, r9
          hspi->RxXferCount--;
 808a154:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a158:	3b01      	subs	r3, #1
 808a15a:	b29b      	uxth	r3, r3
 808a15c:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 808a160:	e766      	b.n	808a030 <HAL_SPI_TransmitReceive+0x170>
        txallowed = 0U;
 808a162:	f04f 0900 	mov.w	r9, #0
 808a166:	e746      	b.n	8089ff6 <HAL_SPI_TransmitReceive+0x136>
        txallowed = 0U;
 808a168:	f04f 0900 	mov.w	r9, #0
 808a16c:	e7c6      	b.n	808a0fc <HAL_SPI_TransmitReceive+0x23c>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 808a16e:	6853      	ldr	r3, [r2, #4]
        txallowed = 1U;
 808a170:	f04f 0901 	mov.w	r9, #1
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 808a174:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 808a178:	6053      	str	r3, [r2, #4]
 808a17a:	e759      	b.n	808a030 <HAL_SPI_TransmitReceive+0x170>
      *((__IO uint8_t *)&hspi->Instance->DR) = (*pTxData);
 808a17c:	f817 2b01 	ldrb.w	r2, [r7], #1
 808a180:	731a      	strb	r2, [r3, #12]
      hspi->TxXferCount--;
 808a182:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 808a184:	3b01      	subs	r3, #1
 808a186:	b29b      	uxth	r3, r3
 808a188:	87e3      	strh	r3, [r4, #62]	; 0x3e
 808a18a:	e708      	b.n	8089f9e <HAL_SPI_TransmitReceive+0xde>
      hspi->Instance->DR = *((uint16_t *)pTxData);
 808a18c:	f837 2b02 	ldrh.w	r2, [r7], #2
 808a190:	60da      	str	r2, [r3, #12]
      hspi->TxXferCount--;
 808a192:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 808a194:	3b01      	subs	r3, #1
 808a196:	b29b      	uxth	r3, r3
 808a198:	87e3      	strh	r3, [r4, #62]	; 0x3e
 808a19a:	e765      	b.n	808a068 <HAL_SPI_TransmitReceive+0x1a8>
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 808a19c:	783a      	ldrb	r2, [r7, #0]
 808a19e:	3701      	adds	r7, #1
 808a1a0:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 808a1a2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 808a1a4:	3b01      	subs	r3, #1
 808a1a6:	b29b      	uxth	r3, r3
 808a1a8:	87e3      	strh	r3, [r4, #62]	; 0x3e
 808a1aa:	e717      	b.n	8089fdc <HAL_SPI_TransmitReceive+0x11c>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 808a1ac:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 808a1b0:	605a      	str	r2, [r3, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 808a1b2:	681a      	ldr	r2, [r3, #0]
 808a1b4:	0652      	lsls	r2, r2, #25
 808a1b6:	f57f aee6 	bpl.w	8089f86 <HAL_SPI_TransmitReceive+0xc6>
 808a1ba:	e6e8      	b.n	8089f8e <HAL_SPI_TransmitReceive+0xce>
          if (((hspi->Instance->CR1 & SPI_CR1_MSTR) == 0U) && ((hspi->Instance->CR2 & SPI_CR2_NSSP) == SPI_CR2_NSSP))
 808a1bc:	6823      	ldr	r3, [r4, #0]
 808a1be:	681a      	ldr	r2, [r3, #0]
 808a1c0:	0752      	lsls	r2, r2, #29
 808a1c2:	d406      	bmi.n	808a1d2 <HAL_SPI_TransmitReceive+0x312>
 808a1c4:	685a      	ldr	r2, [r3, #4]
 808a1c6:	0710      	lsls	r0, r2, #28
 808a1c8:	d503      	bpl.n	808a1d2 <HAL_SPI_TransmitReceive+0x312>
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 808a1ca:	681a      	ldr	r2, [r3, #0]
 808a1cc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 808a1d0:	601a      	str	r2, [r3, #0]
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 808a1d2:	681a      	ldr	r2, [r3, #0]
        txallowed = 0U;
 808a1d4:	f04f 0900 	mov.w	r9, #0
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 808a1d8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 808a1dc:	601a      	str	r2, [r3, #0]
 808a1de:	e70a      	b.n	8089ff6 <HAL_SPI_TransmitReceive+0x136>
          if (((hspi->Instance->CR1 & SPI_CR1_MSTR) == 0U) && ((hspi->Instance->CR2 & SPI_CR2_NSSP) == SPI_CR2_NSSP))
 808a1e0:	6813      	ldr	r3, [r2, #0]
 808a1e2:	0758      	lsls	r0, r3, #29
 808a1e4:	d406      	bmi.n	808a1f4 <HAL_SPI_TransmitReceive+0x334>
 808a1e6:	6853      	ldr	r3, [r2, #4]
 808a1e8:	0719      	lsls	r1, r3, #28
 808a1ea:	d503      	bpl.n	808a1f4 <HAL_SPI_TransmitReceive+0x334>
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 808a1ec:	6813      	ldr	r3, [r2, #0]
 808a1ee:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 808a1f2:	6013      	str	r3, [r2, #0]
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 808a1f4:	6813      	ldr	r3, [r2, #0]
        txallowed = 0U;
 808a1f6:	f04f 0900 	mov.w	r9, #0
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 808a1fa:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 808a1fe:	6013      	str	r3, [r2, #0]
 808a200:	e77c      	b.n	808a0fc <HAL_SPI_TransmitReceive+0x23c>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 808a202:	2201      	movs	r2, #1
 808a204:	f8cd 8000 	str.w	r8, [sp]
 808a208:	462b      	mov	r3, r5
 808a20a:	4620      	mov	r0, r4
 808a20c:	4611      	mov	r1, r2
 808a20e:	f7ff fc53 	bl	8089ab8 <SPI_WaitFlagStateUntilTimeout>
 808a212:	b9e8      	cbnz	r0, 808a250 <HAL_SPI_TransmitReceive+0x390>
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 808a214:	68e2      	ldr	r2, [r4, #12]
 808a216:	6823      	ldr	r3, [r4, #0]
 808a218:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 808a21c:	d01e      	beq.n	808a25c <HAL_SPI_TransmitReceive+0x39c>
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 808a21e:	6b21      	ldr	r1, [r4, #48]	; 0x30
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 808a220:	7b1a      	ldrb	r2, [r3, #12]
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 808a222:	2902      	cmp	r1, #2
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 808a224:	f8ad 200e 	strh.w	r2, [sp, #14]
      UNUSED(tmpreg);
 808a228:	f8bd 200e 	ldrh.w	r2, [sp, #14]
      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 808a22c:	f47f af2b 	bne.w	808a086 <HAL_SPI_TransmitReceive+0x1c6>
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 808a230:	2201      	movs	r2, #1
 808a232:	f8cd 8000 	str.w	r8, [sp]
 808a236:	462b      	mov	r3, r5
 808a238:	4620      	mov	r0, r4
 808a23a:	4611      	mov	r1, r2
 808a23c:	f7ff fc3c 	bl	8089ab8 <SPI_WaitFlagStateUntilTimeout>
 808a240:	b930      	cbnz	r0, 808a250 <HAL_SPI_TransmitReceive+0x390>
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 808a242:	6823      	ldr	r3, [r4, #0]
 808a244:	7b1a      	ldrb	r2, [r3, #12]
 808a246:	f8ad 200e 	strh.w	r2, [sp, #14]
        UNUSED(tmpreg);
 808a24a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 808a24e:	e71a      	b.n	808a086 <HAL_SPI_TransmitReceive+0x1c6>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a250:	6e23      	ldr	r3, [r4, #96]	; 0x60
          errorcode = HAL_TIMEOUT;
 808a252:	2603      	movs	r6, #3
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a254:	f043 0302 	orr.w	r3, r3, #2
 808a258:	6623      	str	r3, [r4, #96]	; 0x60
          goto error;
 808a25a:	e651      	b.n	8089f00 <HAL_SPI_TransmitReceive+0x40>
      tmpreg = hspi->Instance->DR;
 808a25c:	68da      	ldr	r2, [r3, #12]
 808a25e:	b292      	uxth	r2, r2
 808a260:	f8ad 200e 	strh.w	r2, [sp, #14]
      UNUSED(tmpreg);
 808a264:	f8bd 200e 	ldrh.w	r2, [sp, #14]
 808a268:	e70d      	b.n	808a086 <HAL_SPI_TransmitReceive+0x1c6>
 808a26a:	bf00      	nop

0808a26c <HAL_SPI_Receive>:
{
 808a26c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 808a270:	461e      	mov	r6, r3
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 808a272:	6843      	ldr	r3, [r0, #4]
{
 808a274:	b084      	sub	sp, #16
  __IO uint16_t tmpreg = 0U;
 808a276:	2700      	movs	r7, #0
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 808a278:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
{
 808a27c:	4604      	mov	r4, r0
 808a27e:	4690      	mov	r8, r2
 808a280:	460d      	mov	r5, r1
  __IO uint16_t tmpreg = 0U;
 808a282:	f8ad 700e 	strh.w	r7, [sp, #14]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 808a286:	f000 8092 	beq.w	808a3ae <HAL_SPI_Receive+0x142>
  __HAL_LOCK(hspi);
 808a28a:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 808a28e:	2b01      	cmp	r3, #1
 808a290:	f000 809c 	beq.w	808a3cc <HAL_SPI_Receive+0x160>
 808a294:	2301      	movs	r3, #1
 808a296:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  tickstart = HAL_GetTick();
 808a29a:	f7fb fa89 	bl	80857b0 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 808a29e:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  tickstart = HAL_GetTick();
 808a2a2:	4607      	mov	r7, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 808a2a4:	2b01      	cmp	r3, #1
 808a2a6:	d009      	beq.n	808a2bc <HAL_SPI_Receive+0x50>
    errorcode = HAL_BUSY;
 808a2a8:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 808a2aa:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 808a2ac:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 808a2ae:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 808a2b2:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 808a2b6:	b004      	add	sp, #16
 808a2b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 808a2bc:	2d00      	cmp	r5, #0
 808a2be:	f000 8089 	beq.w	808a3d4 <HAL_SPI_Receive+0x168>
 808a2c2:	fab8 f388 	clz	r3, r8
 808a2c6:	095b      	lsrs	r3, r3, #5
 808a2c8:	2b00      	cmp	r3, #0
 808a2ca:	f040 8083 	bne.w	808a3d4 <HAL_SPI_Receive+0x168>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 808a2ce:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 808a2d0:	2204      	movs	r2, #4
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 808a2d2:	6425      	str	r5, [r4, #64]	; 0x40
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 808a2d4:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 808a2d8:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  hspi->RxXferSize  = Size;
 808a2dc:	f8a4 8044 	strh.w	r8, [r4, #68]	; 0x44
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 808a2e0:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 808a2e2:	63a3      	str	r3, [r4, #56]	; 0x38
  hspi->RxXferCount = Size;
 808a2e4:	f8a4 8046 	strh.w	r8, [r4, #70]	; 0x46
  hspi->TxXferSize  = 0U;
 808a2e8:	87a3      	strh	r3, [r4, #60]	; 0x3c
 808a2ea:	6822      	ldr	r2, [r4, #0]
  hspi->TxXferCount = 0U;
 808a2ec:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->TxISR       = NULL;
 808a2ee:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 808a2f2:	d10e      	bne.n	808a312 <HAL_SPI_Receive+0xa6>
    SPI_RESET_CRC(hspi);
 808a2f4:	6813      	ldr	r3, [r2, #0]
 808a2f6:	f64d 71ff 	movw	r1, #57343	; 0xdfff
 808a2fa:	400b      	ands	r3, r1
 808a2fc:	6013      	str	r3, [r2, #0]
 808a2fe:	6813      	ldr	r3, [r2, #0]
 808a300:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 808a304:	6013      	str	r3, [r2, #0]
    hspi->RxXferCount--;
 808a306:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a30a:	3b01      	subs	r3, #1
 808a30c:	b29b      	uxth	r3, r3
 808a30e:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 808a312:	68e3      	ldr	r3, [r4, #12]
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 808a314:	6851      	ldr	r1, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 808a316:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 808a31a:	bf8c      	ite	hi
 808a31c:	f421 5180 	bichi.w	r1, r1, #4096	; 0x1000
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 808a320:	f441 5180 	orrls.w	r1, r1, #4096	; 0x1000
 808a324:	6051      	str	r1, [r2, #4]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 808a326:	68a1      	ldr	r1, [r4, #8]
 808a328:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 808a32c:	d103      	bne.n	808a336 <HAL_SPI_Receive+0xca>
    SPI_1LINE_RX(hspi);
 808a32e:	6811      	ldr	r1, [r2, #0]
 808a330:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 808a334:	6011      	str	r1, [r2, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 808a336:	6811      	ldr	r1, [r2, #0]
 808a338:	0649      	lsls	r1, r1, #25
 808a33a:	d403      	bmi.n	808a344 <HAL_SPI_Receive+0xd8>
    __HAL_SPI_ENABLE(hspi);
 808a33c:	6811      	ldr	r1, [r2, #0]
 808a33e:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 808a342:	6011      	str	r1, [r2, #0]
  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
 808a344:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 808a348:	d84e      	bhi.n	808a3e8 <HAL_SPI_Receive+0x17c>
    while (hspi->RxXferCount > 0U)
 808a34a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a34e:	b29b      	uxth	r3, r3
 808a350:	b18b      	cbz	r3, 808a376 <HAL_SPI_Receive+0x10a>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 808a352:	6823      	ldr	r3, [r4, #0]
 808a354:	689a      	ldr	r2, [r3, #8]
 808a356:	07d2      	lsls	r2, r2, #31
 808a358:	d55e      	bpl.n	808a418 <HAL_SPI_Receive+0x1ac>
        (*pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 808a35a:	7b1b      	ldrb	r3, [r3, #12]
 808a35c:	f805 3b01 	strb.w	r3, [r5], #1
        hspi->RxXferCount--;
 808a360:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a364:	3b01      	subs	r3, #1
 808a366:	b29b      	uxth	r3, r3
 808a368:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    while (hspi->RxXferCount > 0U)
 808a36c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a370:	b29b      	uxth	r3, r3
 808a372:	2b00      	cmp	r3, #0
 808a374:	d1ed      	bne.n	808a352 <HAL_SPI_Receive+0xe6>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 808a376:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 808a378:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 808a37c:	d056      	beq.n	808a42c <HAL_SPI_Receive+0x1c0>
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 808a37e:	463a      	mov	r2, r7
 808a380:	4631      	mov	r1, r6
 808a382:	4620      	mov	r0, r4
 808a384:	f7ff fc0a 	bl	8089b9c <SPI_EndRxTransaction>
 808a388:	b108      	cbz	r0, 808a38e <HAL_SPI_Receive+0x122>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 808a38a:	2320      	movs	r3, #32
 808a38c:	6623      	str	r3, [r4, #96]	; 0x60
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 808a38e:	6823      	ldr	r3, [r4, #0]
 808a390:	689a      	ldr	r2, [r3, #8]
 808a392:	06d2      	lsls	r2, r2, #27
 808a394:	d506      	bpl.n	808a3a4 <HAL_SPI_Receive+0x138>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a396:	6e22      	ldr	r2, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 808a398:	f64f 71ef 	movw	r1, #65519	; 0xffef
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a39c:	f042 0202 	orr.w	r2, r2, #2
 808a3a0:	6622      	str	r2, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 808a3a2:	6099      	str	r1, [r3, #8]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 808a3a4:	6e20      	ldr	r0, [r4, #96]	; 0x60
    errorcode = HAL_BUSY;
 808a3a6:	3000      	adds	r0, #0
 808a3a8:	bf18      	it	ne
 808a3aa:	2001      	movne	r0, #1
error :
 808a3ac:	e77d      	b.n	808a2aa <HAL_SPI_Receive+0x3e>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 808a3ae:	6883      	ldr	r3, [r0, #8]
 808a3b0:	2b00      	cmp	r3, #0
 808a3b2:	f47f af6a 	bne.w	808a28a <HAL_SPI_Receive+0x1e>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 808a3b6:	2704      	movs	r7, #4
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 808a3b8:	4613      	mov	r3, r2
 808a3ba:	460a      	mov	r2, r1
 808a3bc:	9600      	str	r6, [sp, #0]
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 808a3be:	f880 705d 	strb.w	r7, [r0, #93]	; 0x5d
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 808a3c2:	f7ff fd7d 	bl	8089ec0 <HAL_SPI_TransmitReceive>
}
 808a3c6:	b004      	add	sp, #16
 808a3c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(hspi);
 808a3cc:	2002      	movs	r0, #2
}
 808a3ce:	b004      	add	sp, #16
 808a3d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    errorcode = HAL_ERROR;
 808a3d4:	2001      	movs	r0, #1
 808a3d6:	e768      	b.n	808a2aa <HAL_SPI_Receive+0x3e>
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 808a3d8:	b336      	cbz	r6, 808a428 <HAL_SPI_Receive+0x1bc>
 808a3da:	1c71      	adds	r1, r6, #1
 808a3dc:	d004      	beq.n	808a3e8 <HAL_SPI_Receive+0x17c>
 808a3de:	f7fb f9e7 	bl	80857b0 <HAL_GetTick>
 808a3e2:	1bc0      	subs	r0, r0, r7
 808a3e4:	42b0      	cmp	r0, r6
 808a3e6:	d21f      	bcs.n	808a428 <HAL_SPI_Receive+0x1bc>
    while (hspi->RxXferCount > 0U)
 808a3e8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a3ec:	b29b      	uxth	r3, r3
 808a3ee:	2b00      	cmp	r3, #0
 808a3f0:	d0c1      	beq.n	808a376 <HAL_SPI_Receive+0x10a>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 808a3f2:	6823      	ldr	r3, [r4, #0]
 808a3f4:	689a      	ldr	r2, [r3, #8]
 808a3f6:	07d0      	lsls	r0, r2, #31
 808a3f8:	d5ee      	bpl.n	808a3d8 <HAL_SPI_Receive+0x16c>
        *((uint16_t *)pData) = hspi->Instance->DR;
 808a3fa:	68db      	ldr	r3, [r3, #12]
 808a3fc:	f825 3b02 	strh.w	r3, [r5], #2
        hspi->RxXferCount--;
 808a400:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a404:	3b01      	subs	r3, #1
 808a406:	b29b      	uxth	r3, r3
 808a408:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    while (hspi->RxXferCount > 0U)
 808a40c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 808a410:	b29b      	uxth	r3, r3
 808a412:	2b00      	cmp	r3, #0
 808a414:	d1ed      	bne.n	808a3f2 <HAL_SPI_Receive+0x186>
 808a416:	e7ae      	b.n	808a376 <HAL_SPI_Receive+0x10a>
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 808a418:	b136      	cbz	r6, 808a428 <HAL_SPI_Receive+0x1bc>
 808a41a:	1c73      	adds	r3, r6, #1
 808a41c:	d095      	beq.n	808a34a <HAL_SPI_Receive+0xde>
 808a41e:	f7fb f9c7 	bl	80857b0 <HAL_GetTick>
 808a422:	1bc0      	subs	r0, r0, r7
 808a424:	42b0      	cmp	r0, r6
 808a426:	d390      	bcc.n	808a34a <HAL_SPI_Receive+0xde>
          errorcode = HAL_TIMEOUT;
 808a428:	2003      	movs	r0, #3
 808a42a:	e73e      	b.n	808a2aa <HAL_SPI_Receive+0x3e>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 808a42c:	f8d4 e000 	ldr.w	lr, [r4]
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 808a430:	2201      	movs	r2, #1
 808a432:	4633      	mov	r3, r6
 808a434:	4620      	mov	r0, r4
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 808a436:	f8de c000 	ldr.w	ip, [lr]
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 808a43a:	4611      	mov	r1, r2
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 808a43c:	f44c 5c80 	orr.w	ip, ip, #4096	; 0x1000
 808a440:	f8ce c000 	str.w	ip, [lr]
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 808a444:	9700      	str	r7, [sp, #0]
 808a446:	f7ff fb37 	bl	8089ab8 <SPI_WaitFlagStateUntilTimeout>
 808a44a:	2800      	cmp	r0, #0
 808a44c:	d1ec      	bne.n	808a428 <HAL_SPI_Receive+0x1bc>
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 808a44e:	68e2      	ldr	r2, [r4, #12]
 808a450:	6823      	ldr	r3, [r4, #0]
 808a452:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 808a456:	d930      	bls.n	808a4ba <HAL_SPI_Receive+0x24e>
      *((uint16_t *)pData) = hspi->Instance->DR;
 808a458:	68db      	ldr	r3, [r3, #12]
 808a45a:	802b      	strh	r3, [r5, #0]
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 808a45c:	2201      	movs	r2, #1
 808a45e:	9700      	str	r7, [sp, #0]
 808a460:	4633      	mov	r3, r6
 808a462:	4620      	mov	r0, r4
 808a464:	4611      	mov	r1, r2
 808a466:	f7ff fb27 	bl	8089ab8 <SPI_WaitFlagStateUntilTimeout>
 808a46a:	bb00      	cbnz	r0, 808a4ae <HAL_SPI_Receive+0x242>
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 808a46c:	68e3      	ldr	r3, [r4, #12]
 808a46e:	6822      	ldr	r2, [r4, #0]
 808a470:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 808a474:	d024      	beq.n	808a4c0 <HAL_SPI_Receive+0x254>
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 808a476:	7b12      	ldrb	r2, [r2, #12]
      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 808a478:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 808a47c:	f8ad 200e 	strh.w	r2, [sp, #14]
      UNUSED(tmpreg);
 808a480:	f8bd 200e 	ldrh.w	r2, [sp, #14]
      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 808a484:	f47f af7b 	bne.w	808a37e <HAL_SPI_Receive+0x112>
 808a488:	6b23      	ldr	r3, [r4, #48]	; 0x30
 808a48a:	2b02      	cmp	r3, #2
 808a48c:	f47f af77 	bne.w	808a37e <HAL_SPI_Receive+0x112>
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout, tickstart) != HAL_OK)
 808a490:	2201      	movs	r2, #1
 808a492:	9700      	str	r7, [sp, #0]
 808a494:	4633      	mov	r3, r6
 808a496:	4620      	mov	r0, r4
 808a498:	4611      	mov	r1, r2
 808a49a:	f7ff fb0d 	bl	8089ab8 <SPI_WaitFlagStateUntilTimeout>
 808a49e:	b930      	cbnz	r0, 808a4ae <HAL_SPI_Receive+0x242>
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 808a4a0:	6823      	ldr	r3, [r4, #0]
 808a4a2:	7b1b      	ldrb	r3, [r3, #12]
 808a4a4:	f8ad 300e 	strh.w	r3, [sp, #14]
        UNUSED(tmpreg);
 808a4a8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 808a4ac:	e767      	b.n	808a37e <HAL_SPI_Receive+0x112>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a4ae:	6e23      	ldr	r3, [r4, #96]	; 0x60
          errorcode = HAL_TIMEOUT;
 808a4b0:	2003      	movs	r0, #3
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 808a4b2:	f043 0302 	orr.w	r3, r3, #2
 808a4b6:	6623      	str	r3, [r4, #96]	; 0x60
          goto error;
 808a4b8:	e6f7      	b.n	808a2aa <HAL_SPI_Receive+0x3e>
      (*pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 808a4ba:	7b1b      	ldrb	r3, [r3, #12]
 808a4bc:	702b      	strb	r3, [r5, #0]
 808a4be:	e7cd      	b.n	808a45c <HAL_SPI_Receive+0x1f0>
      tmpreg = hspi->Instance->DR;
 808a4c0:	68d3      	ldr	r3, [r2, #12]
 808a4c2:	b29b      	uxth	r3, r3
 808a4c4:	f8ad 300e 	strh.w	r3, [sp, #14]
      UNUSED(tmpreg);
 808a4c8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 808a4cc:	e757      	b.n	808a37e <HAL_SPI_Receive+0x112>
 808a4ce:	bf00      	nop

0808a4d0 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 808a4d0:	4770      	bx	lr
 808a4d2:	bf00      	nop

0808a4d4 <HAL_TIM_Base_Start>:
  * @param  htim pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 808a4d4:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 808a4d6:	2202      	movs	r2, #2
  /* Change the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
  
  /* Return function status */
  return HAL_OK;
}
 808a4d8:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
 808a4da:	6819      	ldr	r1, [r3, #0]
{
 808a4dc:	b410      	push	{r4}
  htim->State= HAL_TIM_STATE_READY;
 808a4de:	2401      	movs	r4, #1
  htim->State= HAL_TIM_STATE_BUSY;
 808a4e0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  __HAL_TIM_ENABLE(htim);
 808a4e4:	680a      	ldr	r2, [r1, #0]
 808a4e6:	4322      	orrs	r2, r4
 808a4e8:	600a      	str	r2, [r1, #0]
  htim->State= HAL_TIM_STATE_READY;
 808a4ea:	f883 403d 	strb.w	r4, [r3, #61]	; 0x3d
}
 808a4ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 808a4f2:	4770      	bx	lr

0808a4f4 <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 808a4f4:	6803      	ldr	r3, [r0, #0]
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
      
  /* Return function status */
  return HAL_OK;
}
 808a4f6:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 808a4f8:	68da      	ldr	r2, [r3, #12]
 808a4fa:	f042 0201 	orr.w	r2, r2, #1
 808a4fe:	60da      	str	r2, [r3, #12]
  __HAL_TIM_ENABLE(htim);
 808a500:	681a      	ldr	r2, [r3, #0]
 808a502:	f042 0201 	orr.w	r2, r2, #1
 808a506:	601a      	str	r2, [r3, #0]
}
 808a508:	4770      	bx	lr
 808a50a:	bf00      	nop

0808a50c <HAL_TIM_Base_Stop_IT>:
HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  /* Disable the TIM Update interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 808a50c:	6803      	ldr	r3, [r0, #0]
      
  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 808a50e:	f241 1111 	movw	r1, #4369	; 0x1111
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 808a512:	68da      	ldr	r2, [r3, #12]
 808a514:	f022 0201 	bic.w	r2, r2, #1
 808a518:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
 808a51a:	6a1a      	ldr	r2, [r3, #32]
 808a51c:	420a      	tst	r2, r1
 808a51e:	d108      	bne.n	808a532 <HAL_TIM_Base_Stop_IT+0x26>
 808a520:	6a19      	ldr	r1, [r3, #32]
 808a522:	f240 4244 	movw	r2, #1092	; 0x444
 808a526:	4211      	tst	r1, r2
 808a528:	d103      	bne.n	808a532 <HAL_TIM_Base_Stop_IT+0x26>
 808a52a:	681a      	ldr	r2, [r3, #0]
 808a52c:	f022 0201 	bic.w	r2, r2, #1
 808a530:	601a      	str	r2, [r3, #0]
    
  /* Return function status */
  return HAL_OK;
}
 808a532:	2000      	movs	r0, #0
 808a534:	4770      	bx	lr
 808a536:	bf00      	nop

0808a538 <HAL_TIM_OC_DelayElapsedCallback>:
 808a538:	4770      	bx	lr
 808a53a:	bf00      	nop

0808a53c <HAL_TIM_IC_CaptureCallback>:
 808a53c:	4770      	bx	lr
 808a53e:	bf00      	nop

0808a540 <HAL_TIM_PWM_PulseFinishedCallback>:
 808a540:	4770      	bx	lr
 808a542:	bf00      	nop

0808a544 <HAL_TIM_TriggerCallback>:
 808a544:	4770      	bx	lr
 808a546:	bf00      	nop

0808a548 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 808a548:	6803      	ldr	r3, [r0, #0]
 808a54a:	691a      	ldr	r2, [r3, #16]
 808a54c:	0791      	lsls	r1, r2, #30
{
 808a54e:	b510      	push	{r4, lr}
 808a550:	4604      	mov	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 808a552:	d502      	bpl.n	808a55a <HAL_TIM_IRQHandler+0x12>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 808a554:	68da      	ldr	r2, [r3, #12]
 808a556:	0792      	lsls	r2, r2, #30
 808a558:	d468      	bmi.n	808a62c <HAL_TIM_IRQHandler+0xe4>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 808a55a:	691a      	ldr	r2, [r3, #16]
 808a55c:	0752      	lsls	r2, r2, #29
 808a55e:	d502      	bpl.n	808a566 <HAL_TIM_IRQHandler+0x1e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 808a560:	68da      	ldr	r2, [r3, #12]
 808a562:	0750      	lsls	r0, r2, #29
 808a564:	d44f      	bmi.n	808a606 <HAL_TIM_IRQHandler+0xbe>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 808a566:	691a      	ldr	r2, [r3, #16]
 808a568:	0711      	lsls	r1, r2, #28
 808a56a:	d502      	bpl.n	808a572 <HAL_TIM_IRQHandler+0x2a>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 808a56c:	68da      	ldr	r2, [r3, #12]
 808a56e:	0712      	lsls	r2, r2, #28
 808a570:	d437      	bmi.n	808a5e2 <HAL_TIM_IRQHandler+0x9a>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 808a572:	691a      	ldr	r2, [r3, #16]
 808a574:	06d0      	lsls	r0, r2, #27
 808a576:	d502      	bpl.n	808a57e <HAL_TIM_IRQHandler+0x36>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 808a578:	68da      	ldr	r2, [r3, #12]
 808a57a:	06d1      	lsls	r1, r2, #27
 808a57c:	d41e      	bmi.n	808a5bc <HAL_TIM_IRQHandler+0x74>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 808a57e:	691a      	ldr	r2, [r3, #16]
 808a580:	07d2      	lsls	r2, r2, #31
 808a582:	d502      	bpl.n	808a58a <HAL_TIM_IRQHandler+0x42>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 808a584:	68da      	ldr	r2, [r3, #12]
 808a586:	07d0      	lsls	r0, r2, #31
 808a588:	d469      	bmi.n	808a65e <HAL_TIM_IRQHandler+0x116>
      HAL_TIM_PeriodElapsedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 808a58a:	691a      	ldr	r2, [r3, #16]
 808a58c:	0611      	lsls	r1, r2, #24
 808a58e:	d502      	bpl.n	808a596 <HAL_TIM_IRQHandler+0x4e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 808a590:	68da      	ldr	r2, [r3, #12]
 808a592:	0612      	lsls	r2, r2, #24
 808a594:	d46b      	bmi.n	808a66e <HAL_TIM_IRQHandler+0x126>

    }
  }
  
    /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 808a596:	691a      	ldr	r2, [r3, #16]
 808a598:	05d0      	lsls	r0, r2, #23
 808a59a:	d502      	bpl.n	808a5a2 <HAL_TIM_IRQHandler+0x5a>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 808a59c:	68da      	ldr	r2, [r3, #12]
 808a59e:	0611      	lsls	r1, r2, #24
 808a5a0:	d46d      	bmi.n	808a67e <HAL_TIM_IRQHandler+0x136>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }

  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 808a5a2:	691a      	ldr	r2, [r3, #16]
 808a5a4:	0652      	lsls	r2, r2, #25
 808a5a6:	d502      	bpl.n	808a5ae <HAL_TIM_IRQHandler+0x66>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 808a5a8:	68da      	ldr	r2, [r3, #12]
 808a5aa:	0650      	lsls	r0, r2, #25
 808a5ac:	d46f      	bmi.n	808a68e <HAL_TIM_IRQHandler+0x146>
      HAL_TIM_TriggerCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 808a5ae:	691a      	ldr	r2, [r3, #16]
 808a5b0:	0691      	lsls	r1, r2, #26
 808a5b2:	d502      	bpl.n	808a5ba <HAL_TIM_IRQHandler+0x72>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 808a5b4:	68da      	ldr	r2, [r3, #12]
 808a5b6:	0692      	lsls	r2, r2, #26
 808a5b8:	d449      	bmi.n	808a64e <HAL_TIM_IRQHandler+0x106>
#else
      HAL_TIMEx_CommutationCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 808a5ba:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 808a5bc:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 808a5c0:	2208      	movs	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 808a5c2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 808a5c4:	6119      	str	r1, [r3, #16]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 808a5c6:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 808a5c8:	7722      	strb	r2, [r4, #28]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 808a5ca:	f413 7f40 	tst.w	r3, #768	; 0x300
 808a5ce:	d16f      	bne.n	808a6b0 <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 808a5d0:	f7ff ffb2 	bl	808a538 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 808a5d4:	4620      	mov	r0, r4
 808a5d6:	f7ff ffb3 	bl	808a540 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 808a5da:	2200      	movs	r2, #0
 808a5dc:	6823      	ldr	r3, [r4, #0]
 808a5de:	7722      	strb	r2, [r4, #28]
 808a5e0:	e7cd      	b.n	808a57e <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 808a5e2:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 808a5e6:	2204      	movs	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 808a5e8:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 808a5ea:	6119      	str	r1, [r3, #16]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 808a5ec:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 808a5ee:	7722      	strb	r2, [r4, #28]
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 808a5f0:	079b      	lsls	r3, r3, #30
 808a5f2:	d15a      	bne.n	808a6aa <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 808a5f4:	f7ff ffa0 	bl	808a538 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 808a5f8:	4620      	mov	r0, r4
 808a5fa:	f7ff ffa1 	bl	808a540 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 808a5fe:	2200      	movs	r2, #0
 808a600:	6823      	ldr	r3, [r4, #0]
 808a602:	7722      	strb	r2, [r4, #28]
 808a604:	e7b5      	b.n	808a572 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 808a606:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 808a60a:	2202      	movs	r2, #2
        HAL_TIM_IC_CaptureCallback(htim);
 808a60c:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 808a60e:	6119      	str	r1, [r3, #16]
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 808a610:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 808a612:	7722      	strb	r2, [r4, #28]
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 808a614:	f413 7f40 	tst.w	r3, #768	; 0x300
 808a618:	d144      	bne.n	808a6a4 <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 808a61a:	f7ff ff8d 	bl	808a538 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 808a61e:	4620      	mov	r0, r4
 808a620:	f7ff ff8e 	bl	808a540 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 808a624:	2200      	movs	r2, #0
 808a626:	6823      	ldr	r3, [r4, #0]
 808a628:	7722      	strb	r2, [r4, #28]
 808a62a:	e79c      	b.n	808a566 <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 808a62c:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 808a630:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 808a632:	6119      	str	r1, [r3, #16]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 808a634:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 808a636:	7702      	strb	r2, [r0, #28]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 808a638:	0799      	lsls	r1, r3, #30
 808a63a:	d130      	bne.n	808a69e <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 808a63c:	f7ff ff7c 	bl	808a538 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 808a640:	4620      	mov	r0, r4
 808a642:	f7ff ff7d 	bl	808a540 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 808a646:	2200      	movs	r2, #0
 808a648:	6823      	ldr	r3, [r4, #0]
 808a64a:	7722      	strb	r2, [r4, #28]
 808a64c:	e785      	b.n	808a55a <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 808a64e:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutationCallback(htim);
 808a652:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 808a654:	611a      	str	r2, [r3, #16]
}
 808a656:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutationCallback(htim);
 808a65a:	f000 b8c5 	b.w	808a7e8 <HAL_TIMEx_CommutationCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 808a65e:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 808a662:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 808a664:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 808a666:	f000 f90b 	bl	808a880 <HAL_TIM_PeriodElapsedCallback>
 808a66a:	6823      	ldr	r3, [r4, #0]
 808a66c:	e78d      	b.n	808a58a <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 808a66e:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 808a672:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 808a674:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 808a676:	f000 f8b9 	bl	808a7ec <HAL_TIMEx_BreakCallback>
 808a67a:	6823      	ldr	r3, [r4, #0]
 808a67c:	e78b      	b.n	808a596 <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 808a67e:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 808a682:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 808a684:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 808a686:	f000 f8b1 	bl	808a7ec <HAL_TIMEx_BreakCallback>
 808a68a:	6823      	ldr	r3, [r4, #0]
 808a68c:	e789      	b.n	808a5a2 <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 808a68e:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 808a692:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 808a694:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 808a696:	f7ff ff55 	bl	808a544 <HAL_TIM_TriggerCallback>
 808a69a:	6823      	ldr	r3, [r4, #0]
 808a69c:	e787      	b.n	808a5ae <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 808a69e:	f7ff ff4d 	bl	808a53c <HAL_TIM_IC_CaptureCallback>
 808a6a2:	e7d0      	b.n	808a646 <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 808a6a4:	f7ff ff4a 	bl	808a53c <HAL_TIM_IC_CaptureCallback>
 808a6a8:	e7bc      	b.n	808a624 <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 808a6aa:	f7ff ff47 	bl	808a53c <HAL_TIM_IC_CaptureCallback>
 808a6ae:	e7a6      	b.n	808a5fe <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 808a6b0:	f7ff ff44 	bl	808a53c <HAL_TIM_IC_CaptureCallback>
 808a6b4:	e791      	b.n	808a5da <HAL_TIM_IRQHandler+0x92>
 808a6b6:	bf00      	nop

0808a6b8 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure pointer on TIM Time Base required parameters  
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 808a6b8:	b470      	push	{r4, r5, r6}
 808a6ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 808a6be:	2400      	movs	r4, #0
 808a6c0:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  tmpcr1 = TIMx->CR1;
 808a6c4:	6803      	ldr	r3, [r0, #0]
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 808a6c6:	f2c4 0401 	movt	r4, #16385	; 0x4001
 808a6ca:	f2c4 0201 	movt	r2, #16385	; 0x4001
 808a6ce:	eba0 0404 	sub.w	r4, r0, r4
 808a6d2:	eba0 0202 	sub.w	r2, r0, r2
 808a6d6:	fab4 f484 	clz	r4, r4
 808a6da:	fab2 f282 	clz	r2, r2
 808a6de:	ea4f 1454 	mov.w	r4, r4, lsr #5
 808a6e2:	ea4f 1252 	mov.w	r2, r2, lsr #5
 808a6e6:	d039      	beq.n	808a75c <TIM_Base_SetConfig+0xa4>
 808a6e8:	bbc4      	cbnz	r4, 808a75c <TIM_Base_SetConfig+0xa4>
 808a6ea:	f44f 6580 	mov.w	r5, #1024	; 0x400
 808a6ee:	f2c4 0500 	movt	r5, #16384	; 0x4000
 808a6f2:	42a8      	cmp	r0, r5
 808a6f4:	d032      	beq.n	808a75c <TIM_Base_SetConfig+0xa4>
 808a6f6:	f44f 6500 	mov.w	r5, #2048	; 0x800
 808a6fa:	f2c4 0500 	movt	r5, #16384	; 0x4000
 808a6fe:	42a8      	cmp	r0, r5
 808a700:	d02c      	beq.n	808a75c <TIM_Base_SetConfig+0xa4>
 808a702:	f44f 6540 	mov.w	r5, #3072	; 0xc00
 808a706:	f2c4 0500 	movt	r5, #16384	; 0x4000
 808a70a:	42a8      	cmp	r0, r5
 808a70c:	d043      	beq.n	808a796 <TIM_Base_SetConfig+0xde>
 808a70e:	2a00      	cmp	r2, #0
 808a710:	d141      	bne.n	808a796 <TIM_Base_SetConfig+0xde>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 808a712:	f44f 4580 	mov.w	r5, #16384	; 0x4000
 808a716:	f2c4 0501 	movt	r5, #16385	; 0x4001
 808a71a:	42a8      	cmp	r0, r5
 808a71c:	d022      	beq.n	808a764 <TIM_Base_SetConfig+0xac>
 808a71e:	f44f 4588 	mov.w	r5, #17408	; 0x4400
 808a722:	f2c4 0501 	movt	r5, #16385	; 0x4001
 808a726:	42a8      	cmp	r0, r5
 808a728:	d01c      	beq.n	808a764 <TIM_Base_SetConfig+0xac>
 808a72a:	f44f 4590 	mov.w	r5, #18432	; 0x4800
 808a72e:	f2c4 0501 	movt	r5, #16385	; 0x4001
 808a732:	42a8      	cmp	r0, r5
 808a734:	d016      	beq.n	808a764 <TIM_Base_SetConfig+0xac>
 808a736:	f44f 55c0 	mov.w	r5, #6144	; 0x1800
 808a73a:	f2c4 0500 	movt	r5, #16384	; 0x4000
 808a73e:	42a8      	cmp	r0, r5
 808a740:	d010      	beq.n	808a764 <TIM_Base_SetConfig+0xac>
 808a742:	f44f 55e0 	mov.w	r5, #7168	; 0x1c00
 808a746:	f2c4 0500 	movt	r5, #16384	; 0x4000
 808a74a:	42a8      	cmp	r0, r5
 808a74c:	d00a      	beq.n	808a764 <TIM_Base_SetConfig+0xac>
 808a74e:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 808a752:	f2c4 0500 	movt	r5, #16384	; 0x4000
 808a756:	42a8      	cmp	r0, r5
 808a758:	d108      	bne.n	808a76c <TIM_Base_SetConfig+0xb4>
 808a75a:	e003      	b.n	808a764 <TIM_Base_SetConfig+0xac>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 808a75c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 808a760:	684d      	ldr	r5, [r1, #4]
 808a762:	432b      	orrs	r3, r5
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 808a764:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 808a768:	68cd      	ldr	r5, [r1, #12]
 808a76a:	432b      	orrs	r3, r5
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 808a76c:	694d      	ldr	r5, [r1, #20]
 808a76e:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 808a772:	688e      	ldr	r6, [r1, #8]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 808a774:	432b      	orrs	r3, r5
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 808a776:	680d      	ldr	r5, [r1, #0]
  TIMx->CR1 = tmpcr1;
 808a778:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 808a77a:	62c6      	str	r6, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 808a77c:	6285      	str	r5, [r0, #40]	; 0x28
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 808a77e:	b924      	cbnz	r4, 808a78a <TIM_Base_SetConfig+0xd2>
 808a780:	b91a      	cbnz	r2, 808a78a <TIM_Base_SetConfig+0xd2>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 808a782:	2301      	movs	r3, #1
}
 808a784:	bc70      	pop	{r4, r5, r6}
  TIMx->EGR = TIM_EGR_UG;
 808a786:	6143      	str	r3, [r0, #20]
}
 808a788:	4770      	bx	lr
    TIMx->RCR = Structure->RepetitionCounter;
 808a78a:	690b      	ldr	r3, [r1, #16]
 808a78c:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 808a78e:	2301      	movs	r3, #1
}
 808a790:	bc70      	pop	{r4, r5, r6}
  TIMx->EGR = TIM_EGR_UG;
 808a792:	6143      	str	r3, [r0, #20]
}
 808a794:	4770      	bx	lr
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 808a796:	f44f 6540 	mov.w	r5, #3072	; 0xc00
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 808a79a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 808a79e:	684e      	ldr	r6, [r1, #4]
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 808a7a0:	f2c4 0500 	movt	r5, #16384	; 0x4000
    tmpcr1 |= Structure->CounterMode;
 808a7a4:	4333      	orrs	r3, r6
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 808a7a6:	42a8      	cmp	r0, r5
 808a7a8:	d0dc      	beq.n	808a764 <TIM_Base_SetConfig+0xac>
 808a7aa:	2a00      	cmp	r2, #0
 808a7ac:	d1da      	bne.n	808a764 <TIM_Base_SetConfig+0xac>
 808a7ae:	e7b0      	b.n	808a712 <TIM_Base_SetConfig+0x5a>

0808a7b0 <HAL_TIM_Base_Init>:
  if(htim == NULL)
 808a7b0:	b1b8      	cbz	r0, 808a7e2 <HAL_TIM_Base_Init+0x32>
  if(htim->State == HAL_TIM_STATE_RESET)
 808a7b2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
{ 
 808a7b6:	b510      	push	{r4, lr}
  if(htim->State == HAL_TIM_STATE_RESET)
 808a7b8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 808a7bc:	4604      	mov	r4, r0
 808a7be:	b15b      	cbz	r3, 808a7d8 <HAL_TIM_Base_Init+0x28>
  htim->State= HAL_TIM_STATE_BUSY;
 808a7c0:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 808a7c2:	6820      	ldr	r0, [r4, #0]
 808a7c4:	1d21      	adds	r1, r4, #4
  htim->State= HAL_TIM_STATE_BUSY;
 808a7c6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 808a7ca:	f7ff ff75 	bl	808a6b8 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 808a7ce:	2301      	movs	r3, #1
  return HAL_OK;
 808a7d0:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 808a7d2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 808a7d6:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 808a7d8:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 808a7dc:	f7ff fe78 	bl	808a4d0 <HAL_TIM_Base_MspInit>
 808a7e0:	e7ee      	b.n	808a7c0 <HAL_TIM_Base_Init+0x10>
    return HAL_ERROR;
 808a7e2:	2001      	movs	r0, #1
}
 808a7e4:	4770      	bx	lr
 808a7e6:	bf00      	nop

0808a7e8 <HAL_TIMEx_CommutationCallback>:
 808a7e8:	4770      	bx	lr
 808a7ea:	bf00      	nop

0808a7ec <HAL_TIMEx_BreakCallback>:
 808a7ec:	4770      	bx	lr
 808a7ee:	bf00      	nop

0808a7f0 <HAL_InitTick>:
 *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
 * @param  TickPriority Tick interrupt priority.
 * @retval HAL status
 */
HAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority)
{
 808a7f0:	b530      	push	{r4, r5, lr}
	uint32_t              uwTimclock, uwAPB1Prescaler = 0U;
	uint32_t              uwPrescalerValue = 0U;
	uint32_t              pFLatency;

	/*Configure the TIM6 IRQ priority */
	HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0U);
 808a7f2:	4601      	mov	r1, r0
{
 808a7f4:	b089      	sub	sp, #36	; 0x24
	HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0U);
 808a7f6:	2200      	movs	r2, #0
 808a7f8:	2036      	movs	r0, #54	; 0x36
 808a7fa:	f7fb f809 	bl	8085810 <HAL_NVIC_SetPriority>

	/* Enable the TIM6 global Interrupt */
	HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 808a7fe:	2036      	movs	r0, #54	; 0x36
 808a800:	f7fb f842 	bl	8085888 <HAL_NVIC_EnableIRQ>

	/* Enable TIM6 clock */
	__HAL_RCC_TIM6_CLK_ENABLE();
 808a804:	f44f 5360 	mov.w	r3, #14336	; 0x3800

	/* Get clock configuration */
	HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 808a808:	a901      	add	r1, sp, #4
 808a80a:	a803      	add	r0, sp, #12
	__HAL_RCC_TIM6_CLK_ENABLE();
 808a80c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 808a810:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 808a812:	f042 0210 	orr.w	r2, r2, #16
 808a816:	641a      	str	r2, [r3, #64]	; 0x40
 808a818:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 808a81a:	f003 0310 	and.w	r3, r3, #16
 808a81e:	9302      	str	r3, [sp, #8]
 808a820:	9b02      	ldr	r3, [sp, #8]
	HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 808a822:	f7fd fa77 	bl	8087d14 <HAL_RCC_GetClockConfig>

	/* Get APB1 prescaler */
	uwAPB1Prescaler = clkconfig.APB1CLKDivider;

	/* Compute TIM6 clock */
	if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 808a826:	9b06      	ldr	r3, [sp, #24]
 808a828:	bb0b      	cbnz	r3, 808a86e <HAL_InitTick+0x7e>
	{
		uwTimclock = HAL_RCC_GetPCLK1Freq();
 808a82a:	f7fd fa4b 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
	{
		uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
	}

	/* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808a82e:	f64d 6383 	movw	r3, #56963	; 0xde83

	/* Initialize TIM6 */
	TimHandle.Instance = TIM6;
 808a832:	f64d 14c4 	movw	r4, #55748	; 0xd9c4
 808a836:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  + ClockDivision = 0
  + Counter direction = Up
	 */
	TimHandle.Init.Period = (1000000U / 1000U) - 1U;
	TimHandle.Init.Prescaler = uwPrescalerValue;
	TimHandle.Init.ClockDivision = 0;
 808a83a:	2200      	movs	r2, #0
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808a83c:	f2c4 331b 	movt	r3, #17179	; 0x431b
	TimHandle.Instance = TIM6;
 808a840:	f2c2 0402 	movt	r4, #8194	; 0x2002
	TimHandle.Init.Period = (1000000U / 1000U) - 1U;
 808a844:	f240 35e7 	movw	r5, #999	; 0x3e7
	TimHandle.Instance = TIM6;
 808a848:	f2c4 0100 	movt	r1, #16384	; 0x4000
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808a84c:	fba3 0300 	umull	r0, r3, r3, r0
	TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
	TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if(HAL_TIM_Base_Init(&TimHandle) == HAL_OK)
 808a850:	4620      	mov	r0, r4
	TimHandle.Instance = TIM6;
 808a852:	6021      	str	r1, [r4, #0]
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808a854:	0c9b      	lsrs	r3, r3, #18
	TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
 808a856:	60a2      	str	r2, [r4, #8]
	TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 808a858:	61a2      	str	r2, [r4, #24]
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808a85a:	3b01      	subs	r3, #1
	TimHandle.Init.ClockDivision = 0;
 808a85c:	e9c4 5203 	strd	r5, r2, [r4, #12]
	TimHandle.Init.Prescaler = uwPrescalerValue;
 808a860:	6063      	str	r3, [r4, #4]
	if(HAL_TIM_Base_Init(&TimHandle) == HAL_OK)
 808a862:	f7ff ffa5 	bl	808a7b0 <HAL_TIM_Base_Init>
 808a866:	b130      	cbz	r0, 808a876 <HAL_InitTick+0x86>
		/* Start the TIM time Base generation in interrupt mode */
		return HAL_TIM_Base_Start_IT(&TimHandle);
	}

	/* Return function status */
	return HAL_ERROR;
 808a868:	2001      	movs	r0, #1
}
 808a86a:	b009      	add	sp, #36	; 0x24
 808a86c:	bd30      	pop	{r4, r5, pc}
		uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 808a86e:	f7fd fa29 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
 808a872:	0040      	lsls	r0, r0, #1
 808a874:	e7db      	b.n	808a82e <HAL_InitTick+0x3e>
		return HAL_TIM_Base_Start_IT(&TimHandle);
 808a876:	4620      	mov	r0, r4
 808a878:	f7ff fe3c 	bl	808a4f4 <HAL_TIM_Base_Start_IT>
}
 808a87c:	b009      	add	sp, #36	; 0x24
 808a87e:	bd30      	pop	{r4, r5, pc}

0808a880 <HAL_TIM_PeriodElapsedCallback>:
 * @param  htim  TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	if (htim == &TimHandle) { // must be incremented only in case of TIM 6
 808a880:	f64d 13c4 	movw	r3, #55748	; 0xd9c4
 808a884:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808a888:	4283      	cmp	r3, r0
 808a88a:	d000      	beq.n	808a88e <HAL_TIM_PeriodElapsedCallback+0xe>
		HAL_IncTick();
	}
}
 808a88c:	4770      	bx	lr
		HAL_IncTick();
 808a88e:	f7fa bf81 	b.w	8085794 <HAL_IncTick>
 808a892:	bf00      	nop

0808a894 <TIM6_DAC_IRQHandler>:
 * @brief  This function handles TIM interrupt request.
 * @retval None
 */
void TIM6_DAC_IRQHandler(void)
{
	HAL_TIM_IRQHandler(&TimHandle);
 808a894:	f64d 10c4 	movw	r0, #55748	; 0xd9c4
 808a898:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808a89c:	f7ff be54 	b.w	808a548 <HAL_TIM_IRQHandler>

0808a8a0 <HAL_UART_MspInit>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 808a8a0:	4770      	bx	lr
 808a8a2:	bf00      	nop

0808a8a4 <HAL_UART_MspDeInit>:
 808a8a4:	4770      	bx	lr
 808a8a6:	bf00      	nop

0808a8a8 <HAL_UART_DeInit>:
  if(huart == NULL)
 808a8a8:	b1c0      	cbz	r0, 808a8dc <HAL_UART_DeInit+0x34>
  huart->gState = HAL_UART_STATE_BUSY;
 808a8aa:	2224      	movs	r2, #36	; 0x24
{
 808a8ac:	b538      	push	{r3, r4, r5, lr}
  __HAL_UART_DISABLE(huart);
 808a8ae:	6803      	ldr	r3, [r0, #0]
  huart->Instance->CR1 = 0x0U;
 808a8b0:	2500      	movs	r5, #0
  huart->gState = HAL_UART_STATE_BUSY;
 808a8b2:	f880 2069 	strb.w	r2, [r0, #105]	; 0x69
 808a8b6:	4604      	mov	r4, r0
  __HAL_UART_DISABLE(huart);
 808a8b8:	681a      	ldr	r2, [r3, #0]
 808a8ba:	f022 0201 	bic.w	r2, r2, #1
 808a8be:	601a      	str	r2, [r3, #0]
  huart->Instance->CR1 = 0x0U;
 808a8c0:	601d      	str	r5, [r3, #0]
  huart->Instance->CR2 = 0x0U;
 808a8c2:	605d      	str	r5, [r3, #4]
  huart->Instance->CR3 = 0x0U;
 808a8c4:	609d      	str	r5, [r3, #8]
  HAL_UART_MspDeInit(huart);
 808a8c6:	f7ff ffed 	bl	808a8a4 <HAL_UART_MspDeInit>
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 808a8ca:	66e5      	str	r5, [r4, #108]	; 0x6c
  __HAL_UNLOCK(huart);
 808a8cc:	f884 5068 	strb.w	r5, [r4, #104]	; 0x68
  return HAL_OK;
 808a8d0:	4628      	mov	r0, r5
  huart->gState    = HAL_UART_STATE_RESET;
 808a8d2:	f884 5069 	strb.w	r5, [r4, #105]	; 0x69
  huart->RxState   = HAL_UART_STATE_RESET;
 808a8d6:	f884 506a 	strb.w	r5, [r4, #106]	; 0x6a
}
 808a8da:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 808a8dc:	2001      	movs	r0, #1
}
 808a8de:	4770      	bx	lr

0808a8e0 <HAL_UART_Receive_IT>:
  * @param pData pointer to data buffer.
  * @param Size amount of data to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 808a8e0:	4603      	mov	r3, r0
  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY)
 808a8e2:	f890 006a 	ldrb.w	r0, [r0, #106]	; 0x6a
 808a8e6:	2820      	cmp	r0, #32
 808a8e8:	d12d      	bne.n	808a946 <HAL_UART_Receive_IT+0x66>
  {
    if((pData == NULL ) || (Size == 0U))
 808a8ea:	b371      	cbz	r1, 808a94a <HAL_UART_Receive_IT+0x6a>
 808a8ec:	b36a      	cbz	r2, 808a94a <HAL_UART_Receive_IT+0x6a>
    {
      return HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 808a8ee:	f893 0068 	ldrb.w	r0, [r3, #104]	; 0x68
 808a8f2:	2801      	cmp	r0, #1
 808a8f4:	d027      	beq.n	808a946 <HAL_UART_Receive_IT+0x66>
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
    huart->RxXferCount = Size;

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 808a8f6:	6898      	ldr	r0, [r3, #8]
{
 808a8f8:	b410      	push	{r4}
    UART_MASK_COMPUTATION(huart);
 808a8fa:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
    __HAL_LOCK(huart);
 808a8fe:	f04f 0401 	mov.w	r4, #1
    huart->pRxBuffPtr = pData;
 808a902:	6559      	str	r1, [r3, #84]	; 0x54
    huart->RxXferSize = Size;
 808a904:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
    huart->RxXferCount = Size;
 808a908:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    __HAL_LOCK(huart);
 808a90c:	f883 4068 	strb.w	r4, [r3, #104]	; 0x68
    UART_MASK_COMPUTATION(huart);
 808a910:	d01d      	beq.n	808a94e <HAL_UART_Receive_IT+0x6e>
 808a912:	bb40      	cbnz	r0, 808a966 <HAL_UART_Receive_IT+0x86>
 808a914:	691a      	ldr	r2, [r3, #16]
 808a916:	bb12      	cbnz	r2, 808a95e <HAL_UART_Receive_IT+0x7e>
 808a918:	22ff      	movs	r2, #255	; 0xff
 808a91a:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 808a91e:	2400      	movs	r4, #0

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 808a920:	681a      	ldr	r2, [r3, #0]
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 808a922:	2122      	movs	r1, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 808a924:	66dc      	str	r4, [r3, #108]	; 0x6c

    /* Enable the UART Parity Error and Data Register not empty Interrupts */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);

    return HAL_OK;
 808a926:	4620      	mov	r0, r4
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 808a928:	f883 106a 	strb.w	r1, [r3, #106]	; 0x6a
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 808a92c:	6891      	ldr	r1, [r2, #8]
    __HAL_UNLOCK(huart);
 808a92e:	f883 4068 	strb.w	r4, [r3, #104]	; 0x68
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 808a932:	f041 0101 	orr.w	r1, r1, #1
  }
  else
  {
    return HAL_BUSY;
  }
}
 808a936:	f85d 4b04 	ldr.w	r4, [sp], #4
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 808a93a:	6091      	str	r1, [r2, #8]
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 808a93c:	6813      	ldr	r3, [r2, #0]
 808a93e:	f443 7390 	orr.w	r3, r3, #288	; 0x120
 808a942:	6013      	str	r3, [r2, #0]
}
 808a944:	4770      	bx	lr
    return HAL_BUSY;
 808a946:	2002      	movs	r0, #2
}
 808a948:	4770      	bx	lr
      return HAL_ERROR;
 808a94a:	2001      	movs	r0, #1
 808a94c:	4770      	bx	lr
    UART_MASK_COMPUTATION(huart);
 808a94e:	691a      	ldr	r2, [r3, #16]
 808a950:	2a00      	cmp	r2, #0
 808a952:	d1e1      	bne.n	808a918 <HAL_UART_Receive_IT+0x38>
 808a954:	f240 12ff 	movw	r2, #511	; 0x1ff
 808a958:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 808a95c:	e7df      	b.n	808a91e <HAL_UART_Receive_IT+0x3e>
 808a95e:	227f      	movs	r2, #127	; 0x7f
 808a960:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 808a964:	e7db      	b.n	808a91e <HAL_UART_Receive_IT+0x3e>
 808a966:	f1b0 5f80 	cmp.w	r0, #268435456	; 0x10000000
 808a96a:	d1d8      	bne.n	808a91e <HAL_UART_Receive_IT+0x3e>
 808a96c:	691a      	ldr	r2, [r3, #16]
 808a96e:	2a00      	cmp	r2, #0
 808a970:	d0f5      	beq.n	808a95e <HAL_UART_Receive_IT+0x7e>
 808a972:	223f      	movs	r2, #63	; 0x3f
 808a974:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 808a978:	e7d1      	b.n	808a91e <HAL_UART_Receive_IT+0x3e>
 808a97a:	bf00      	nop

0808a97c <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 808a97c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 808a980:	9d08      	ldr	r5, [sp, #32]
 808a982:	4680      	mov	r8, r0
 808a984:	460f      	mov	r7, r1
 808a986:	4616      	mov	r6, r2
 808a988:	4699      	mov	r9, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 808a98a:	f8d8 4000 	ldr.w	r4, [r8]
 808a98e:	e001      	b.n	808a994 <UART_WaitOnFlagUntilTimeout+0x18>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 808a990:	1c6b      	adds	r3, r5, #1
 808a992:	d10a      	bne.n	808a9aa <UART_WaitOnFlagUntilTimeout+0x2e>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 808a994:	69e0      	ldr	r0, [r4, #28]
 808a996:	ea37 0300 	bics.w	r3, r7, r0
 808a99a:	bf0c      	ite	eq
 808a99c:	2001      	moveq	r0, #1
 808a99e:	2000      	movne	r0, #0
 808a9a0:	42b0      	cmp	r0, r6
 808a9a2:	d0f5      	beq.n	808a990 <UART_WaitOnFlagUntilTimeout+0x14>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 808a9a4:	2000      	movs	r0, #0
}
 808a9a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
 808a9aa:	b13d      	cbz	r5, 808a9bc <UART_WaitOnFlagUntilTimeout+0x40>
 808a9ac:	f7fa ff00 	bl	80857b0 <HAL_GetTick>
 808a9b0:	eba0 0009 	sub.w	r0, r0, r9
 808a9b4:	42a8      	cmp	r0, r5
 808a9b6:	d3e8      	bcc.n	808a98a <UART_WaitOnFlagUntilTimeout+0xe>
 808a9b8:	f8d8 4000 	ldr.w	r4, [r8]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 808a9bc:	6823      	ldr	r3, [r4, #0]
        huart->gState = HAL_UART_STATE_READY;
 808a9be:	2220      	movs	r2, #32
        __HAL_UNLOCK(huart);
 808a9c0:	2100      	movs	r1, #0
 808a9c2:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 808a9c4:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 808a9c8:	6023      	str	r3, [r4, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 808a9ca:	68a3      	ldr	r3, [r4, #8]
 808a9cc:	f023 0301 	bic.w	r3, r3, #1
 808a9d0:	60a3      	str	r3, [r4, #8]
        huart->gState = HAL_UART_STATE_READY;
 808a9d2:	f888 2069 	strb.w	r2, [r8, #105]	; 0x69
        __HAL_UNLOCK(huart);
 808a9d6:	f888 1068 	strb.w	r1, [r8, #104]	; 0x68
        huart->RxState = HAL_UART_STATE_READY;
 808a9da:	f888 206a 	strb.w	r2, [r8, #106]	; 0x6a
 808a9de:	e7e2      	b.n	808a9a6 <UART_WaitOnFlagUntilTimeout+0x2a>

0808a9e0 <HAL_UART_Transmit>:
{
 808a9e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 808a9e4:	461f      	mov	r7, r3
  if(huart->gState == HAL_UART_STATE_READY)
 808a9e6:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
{
 808a9ea:	b084      	sub	sp, #16
  if(huart->gState == HAL_UART_STATE_READY)
 808a9ec:	2b20      	cmp	r3, #32
 808a9ee:	d136      	bne.n	808aa5e <HAL_UART_Transmit+0x7e>
 808a9f0:	460e      	mov	r6, r1
    if((pData == NULL ) || (Size == 0U))
 808a9f2:	2900      	cmp	r1, #0
 808a9f4:	d037      	beq.n	808aa66 <HAL_UART_Transmit+0x86>
 808a9f6:	fab2 f382 	clz	r3, r2
 808a9fa:	9203      	str	r2, [sp, #12]
 808a9fc:	095b      	lsrs	r3, r3, #5
 808a9fe:	bb93      	cbnz	r3, 808aa66 <HAL_UART_Transmit+0x86>
    __HAL_LOCK(huart);
 808aa00:	f890 1068 	ldrb.w	r1, [r0, #104]	; 0x68
 808aa04:	4604      	mov	r4, r0
 808aa06:	2901      	cmp	r1, #1
 808aa08:	d029      	beq.n	808aa5e <HAL_UART_Transmit+0x7e>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 808aa0a:	66c3      	str	r3, [r0, #108]	; 0x6c
    __HAL_LOCK(huart);
 808aa0c:	2101      	movs	r1, #1
    huart->gState = HAL_UART_STATE_BUSY_TX;
 808aa0e:	2321      	movs	r3, #33	; 0x21
    __HAL_LOCK(huart);
 808aa10:	f880 1068 	strb.w	r1, [r0, #104]	; 0x68
    huart->gState = HAL_UART_STATE_BUSY_TX;
 808aa14:	f880 3069 	strb.w	r3, [r0, #105]	; 0x69
    tickstart = HAL_GetTick();
 808aa18:	f7fa feca 	bl	80857b0 <HAL_GetTick>
    huart->TxXferSize = Size;
 808aa1c:	9a03      	ldr	r2, [sp, #12]
    tickstart = HAL_GetTick();
 808aa1e:	4680      	mov	r8, r0
    huart->TxXferSize = Size;
 808aa20:	f8a4 2050 	strh.w	r2, [r4, #80]	; 0x50
    huart->TxXferCount = Size;
 808aa24:	f8a4 2052 	strh.w	r2, [r4, #82]	; 0x52
    while(huart->TxXferCount > 0U)
 808aa28:	f8b4 5052 	ldrh.w	r5, [r4, #82]	; 0x52
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 808aa2c:	4643      	mov	r3, r8
 808aa2e:	2200      	movs	r2, #0
 808aa30:	2180      	movs	r1, #128	; 0x80
    while(huart->TxXferCount > 0U)
 808aa32:	b2ad      	uxth	r5, r5
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 808aa34:	4620      	mov	r0, r4
    while(huart->TxXferCount > 0U)
 808aa36:	b33d      	cbz	r5, 808aa88 <HAL_UART_Transmit+0xa8>
      huart->TxXferCount--;
 808aa38:	f8b4 5052 	ldrh.w	r5, [r4, #82]	; 0x52
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 808aa3c:	9700      	str	r7, [sp, #0]
      huart->TxXferCount--;
 808aa3e:	3d01      	subs	r5, #1
 808aa40:	b2ad      	uxth	r5, r5
 808aa42:	f8a4 5052 	strh.w	r5, [r4, #82]	; 0x52
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 808aa46:	f7ff ff99 	bl	808a97c <UART_WaitOnFlagUntilTimeout>
 808aa4a:	b9c8      	cbnz	r0, 808aa80 <HAL_UART_Transmit+0xa0>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 808aa4c:	68a2      	ldr	r2, [r4, #8]
 808aa4e:	6823      	ldr	r3, [r4, #0]
 808aa50:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 808aa54:	d00b      	beq.n	808aa6e <HAL_UART_Transmit+0x8e>
        huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
 808aa56:	7832      	ldrb	r2, [r6, #0]
 808aa58:	3601      	adds	r6, #1
 808aa5a:	629a      	str	r2, [r3, #40]	; 0x28
 808aa5c:	e7e4      	b.n	808aa28 <HAL_UART_Transmit+0x48>
    return HAL_BUSY;
 808aa5e:	2002      	movs	r0, #2
}
 808aa60:	b004      	add	sp, #16
 808aa62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 808aa66:	2001      	movs	r0, #1
}
 808aa68:	b004      	add	sp, #16
 808aa6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 808aa6e:	6922      	ldr	r2, [r4, #16]
 808aa70:	2a00      	cmp	r2, #0
 808aa72:	d1f0      	bne.n	808aa56 <HAL_UART_Transmit+0x76>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 808aa74:	f836 2b02 	ldrh.w	r2, [r6], #2
 808aa78:	f3c2 0208 	ubfx	r2, r2, #0, #9
 808aa7c:	629a      	str	r2, [r3, #40]	; 0x28
        pData += 2;
 808aa7e:	e7d3      	b.n	808aa28 <HAL_UART_Transmit+0x48>
        return HAL_TIMEOUT;
 808aa80:	2003      	movs	r0, #3
}
 808aa82:	b004      	add	sp, #16
 808aa84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 808aa88:	9700      	str	r7, [sp, #0]
 808aa8a:	462a      	mov	r2, r5
 808aa8c:	2140      	movs	r1, #64	; 0x40
 808aa8e:	f7ff ff75 	bl	808a97c <UART_WaitOnFlagUntilTimeout>
 808aa92:	2800      	cmp	r0, #0
 808aa94:	d1f4      	bne.n	808aa80 <HAL_UART_Transmit+0xa0>
    huart->gState = HAL_UART_STATE_READY;
 808aa96:	2320      	movs	r3, #32
    __HAL_UNLOCK(huart);
 808aa98:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68
    huart->gState = HAL_UART_STATE_READY;
 808aa9c:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
    return HAL_OK;
 808aaa0:	e7de      	b.n	808aa60 <HAL_UART_Transmit+0x80>
 808aaa2:	bf00      	nop

0808aaa4 <HAL_UART_TxCpltCallback>:
 808aaa4:	4770      	bx	lr
 808aaa6:	bf00      	nop

0808aaa8 <UART_Receive_IT>:
{
  uint16_t* tmp;
  uint16_t uhMask = huart->Mask;

  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
 808aaa8:	f890 206a 	ldrb.w	r2, [r0, #106]	; 0x6a
 808aaac:	2a22      	cmp	r2, #34	; 0x22
{
 808aaae:	b538      	push	{r3, r4, r5, lr}
 808aab0:	6803      	ldr	r3, [r0, #0]
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
 808aab2:	d114      	bne.n	808aade <UART_Receive_IT+0x36>
  {

    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 808aab4:	6884      	ldr	r4, [r0, #8]
  uint16_t uhMask = huart->Mask;
 808aab6:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 808aaba:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 808aabe:	6d42      	ldr	r2, [r0, #84]	; 0x54
 808aac0:	d013      	beq.n	808aaea <UART_Receive_IT+0x42>
      *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
      huart->pRxBuffPtr +=2;
    }
    else
    {
      *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 808aac2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 808aac4:	1c54      	adds	r4, r2, #1
 808aac6:	400b      	ands	r3, r1
 808aac8:	6544      	str	r4, [r0, #84]	; 0x54
 808aaca:	7013      	strb	r3, [r2, #0]
    }

    if(--huart->RxXferCount == 0)
 808aacc:	f8b0 405a 	ldrh.w	r4, [r0, #90]	; 0x5a
 808aad0:	3c01      	subs	r4, #1
 808aad2:	b2a4      	uxth	r4, r4
 808aad4:	f8a0 405a 	strh.w	r4, [r0, #90]	; 0x5a
 808aad8:	b184      	cbz	r4, 808aafc <UART_Receive_IT+0x54>
      HAL_UART_RxCpltCallback(huart);

      return HAL_OK;
    }

    return HAL_OK;
 808aada:	2000      	movs	r0, #0
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);

    return HAL_BUSY;
  }
}
 808aadc:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 808aade:	699a      	ldr	r2, [r3, #24]
    return HAL_BUSY;
 808aae0:	2002      	movs	r0, #2
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 808aae2:	f042 0208 	orr.w	r2, r2, #8
 808aae6:	619a      	str	r2, [r3, #24]
}
 808aae8:	bd38      	pop	{r3, r4, r5, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 808aaea:	6904      	ldr	r4, [r0, #16]
 808aaec:	2c00      	cmp	r4, #0
 808aaee:	d1e8      	bne.n	808aac2 <UART_Receive_IT+0x1a>
      *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 808aaf0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 808aaf2:	400b      	ands	r3, r1
 808aaf4:	f822 3b02 	strh.w	r3, [r2], #2
      huart->pRxBuffPtr +=2;
 808aaf8:	6542      	str	r2, [r0, #84]	; 0x54
 808aafa:	e7e7      	b.n	808aacc <UART_Receive_IT+0x24>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 808aafc:	6802      	ldr	r2, [r0, #0]
      huart->RxState = HAL_UART_STATE_READY;
 808aafe:	2520      	movs	r5, #32
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 808ab00:	6811      	ldr	r1, [r2, #0]
 808ab02:	f421 7190 	bic.w	r1, r1, #288	; 0x120
 808ab06:	6011      	str	r1, [r2, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 808ab08:	6891      	ldr	r1, [r2, #8]
 808ab0a:	f021 0101 	bic.w	r1, r1, #1
 808ab0e:	6091      	str	r1, [r2, #8]
      huart->RxState = HAL_UART_STATE_READY;
 808ab10:	f880 506a 	strb.w	r5, [r0, #106]	; 0x6a
      HAL_UART_RxCpltCallback(huart);
 808ab14:	f7f7 fbf0 	bl	80822f8 <HAL_UART_RxCpltCallback>
 808ab18:	4620      	mov	r0, r4
}
 808ab1a:	bd38      	pop	{r3, r4, r5, pc}

0808ab1c <HAL_UART_ErrorCallback>:
 808ab1c:	4770      	bx	lr
 808ab1e:	bf00      	nop

0808ab20 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 808ab20:	6803      	ldr	r3, [r0, #0]
 808ab22:	69da      	ldr	r2, [r3, #28]
{
 808ab24:	b570      	push	{r4, r5, r6, lr}
  if (errorflags == RESET)
 808ab26:	0716      	lsls	r6, r2, #28
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 808ab28:	681d      	ldr	r5, [r3, #0]
{
 808ab2a:	4604      	mov	r4, r0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 808ab2c:	6899      	ldr	r1, [r3, #8]
  if (errorflags == RESET)
 808ab2e:	d128      	bne.n	808ab82 <HAL_UART_IRQHandler+0x62>
    if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 808ab30:	0691      	lsls	r1, r2, #26
 808ab32:	d502      	bpl.n	808ab3a <HAL_UART_IRQHandler+0x1a>
 808ab34:	06ae      	lsls	r6, r5, #26
 808ab36:	f100 808e 	bmi.w	808ac56 <HAL_UART_IRQHandler+0x136>
  if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 808ab3a:	0616      	lsls	r6, r2, #24
 808ab3c:	d404      	bmi.n	808ab48 <HAL_UART_IRQHandler+0x28>
  if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 808ab3e:	0651      	lsls	r1, r2, #25
 808ab40:	d501      	bpl.n	808ab46 <HAL_UART_IRQHandler+0x26>
 808ab42:	066a      	lsls	r2, r5, #25
 808ab44:	d47c      	bmi.n	808ac40 <HAL_UART_IRQHandler+0x120>
}
 808ab46:	bd70      	pop	{r4, r5, r6, pc}
  if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 808ab48:	0628      	lsls	r0, r5, #24
 808ab4a:	d5f8      	bpl.n	808ab3e <HAL_UART_IRQHandler+0x1e>
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 808ab4c:	f894 2069 	ldrb.w	r2, [r4, #105]	; 0x69
 808ab50:	2a21      	cmp	r2, #33	; 0x21
 808ab52:	d1f8      	bne.n	808ab46 <HAL_UART_IRQHandler+0x26>
    if(huart->TxXferCount == 0U)
 808ab54:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
 808ab58:	b292      	uxth	r2, r2
 808ab5a:	2a00      	cmp	r2, #0
 808ab5c:	f000 8094 	beq.w	808ac88 <HAL_UART_IRQHandler+0x168>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 808ab60:	68a1      	ldr	r1, [r4, #8]
 808ab62:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 808ab64:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 808ab68:	f000 8097 	beq.w	808ac9a <HAL_UART_IRQHandler+0x17a>
        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
 808ab6c:	1c51      	adds	r1, r2, #1
 808ab6e:	64e1      	str	r1, [r4, #76]	; 0x4c
 808ab70:	7812      	ldrb	r2, [r2, #0]
 808ab72:	629a      	str	r2, [r3, #40]	; 0x28
      huart->TxXferCount--;
 808ab74:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 808ab78:	3b01      	subs	r3, #1
 808ab7a:	b29b      	uxth	r3, r3
 808ab7c:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
}
 808ab80:	bd70      	pop	{r4, r5, r6, pc}
     && (   ((cr3its & USART_CR3_EIE) != RESET)
 808ab82:	f011 0101 	ands.w	r1, r1, #1
 808ab86:	d102      	bne.n	808ab8e <HAL_UART_IRQHandler+0x6e>
         || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
 808ab88:	f415 7f90 	tst.w	r5, #288	; 0x120
 808ab8c:	d0d5      	beq.n	808ab3a <HAL_UART_IRQHandler+0x1a>
    if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 808ab8e:	07d0      	lsls	r0, r2, #31
 808ab90:	d507      	bpl.n	808aba2 <HAL_UART_IRQHandler+0x82>
 808ab92:	05ee      	lsls	r6, r5, #23
 808ab94:	d505      	bpl.n	808aba2 <HAL_UART_IRQHandler+0x82>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
 808ab96:	2001      	movs	r0, #1
 808ab98:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 808ab9a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 808ab9c:	f040 0001 	orr.w	r0, r0, #1
 808aba0:	66e0      	str	r0, [r4, #108]	; 0x6c
    if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 808aba2:	0790      	lsls	r0, r2, #30
 808aba4:	d43b      	bmi.n	808ac1e <HAL_UART_IRQHandler+0xfe>
    if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 808aba6:	0750      	lsls	r0, r2, #29
 808aba8:	d501      	bpl.n	808abae <HAL_UART_IRQHandler+0x8e>
 808abaa:	2900      	cmp	r1, #0
 808abac:	d141      	bne.n	808ac32 <HAL_UART_IRQHandler+0x112>
    if(((isrflags & USART_ISR_ORE) != RESET) &&
 808abae:	0716      	lsls	r6, r2, #28
 808abb0:	d503      	bpl.n	808abba <HAL_UART_IRQHandler+0x9a>
 808abb2:	06a8      	lsls	r0, r5, #26
 808abb4:	d453      	bmi.n	808ac5e <HAL_UART_IRQHandler+0x13e>
       (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 808abb6:	2900      	cmp	r1, #0
 808abb8:	d151      	bne.n	808ac5e <HAL_UART_IRQHandler+0x13e>
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 808abba:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 808abbc:	2900      	cmp	r1, #0
 808abbe:	d0c2      	beq.n	808ab46 <HAL_UART_IRQHandler+0x26>
      if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 808abc0:	0696      	lsls	r6, r2, #26
 808abc2:	d501      	bpl.n	808abc8 <HAL_UART_IRQHandler+0xa8>
 808abc4:	06a8      	lsls	r0, r5, #26
 808abc6:	d455      	bmi.n	808ac74 <HAL_UART_IRQHandler+0x154>
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
 808abc8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 808abca:	0711      	lsls	r1, r2, #28
 808abcc:	d403      	bmi.n	808abd6 <HAL_UART_IRQHandler+0xb6>
          (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 808abce:	689d      	ldr	r5, [r3, #8]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
 808abd0:	f015 0540 	ands.w	r5, r5, #64	; 0x40
 808abd4:	d053      	beq.n	808ac7e <HAL_UART_IRQHandler+0x15e>
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 808abd6:	681a      	ldr	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 808abd8:	2120      	movs	r1, #32
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 808abda:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 808abde:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 808abe0:	689a      	ldr	r2, [r3, #8]
 808abe2:	f022 0201 	bic.w	r2, r2, #1
 808abe6:	609a      	str	r2, [r3, #8]
  huart->RxState = HAL_UART_STATE_READY;
 808abe8:	f884 106a 	strb.w	r1, [r4, #106]	; 0x6a
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 808abec:	689a      	ldr	r2, [r3, #8]
 808abee:	0652      	lsls	r2, r2, #25
 808abf0:	d53c      	bpl.n	808ac6c <HAL_UART_IRQHandler+0x14c>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 808abf2:	689a      	ldr	r2, [r3, #8]
          if(huart->hdmarx != NULL)
 808abf4:	6e61      	ldr	r1, [r4, #100]	; 0x64
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 808abf6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 808abfa:	609a      	str	r2, [r3, #8]
          if(huart->hdmarx != NULL)
 808abfc:	2900      	cmp	r1, #0
 808abfe:	d035      	beq.n	808ac6c <HAL_UART_IRQHandler+0x14c>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 808ac00:	f64a 43b1 	movw	r3, #44209	; 0xacb1
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 808ac04:	4608      	mov	r0, r1
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 808ac06:	f6c0 0308 	movt	r3, #2056	; 0x808
 808ac0a:	650b      	str	r3, [r1, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 808ac0c:	f7fa ffc6 	bl	8085b9c <HAL_DMA_Abort_IT>
 808ac10:	2800      	cmp	r0, #0
 808ac12:	d098      	beq.n	808ab46 <HAL_UART_IRQHandler+0x26>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 808ac14:	6e60      	ldr	r0, [r4, #100]	; 0x64
}
 808ac16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 808ac1a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 808ac1c:	4718      	bx	r3
    if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 808ac1e:	2900      	cmp	r1, #0
 808ac20:	d0c5      	beq.n	808abae <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
 808ac22:	2002      	movs	r0, #2
    if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 808ac24:	0756      	lsls	r6, r2, #29
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
 808ac26:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 808ac28:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 808ac2a:	f040 0004 	orr.w	r0, r0, #4
 808ac2e:	66e0      	str	r0, [r4, #108]	; 0x6c
    if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 808ac30:	d5bd      	bpl.n	808abae <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
 808ac32:	2004      	movs	r0, #4
 808ac34:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 808ac36:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 808ac38:	f040 0002 	orr.w	r0, r0, #2
 808ac3c:	66e0      	str	r0, [r4, #108]	; 0x6c
 808ac3e:	e7b6      	b.n	808abae <HAL_UART_IRQHandler+0x8e>
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 808ac40:	681a      	ldr	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 808ac42:	2120      	movs	r1, #32
  HAL_UART_TxCpltCallback(huart);
 808ac44:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 808ac46:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 808ac4a:	601a      	str	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 808ac4c:	f884 1069 	strb.w	r1, [r4, #105]	; 0x69
  HAL_UART_TxCpltCallback(huart);
 808ac50:	f7ff ff28 	bl	808aaa4 <HAL_UART_TxCpltCallback>
}
 808ac54:	bd70      	pop	{r4, r5, r6, pc}
 808ac56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      UART_Receive_IT(huart);
 808ac5a:	f7ff bf25 	b.w	808aaa8 <UART_Receive_IT>
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
 808ac5e:	2108      	movs	r1, #8
 808ac60:	6219      	str	r1, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 808ac62:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 808ac64:	f041 0108 	orr.w	r1, r1, #8
 808ac68:	66e1      	str	r1, [r4, #108]	; 0x6c
 808ac6a:	e7a6      	b.n	808abba <HAL_UART_IRQHandler+0x9a>
            HAL_UART_ErrorCallback(huart);
 808ac6c:	4620      	mov	r0, r4
 808ac6e:	f7ff ff55 	bl	808ab1c <HAL_UART_ErrorCallback>
}
 808ac72:	bd70      	pop	{r4, r5, r6, pc}
        UART_Receive_IT(huart);
 808ac74:	4620      	mov	r0, r4
 808ac76:	f7ff ff17 	bl	808aaa8 <UART_Receive_IT>
 808ac7a:	6823      	ldr	r3, [r4, #0]
 808ac7c:	e7a4      	b.n	808abc8 <HAL_UART_IRQHandler+0xa8>
        HAL_UART_ErrorCallback(huart);
 808ac7e:	4620      	mov	r0, r4
 808ac80:	f7ff ff4c 	bl	808ab1c <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 808ac84:	66e5      	str	r5, [r4, #108]	; 0x6c
}
 808ac86:	bd70      	pop	{r4, r5, r6, pc}
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 808ac88:	681a      	ldr	r2, [r3, #0]
 808ac8a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 808ac8e:	601a      	str	r2, [r3, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 808ac90:	681a      	ldr	r2, [r3, #0]
 808ac92:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 808ac96:	601a      	str	r2, [r3, #0]
}
 808ac98:	bd70      	pop	{r4, r5, r6, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 808ac9a:	6921      	ldr	r1, [r4, #16]
 808ac9c:	2900      	cmp	r1, #0
 808ac9e:	f47f af65 	bne.w	808ab6c <HAL_UART_IRQHandler+0x4c>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 808aca2:	f832 1b02 	ldrh.w	r1, [r2], #2
 808aca6:	f3c1 0108 	ubfx	r1, r1, #0, #9
 808acaa:	6299      	str	r1, [r3, #40]	; 0x28
        huart->pTxBuffPtr += 2U;
 808acac:	64e2      	str	r2, [r4, #76]	; 0x4c
 808acae:	e761      	b.n	808ab74 <HAL_UART_IRQHandler+0x54>

0808acb0 <UART_DMAAbortOnError>:
{
 808acb0:	b508      	push	{r3, lr}
  huart->RxXferCount = 0U;
 808acb2:	2200      	movs	r2, #0
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
 808acb4:	6b83      	ldr	r3, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
 808acb6:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
  HAL_UART_ErrorCallback(huart);
 808acba:	4618      	mov	r0, r3
  huart->TxXferCount = 0U;
 808acbc:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
  HAL_UART_ErrorCallback(huart);
 808acc0:	f7ff ff2c 	bl	808ab1c <HAL_UART_ErrorCallback>
}
 808acc4:	bd08      	pop	{r3, pc}
 808acc6:	bf00      	nop

0808acc8 <UART_SetConfig>:
  * @brief Configure the UART peripheral
  * @param huart uart handle
  * @retval None
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 808acc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   *  the UART Word Length, Parity, Mode and oversampling:
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 808acca:	6902      	ldr	r2, [r0, #16]
{
 808accc:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 808acce:	6883      	ldr	r3, [r0, #8]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 808acd0:	f646 11f3 	movw	r1, #27123	; 0x69f3
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 808acd4:	6940      	ldr	r0, [r0, #20]
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 808acd6:	f44f 5580 	mov.w	r5, #4096	; 0x1000
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 808acda:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 808acdc:	6823      	ldr	r3, [r4, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 808acde:	69e6      	ldr	r6, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 808ace0:	f6ce 71ff 	movt	r1, #61439	; 0xefff
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 808ace4:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 808ace6:	6818      	ldr	r0, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 808ace8:	68e7      	ldr	r7, [r4, #12]
  UART_GETCLOCKSOURCE(huart, clocksource);
 808acea:	f2c4 0501 	movt	r5, #16385	; 0x4001
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 808acee:	4001      	ands	r1, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 808acf0:	4332      	orrs	r2, r6
  UART_GETCLOCKSOURCE(huart, clocksource);
 808acf2:	42ab      	cmp	r3, r5
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 808acf4:	ea42 0201 	orr.w	r2, r2, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 808acf8:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 808acfa:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 808acfc:	6858      	ldr	r0, [r3, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 808acfe:	6a22      	ldr	r2, [r4, #32]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 808ad00:	f420 5040 	bic.w	r0, r0, #12288	; 0x3000
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 808ad04:	ea42 0201 	orr.w	r2, r2, r1
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 808ad08:	ea40 0007 	orr.w	r0, r0, r7
 808ad0c:	6058      	str	r0, [r3, #4]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 808ad0e:	6899      	ldr	r1, [r3, #8]
 808ad10:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 808ad14:	ea42 0201 	orr.w	r2, r2, r1
 808ad18:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 808ad1a:	d05d      	beq.n	808add8 <UART_SetConfig+0x110>
 808ad1c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 808ad20:	f2c4 0200 	movt	r2, #16384	; 0x4000
 808ad24:	4293      	cmp	r3, r2
 808ad26:	d02f      	beq.n	808ad88 <UART_SetConfig+0xc0>
 808ad28:	f44f 4290 	mov.w	r2, #18432	; 0x4800
 808ad2c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 808ad30:	4293      	cmp	r3, r2
 808ad32:	f000 80ad 	beq.w	808ae90 <UART_SetConfig+0x1c8>
 808ad36:	f44f 4298 	mov.w	r2, #19456	; 0x4c00
 808ad3a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 808ad3e:	4293      	cmp	r3, r2
 808ad40:	f000 80d6 	beq.w	808aef0 <UART_SetConfig+0x228>
 808ad44:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
 808ad48:	f2c4 0200 	movt	r2, #16384	; 0x4000
 808ad4c:	4293      	cmp	r3, r2
 808ad4e:	d05b      	beq.n	808ae08 <UART_SetConfig+0x140>
 808ad50:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
 808ad54:	f2c4 0201 	movt	r2, #16385	; 0x4001
 808ad58:	4293      	cmp	r3, r2
 808ad5a:	f000 80b5 	beq.w	808aec8 <UART_SetConfig+0x200>
 808ad5e:	f44f 42f0 	mov.w	r2, #30720	; 0x7800
 808ad62:	f2c4 0200 	movt	r2, #16384	; 0x4000
 808ad66:	4293      	cmp	r3, r2
 808ad68:	f000 810e 	beq.w	808af88 <UART_SetConfig+0x2c0>
 808ad6c:	f44f 42f8 	mov.w	r2, #31744	; 0x7c00
 808ad70:	f2c4 0200 	movt	r2, #16384	; 0x4000
 808ad74:	4293      	cmp	r3, r2
 808ad76:	f000 811b 	beq.w	808afb0 <UART_SetConfig+0x2e8>

  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 808ad7a:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 808ad7e:	f000 80f4 	beq.w	808af6a <UART_SetConfig+0x2a2>
    case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
      break;
      case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 808ad82:	2201      	movs	r2, #1
    }
  }

  return ret;

}
 808ad84:	4610      	mov	r0, r2
 808ad86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 808ad88:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808ad8c:	f642 1198 	movw	r1, #10648	; 0x2998
 808ad90:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808ad94:	f6c0 0109 	movt	r1, #2057	; 0x809
 808ad98:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808ad9c:	f002 020c 	and.w	r2, r2, #12
 808ada0:	5c8a      	ldrb	r2, [r1, r2]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 808ada2:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 808ada6:	d025      	beq.n	808adf4 <UART_SetConfig+0x12c>
    switch (clocksource)
 808ada8:	2a08      	cmp	r2, #8
 808adaa:	d8ea      	bhi.n	808ad82 <UART_SetConfig+0xba>
 808adac:	a101      	add	r1, pc, #4	; (adr r1, 808adb4 <UART_SetConfig+0xec>)
 808adae:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 808adb2:	bf00      	nop
 808adb4:	0808ae85 	.word	0x0808ae85
 808adb8:	0808ae39 	.word	0x0808ae39
 808adbc:	0808af4f 	.word	0x0808af4f
 808adc0:	0808ad83 	.word	0x0808ad83
 808adc4:	0808aee5 	.word	0x0808aee5
 808adc8:	0808ad83 	.word	0x0808ad83
 808adcc:	0808ad83 	.word	0x0808ad83
 808add0:	0808ad83 	.word	0x0808ad83
 808add4:	0808aeb7 	.word	0x0808aeb7
  UART_GETCLOCKSOURCE(huart, clocksource);
 808add8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808addc:	f642 1194 	movw	r1, #10644	; 0x2994
 808ade0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808ade4:	f6c0 0109 	movt	r1, #2057	; 0x809
 808ade8:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808adec:	f002 0203 	and.w	r2, r2, #3
 808adf0:	5c8a      	ldrb	r2, [r1, r2]
 808adf2:	e7d6      	b.n	808ada2 <UART_SetConfig+0xda>
    switch (clocksource)
 808adf4:	2a08      	cmp	r2, #8
 808adf6:	f200 80b8 	bhi.w	808af6a <UART_SetConfig+0x2a2>
 808adfa:	e8df f002 	tbb	[pc, r2]
 808adfe:	2a46      	.short	0x2a46
 808ae00:	b676b689 	.word	0xb676b689
 808ae04:	b6b6      	.short	0xb6b6
 808ae06:	9a          	.byte	0x9a
 808ae07:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 808ae08:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808ae0c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808ae10:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808ae14:	f402 7240 	and.w	r2, r2, #768	; 0x300
 808ae18:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 808ae1c:	d05f      	beq.n	808aede <UART_SetConfig+0x216>
 808ae1e:	d92b      	bls.n	808ae78 <UART_SetConfig+0x1b0>
 808ae20:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 808ae24:	d071      	beq.n	808af0a <UART_SetConfig+0x242>
 808ae26:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 808ae2a:	d041      	beq.n	808aeb0 <UART_SetConfig+0x1e8>
 808ae2c:	e7a5      	b.n	808ad7a <UART_SetConfig+0xb2>
 808ae2e:	2a00      	cmp	r2, #0
 808ae30:	d1a3      	bne.n	808ad7a <UART_SetConfig+0xb2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 808ae32:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 808ae36:	d00c      	beq.n	808ae52 <UART_SetConfig+0x18a>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 808ae38:	f7fc ff58 	bl	8087cec <HAL_RCC_GetPCLK2Freq>
  HAL_StatusTypeDef ret               = HAL_OK;
 808ae3c:	2200      	movs	r2, #0
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 808ae3e:	e9d4 1300 	ldrd	r1, r3, [r4]
 808ae42:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 808ae46:	fbb0 f0f3 	udiv	r0, r0, r3
 808ae4a:	b280      	uxth	r0, r0
 808ae4c:	60c8      	str	r0, [r1, #12]
}
 808ae4e:	4610      	mov	r0, r2
 808ae50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 808ae52:	f7fc ff4b 	bl	8087cec <HAL_RCC_GetPCLK2Freq>
  HAL_StatusTypeDef ret               = HAL_OK;
 808ae56:	2200      	movs	r2, #0
 808ae58:	e9d4 3500 	ldrd	r3, r5, [r4]
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 808ae5c:	0869      	lsrs	r1, r5, #1
 808ae5e:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 808ae62:	fbb0 f0f5 	udiv	r0, r0, r5
 808ae66:	f3c0 0142 	ubfx	r1, r0, #1, #3
 808ae6a:	f020 000f 	bic.w	r0, r0, #15
 808ae6e:	4301      	orrs	r1, r0
 808ae70:	b289      	uxth	r1, r1
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 808ae72:	60d9      	str	r1, [r3, #12]
}
 808ae74:	4610      	mov	r0, r2
 808ae76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 808ae78:	2a00      	cmp	r2, #0
 808ae7a:	f47f af7e 	bne.w	808ad7a <UART_SetConfig+0xb2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 808ae7e:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 808ae82:	d002      	beq.n	808ae8a <UART_SetConfig+0x1c2>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 808ae84:	f7fc ff1e 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
 808ae88:	e7d8      	b.n	808ae3c <UART_SetConfig+0x174>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 808ae8a:	f7fc ff1b 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
 808ae8e:	e7e2      	b.n	808ae56 <UART_SetConfig+0x18e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 808ae90:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808ae94:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808ae98:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808ae9c:	f002 0230 	and.w	r2, r2, #48	; 0x30
 808aea0:	2a10      	cmp	r2, #16
 808aea2:	d01c      	beq.n	808aede <UART_SetConfig+0x216>
 808aea4:	d9e8      	bls.n	808ae78 <UART_SetConfig+0x1b0>
 808aea6:	2a20      	cmp	r2, #32
 808aea8:	d02f      	beq.n	808af0a <UART_SetConfig+0x242>
 808aeaa:	2a30      	cmp	r2, #48	; 0x30
 808aeac:	f47f af65 	bne.w	808ad7a <UART_SetConfig+0xb2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 808aeb0:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 808aeb4:	d03d      	beq.n	808af32 <UART_SetConfig+0x26a>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 808aeb6:	6860      	ldr	r0, [r4, #4]
  HAL_StatusTypeDef ret               = HAL_OK;
 808aeb8:	2200      	movs	r2, #0
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 808aeba:	0841      	lsrs	r1, r0, #1
 808aebc:	f501 4100 	add.w	r1, r1, #32768	; 0x8000
 808aec0:	fbb1 f1f0 	udiv	r1, r1, r0
 808aec4:	b289      	uxth	r1, r1
 808aec6:	e7d4      	b.n	808ae72 <UART_SetConfig+0x1aa>
  UART_GETCLOCKSOURCE(huart, clocksource);
 808aec8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808aecc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808aed0:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808aed4:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 808aed8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 808aedc:	d148      	bne.n	808af70 <UART_SetConfig+0x2a8>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 808aede:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 808aee2:	d002      	beq.n	808aeea <UART_SetConfig+0x222>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 808aee4:	f7fc fdf4 	bl	8087ad0 <HAL_RCC_GetSysClockFreq>
 808aee8:	e7a8      	b.n	808ae3c <UART_SetConfig+0x174>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 808aeea:	f7fc fdf1 	bl	8087ad0 <HAL_RCC_GetSysClockFreq>
 808aeee:	e7b2      	b.n	808ae56 <UART_SetConfig+0x18e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 808aef0:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808aef4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808aef8:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808aefc:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 808af00:	2a40      	cmp	r2, #64	; 0x40
 808af02:	d0ec      	beq.n	808aede <UART_SetConfig+0x216>
 808af04:	d9b8      	bls.n	808ae78 <UART_SetConfig+0x1b0>
 808af06:	2a80      	cmp	r2, #128	; 0x80
 808af08:	d13b      	bne.n	808af82 <UART_SetConfig+0x2ba>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 808af0a:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 808af0e:	d11e      	bne.n	808af4e <UART_SetConfig+0x286>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 808af10:	f44f 4190 	mov.w	r1, #18432	; 0x4800
 808af14:	6860      	ldr	r0, [r4, #4]
  HAL_StatusTypeDef ret               = HAL_OK;
 808af16:	2200      	movs	r2, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 808af18:	f2c0 11e8 	movt	r1, #488	; 0x1e8
 808af1c:	eb01 0150 	add.w	r1, r1, r0, lsr #1
 808af20:	fbb1 f0f0 	udiv	r0, r1, r0
 808af24:	f3c0 0142 	ubfx	r1, r0, #1, #3
 808af28:	f020 000f 	bic.w	r0, r0, #15
 808af2c:	4301      	orrs	r1, r0
 808af2e:	b289      	uxth	r1, r1
      break;
 808af30:	e79f      	b.n	808ae72 <UART_SetConfig+0x1aa>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 808af32:	6861      	ldr	r1, [r4, #4]
  HAL_StatusTypeDef ret               = HAL_OK;
 808af34:	2200      	movs	r2, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 808af36:	0848      	lsrs	r0, r1, #1
 808af38:	f500 3080 	add.w	r0, r0, #65536	; 0x10000
 808af3c:	fbb0 f0f1 	udiv	r0, r0, r1
 808af40:	f3c0 0142 	ubfx	r1, r0, #1, #3
 808af44:	f020 000f 	bic.w	r0, r0, #15
 808af48:	4301      	orrs	r1, r0
 808af4a:	b289      	uxth	r1, r1
      break;
 808af4c:	e791      	b.n	808ae72 <UART_SetConfig+0x1aa>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 808af4e:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 808af52:	6860      	ldr	r0, [r4, #4]
  HAL_StatusTypeDef ret               = HAL_OK;
 808af54:	2200      	movs	r2, #0
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 808af56:	f2c0 01f4 	movt	r1, #244	; 0xf4
 808af5a:	eb01 0150 	add.w	r1, r1, r0, lsr #1
 808af5e:	fbb1 f1f0 	udiv	r1, r1, r0
 808af62:	b289      	uxth	r1, r1
}
 808af64:	4610      	mov	r0, r2
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 808af66:	60d9      	str	r1, [r3, #12]
}
 808af68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (clocksource)
 808af6a:	2100      	movs	r1, #0
        ret = HAL_ERROR;
 808af6c:	2201      	movs	r2, #1
 808af6e:	e780      	b.n	808ae72 <UART_SetConfig+0x1aa>
  UART_GETCLOCKSOURCE(huart, clocksource);
 808af70:	f67f af5d 	bls.w	808ae2e <UART_SetConfig+0x166>
 808af74:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 808af78:	d0c7      	beq.n	808af0a <UART_SetConfig+0x242>
 808af7a:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 808af7e:	d097      	beq.n	808aeb0 <UART_SetConfig+0x1e8>
 808af80:	e6fb      	b.n	808ad7a <UART_SetConfig+0xb2>
 808af82:	2ac0      	cmp	r2, #192	; 0xc0
 808af84:	d094      	beq.n	808aeb0 <UART_SetConfig+0x1e8>
 808af86:	e6f8      	b.n	808ad7a <UART_SetConfig+0xb2>
 808af88:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808af8c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808af90:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808af94:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 808af98:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 808af9c:	d09f      	beq.n	808aede <UART_SetConfig+0x216>
 808af9e:	f67f af6b 	bls.w	808ae78 <UART_SetConfig+0x1b0>
 808afa2:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 808afa6:	d0b0      	beq.n	808af0a <UART_SetConfig+0x242>
 808afa8:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 808afac:	d080      	beq.n	808aeb0 <UART_SetConfig+0x1e8>
 808afae:	e6e4      	b.n	808ad7a <UART_SetConfig+0xb2>
 808afb0:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 808afb4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 808afb8:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 808afbc:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 808afc0:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 808afc4:	d08b      	beq.n	808aede <UART_SetConfig+0x216>
 808afc6:	f67f af57 	bls.w	808ae78 <UART_SetConfig+0x1b0>
 808afca:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 808afce:	d09c      	beq.n	808af0a <UART_SetConfig+0x242>
 808afd0:	f5b2 4f40 	cmp.w	r2, #49152	; 0xc000
 808afd4:	f43f af6c 	beq.w	808aeb0 <UART_SetConfig+0x1e8>
 808afd8:	e6cf      	b.n	808ad7a <UART_SetConfig+0xb2>
 808afda:	bf00      	nop

0808afdc <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 808afdc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 808afde:	07da      	lsls	r2, r3, #31
{
 808afe0:	b410      	push	{r4}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 808afe2:	d506      	bpl.n	808aff2 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 808afe4:	6801      	ldr	r1, [r0, #0]
 808afe6:	6a84      	ldr	r4, [r0, #40]	; 0x28
 808afe8:	684a      	ldr	r2, [r1, #4]
 808afea:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 808afee:	4322      	orrs	r2, r4
 808aff0:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 808aff2:	079c      	lsls	r4, r3, #30
 808aff4:	d506      	bpl.n	808b004 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 808aff6:	6801      	ldr	r1, [r0, #0]
 808aff8:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 808affa:	684a      	ldr	r2, [r1, #4]
 808affc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 808b000:	4322      	orrs	r2, r4
 808b002:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 808b004:	0759      	lsls	r1, r3, #29
 808b006:	d506      	bpl.n	808b016 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 808b008:	6801      	ldr	r1, [r0, #0]
 808b00a:	6b04      	ldr	r4, [r0, #48]	; 0x30
 808b00c:	684a      	ldr	r2, [r1, #4]
 808b00e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 808b012:	4322      	orrs	r2, r4
 808b014:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 808b016:	071a      	lsls	r2, r3, #28
 808b018:	d506      	bpl.n	808b028 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 808b01a:	6801      	ldr	r1, [r0, #0]
 808b01c:	6b44      	ldr	r4, [r0, #52]	; 0x34
 808b01e:	684a      	ldr	r2, [r1, #4]
 808b020:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 808b024:	4322      	orrs	r2, r4
 808b026:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 808b028:	06dc      	lsls	r4, r3, #27
 808b02a:	d506      	bpl.n	808b03a <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 808b02c:	6801      	ldr	r1, [r0, #0]
 808b02e:	6b84      	ldr	r4, [r0, #56]	; 0x38
 808b030:	688a      	ldr	r2, [r1, #8]
 808b032:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 808b036:	4322      	orrs	r2, r4
 808b038:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 808b03a:	0699      	lsls	r1, r3, #26
 808b03c:	d506      	bpl.n	808b04c <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 808b03e:	6801      	ldr	r1, [r0, #0]
 808b040:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 808b042:	688a      	ldr	r2, [r1, #8]
 808b044:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 808b048:	4322      	orrs	r2, r4
 808b04a:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 808b04c:	065a      	lsls	r2, r3, #25
 808b04e:	d50a      	bpl.n	808b066 <UART_AdvFeatureConfig+0x8a>
  {
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 808b050:	6801      	ldr	r1, [r0, #0]
 808b052:	6c04      	ldr	r4, [r0, #64]	; 0x40
 808b054:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 808b056:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 808b05a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 808b05e:	ea42 0204 	orr.w	r2, r2, r4
 808b062:	604a      	str	r2, [r1, #4]
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 808b064:	d00b      	beq.n	808b07e <UART_AdvFeatureConfig+0xa2>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 808b066:	061b      	lsls	r3, r3, #24
 808b068:	d506      	bpl.n	808b078 <UART_AdvFeatureConfig+0x9c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 808b06a:	6802      	ldr	r2, [r0, #0]
 808b06c:	6c81      	ldr	r1, [r0, #72]	; 0x48
 808b06e:	6853      	ldr	r3, [r2, #4]
 808b070:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 808b074:	430b      	orrs	r3, r1
 808b076:	6053      	str	r3, [r2, #4]
  }
}
 808b078:	f85d 4b04 	ldr.w	r4, [sp], #4
 808b07c:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 808b07e:	684a      	ldr	r2, [r1, #4]
 808b080:	6c44      	ldr	r4, [r0, #68]	; 0x44
 808b082:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 808b086:	4322      	orrs	r2, r4
 808b088:	604a      	str	r2, [r1, #4]
 808b08a:	e7ec      	b.n	808b066 <UART_AdvFeatureConfig+0x8a>

0808b08c <UART_CheckIdleState>:
  * @brief Check the UART Idle State
  * @param huart uart handle
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 808b08c:	b570      	push	{r4, r5, r6, lr}
  uint32_t tickstart = 0U;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 808b08e:	2500      	movs	r5, #0
{
 808b090:	4604      	mov	r4, r0
 808b092:	b082      	sub	sp, #8
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 808b094:	66c5      	str	r5, [r0, #108]	; 0x6c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 808b096:	f7fa fb8b 	bl	80857b0 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 808b09a:	6822      	ldr	r2, [r4, #0]
 808b09c:	6812      	ldr	r2, [r2, #0]
 808b09e:	0713      	lsls	r3, r2, #28
 808b0a0:	d40a      	bmi.n	808b0b8 <UART_CheckIdleState+0x2c>
  /* Initialize the UART State */
  huart->gState= HAL_UART_STATE_READY;
  huart->RxState= HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 808b0a2:	2300      	movs	r3, #0
  huart->gState= HAL_UART_STATE_READY;
 808b0a4:	2220      	movs	r2, #32

  return HAL_OK;
 808b0a6:	4618      	mov	r0, r3
  huart->gState= HAL_UART_STATE_READY;
 808b0a8:	f884 2069 	strb.w	r2, [r4, #105]	; 0x69
  __HAL_UNLOCK(huart);
 808b0ac:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
  huart->RxState= HAL_UART_STATE_READY;
 808b0b0:	f884 206a 	strb.w	r2, [r4, #106]	; 0x6a
}
 808b0b4:	b002      	add	sp, #8
 808b0b6:	bd70      	pop	{r4, r5, r6, pc}
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 808b0b8:	f06f 467e 	mvn.w	r6, #4261412864	; 0xfe000000
 808b0bc:	4603      	mov	r3, r0
 808b0be:	462a      	mov	r2, r5
 808b0c0:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 808b0c4:	9600      	str	r6, [sp, #0]
 808b0c6:	4620      	mov	r0, r4
 808b0c8:	f7ff fc58 	bl	808a97c <UART_WaitOnFlagUntilTimeout>
 808b0cc:	2800      	cmp	r0, #0
 808b0ce:	d0e8      	beq.n	808b0a2 <UART_CheckIdleState+0x16>
      return HAL_TIMEOUT;
 808b0d0:	2003      	movs	r0, #3
}
 808b0d2:	b002      	add	sp, #8
 808b0d4:	bd70      	pop	{r4, r5, r6, pc}
 808b0d6:	bf00      	nop

0808b0d8 <HAL_UART_Init>:
  if(huart == NULL)
 808b0d8:	b390      	cbz	r0, 808b140 <HAL_UART_Init+0x68>
  if(huart->gState == HAL_UART_STATE_RESET)
 808b0da:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
{
 808b0de:	b510      	push	{r4, lr}
  if(huart->gState == HAL_UART_STATE_RESET)
 808b0e0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 808b0e4:	4604      	mov	r4, r0
 808b0e6:	b303      	cbz	r3, 808b12a <HAL_UART_Init+0x52>
  __HAL_UART_DISABLE(huart);
 808b0e8:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 808b0ea:	2324      	movs	r3, #36	; 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
 808b0ec:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
 808b0ee:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  __HAL_UART_DISABLE(huart);
 808b0f2:	6813      	ldr	r3, [r2, #0]
 808b0f4:	f023 0301 	bic.w	r3, r3, #1
 808b0f8:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 808b0fa:	f7ff fde5 	bl	808acc8 <UART_SetConfig>
 808b0fe:	2801      	cmp	r0, #1
 808b100:	d018      	beq.n	808b134 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 808b102:	6a63      	ldr	r3, [r4, #36]	; 0x24
 808b104:	b9c3      	cbnz	r3, 808b138 <HAL_UART_Init+0x60>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 808b106:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 808b108:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 808b10a:	685a      	ldr	r2, [r3, #4]
 808b10c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 808b110:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 808b112:	689a      	ldr	r2, [r3, #8]
 808b114:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 808b118:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 808b11a:	681a      	ldr	r2, [r3, #0]
 808b11c:	f042 0201 	orr.w	r2, r2, #1
}
 808b120:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
 808b124:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 808b126:	f7ff bfb1 	b.w	808b08c <UART_CheckIdleState>
    huart->Lock = HAL_UNLOCKED;
 808b12a:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68
    HAL_UART_MspInit(huart);
 808b12e:	f7ff fbb7 	bl	808a8a0 <HAL_UART_MspInit>
 808b132:	e7d9      	b.n	808b0e8 <HAL_UART_Init+0x10>
}
 808b134:	2001      	movs	r0, #1
 808b136:	bd10      	pop	{r4, pc}
    UART_AdvFeatureConfig(huart);
 808b138:	4620      	mov	r0, r4
 808b13a:	f7ff ff4f 	bl	808afdc <UART_AdvFeatureConfig>
 808b13e:	e7e2      	b.n	808b106 <HAL_UART_Init+0x2e>
}
 808b140:	2001      	movs	r0, #1
 808b142:	4770      	bx	lr

0808b144 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 808b144:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 808b148:	680f      	ldr	r7, [r1, #0]
 808b14a:	f8d1 e024 	ldr.w	lr, [r1, #36]	; 0x24
 808b14e:	2f01      	cmp	r7, #1
 808b150:	e9d1 3207 	ldrd	r3, r2, [r1, #28]
 808b154:	e9d1 4801 	ldrd	r4, r8, [r1, #4]
 808b158:	e9d1 c603 	ldrd	ip, r6, [r1, #12]
 808b15c:	e9d1 5105 	ldrd	r5, r1, [r1, #20]
 808b160:	d015      	beq.n	808b18e <FMC_SDRAM_Init+0x4a>
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b162:	431a      	orrs	r2, r3
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 808b164:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 808b168:	6803      	ldr	r3, [r0, #0]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b16a:	ea42 020e 	orr.w	r2, r2, lr
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 808b16e:	f6cf 77ff 	movt	r7, #65535	; 0xffff
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b172:	4322      	orrs	r2, r4
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 808b174:	401f      	ands	r7, r3
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b176:	ea42 0308 	orr.w	r3, r2, r8
 808b17a:	ea43 030c 	orr.w	r3, r3, ip
 808b17e:	4333      	orrs	r3, r6
 808b180:	432b      	orrs	r3, r5
 808b182:	430b      	orrs	r3, r1
 808b184:	433b      	orrs	r3, r7
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 808b186:	6003      	str	r3, [r0, #0]
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
 808b188:	2000      	movs	r0, #0
 808b18a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b18e:	ea44 0408 	orr.w	r4, r4, r8
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 808b192:	431a      	orrs	r2, r3
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 808b194:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 808b198:	f8d0 8000 	ldr.w	r8, [r0]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b19c:	ea44 030c 	orr.w	r3, r4, ip
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 808b1a0:	f8d0 c004 	ldr.w	ip, [r0, #4]
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 808b1a4:	f6cf 77ff 	movt	r7, #65535	; 0xffff
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 808b1a8:	ea42 020e 	orr.w	r2, r2, lr
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b1ac:	4333      	orrs	r3, r6
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 808b1ae:	f428 44f8 	bic.w	r4, r8, #31744	; 0x7c00
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 808b1b2:	ea0c 0707 	and.w	r7, ip, r7
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b1b6:	432b      	orrs	r3, r5
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 808b1b8:	4322      	orrs	r2, r4
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b1ba:	430b      	orrs	r3, r1
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 808b1bc:	6002      	str	r2, [r0, #0]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 808b1be:	433b      	orrs	r3, r7
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 808b1c0:	6043      	str	r3, [r0, #4]
}
 808b1c2:	2000      	movs	r0, #0
 808b1c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0808b1c8 <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 808b1c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 808b1cc:	690b      	ldr	r3, [r1, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 808b1ce:	2a01      	cmp	r2, #1
 808b1d0:	68cf      	ldr	r7, [r1, #12]
 808b1d2:	694e      	ldr	r6, [r1, #20]
 808b1d4:	f103 3eff 	add.w	lr, r3, #4294967295	; 0xffffffff
 808b1d8:	684d      	ldr	r5, [r1, #4]
 808b1da:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
 808b1de:	688c      	ldr	r4, [r1, #8]
 808b1e0:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
 808b1e4:	f8d1 c018 	ldr.w	ip, [r1, #24]
 808b1e8:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
 808b1ec:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 808b1f0:	680b      	ldr	r3, [r1, #0]
 808b1f2:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
 808b1f6:	ea4f 3707 	mov.w	r7, r7, lsl #12
 808b1fa:	ea4f 5606 	mov.w	r6, r6, lsl #20
 808b1fe:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 808b202:	ea4f 1505 	mov.w	r5, r5, lsl #4
 808b206:	ea4f 2404 	mov.w	r4, r4, lsl #8
 808b20a:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 808b20e:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
 808b212:	d012      	beq.n	808b23a <FMC_SDRAM_Timing_Init+0x72>
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b214:	ea47 0206 	orr.w	r2, r7, r6
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 808b218:	6881      	ldr	r1, [r0, #8]
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b21a:	ea42 0208 	orr.w	r2, r2, r8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 808b21e:	f001 4170 	and.w	r1, r1, #4026531840	; 0xf0000000
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b222:	ea42 0305 	orr.w	r3, r2, r5
 808b226:	4323      	orrs	r3, r4
 808b228:	ea43 030e 	orr.w	r3, r3, lr
 808b22c:	ea43 030c 	orr.w	r3, r3, ip
 808b230:	430b      	orrs	r3, r1
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 808b232:	6083      	str	r3, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
 808b234:	2000      	movs	r0, #0
 808b236:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b23a:	ea45 0104 	orr.w	r1, r5, r4
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 808b23e:	f640 74ff 	movw	r4, #4095	; 0xfff
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 808b242:	6885      	ldr	r5, [r0, #8]
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 808b244:	ea47 0206 	orr.w	r2, r7, r6
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b248:	ea41 0308 	orr.w	r3, r1, r8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 808b24c:	f6cf 740f 	movt	r4, #65295	; 0xff0f
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 808b250:	68c1      	ldr	r1, [r0, #12]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b252:	ea43 030e 	orr.w	r3, r3, lr
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 808b256:	402c      	ands	r4, r5
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 808b258:	f001 4170 	and.w	r1, r1, #4026531840	; 0xf0000000
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b25c:	ea43 030c 	orr.w	r3, r3, ip
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 808b260:	4322      	orrs	r2, r4
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 808b262:	430b      	orrs	r3, r1
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 808b264:	6082      	str	r2, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 808b266:	60c3      	str	r3, [r0, #12]
}
 808b268:	2000      	movs	r0, #0
 808b26a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 808b26e:	bf00      	nop

0808b270 <FMC_SDRAM_SendCommand>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 808b270:	b430      	push	{r4, r5}
  __IO uint32_t tmpr = 0;
 808b272:	2200      	movs	r2, #0
{
 808b274:	b082      	sub	sp, #8
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 808b276:	684d      	ldr	r5, [r1, #4]
{
 808b278:	4604      	mov	r4, r0
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 808b27a:	680b      	ldr	r3, [r1, #0]
                    );
    
  Device->SDCMR = tmpr;
  
  return HAL_OK;  
}
 808b27c:	4610      	mov	r0, r2
  __IO uint32_t tmpr = 0;
 808b27e:	9201      	str	r2, [sp, #4]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 808b280:	432b      	orrs	r3, r5
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 808b282:	e9d1 2502 	ldrd	r2, r5, [r1, #8]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 808b286:	ea43 2345 	orr.w	r3, r3, r5, lsl #9
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 808b28a:	3a01      	subs	r2, #1
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 808b28c:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
 808b290:	9301      	str	r3, [sp, #4]
  Device->SDCMR = tmpr;
 808b292:	9b01      	ldr	r3, [sp, #4]
 808b294:	6123      	str	r3, [r4, #16]
}
 808b296:	b002      	add	sp, #8
 808b298:	bc30      	pop	{r4, r5}
 808b29a:	4770      	bx	lr

0808b29c <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance  
  * @param  RefreshRate The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 808b29c:	4602      	mov	r2, r0
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
  
  return HAL_OK;   
}
 808b29e:	2000      	movs	r0, #0
  Device->SDRTR |= (RefreshRate<<1);
 808b2a0:	6953      	ldr	r3, [r2, #20]
 808b2a2:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
 808b2a6:	6151      	str	r1, [r2, #20]
}
 808b2a8:	4770      	bx	lr
 808b2aa:	bf00      	nop

0808b2ac <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
 808b2ac:	b430      	push	{r4, r5}
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b2ae:	f24b 3474 	movw	r4, #45940	; 0xb374
 808b2b2:	f644 55d3 	movw	r5, #19923	; 0x4dd3
{
 808b2b6:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b2b8:	f241 3388 	movw	r3, #5000	; 0x1388
 808b2bc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808b2c0:	f2c1 0562 	movt	r5, #4194	; 0x1062
 808b2c4:	6822      	ldr	r2, [r4, #0]
 808b2c6:	fba5 0202 	umull	r0, r2, r5, r2
 808b2ca:	0a52      	lsrs	r2, r2, #9
 808b2cc:	fb03 f302 	mul.w	r3, r3, r2
 808b2d0:	e003      	b.n	808b2da <SDMMC_GetCmdResp2+0x2e>
    if (count-- == 0)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 808b2d2:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 808b2d4:	f012 0f45 	tst.w	r2, #69	; 0x45
 808b2d8:	d106      	bne.n	808b2e8 <SDMMC_GetCmdResp2+0x3c>
    if (count-- == 0)
 808b2da:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 808b2de:	d2f8      	bcs.n	808b2d2 <SDMMC_GetCmdResp2+0x26>
      return SDMMC_ERROR_TIMEOUT;
 808b2e0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
  }

  return SDMMC_ERROR_NONE;
}
 808b2e4:	bc30      	pop	{r4, r5}
 808b2e6:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 808b2e8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 808b2ea:	075b      	lsls	r3, r3, #29
 808b2ec:	d40c      	bmi.n	808b308 <SDMMC_GetCmdResp2+0x5c>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 808b2ee:	6b48      	ldr	r0, [r1, #52]	; 0x34
 808b2f0:	f010 0001 	ands.w	r0, r0, #1
 808b2f4:	d104      	bne.n	808b300 <SDMMC_GetCmdResp2+0x54>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
 808b2f6:	f240 53ff 	movw	r3, #1535	; 0x5ff
 808b2fa:	638b      	str	r3, [r1, #56]	; 0x38
}
 808b2fc:	bc30      	pop	{r4, r5}
 808b2fe:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 808b300:	2001      	movs	r0, #1
 808b302:	6388      	str	r0, [r1, #56]	; 0x38
}
 808b304:	bc30      	pop	{r4, r5}
 808b306:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 808b308:	2004      	movs	r0, #4
 808b30a:	6388      	str	r0, [r1, #56]	; 0x38
}
 808b30c:	bc30      	pop	{r4, r5}
 808b30e:	4770      	bx	lr

0808b310 <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
 808b310:	b430      	push	{r4, r5}
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b312:	f24b 3474 	movw	r4, #45940	; 0xb374
 808b316:	f644 55d3 	movw	r5, #19923	; 0x4dd3
{
 808b31a:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b31c:	f241 3388 	movw	r3, #5000	; 0x1388
 808b320:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808b324:	f2c1 0562 	movt	r5, #4194	; 0x1062
 808b328:	6822      	ldr	r2, [r4, #0]
 808b32a:	fba5 0202 	umull	r0, r2, r5, r2
 808b32e:	0a52      	lsrs	r2, r2, #9
 808b330:	fb03 f302 	mul.w	r3, r3, r2
 808b334:	e003      	b.n	808b33e <SDMMC_GetCmdResp3+0x2e>
    if (count-- == 0)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 808b336:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 808b338:	f012 0f45 	tst.w	r2, #69	; 0x45
 808b33c:	d106      	bne.n	808b34c <SDMMC_GetCmdResp3+0x3c>
    if (count-- == 0)
 808b33e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 808b342:	d2f8      	bcs.n	808b336 <SDMMC_GetCmdResp3+0x26>
      return SDMMC_ERROR_TIMEOUT;
 808b344:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
  }
  
  return SDMMC_ERROR_NONE;
}
 808b348:	bc30      	pop	{r4, r5}
 808b34a:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 808b34c:	6b48      	ldr	r0, [r1, #52]	; 0x34
 808b34e:	f010 0004 	ands.w	r0, r0, #4
 808b352:	d104      	bne.n	808b35e <SDMMC_GetCmdResp3+0x4e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
 808b354:	f240 53ff 	movw	r3, #1535	; 0x5ff
 808b358:	638b      	str	r3, [r1, #56]	; 0x38
}
 808b35a:	bc30      	pop	{r4, r5}
 808b35c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 808b35e:	2004      	movs	r0, #4
 808b360:	6388      	str	r0, [r1, #56]	; 0x38
}
 808b362:	bc30      	pop	{r4, r5}
 808b364:	4770      	bx	lr
 808b366:	bf00      	nop

0808b368 <SDMMC_GetCmdResp1>:
{
 808b368:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8 /1000);
 808b36a:	f24b 3474 	movw	r4, #45940	; 0xb374
 808b36e:	f644 55d3 	movw	r5, #19923	; 0x4dd3
{
 808b372:	b082      	sub	sp, #8
  register uint32_t count = Timeout * (SystemCoreClock / 8 /1000);
 808b374:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808b378:	f2c1 0562 	movt	r5, #4194	; 0x1062
 808b37c:	6823      	ldr	r3, [r4, #0]
 808b37e:	fba5 4303 	umull	r4, r3, r5, r3
 808b382:	0a5b      	lsrs	r3, r3, #9
 808b384:	fb02 f203 	mul.w	r2, r2, r3
    if (count-- == 0)
 808b388:	b19a      	cbz	r2, 808b3b2 <SDMMC_GetCmdResp1+0x4a>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 808b38a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 808b38c:	3a01      	subs	r2, #1
 808b38e:	f013 0f45 	tst.w	r3, #69	; 0x45
 808b392:	d0f9      	beq.n	808b388 <SDMMC_GetCmdResp1+0x20>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 808b394:	6b43      	ldr	r3, [r0, #52]	; 0x34
 808b396:	075b      	lsls	r3, r3, #29
 808b398:	d416      	bmi.n	808b3c8 <SDMMC_GetCmdResp1+0x60>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 808b39a:	6b42      	ldr	r2, [r0, #52]	; 0x34
 808b39c:	f012 0201 	ands.w	r2, r2, #1
 808b3a0:	d10c      	bne.n	808b3bc <SDMMC_GetCmdResp1+0x54>
  return (uint8_t)(SDMMCx->RESPCMD);
 808b3a2:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 808b3a4:	b2db      	uxtb	r3, r3
 808b3a6:	4299      	cmp	r1, r3
 808b3a8:	d014      	beq.n	808b3d4 <SDMMC_GetCmdResp1+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 808b3aa:	2001      	movs	r0, #1
}
 808b3ac:	b002      	add	sp, #8
 808b3ae:	bc30      	pop	{r4, r5}
 808b3b0:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 808b3b2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 808b3b6:	b002      	add	sp, #8
 808b3b8:	bc30      	pop	{r4, r5}
 808b3ba:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 808b3bc:	2301      	movs	r3, #1
 808b3be:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 808b3c0:	4618      	mov	r0, r3
}
 808b3c2:	b002      	add	sp, #8
 808b3c4:	bc30      	pop	{r4, r5}
 808b3c6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 808b3c8:	2304      	movs	r3, #4
 808b3ca:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 808b3cc:	4618      	mov	r0, r3
}
 808b3ce:	b002      	add	sp, #8
 808b3d0:	bc30      	pop	{r4, r5}
 808b3d2:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
 808b3d4:	f240 54ff 	movw	r4, #1535	; 0x5ff
  tmp = (uint32_t)&(SDMMCx->RESP1) + Response;
 808b3d8:	f100 0114 	add.w	r1, r0, #20
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 808b3dc:	f24e 0308 	movw	r3, #57352	; 0xe008
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
 808b3e0:	6384      	str	r4, [r0, #56]	; 0x38
  __IO uint32_t tmp = 0;
 808b3e2:	9201      	str	r2, [sp, #4]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 808b3e4:	f6cf 53ff 	movt	r3, #65023	; 0xfdff
  tmp = (uint32_t)&(SDMMCx->RESP1) + Response;
 808b3e8:	9101      	str	r1, [sp, #4]
  return (*(__IO uint32_t *) tmp);
 808b3ea:	9a01      	ldr	r2, [sp, #4]
 808b3ec:	6812      	ldr	r2, [r2, #0]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 808b3ee:	4013      	ands	r3, r2
 808b3f0:	b34b      	cbz	r3, 808b446 <SDMMC_GetCmdResp1+0xde>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 808b3f2:	2a00      	cmp	r2, #0
 808b3f4:	db2b      	blt.n	808b44e <SDMMC_GetCmdResp1+0xe6>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 808b3f6:	0055      	lsls	r5, r2, #1
 808b3f8:	d427      	bmi.n	808b44a <SDMMC_GetCmdResp1+0xe2>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 808b3fa:	0094      	lsls	r4, r2, #2
 808b3fc:	d42a      	bmi.n	808b454 <SDMMC_GetCmdResp1+0xec>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 808b3fe:	00d1      	lsls	r1, r2, #3
 808b400:	d42a      	bmi.n	808b458 <SDMMC_GetCmdResp1+0xf0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 808b402:	0113      	lsls	r3, r2, #4
 808b404:	d42b      	bmi.n	808b45e <SDMMC_GetCmdResp1+0xf6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 808b406:	0155      	lsls	r5, r2, #5
 808b408:	d42c      	bmi.n	808b464 <SDMMC_GetCmdResp1+0xfc>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 808b40a:	01d4      	lsls	r4, r2, #7
 808b40c:	d430      	bmi.n	808b470 <SDMMC_GetCmdResp1+0x108>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 808b40e:	0211      	lsls	r1, r2, #8
 808b410:	d42b      	bmi.n	808b46a <SDMMC_GetCmdResp1+0x102>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 808b412:	0253      	lsls	r3, r2, #9
 808b414:	d432      	bmi.n	808b47c <SDMMC_GetCmdResp1+0x114>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 808b416:	0295      	lsls	r5, r2, #10
 808b418:	d42d      	bmi.n	808b476 <SDMMC_GetCmdResp1+0x10e>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 808b41a:	02d4      	lsls	r4, r2, #11
 808b41c:	d437      	bmi.n	808b48e <SDMMC_GetCmdResp1+0x126>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 808b41e:	0351      	lsls	r1, r2, #13
 808b420:	d432      	bmi.n	808b488 <SDMMC_GetCmdResp1+0x120>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 808b422:	0393      	lsls	r3, r2, #14
 808b424:	d43f      	bmi.n	808b4a6 <SDMMC_GetCmdResp1+0x13e>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 808b426:	03d5      	lsls	r5, r2, #15
 808b428:	d43a      	bmi.n	808b4a0 <SDMMC_GetCmdResp1+0x138>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 808b42a:	0414      	lsls	r4, r2, #16
 808b42c:	d435      	bmi.n	808b49a <SDMMC_GetCmdResp1+0x132>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 808b42e:	0451      	lsls	r1, r2, #17
 808b430:	d430      	bmi.n	808b494 <SDMMC_GetCmdResp1+0x12c>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 808b432:	0493      	lsls	r3, r2, #18
 808b434:	d425      	bmi.n	808b482 <SDMMC_GetCmdResp1+0x11a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 808b436:	f012 0f08 	tst.w	r2, #8
 808b43a:	bf14      	ite	ne
 808b43c:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
 808b440:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 808b444:	e7b7      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_NONE;
 808b446:	4618      	mov	r0, r3
 808b448:	e7b5      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 808b44a:	2040      	movs	r0, #64	; 0x40
 808b44c:	e7b3      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 808b44e:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 808b452:	e7b0      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 808b454:	2080      	movs	r0, #128	; 0x80
 808b456:	e7ae      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 808b458:	f44f 7080 	mov.w	r0, #256	; 0x100
 808b45c:	e7ab      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 808b45e:	f44f 7000 	mov.w	r0, #512	; 0x200
 808b462:	e7a8      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 808b464:	f44f 6080 	mov.w	r0, #1024	; 0x400
 808b468:	e7a5      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_COM_CRC_FAILED;
 808b46a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 808b46e:	e7a2      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 808b470:	f44f 6000 	mov.w	r0, #2048	; 0x800
 808b474:	e79f      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 808b476:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 808b47a:	e79c      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_ILLEGAL_CMD;
 808b47c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 808b480:	e799      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_ERASE_RESET;
 808b482:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 808b486:	e796      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 808b488:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 808b48c:	e793      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_CC_ERR;
 808b48e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 808b492:	e790      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 808b494:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 808b498:	e78d      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 808b49a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 808b49e:	e78a      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 808b4a0:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 808b4a4:	e787      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 808b4a6:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 808b4aa:	e784      	b.n	808b3b6 <SDMMC_GetCmdResp1+0x4e>

0808b4ac <SDMMC_Init>:
{
 808b4ac:	b084      	sub	sp, #16
 808b4ae:	b470      	push	{r4, r5, r6}
 808b4b0:	ae04      	add	r6, sp, #16
             Init.ClockPowerSave      |\
 808b4b2:	9c07      	ldr	r4, [sp, #28]
{
 808b4b4:	4605      	mov	r5, r0
}
 808b4b6:	2000      	movs	r0, #0
{
 808b4b8:	e886 000e 	stmia.w	r6, {r1, r2, r3}
  tmpreg |= (Init.ClockEdge           |\
 808b4bc:	460b      	mov	r3, r1
 808b4be:	9905      	ldr	r1, [sp, #20]
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 808b4c0:	f44f 4201 	mov.w	r2, #33024	; 0x8100
  tmpreg |= (Init.ClockEdge           |\
 808b4c4:	430b      	orrs	r3, r1
             Init.ClockBypass         |\
 808b4c6:	9906      	ldr	r1, [sp, #24]
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 808b4c8:	f6cf 72ff 	movt	r2, #65535	; 0xffff
             Init.ClockBypass         |\
 808b4cc:	430b      	orrs	r3, r1
             Init.BusWide             |\
 808b4ce:	9908      	ldr	r1, [sp, #32]
             Init.ClockPowerSave      |\
 808b4d0:	4323      	orrs	r3, r4
             Init.HardwareFlowControl |\
 808b4d2:	9c09      	ldr	r4, [sp, #36]	; 0x24
             Init.BusWide             |\
 808b4d4:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 808b4d6:	6869      	ldr	r1, [r5, #4]
             Init.HardwareFlowControl |\
 808b4d8:	4323      	orrs	r3, r4
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 808b4da:	400a      	ands	r2, r1
 808b4dc:	4313      	orrs	r3, r2
 808b4de:	606b      	str	r3, [r5, #4]
}
 808b4e0:	bc70      	pop	{r4, r5, r6}
 808b4e2:	b004      	add	sp, #16
 808b4e4:	4770      	bx	lr
 808b4e6:	bf00      	nop

0808b4e8 <SDMMC_ReadFIFO>:
  return (SDMMCx->FIFO);
 808b4e8:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 808b4ec:	4770      	bx	lr
 808b4ee:	bf00      	nop

0808b4f0 <SDMMC_WriteFIFO>:
{ 
 808b4f0:	4603      	mov	r3, r0
  SDMMCx->FIFO = *pWriteData;
 808b4f2:	680a      	ldr	r2, [r1, #0]
}
 808b4f4:	2000      	movs	r0, #0
  SDMMCx->FIFO = *pWriteData;
 808b4f6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 808b4fa:	4770      	bx	lr

0808b4fc <SDMMC_PowerState_ON>:
{  
 808b4fc:	4603      	mov	r3, r0
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
 808b4fe:	2203      	movs	r2, #3
}
 808b500:	2000      	movs	r0, #0
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
 808b502:	601a      	str	r2, [r3, #0]
}
 808b504:	4770      	bx	lr
 808b506:	bf00      	nop

0808b508 <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 808b508:	6800      	ldr	r0, [r0, #0]
}
 808b50a:	f000 0003 	and.w	r0, r0, #3
 808b50e:	4770      	bx	lr

0808b510 <SDMMC_GetResponse>:
  tmp = (uint32_t)&(SDMMCx->RESP1) + Response;
 808b510:	3014      	adds	r0, #20
{
 808b512:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 808b514:	2300      	movs	r3, #0
  tmp = (uint32_t)&(SDMMCx->RESP1) + Response;
 808b516:	4401      	add	r1, r0
  __IO uint32_t tmp = 0;
 808b518:	9301      	str	r3, [sp, #4]
  tmp = (uint32_t)&(SDMMCx->RESP1) + Response;
 808b51a:	9101      	str	r1, [sp, #4]
  return (*(__IO uint32_t *) tmp);
 808b51c:	9b01      	ldr	r3, [sp, #4]
 808b51e:	6818      	ldr	r0, [r3, #0]
}  
 808b520:	b002      	add	sp, #8
 808b522:	4770      	bx	lr

0808b524 <SDMMC_ConfigData>:
{
 808b524:	b430      	push	{r4, r5}
 808b526:	4602      	mov	r2, r0
  SDMMCx->DTIMER = Data->DataTimeOut;
 808b528:	680c      	ldr	r4, [r1, #0]
}
 808b52a:	2000      	movs	r0, #0
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 808b52c:	e9d1 3502 	ldrd	r3, r5, [r1, #8]
 808b530:	432b      	orrs	r3, r5
  SDMMCx->DLEN = Data->DataLength;
 808b532:	684d      	ldr	r5, [r1, #4]
  SDMMCx->DTIMER = Data->DataTimeOut;
 808b534:	6254      	str	r4, [r2, #36]	; 0x24
                       Data->TransferDir   |\
 808b536:	690c      	ldr	r4, [r1, #16]
  SDMMCx->DLEN = Data->DataLength;
 808b538:	6295      	str	r5, [r2, #40]	; 0x28
                       Data->TransferDir   |\
 808b53a:	4323      	orrs	r3, r4
                       Data->TransferMode  |\
 808b53c:	694d      	ldr	r5, [r1, #20]
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 808b53e:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
                       Data->TransferMode  |\
 808b540:	432b      	orrs	r3, r5
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 808b542:	f024 01f7 	bic.w	r1, r4, #247	; 0xf7
 808b546:	430b      	orrs	r3, r1
}
 808b548:	bc30      	pop	{r4, r5}
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 808b54a:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 808b54c:	4770      	bx	lr
 808b54e:	bf00      	nop

0808b550 <SDMMC_CmdBlockLength>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b550:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 808b554:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b558:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b55a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b55e:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b560:	68c5      	ldr	r5, [r0, #12]
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 808b562:	2110      	movs	r1, #16
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b564:	402b      	ands	r3, r5
 808b566:	f443 638a 	orr.w	r3, r3, #1104	; 0x450
}
 808b56a:	bc30      	pop	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b56c:	60c3      	str	r3, [r0, #12]
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 808b56e:	f7ff befb 	b.w	808b368 <SDMMC_GetCmdResp1>
 808b572:	bf00      	nop

0808b574 <SDMMC_CmdReadSingleBlock>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b574:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 808b578:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b57c:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b57e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b582:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b584:	68c1      	ldr	r1, [r0, #12]
 808b586:	f240 4551 	movw	r5, #1105	; 0x451
 808b58a:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 808b58c:	2111      	movs	r1, #17
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b58e:	431d      	orrs	r5, r3
 808b590:	60c5      	str	r5, [r0, #12]
}
 808b592:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 808b594:	f7ff bee8 	b.w	808b368 <SDMMC_GetCmdResp1>

0808b598 <SDMMC_CmdReadMultiBlock>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b598:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 808b59c:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b5a0:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5a2:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b5a6:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5a8:	68c1      	ldr	r1, [r0, #12]
 808b5aa:	f240 4552 	movw	r5, #1106	; 0x452
 808b5ae:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 808b5b0:	2112      	movs	r1, #18
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5b2:	431d      	orrs	r5, r3
 808b5b4:	60c5      	str	r5, [r0, #12]
}
 808b5b6:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 808b5b8:	f7ff bed6 	b.w	808b368 <SDMMC_GetCmdResp1>

0808b5bc <SDMMC_CmdWriteSingleBlock>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5bc:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 808b5c0:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b5c4:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5c6:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b5ca:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5cc:	68c5      	ldr	r5, [r0, #12]
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 808b5ce:	2118      	movs	r1, #24
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5d0:	402b      	ands	r3, r5
 808b5d2:	f443 638b 	orr.w	r3, r3, #1112	; 0x458
}
 808b5d6:	bc30      	pop	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5d8:	60c3      	str	r3, [r0, #12]
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 808b5da:	f7ff bec5 	b.w	808b368 <SDMMC_GetCmdResp1>
 808b5de:	bf00      	nop

0808b5e0 <SDMMC_CmdWriteMultiBlock>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5e0:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 808b5e4:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b5e8:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5ea:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b5ee:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5f0:	68c1      	ldr	r1, [r0, #12]
 808b5f2:	f240 4559 	movw	r5, #1113	; 0x459
 808b5f6:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 808b5f8:	2119      	movs	r1, #25
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b5fa:	431d      	orrs	r5, r3
 808b5fc:	60c5      	str	r5, [r0, #12]
}
 808b5fe:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 808b600:	f7ff beb2 	b.w	808b368 <SDMMC_GetCmdResp1>

0808b604 <SDMMC_CmdSDEraseStartAdd>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b604:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
 808b608:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b60c:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b60e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b612:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b614:	68c5      	ldr	r5, [r0, #12]
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
 808b616:	2120      	movs	r1, #32
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b618:	402b      	ands	r3, r5
 808b61a:	f443 638c 	orr.w	r3, r3, #1120	; 0x460
}
 808b61e:	bc30      	pop	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b620:	60c3      	str	r3, [r0, #12]
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
 808b622:	f7ff bea1 	b.w	808b368 <SDMMC_GetCmdResp1>
 808b626:	bf00      	nop

0808b628 <SDMMC_CmdSDEraseEndAdd>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b628:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
 808b62c:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b630:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b632:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b636:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b638:	68c1      	ldr	r1, [r0, #12]
 808b63a:	f240 4561 	movw	r5, #1121	; 0x461
 808b63e:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
 808b640:	2121      	movs	r1, #33	; 0x21
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b642:	431d      	orrs	r5, r3
 808b644:	60c5      	str	r5, [r0, #12]
}
 808b646:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
 808b648:	f7ff be8e 	b.w	808b368 <SDMMC_GetCmdResp1>

0808b64c <SDMMC_CmdErase>:
  SDMMCx->ARG = Command->Argument;
 808b64c:	2200      	movs	r2, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b64e:	f44f 4370 	mov.w	r3, #61440	; 0xf000
{
 808b652:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b654:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b658:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b65a:	68c1      	ldr	r1, [r0, #12]
 808b65c:	f240 4566 	movw	r5, #1126	; 0x466
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE, SDMMC_MAXERASETIMEOUT);
 808b660:	f24f 6218 	movw	r2, #63000	; 0xf618
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b664:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE, SDMMC_MAXERASETIMEOUT);
 808b666:	2126      	movs	r1, #38	; 0x26
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b668:	431d      	orrs	r5, r3
 808b66a:	60c5      	str	r5, [r0, #12]
}
 808b66c:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE, SDMMC_MAXERASETIMEOUT);
 808b66e:	f7ff be7b 	b.w	808b368 <SDMMC_GetCmdResp1>
 808b672:	bf00      	nop

0808b674 <SDMMC_CmdStopTransfer>:
  SDMMCx->ARG = Command->Argument;
 808b674:	2200      	movs	r2, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b676:	f44f 4370 	mov.w	r3, #61440	; 0xf000
{
 808b67a:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b67c:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b680:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b682:	68c1      	ldr	r1, [r0, #12]
 808b684:	f240 454c 	movw	r5, #1100	; 0x44c
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, 100000000/*SDMMC_CMDTIMEOUT*/);
 808b688:	f44f 4261 	mov.w	r2, #57600	; 0xe100
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b68c:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, 100000000/*SDMMC_CMDTIMEOUT*/);
 808b68e:	210c      	movs	r1, #12
 808b690:	f2c0 52f5 	movt	r2, #1525	; 0x5f5
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b694:	431d      	orrs	r5, r3
 808b696:	60c5      	str	r5, [r0, #12]
}
 808b698:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, 100000000/*SDMMC_CMDTIMEOUT*/);
 808b69a:	f7ff be65 	b.w	808b368 <SDMMC_GetCmdResp1>
 808b69e:	bf00      	nop

0808b6a0 <SDMMC_CmdSelDesel>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6a0:	f44f 4370 	mov.w	r3, #61440	; 0xf000
{
 808b6a4:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6a6:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b6aa:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6ac:	68c1      	ldr	r1, [r0, #12]
 808b6ae:	f240 4547 	movw	r5, #1095	; 0x447
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 808b6b2:	f241 3288 	movw	r2, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6b6:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 808b6b8:	2107      	movs	r1, #7
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6ba:	431d      	orrs	r5, r3
 808b6bc:	60c5      	str	r5, [r0, #12]
}
 808b6be:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 808b6c0:	f7ff be52 	b.w	808b368 <SDMMC_GetCmdResp1>

0808b6c4 <SDMMC_CmdGoIdleState>:
{
 808b6c4:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b6c6:	f24b 3474 	movw	r4, #45940	; 0xb374
{
 808b6ca:	4601      	mov	r1, r0
  SDMMCx->ARG = Command->Argument;
 808b6cc:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b6ce:	f644 55d3 	movw	r5, #19923	; 0x4dd3
 808b6d2:	f2c2 0400 	movt	r4, #8192	; 0x2000
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6d6:	f44f 4270 	mov.w	r2, #61440	; 0xf000
  SDMMCx->ARG = Command->Argument;
 808b6da:	6083      	str	r3, [r0, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b6dc:	f2c1 0562 	movt	r5, #4194	; 0x1062
 808b6e0:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6e2:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 808b6e6:	68cc      	ldr	r4, [r1, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b6e8:	f241 3388 	movw	r3, #5000	; 0x1388
 808b6ec:	fba5 5000 	umull	r5, r0, r5, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6f0:	4022      	ands	r2, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b6f2:	0a40      	lsrs	r0, r0, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6f4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b6f8:	fb03 f300 	mul.w	r3, r3, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b6fc:	60ca      	str	r2, [r1, #12]
 808b6fe:	e002      	b.n	808b706 <SDMMC_CmdGoIdleState+0x42>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 808b700:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 808b702:	0612      	lsls	r2, r2, #24
 808b704:	d406      	bmi.n	808b714 <SDMMC_CmdGoIdleState+0x50>
    if (count-- == 0)
 808b706:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 808b70a:	d2f9      	bcs.n	808b700 <SDMMC_CmdGoIdleState+0x3c>
      return SDMMC_ERROR_TIMEOUT;
 808b70c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 808b710:	bc30      	pop	{r4, r5}
 808b712:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
 808b714:	f240 53ff 	movw	r3, #1535	; 0x5ff
  return SDMMC_ERROR_NONE;
 808b718:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
 808b71a:	638b      	str	r3, [r1, #56]	; 0x38
}
 808b71c:	bc30      	pop	{r4, r5}
 808b71e:	4770      	bx	lr

0808b720 <SDMMC_CmdOperCond>:
{
 808b720:	b430      	push	{r4, r5}
  */
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b722:	f24b 3474 	movw	r4, #45940	; 0xb374
{
 808b726:	4601      	mov	r1, r0
  SDMMCx->ARG = Command->Argument;
 808b728:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b72c:	f644 55d3 	movw	r5, #19923	; 0x4dd3
 808b730:	f2c2 0400 	movt	r4, #8192	; 0x2000
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b734:	f44f 4270 	mov.w	r2, #61440	; 0xf000
  SDMMCx->ARG = Command->Argument;
 808b738:	6083      	str	r3, [r0, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b73a:	f2c1 0562 	movt	r5, #4194	; 0x1062
 808b73e:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b740:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 808b744:	68cc      	ldr	r4, [r1, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b746:	f241 3388 	movw	r3, #5000	; 0x1388
 808b74a:	fba5 5000 	umull	r5, r0, r5, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b74e:	4022      	ands	r2, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b750:	0a40      	lsrs	r0, r0, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b752:	f442 6289 	orr.w	r2, r2, #1096	; 0x448
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b756:	fb03 f300 	mul.w	r3, r3, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b75a:	60ca      	str	r2, [r1, #12]
 808b75c:	e003      	b.n	808b766 <SDMMC_CmdOperCond+0x46>
    if (count-- == 0)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 808b75e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 808b760:	f012 0f45 	tst.w	r2, #69	; 0x45
 808b764:	d106      	bne.n	808b774 <SDMMC_CmdOperCond+0x54>
    if (count-- == 0)
 808b766:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 808b76a:	d2f8      	bcs.n	808b75e <SDMMC_CmdOperCond+0x3e>
      return SDMMC_ERROR_TIMEOUT;
 808b76c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 808b770:	bc30      	pop	{r4, r5}
 808b772:	4770      	bx	lr

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 808b774:	6b48      	ldr	r0, [r1, #52]	; 0x34
 808b776:	f010 0004 	ands.w	r0, r0, #4
 808b77a:	d10a      	bne.n	808b792 <SDMMC_CmdOperCond+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 808b77c:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 808b77e:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 808b782:	d003      	beq.n	808b78c <SDMMC_CmdOperCond+0x6c>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 808b784:	2340      	movs	r3, #64	; 0x40
 808b786:	638b      	str	r3, [r1, #56]	; 0x38
}
 808b788:	bc30      	pop	{r4, r5}
 808b78a:	4770      	bx	lr
  }
  
  return SDMMC_ERROR_NONE;
 808b78c:	4618      	mov	r0, r3
}
 808b78e:	bc30      	pop	{r4, r5}
 808b790:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 808b792:	2340      	movs	r3, #64	; 0x40
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 808b794:	2004      	movs	r0, #4
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 808b796:	638b      	str	r3, [r1, #56]	; 0x38
}
 808b798:	bc30      	pop	{r4, r5}
 808b79a:	4770      	bx	lr

0808b79c <SDMMC_CmdAppCommand>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b79c:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
 808b7a0:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b7a4:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7a6:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b7aa:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7ac:	68c1      	ldr	r1, [r0, #12]
 808b7ae:	f240 4577 	movw	r5, #1143	; 0x477
 808b7b2:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
 808b7b4:	2137      	movs	r1, #55	; 0x37
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7b6:	431d      	orrs	r5, r3
 808b7b8:	60c5      	str	r5, [r0, #12]
}
 808b7ba:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
 808b7bc:	f7ff bdd4 	b.w	808b368 <SDMMC_GetCmdResp1>

0808b7c0 <SDMMC_CmdAppOperCommand>:
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
 808b7c0:	2200      	movs	r2, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7c2:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
 808b7c6:	f2c8 0210 	movt	r2, #32784	; 0x8010
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7ca:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
 808b7ce:	430a      	orrs	r2, r1
{
 808b7d0:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 808b7d2:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7d4:	f240 4569 	movw	r5, #1129	; 0x469
 808b7d8:	68c2      	ldr	r2, [r0, #12]
 808b7da:	4013      	ands	r3, r2
 808b7dc:	431d      	orrs	r5, r3
 808b7de:	60c5      	str	r5, [r0, #12]
}
 808b7e0:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 808b7e2:	f7ff bd95 	b.w	808b310 <SDMMC_GetCmdResp3>
 808b7e6:	bf00      	nop

0808b7e8 <SDMMC_CmdBusWidth>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7e8:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
 808b7ec:	f241 3288 	movw	r2, #5000	; 0x1388
{
 808b7f0:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7f2:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b7f6:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b7f8:	68c1      	ldr	r1, [r0, #12]
 808b7fa:	f240 4546 	movw	r5, #1094	; 0x446
 808b7fe:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
 808b800:	2106      	movs	r1, #6
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b802:	431d      	orrs	r5, r3
 808b804:	60c5      	str	r5, [r0, #12]
}
 808b806:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
 808b808:	f7ff bdae 	b.w	808b368 <SDMMC_GetCmdResp1>

0808b80c <SDMMC_CmdSendSCR>:
  SDMMCx->ARG = Command->Argument;
 808b80c:	2200      	movs	r2, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b80e:	f44f 4370 	mov.w	r3, #61440	; 0xf000
{
 808b812:	b430      	push	{r4, r5}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b814:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b818:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b81a:	68c1      	ldr	r1, [r0, #12]
 808b81c:	f240 4573 	movw	r5, #1139	; 0x473
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
 808b820:	f241 3288 	movw	r2, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b824:	400b      	ands	r3, r1
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
 808b826:	2133      	movs	r1, #51	; 0x33
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b828:	431d      	orrs	r5, r3
 808b82a:	60c5      	str	r5, [r0, #12]
}
 808b82c:	bc30      	pop	{r4, r5}
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
 808b82e:	f7ff bd9b 	b.w	808b368 <SDMMC_GetCmdResp1>
 808b832:	bf00      	nop

0808b834 <SDMMC_CmdSendCID>:
{
 808b834:	b410      	push	{r4}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b836:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  SDMMCx->ARG = Command->Argument;
 808b83a:	2400      	movs	r4, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b83c:	f240 41c2 	movw	r1, #1218	; 0x4c2
  SDMMCx->ARG = Command->Argument;
 808b840:	6084      	str	r4, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b842:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 808b846:	68c4      	ldr	r4, [r0, #12]
 808b848:	4023      	ands	r3, r4
}
 808b84a:	f85d 4b04 	ldr.w	r4, [sp], #4
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b84e:	4319      	orrs	r1, r3
 808b850:	60c1      	str	r1, [r0, #12]
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 808b852:	f7ff bd2b 	b.w	808b2ac <SDMMC_GetCmdResp2>
 808b856:	bf00      	nop

0808b858 <SDMMC_CmdSendCSD>:
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b858:	f44f 4370 	mov.w	r3, #61440	; 0xf000
{
 808b85c:	b410      	push	{r4}
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b85e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  SDMMCx->ARG = Command->Argument;
 808b862:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b864:	68c1      	ldr	r1, [r0, #12]
 808b866:	f240 44c9 	movw	r4, #1225	; 0x4c9
 808b86a:	400b      	ands	r3, r1
 808b86c:	431c      	orrs	r4, r3
 808b86e:	60c4      	str	r4, [r0, #12]
}
 808b870:	f85d 4b04 	ldr.w	r4, [sp], #4
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 808b874:	f7ff bd1a 	b.w	808b2ac <SDMMC_GetCmdResp2>

0808b878 <SDMMC_CmdSetRelAdd>:
{
 808b878:	b470      	push	{r4, r5, r6}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b87a:	f24b 3574 	movw	r5, #45940	; 0xb374
  SDMMCx->ARG = Command->Argument;
 808b87e:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b880:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b884:	f44f 4470 	mov.w	r4, #61440	; 0xf000
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b888:	f2c2 0500 	movt	r5, #8192	; 0x2000
  SDMMCx->ARG = Command->Argument;
 808b88c:	6083      	str	r3, [r0, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b88e:	f2c1 0262 	movt	r2, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b892:	68c6      	ldr	r6, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b894:	682b      	ldr	r3, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b896:	f6cf 74ff 	movt	r4, #65535	; 0xffff
 808b89a:	f240 4543 	movw	r5, #1091	; 0x443
{
 808b89e:	b083      	sub	sp, #12
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b8a0:	fba2 3203 	umull	r3, r2, r2, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b8a4:	4034      	ands	r4, r6
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b8a6:	f241 3388 	movw	r3, #5000	; 0x1388
 808b8aa:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b8ac:	4325      	orrs	r5, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8 /1000);
 808b8ae:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 808b8b2:	60c5      	str	r5, [r0, #12]
 808b8b4:	e003      	b.n	808b8be <SDMMC_CmdSetRelAdd+0x46>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 808b8b6:	6b42      	ldr	r2, [r0, #52]	; 0x34
 808b8b8:	f012 0f45 	tst.w	r2, #69	; 0x45
 808b8bc:	d107      	bne.n	808b8ce <SDMMC_CmdSetRelAdd+0x56>
    if (count-- == 0)
 808b8be:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 808b8c2:	d2f8      	bcs.n	808b8b6 <SDMMC_CmdSetRelAdd+0x3e>
      return SDMMC_ERROR_TIMEOUT;
 808b8c4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 808b8c8:	b003      	add	sp, #12
 808b8ca:	bc70      	pop	{r4, r5, r6}
 808b8cc:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 808b8ce:	6b43      	ldr	r3, [r0, #52]	; 0x34
 808b8d0:	075c      	lsls	r4, r3, #29
 808b8d2:	d411      	bmi.n	808b8f8 <SDMMC_CmdSetRelAdd+0x80>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 808b8d4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 808b8d6:	f013 0301 	ands.w	r3, r3, #1
 808b8da:	d107      	bne.n	808b8ec <SDMMC_CmdSetRelAdd+0x74>
  return (uint8_t)(SDMMCx->RESPCMD);
 808b8dc:	6902      	ldr	r2, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 808b8de:	b2d2      	uxtb	r2, r2
 808b8e0:	2a03      	cmp	r2, #3
 808b8e2:	d00f      	beq.n	808b904 <SDMMC_CmdSetRelAdd+0x8c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 808b8e4:	2001      	movs	r0, #1
}
 808b8e6:	b003      	add	sp, #12
 808b8e8:	bc70      	pop	{r4, r5, r6}
 808b8ea:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 808b8ec:	2301      	movs	r3, #1
 808b8ee:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 808b8f0:	4618      	mov	r0, r3
}
 808b8f2:	b003      	add	sp, #12
 808b8f4:	bc70      	pop	{r4, r5, r6}
 808b8f6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 808b8f8:	2304      	movs	r3, #4
 808b8fa:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 808b8fc:	4618      	mov	r0, r3
}
 808b8fe:	b003      	add	sp, #12
 808b900:	bc70      	pop	{r4, r5, r6}
 808b902:	4770      	bx	lr
  tmp = (uint32_t)&(SDMMCx->RESP1) + Response;
 808b904:	f100 0214 	add.w	r2, r0, #20
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_FLAGS);
 808b908:	f240 54ff 	movw	r4, #1535	; 0x5ff
 808b90c:	6384      	str	r4, [r0, #56]	; 0x38
  __IO uint32_t tmp = 0;
 808b90e:	9301      	str	r3, [sp, #4]
  tmp = (uint32_t)&(SDMMCx->RESP1) + Response;
 808b910:	9201      	str	r2, [sp, #4]
  return (*(__IO uint32_t *) tmp);
 808b912:	9b01      	ldr	r3, [sp, #4]
 808b914:	681b      	ldr	r3, [r3, #0]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 808b916:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
 808b91a:	d009      	beq.n	808b930 <SDMMC_CmdSetRelAdd+0xb8>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 808b91c:	045a      	lsls	r2, r3, #17
 808b91e:	d40a      	bmi.n	808b936 <SDMMC_CmdSetRelAdd+0xbe>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 808b920:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 808b924:	bf14      	ite	ne
 808b926:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 808b92a:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 808b92e:	e7cb      	b.n	808b8c8 <SDMMC_CmdSetRelAdd+0x50>
    *pRCA = (uint16_t) (response_r1 >> 16);
 808b930:	0c1b      	lsrs	r3, r3, #16
 808b932:	800b      	strh	r3, [r1, #0]
 808b934:	e7c8      	b.n	808b8c8 <SDMMC_CmdSetRelAdd+0x50>
    return SDMMC_ERROR_ILLEGAL_CMD;
 808b936:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 808b93a:	e7c5      	b.n	808b8c8 <SDMMC_CmdSetRelAdd+0x50>

0808b93c <LEGACY_GUI_ProgressBar>:
#include "stm32746g_discovery.h"
#include "gui.h"
#include "../wrapper.h"

void LEGACY_GUI_ProgressBar(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t val, uint8_t maxval)
{
 808b93c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 808b940:	4681      	mov	r9, r0
 808b942:	b081      	sub	sp, #4
	uint16_t length;

	/* dessin du cadre */
	GLCD_SetTextColor(Black);
	GLCD_DrawLine(x,y,x+w,y);
 808b944:	1884      	adds	r4, r0, r2
{
 808b946:	4688      	mov	r8, r1
	GLCD_DrawLine(x,y,x,y+h);
 808b948:	eb01 0b03 	add.w	fp, r1, r3
	GLCD_SetTextColor(Black);
 808b94c:	2000      	movs	r0, #0
{
 808b94e:	f89d 6028 	ldrb.w	r6, [sp, #40]	; 0x28
 808b952:	4617      	mov	r7, r2
 808b954:	f89d a02c 	ldrb.w	sl, [sp, #44]	; 0x2c
 808b958:	461d      	mov	r5, r3
	GLCD_SetTextColor(Black);
 808b95a:	f000 fd61 	bl	808c420 <GLCD_SetTextColor>
	GLCD_DrawLine(x,y,x+w,y);
 808b95e:	4622      	mov	r2, r4
 808b960:	4643      	mov	r3, r8
 808b962:	4641      	mov	r1, r8
 808b964:	4648      	mov	r0, r9
	GLCD_DrawLine(x,y+h,x+w,y+h);

	if (val>maxval) val = maxval;

	/* Dessin du remplissage */
	length = (uint16_t)(val * (w-4)) /maxval;
 808b966:	3f04      	subs	r7, #4
	GLCD_DrawLine(x,y,x+w,y);
 808b968:	f000 fdfe 	bl	808c568 <GLCD_DrawLine>
	GLCD_DrawLine(x,y,x,y+h);
 808b96c:	465b      	mov	r3, fp
 808b96e:	464a      	mov	r2, r9
 808b970:	4641      	mov	r1, r8
 808b972:	4648      	mov	r0, r9
 808b974:	f000 fdf8 	bl	808c568 <GLCD_DrawLine>
	GLCD_DrawLine(x+w,y,x+w,y+h);
 808b978:	465b      	mov	r3, fp
 808b97a:	4622      	mov	r2, r4
 808b97c:	4641      	mov	r1, r8
 808b97e:	4620      	mov	r0, r4

	GLCD_SetTextColor(Blue);
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+length , (y+2)+h-4);
 808b980:	f108 0802 	add.w	r8, r8, #2
	GLCD_DrawLine(x+w,y,x+w,y+h);
 808b984:	f000 fdf0 	bl	808c568 <GLCD_DrawLine>
	GLCD_DrawLine(x,y+h,x+w,y+h);
 808b988:	465b      	mov	r3, fp
 808b98a:	4622      	mov	r2, r4
 808b98c:	4659      	mov	r1, fp
 808b98e:	4648      	mov	r0, r9
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+length , (y+2)+h-4);
 808b990:	4445      	add	r5, r8
	GLCD_DrawLine(x,y+h,x+w,y+h);
 808b992:	f000 fde9 	bl	808c568 <GLCD_DrawLine>
	length = (uint16_t)(val * (w-4)) /maxval;
 808b996:	4556      	cmp	r6, sl
	GLCD_SetTextColor(Blue);
 808b998:	f04f 0003 	mov.w	r0, #3
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+length , (y+2)+h-4);
 808b99c:	f1a5 0504 	sub.w	r5, r5, #4
	length = (uint16_t)(val * (w-4)) /maxval;
 808b9a0:	bf28      	it	cs
 808b9a2:	4656      	movcs	r6, sl
	GLCD_SetTextColor(Blue);
 808b9a4:	f000 fd3c 	bl	808c420 <GLCD_SetTextColor>
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+length , (y+2)+h-4);
 808b9a8:	f109 0002 	add.w	r0, r9, #2
 808b9ac:	4641      	mov	r1, r8
	length = (uint16_t)(val * (w-4)) /maxval;
 808b9ae:	fb16 f407 	smulbb	r4, r6, r7
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+length , (y+2)+h-4);
 808b9b2:	462b      	mov	r3, r5
	length = (uint16_t)(val * (w-4)) /maxval;
 808b9b4:	b2a4      	uxth	r4, r4
 808b9b6:	fb94 f4fa 	sdiv	r4, r4, sl
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+length , (y+2)+h-4);
 808b9ba:	1826      	adds	r6, r4, r0
 808b9bc:	4632      	mov	r2, r6
 808b9be:	f000 fdef 	bl	808c5a0 <GLCD_DrawFillRectangle>

	GLCD_SetTextColor(White);
 808b9c2:	20ff      	movs	r0, #255	; 0xff
 808b9c4:	f000 fd2c 	bl	808c420 <GLCD_SetTextColor>
	GLCD_DrawFillRectangle(x+2+length+1, y+2, (x+2+length+1)+(w-4)-length, (y+2)+ h-4);
 808b9c8:	1c70      	adds	r0, r6, #1
 808b9ca:	462b      	mov	r3, r5
 808b9cc:	4641      	mov	r1, r8
 808b9ce:	183a      	adds	r2, r7, r0
 808b9d0:	1b12      	subs	r2, r2, r4
}
 808b9d2:	b001      	add	sp, #4
 808b9d4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	GLCD_DrawFillRectangle(x+2+length+1, y+2, (x+2+length+1)+(w-4)-length, (y+2)+ h-4);
 808b9d8:	f000 bde2 	b.w	808c5a0 <GLCD_DrawFillRectangle>

0808b9dc <LEGACY_GUI_CenterBar>:

void LEGACY_GUI_CenterBar(uint16_t x, uint16_t y, uint16_t w, uint16_t h, int val, uint32_t absolutemaxval)
{
 808b9dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int length_tot;
	uint16_t length;

	/* dessin du cadre */
	GLCD_SetTextColor(Black);
	GLCD_DrawLine(x,y,x+w,y);
 808b9e0:	1887      	adds	r7, r0, r2
{
 808b9e2:	b081      	sub	sp, #4
 808b9e4:	4606      	mov	r6, r0
 808b9e6:	460d      	mov	r5, r1
	GLCD_DrawLine(x,y,x,y+h);
 808b9e8:	eb01 0b03 	add.w	fp, r1, r3
	GLCD_SetTextColor(Black);
 808b9ec:	2000      	movs	r0, #0
{
 808b9ee:	4691      	mov	r9, r2
 808b9f0:	4698      	mov	r8, r3
 808b9f2:	e9dd 4a0a 	ldrd	r4, sl, [sp, #40]	; 0x28
	GLCD_SetTextColor(Black);
 808b9f6:	f000 fd13 	bl	808c420 <GLCD_SetTextColor>
	GLCD_DrawLine(x,y,x+w,y);
 808b9fa:	463a      	mov	r2, r7
 808b9fc:	462b      	mov	r3, r5
 808b9fe:	4629      	mov	r1, r5
 808ba00:	4630      	mov	r0, r6
 808ba02:	f000 fdb1 	bl	808c568 <GLCD_DrawLine>
	GLCD_DrawLine(x,y,x,y+h);
 808ba06:	465b      	mov	r3, fp
 808ba08:	4632      	mov	r2, r6
 808ba0a:	4629      	mov	r1, r5
 808ba0c:	4630      	mov	r0, r6
 808ba0e:	f000 fdab 	bl	808c568 <GLCD_DrawLine>
	GLCD_DrawLine(x+w,y,x+w,y+h);
 808ba12:	465b      	mov	r3, fp
 808ba14:	463a      	mov	r2, r7
 808ba16:	4629      	mov	r1, r5
 808ba18:	4638      	mov	r0, r7
 808ba1a:	f000 fda5 	bl	808c568 <GLCD_DrawLine>
	GLCD_DrawLine(x,y+h,x+w,y+h);
 808ba1e:	465b      	mov	r3, fp
 808ba20:	463a      	mov	r2, r7
 808ba22:	4659      	mov	r1, fp
 808ba24:	4630      	mov	r0, r6
 808ba26:	f000 fd9f 	bl	808c568 <GLCD_DrawLine>

	if ((val>0) && ((uint32_t)val >= absolutemaxval)) 
 808ba2a:	2c00      	cmp	r4, #0
 808ba2c:	dd03      	ble.n	808ba36 <LEGACY_GUI_CenterBar+0x5a>
 808ba2e:	4554      	cmp	r4, sl
	{
		val = absolutemaxval-1;
 808ba30:	bf28      	it	cs
 808ba32:	f10a 34ff 	addcs.w	r4, sl, #4294967295	; 0xffffffff
	}

	if ((val<0) && ((uint32_t)(-val) >= absolutemaxval)) 
 808ba36:	2c00      	cmp	r4, #0
 808ba38:	da04      	bge.n	808ba44 <LEGACY_GUI_CenterBar+0x68>
 808ba3a:	4263      	negs	r3, r4
 808ba3c:	4553      	cmp	r3, sl
	{
		val = -(absolutemaxval-1);
 808ba3e:	bf28      	it	cs
 808ba40:	f1ca 0401 	rsbcs	r4, sl, #1
	}
	//	if ((val<0) && (-val >absolutemaxval)) val = -absolutemaxval;

	/* Dessin du remplissage */
	length1 = (int)((w-4)/2);
 808ba44:	f1a9 0704 	sub.w	r7, r9, #4
	length2 = (int)(length2/2);
	length_tot = length1 + length2;
	length = (uint16_t)length_tot;

	GLCD_SetTextColor(Blue);
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+ length, (y+2) + h-4);
 808ba48:	3502      	adds	r5, #2
	GLCD_SetTextColor(Blue);
 808ba4a:	2003      	movs	r0, #3
	length2 = (int)(((int)val * (int)(w-4)) /((int)absolutemaxval));
 808ba4c:	fb04 f407 	mul.w	r4, r4, r7
	length1 = (int)((w-4)/2);
 808ba50:	2f00      	cmp	r7, #0
 808ba52:	463b      	mov	r3, r7
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+ length, (y+2) + h-4);
 808ba54:	44a8      	add	r8, r5
	length1 = (int)((w-4)/2);
 808ba56:	bfb8      	it	lt
 808ba58:	f1a9 0303 	sublt.w	r3, r9, #3
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+ length, (y+2) + h-4);
 808ba5c:	f1a8 0804 	sub.w	r8, r8, #4
	length1 = (int)((w-4)/2);
 808ba60:	105b      	asrs	r3, r3, #1
	length2 = (int)(((int)val * (int)(w-4)) /((int)absolutemaxval));
 808ba62:	fb94 f4fa 	sdiv	r4, r4, sl
	length2 = (int)(length2/2);
 808ba66:	2c00      	cmp	r4, #0
 808ba68:	bfb8      	it	lt
 808ba6a:	3401      	addlt	r4, #1
	length_tot = length1 + length2;
 808ba6c:	eb03 0464 	add.w	r4, r3, r4, asr #1
	GLCD_SetTextColor(Blue);
 808ba70:	f000 fcd6 	bl	808c420 <GLCD_SetTextColor>
	GLCD_DrawFillRectangle(x+2, y+2, (x+2)+ length, (y+2) + h-4);
 808ba74:	1cb0      	adds	r0, r6, #2
 808ba76:	b2a4      	uxth	r4, r4
 808ba78:	4629      	mov	r1, r5
 808ba7a:	4643      	mov	r3, r8
 808ba7c:	1906      	adds	r6, r0, r4
 808ba7e:	4632      	mov	r2, r6
 808ba80:	f000 fd8e 	bl	808c5a0 <GLCD_DrawFillRectangle>

	GLCD_SetTextColor(White);
 808ba84:	20ff      	movs	r0, #255	; 0xff
 808ba86:	f000 fccb 	bl	808c420 <GLCD_SetTextColor>
	GLCD_DrawFillRectangle(x+2+length+1, y+2, (x+2+length+1)+(w-4)-length, (y+2)+h-4);
 808ba8a:	1c70      	adds	r0, r6, #1
 808ba8c:	4643      	mov	r3, r8
 808ba8e:	4629      	mov	r1, r5
 808ba90:	183a      	adds	r2, r7, r0
 808ba92:	1b12      	subs	r2, r2, r4
}
 808ba94:	b001      	add	sp, #4
 808ba96:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	GLCD_DrawFillRectangle(x+2+length+1, y+2, (x+2+length+1)+(w-4)-length, (y+2)+h-4);
 808ba9a:	f000 bd81 	b.w	808c5a0 <GLCD_DrawFillRectangle>
 808ba9e:	bf00      	nop

0808baa0 <LEGACY_GUI_CreateWindow>:
#include "string.h"

const char* blackbkg="                                        ";

void LEGACY_GUI_CreateWindow(const char *title, COLOR background, COLOR titlebarText, COLOR titlebarBgnd)
{
 808baa0:	b570      	push	{r4, r5, r6, lr}
 808baa2:	4616      	mov	r6, r2
 808baa4:	461d      	mov	r5, r3
 808baa6:	4604      	mov	r4, r0
	GLCD_Clear(background);
 808baa8:	4608      	mov	r0, r1
 808baaa:	f000 fc95 	bl	808c3d8 <GLCD_Clear>
	GLCD_SetTextColor(titlebarText);
 808baae:	4630      	mov	r0, r6
 808bab0:	f000 fcb6 	bl	808c420 <GLCD_SetTextColor>
	GLCD_SetBackColor(titlebarBgnd);
 808bab4:	4628      	mov	r0, r5
 808bab6:	f000 fcc9 	bl	808c44c <GLCD_SetBackColor>
	GLCD_DrawString(0,0,blackbkg);
 808baba:	f24b 0384 	movw	r3, #45188	; 0xb084
 808babe:	2100      	movs	r1, #0
 808bac0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bac4:	4608      	mov	r0, r1
 808bac6:	681a      	ldr	r2, [r3, #0]
 808bac8:	f000 fd16 	bl	808c4f8 <GLCD_DrawString>
	GLCD_DrawString((40-strlen(title))/2, 0, title);
 808bacc:	4620      	mov	r0, r4
 808bace:	f7f4 fab7 	bl	8080040 <strlen>
 808bad2:	f1c0 0028 	rsb	r0, r0, #40	; 0x28
 808bad6:	4622      	mov	r2, r4
 808bad8:	2100      	movs	r1, #0
 808bada:	0840      	lsrs	r0, r0, #1
}
 808badc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	GLCD_DrawString((40-strlen(title))/2, 0, title);
 808bae0:	f000 bd0a 	b.w	808c4f8 <GLCD_DrawString>
	...

0808baf0 <ABI_Ptr_Table>:
 808baf0:	0808bbf9 	.word	0x0808bbf9
 808baf4:	0808bf69 	.word	0x0808bf69
 808baf8:	0808bfb9 	.word	0x0808bfb9
 808bafc:	0808bc01 	.word	0x0808bc01
 808bb00:	0808bc01 	.word	0x0808bc01
 808bb04:	0808bc01 	.word	0x0808bc01
 808bb08:	0808c3cd 	.word	0x0808c3cd
 808bb0c:	0808c3d9 	.word	0x0808c3d9
 808bb10:	0808c421 	.word	0x0808c421
 808bb14:	0808c44d 	.word	0x0808c44d
 808bb18:	0808c479 	.word	0x0808c479
 808bb1c:	0808c4b1 	.word	0x0808c4b1
 808bb20:	0808c535 	.word	0x0808c535
 808bb24:	0808c569 	.word	0x0808c569
 808bb28:	0808c57d 	.word	0x0808c57d
 808bb2c:	0808c5a1 	.word	0x0808c5a1
 808bb30:	0808c5c5 	.word	0x0808c5c5
 808bb34:	0808c5d5 	.word	0x0808c5d5
 808bb38:	0808c5e5 	.word	0x0808c5e5
 808bb3c:	0808c6b9 	.word	0x0808c6b9
 808bb40:	0808c6cd 	.word	0x0808c6cd
 808bb44:	0808c6d5 	.word	0x0808c6d5
 808bb48:	0808c79d 	.word	0x0808c79d
 808bb4c:	0808c819 	.word	0x0808c819
 808bb50:	0808c81d 	.word	0x0808c81d
 808bb54:	0808c829 	.word	0x0808c829
 808bb58:	0808c865 	.word	0x0808c865
 808bb5c:	0808c86d 	.word	0x0808c86d
 808bb60:	0808c909 	.word	0x0808c909
 808bb64:	0808c941 	.word	0x0808c941
 808bb68:	0808c969 	.word	0x0808c969
 808bb6c:	0808c991 	.word	0x0808c991
 808bb70:	0808c9c9 	.word	0x0808c9c9
 808bb74:	0808c9d5 	.word	0x0808c9d5
 808bb78:	0808c9e1 	.word	0x0808c9e1
 808bb7c:	0808ca01 	.word	0x0808ca01
 808bb80:	0808ca45 	.word	0x0808ca45
 808bb84:	0808ca65 	.word	0x0808ca65
 808bb88:	0808ca79 	.word	0x0808ca79
 808bb8c:	0808c62d 	.word	0x0808c62d
 808bb90:	0808c679 	.word	0x0808c679
 808bb94:	0808c67d 	.word	0x0808c67d
 808bb98:	0808c681 	.word	0x0808c681
 808bb9c:	0808c685 	.word	0x0808c685
 808bba0:	0808c689 	.word	0x0808c689
 808bba4:	0808c68d 	.word	0x0808c68d
 808bba8:	0808c691 	.word	0x0808c691
 808bbac:	0808c695 	.word	0x0808c695
 808bbb0:	0808c699 	.word	0x0808c699
 808bbb4:	0808c69d 	.word	0x0808c69d
 808bbb8:	0808c6a1 	.word	0x0808c6a1
 808bbbc:	0808c6a5 	.word	0x0808c6a5
 808bbc0:	0808c6a9 	.word	0x0808c6a9
 808bbc4:	0808c6ad 	.word	0x0808c6ad
 808bbc8:	0808c6b1 	.word	0x0808c6b1
 808bbcc:	0808c6b5 	.word	0x0808c6b5
 808bbd0:	0808ce85 	.word	0x0808ce85
 808bbd4:	0808cee1 	.word	0x0808cee1
 808bbd8:	0808cf35 	.word	0x0808cf35
 808bbdc:	0808cf45 	.word	0x0808cf45
 808bbe0:	0808cf65 	.word	0x0808cf65
 808bbe4:	0808cf7d 	.word	0x0808cf7d
 808bbe8:	0808d00d 	.word	0x0808d00d
 808bbec:	0808cb09 	.word	0x0808cb09
 808bbf0:	0808cb7d 	.word	0x0808cb7d
 808bbf4:	0808cba5 	.word	0x0808cba5

0808bbf8 <API_GetOSVersion>:
	(void *)ABI_Ptr_Table
};

void API_GetOSVersion(int* major, int* minor)
{
	*major = BL_MAJOR_VERSION;
 808bbf8:	2301      	movs	r3, #1
 808bbfa:	6003      	str	r3, [r0, #0]
	*minor = BL_MINOR_VERSION;
 808bbfc:	600b      	str	r3, [r1, #0]
}
 808bbfe:	4770      	bx	lr

0808bc00 <API_InvalidFunction>:

void API_InvalidFunction(void)
{
	PANIC_SoftwarePanic("Invalid API Call", "Invalid function requested.");
 808bc00:	f642 11e0 	movw	r1, #10720	; 0x29e0
 808bc04:	f642 10fc 	movw	r0, #10748	; 0x29fc
 808bc08:	f6c0 0109 	movt	r1, #2057	; 0x809
 808bc0c:	f6c0 0009 	movt	r0, #2057	; 0x809
 808bc10:	f000 b968 	b.w	808bee4 <PANIC_SoftwarePanic>

0808bc14 <CONSOLE_GotoXY>:
int CONSOLE_X=0;
int CONSOLE_Y=0;

void CONSOLE_GotoXY(int x, int y)
{
	if ((x>=0) && (x<40)) CONSOLE_X=x;
 808bc14:	2827      	cmp	r0, #39	; 0x27
 808bc16:	d804      	bhi.n	808bc22 <CONSOLE_GotoXY+0xe>
 808bc18:	f64b 2378 	movw	r3, #47736	; 0xba78
 808bc1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bc20:	6018      	str	r0, [r3, #0]
	if ((y>=0) && (y<15)) CONSOLE_Y=y;
 808bc22:	290e      	cmp	r1, #14
 808bc24:	d804      	bhi.n	808bc30 <CONSOLE_GotoXY+0x1c>
 808bc26:	f64b 237c 	movw	r3, #47740	; 0xba7c
 808bc2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bc2e:	6019      	str	r1, [r3, #0]
}
 808bc30:	4770      	bx	lr
 808bc32:	bf00      	nop

0808bc34 <CONSOLE_PrintChar>:

int CONSOLE_PrintChar(int c)
{
	if ((c=='\n') || (c=='\r')) 
 808bc34:	280a      	cmp	r0, #10
{
 808bc36:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((c=='\n') || (c=='\r')) 
 808bc38:	d005      	beq.n	808bc46 <CONSOLE_PrintChar+0x12>
 808bc3a:	f1a0 060d 	sub.w	r6, r0, #13
 808bc3e:	fab6 f686 	clz	r6, r6
 808bc42:	0976      	lsrs	r6, r6, #5
 808bc44:	b196      	cbz	r6, 808bc6c <CONSOLE_PrintChar+0x38>
	{
		CONSOLE_X=0;
		CONSOLE_Y++;
 808bc46:	f64b 237c 	movw	r3, #47740	; 0xba7c
		CONSOLE_X=0;
 808bc4a:	f64b 2178 	movw	r1, #47736	; 0xba78
 808bc4e:	2000      	movs	r0, #0
		CONSOLE_Y++;
 808bc50:	f2c2 0300 	movt	r3, #8192	; 0x2000
		CONSOLE_X=0;
 808bc54:	f2c2 0100 	movt	r1, #8192	; 0x2000
		CONSOLE_Y++;
 808bc58:	681a      	ldr	r2, [r3, #0]
		CONSOLE_X=0;
 808bc5a:	6008      	str	r0, [r1, #0]
		CONSOLE_Y++;
 808bc5c:	3201      	adds	r2, #1

		if (CONSOLE_Y>=15) CONSOLE_Y--;
 808bc5e:	2a0e      	cmp	r2, #14
 808bc60:	dd01      	ble.n	808bc66 <CONSOLE_PrintChar+0x32>
			if (CONSOLE_Y>=15) CONSOLE_Y--;
		}
	}

	return 1;
}
 808bc62:	2001      	movs	r0, #1
 808bc64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		CONSOLE_Y++;
 808bc66:	601a      	str	r2, [r3, #0]
}
 808bc68:	2001      	movs	r0, #1
 808bc6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		GLCD_DrawChar(CONSOLE_X,CONSOLE_Y, (uint8_t)c);
 808bc6c:	f64b 277c 	movw	r7, #47740	; 0xba7c
 808bc70:	f64b 2578 	movw	r5, #47736	; 0xba78
 808bc74:	4604      	mov	r4, r0
		GLCD_SetTextColor(White);
 808bc76:	20ff      	movs	r0, #255	; 0xff
		GLCD_DrawChar(CONSOLE_X,CONSOLE_Y, (uint8_t)c);
 808bc78:	f2c2 0500 	movt	r5, #8192	; 0x2000
 808bc7c:	f2c2 0700 	movt	r7, #8192	; 0x2000
		GLCD_SetTextColor(White);
 808bc80:	f000 fbce 	bl	808c420 <GLCD_SetTextColor>
		GLCD_SetBackColor(Black);
 808bc84:	4630      	mov	r0, r6
 808bc86:	f000 fbe1 	bl	808c44c <GLCD_SetBackColor>
		GLCD_DrawChar(CONSOLE_X,CONSOLE_Y, (uint8_t)c);
 808bc8a:	6839      	ldr	r1, [r7, #0]
 808bc8c:	b2e2      	uxtb	r2, r4
 808bc8e:	6828      	ldr	r0, [r5, #0]
 808bc90:	f000 fc0e 	bl	808c4b0 <GLCD_DrawChar>
		CONSOLE_X++;
 808bc94:	682b      	ldr	r3, [r5, #0]
 808bc96:	3301      	adds	r3, #1
		if (CONSOLE_X>=40) 
 808bc98:	2b27      	cmp	r3, #39	; 0x27
 808bc9a:	dd07      	ble.n	808bcac <CONSOLE_PrintChar+0x78>
			CONSOLE_Y++;
 808bc9c:	683b      	ldr	r3, [r7, #0]
}
 808bc9e:	2001      	movs	r0, #1
			CONSOLE_X=0;
 808bca0:	602e      	str	r6, [r5, #0]
			CONSOLE_Y++;
 808bca2:	3301      	adds	r3, #1
			if (CONSOLE_Y>=15) CONSOLE_Y--;
 808bca4:	2b0e      	cmp	r3, #14
			CONSOLE_Y++;
 808bca6:	bfd8      	it	le
 808bca8:	603b      	strle	r3, [r7, #0]
}
 808bcaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		CONSOLE_X++;
 808bcac:	602b      	str	r3, [r5, #0]
}
 808bcae:	2001      	movs	r0, #1
 808bcb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808bcb2:	bf00      	nop

0808bcb4 <NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 808bcb4:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 808bcb8:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 808bcbc:	2304      	movs	r3, #4
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 808bcbe:	f2ce 0200 	movt	r2, #57344	; 0xe000
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 808bcc2:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 808bcc6:	68d1      	ldr	r1, [r2, #12]
 808bcc8:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 808bccc:	430b      	orrs	r3, r1
 808bcce:	60d3      	str	r3, [r2, #12]
 808bcd0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 808bcd4:	bf00      	nop
 808bcd6:	e7fd      	b.n	808bcd4 <NVIC_SystemReset+0x20>

0808bcd8 <PANIC_Display>:
void PANIC_Display(void) {
	char *title;
	char str[42];

	title ="";
	switch (IT_Source)
 808bcd8:	f64b 2380 	movw	r3, #47744	; 0xba80
 808bcdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bce0:	681b      	ldr	r3, [r3, #0]
 808bce2:	2b05      	cmp	r3, #5
void PANIC_Display(void) {
 808bce4:	b510      	push	{r4, lr}
 808bce6:	b08e      	sub	sp, #56	; 0x38
 808bce8:	d87d      	bhi.n	808bde6 <PANIC_Display+0x10e>
 808bcea:	f642 2210 	movw	r2, #10768	; 0x2a10
 808bcee:	f6c0 0209 	movt	r2, #2057	; 0x809
 808bcf2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
		break;
	default:
		title ="Unknown Error";
	}

	GUI_CreateWindow(title, Red, White, Black);
 808bcf6:	2300      	movs	r3, #0
 808bcf8:	22ff      	movs	r2, #255	; 0xff
 808bcfa:	21e0      	movs	r1, #224	; 0xe0

	GLCD_DrawString(0, 3, "Press A to try again");

	GLCD_DrawString(0, 14, "System halted !");
	GLCD_DrawString(0, 10, "Backtrace :");
	sprintf (str, "R0[%08X] R1[%08X] R2[%08X]", (unsigned int)R0, (unsigned int)R1, (unsigned int)R2);
 808bcfc:	f64b 2498 	movw	r4, #47768	; 0xba98
	GUI_CreateWindow(title, Red, White, Black);
 808bd00:	f000 fce6 	bl	808c6d0 <GUI_CreateWindow>
	GLCD_SetTextColor(White);
 808bd04:	20ff      	movs	r0, #255	; 0xff
 808bd06:	f000 fb8b 	bl	808c420 <GLCD_SetTextColor>
	GLCD_SetBackColor(Red);
 808bd0a:	20e0      	movs	r0, #224	; 0xe0
 808bd0c:	f000 fb9e 	bl	808c44c <GLCD_SetBackColor>
	GLCD_DrawString(0, 3, "Press A to try again");
 808bd10:	f642 2238 	movw	r2, #10808	; 0x2a38
 808bd14:	2103      	movs	r1, #3
 808bd16:	2000      	movs	r0, #0
 808bd18:	f6c0 0209 	movt	r2, #2057	; 0x809
	sprintf (str, "R0[%08X] R1[%08X] R2[%08X]", (unsigned int)R0, (unsigned int)R1, (unsigned int)R2);
 808bd1c:	f2c2 0400 	movt	r4, #8192	; 0x2000
	GLCD_DrawString(0, 3, "Press A to try again");
 808bd20:	f000 fbea 	bl	808c4f8 <GLCD_DrawString>
	GLCD_DrawString(0, 14, "System halted !");
 808bd24:	f642 2250 	movw	r2, #10832	; 0x2a50
 808bd28:	210e      	movs	r1, #14
 808bd2a:	2000      	movs	r0, #0
 808bd2c:	f6c0 0209 	movt	r2, #2057	; 0x809
 808bd30:	f000 fbe2 	bl	808c4f8 <GLCD_DrawString>
	GLCD_DrawString(0, 10, "Backtrace :");
 808bd34:	f642 2260 	movw	r2, #10848	; 0x2a60
 808bd38:	210a      	movs	r1, #10
 808bd3a:	2000      	movs	r0, #0
 808bd3c:	f6c0 0209 	movt	r2, #2057	; 0x809
 808bd40:	f000 fbda 	bl	808c4f8 <GLCD_DrawString>
	sprintf (str, "R0[%08X] R1[%08X] R2[%08X]", (unsigned int)R0, (unsigned int)R1, (unsigned int)R2);
 808bd44:	f64b 228c 	movw	r2, #47756	; 0xba8c
 808bd48:	f64b 2390 	movw	r3, #47760	; 0xba90
 808bd4c:	f642 216c 	movw	r1, #10860	; 0x2a6c
 808bd50:	f2c2 0200 	movt	r2, #8192	; 0x2000
 808bd54:	a803      	add	r0, sp, #12
 808bd56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bd5a:	f6c0 0109 	movt	r1, #2057	; 0x809
 808bd5e:	6812      	ldr	r2, [r2, #0]
 808bd60:	681b      	ldr	r3, [r3, #0]
 808bd62:	6824      	ldr	r4, [r4, #0]
 808bd64:	9400      	str	r4, [sp, #0]
	GLCD_DrawString(0, 11, str);
	sprintf (str, "R3[%08X] R12[%08X] LR[%08X]", (unsigned int)R3, (unsigned int)R12, (unsigned int)LR);
 808bd66:	f64b 2484 	movw	r4, #47748	; 0xba84
	sprintf (str, "R0[%08X] R1[%08X] R2[%08X]", (unsigned int)R0, (unsigned int)R1, (unsigned int)R2);
 808bd6a:	f006 f9b3 	bl	80920d4 <siprintf>
	GLCD_DrawString(0, 11, str);
 808bd6e:	aa03      	add	r2, sp, #12
 808bd70:	210b      	movs	r1, #11
 808bd72:	2000      	movs	r0, #0
 808bd74:	f000 fbc0 	bl	808c4f8 <GLCD_DrawString>
	sprintf (str, "R3[%08X] R12[%08X] LR[%08X]", (unsigned int)R3, (unsigned int)R12, (unsigned int)LR);
 808bd78:	f64b 229c 	movw	r2, #47772	; 0xba9c
 808bd7c:	f64b 2394 	movw	r3, #47764	; 0xba94
 808bd80:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808bd84:	f2c2 0200 	movt	r2, #8192	; 0x2000
 808bd88:	f642 2188 	movw	r1, #10888	; 0x2a88
 808bd8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bd90:	a803      	add	r0, sp, #12
 808bd92:	6812      	ldr	r2, [r2, #0]
 808bd94:	f6c0 0109 	movt	r1, #2057	; 0x809
 808bd98:	681b      	ldr	r3, [r3, #0]
 808bd9a:	6824      	ldr	r4, [r4, #0]
 808bd9c:	9400      	str	r4, [sp, #0]
 808bd9e:	f006 f999 	bl	80920d4 <siprintf>
	GLCD_DrawString(0, 12, str);
 808bda2:	aa03      	add	r2, sp, #12
 808bda4:	210c      	movs	r1, #12
 808bda6:	2000      	movs	r0, #0
 808bda8:	f000 fba6 	bl	808c4f8 <GLCD_DrawString>
	sprintf (str, "PC[%08X] XPSR[%08X]", (unsigned int)PC, (unsigned int)XPSR);
 808bdac:	f64b 2288 	movw	r2, #47752	; 0xba88
 808bdb0:	f64b 23a4 	movw	r3, #47780	; 0xbaa4
 808bdb4:	f642 21a4 	movw	r1, #10916	; 0x2aa4
 808bdb8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 808bdbc:	a803      	add	r0, sp, #12
 808bdbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bdc2:	f6c0 0109 	movt	r1, #2057	; 0x809
 808bdc6:	6812      	ldr	r2, [r2, #0]
 808bdc8:	681b      	ldr	r3, [r3, #0]
 808bdca:	f006 f983 	bl	80920d4 <siprintf>
	GLCD_DrawString(0, 13, str);
 808bdce:	aa03      	add	r2, sp, #12
 808bdd0:	210d      	movs	r1, #13
 808bdd2:	2000      	movs	r0, #0
 808bdd4:	f000 fb90 	bl	808c4f8 <GLCD_DrawString>

	while (KEYS_GetState(KEY_A) != KEY_PRESSED);
 808bdd8:	2000      	movs	r0, #0
 808bdda:	f000 fc7b 	bl	808c6d4 <KEYS_GetState>
 808bdde:	2801      	cmp	r0, #1
 808bde0:	d1fa      	bne.n	808bdd8 <PANIC_Display+0x100>

	/* Redemarrage de la carte */
	NVIC_SystemReset();
 808bde2:	f7ff ff67 	bl	808bcb4 <NVIC_SystemReset>
	switch (IT_Source)
 808bde6:	f642 2028 	movw	r0, #10792	; 0x2a28
 808bdea:	f6c0 0009 	movt	r0, #2057	; 0x809
 808bdee:	e782      	b.n	808bcf6 <PANIC_Display+0x1e>

0808bdf0 <PANIC_ReadStack>:
	IT_Source = it_source;
 808bdf0:	f64b 2380 	movw	r3, #47744	; 0xba80
	if ( (sp >= (uint32_t*)0x20000000) && (sp <= (uint32_t*)(0x20001400)))
 808bdf4:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
	IT_Source = it_source;
 808bdf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
	if ( (sp >= (uint32_t*)0x20000000) && (sp <= (uint32_t*)(0x20001400)))
 808bdfc:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
void PANIC_ReadStack(uint32_t it_source, uint32_t *sp) {
 808be00:	b580      	push	{r7, lr}
	IT_Source = it_source;
 808be02:	6018      	str	r0, [r3, #0]
	if ( (sp >= (uint32_t*)0x20000000) && (sp <= (uint32_t*)(0x20001400)))
 808be04:	d83c      	bhi.n	808be80 <PANIC_ReadStack+0x90>
		R0 = sp[0];
 808be06:	f64b 238c 	movw	r3, #47756	; 0xba8c
		R1 = sp[1];
 808be0a:	f64b 2c90 	movw	ip, #47760	; 0xba90
		R0 = sp[0];
 808be0e:	680a      	ldr	r2, [r1, #0]
		R2 = sp[2];
 808be10:	f64b 2698 	movw	r6, #47768	; 0xba98
		R1 = sp[1];
 808be14:	684f      	ldr	r7, [r1, #4]
		R0 = sp[0];
 808be16:	f2c2 0300 	movt	r3, #8192	; 0x2000
		R1 = sp[1];
 808be1a:	f2c2 0c00 	movt	ip, #8192	; 0x2000
		R2 = sp[2];
 808be1e:	f2c2 0600 	movt	r6, #8192	; 0x2000
		R0 = sp[0];
 808be22:	601a      	str	r2, [r3, #0]
		R3 = sp[3];
 808be24:	f64b 259c 	movw	r5, #47772	; 0xba9c
		R1 = sp[1];
 808be28:	f8cc 7000 	str.w	r7, [ip]
		R12 = sp[4];
 808be2c:	f64b 2494 	movw	r4, #47764	; 0xba94
		R2 = sp[2];
 808be30:	688f      	ldr	r7, [r1, #8]
		R3 = sp[3];
 808be32:	f2c2 0500 	movt	r5, #8192	; 0x2000
		R12 = sp[4];
 808be36:	f2c2 0400 	movt	r4, #8192	; 0x2000
		LR = sp[5];
 808be3a:	f64b 2084 	movw	r0, #47748	; 0xba84
		R2 = sp[2];
 808be3e:	6037      	str	r7, [r6, #0]
		PC = sp[6];
 808be40:	f64b 2288 	movw	r2, #47752	; 0xba88
		R3 = sp[3];
 808be44:	68ce      	ldr	r6, [r1, #12]
		XPSR = sp[7];
 808be46:	f64b 23a4 	movw	r3, #47780	; 0xbaa4
		LR = sp[5];
 808be4a:	f2c2 0000 	movt	r0, #8192	; 0x2000
		PC = sp[6];
 808be4e:	f2c2 0200 	movt	r2, #8192	; 0x2000
		R3 = sp[3];
 808be52:	602e      	str	r6, [r5, #0]
		XPSR = sp[7];
 808be54:	f2c2 0300 	movt	r3, #8192	; 0x2000
		LR = sp[5];
 808be58:	e9d1 6504 	ldrd	r6, r5, [r1, #16]
		R12 = sp[4];
 808be5c:	6026      	str	r6, [r4, #0]
		LR = sp[5];
 808be5e:	6005      	str	r5, [r0, #0]
		XPSR = sp[7];
 808be60:	e9d1 4106 	ldrd	r4, r1, [r1, #24]
		PC = sp[6];
 808be64:	6014      	str	r4, [r2, #0]
		XPSR = sp[7];
 808be66:	6019      	str	r1, [r3, #0]
	SetStack((uint32_t)&__system_stack_end__,(uint32_t)&__app_stack_end__);
 808be68:	f241 0100 	movw	r1, #4096	; 0x1000
 808be6c:	f241 4000 	movw	r0, #5120	; 0x1400
 808be70:	f2c2 0100 	movt	r1, #8192	; 0x2000
 808be74:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808be78:	f006 f824 	bl	8091ec4 <SetStack>
	PANIC_Display();
 808be7c:	f7ff ff2c 	bl	808bcd8 <PANIC_Display>
		R0=R1=R2=R3=R12=LR=PC=XPSR=0x0;
 808be80:	f64b 26a4 	movw	r6, #47780	; 0xbaa4
 808be84:	f64b 2588 	movw	r5, #47752	; 0xba88
 808be88:	2200      	movs	r2, #0
 808be8a:	f64b 2484 	movw	r4, #47748	; 0xba84
 808be8e:	f2c2 0600 	movt	r6, #8192	; 0x2000
 808be92:	f2c2 0500 	movt	r5, #8192	; 0x2000
 808be96:	f64b 2094 	movw	r0, #47764	; 0xba94
 808be9a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808be9e:	6032      	str	r2, [r6, #0]
 808bea0:	f64b 279c 	movw	r7, #47772	; 0xba9c
 808bea4:	602a      	str	r2, [r5, #0]
 808bea6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808beaa:	f64b 2698 	movw	r6, #47768	; 0xba98
 808beae:	f64b 2590 	movw	r5, #47760	; 0xba90
 808beb2:	6022      	str	r2, [r4, #0]
 808beb4:	f2c2 0700 	movt	r7, #8192	; 0x2000
 808beb8:	6002      	str	r2, [r0, #0]
 808beba:	f2c2 0500 	movt	r5, #8192	; 0x2000
 808bebe:	f2c2 0600 	movt	r6, #8192	; 0x2000
 808bec2:	f64b 248c 	movw	r4, #47756	; 0xba8c
		SP = (uint32_t)sp;
 808bec6:	f64b 20a0 	movw	r0, #47776	; 0xbaa0
		R0=R1=R2=R3=R12=LR=PC=XPSR=0x0;
 808beca:	603a      	str	r2, [r7, #0]
 808becc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808bed0:	6032      	str	r2, [r6, #0]
		SP = (uint32_t)sp;
 808bed2:	f2c2 0000 	movt	r0, #8192	; 0x2000
		R0=R1=R2=R3=R12=LR=PC=XPSR=0x0;
 808bed6:	602a      	str	r2, [r5, #0]
		IT_Source = 5;
 808bed8:	2505      	movs	r5, #5
		R0=R1=R2=R3=R12=LR=PC=XPSR=0x0;
 808beda:	6022      	str	r2, [r4, #0]
		SP = (uint32_t)sp;
 808bedc:	6001      	str	r1, [r0, #0]
		IT_Source = 5;
 808bede:	601d      	str	r5, [r3, #0]
 808bee0:	e7c2      	b.n	808be68 <PANIC_ReadStack+0x78>
 808bee2:	bf00      	nop

0808bee4 <PANIC_SoftwarePanic>:
}

void PANIC_SoftwarePanic(char *Title, char *Message) {
 808bee4:	b508      	push	{r3, lr}
	GUI_CreateWindow(Title, Yellow, White, Black);
 808bee6:	22ff      	movs	r2, #255	; 0xff
 808bee8:	2300      	movs	r3, #0
void PANIC_SoftwarePanic(char *Title, char *Message) {
 808beea:	460c      	mov	r4, r1
	GUI_CreateWindow(Title, Yellow, White, Black);
 808beec:	21fc      	movs	r1, #252	; 0xfc
 808beee:	f000 fbef 	bl	808c6d0 <GUI_CreateWindow>

	/* Affiche la backtrace */
	GLCD_SetTextColor(White);
 808bef2:	20ff      	movs	r0, #255	; 0xff
 808bef4:	f000 fa94 	bl	808c420 <GLCD_SetTextColor>
	GLCD_SetBackColor(Red);
 808bef8:	20e0      	movs	r0, #224	; 0xe0
 808befa:	f000 faa7 	bl	808c44c <GLCD_SetBackColor>

	GLCD_DrawString(0, 5, Message);
 808befe:	4622      	mov	r2, r4
 808bf00:	2105      	movs	r1, #5
 808bf02:	2000      	movs	r0, #0
 808bf04:	f000 faf8 	bl	808c4f8 <GLCD_DrawString>
	GLCD_DrawString(0, 14, "Press A to try again");
 808bf08:	f642 2238 	movw	r2, #10808	; 0x2a38
 808bf0c:	210e      	movs	r1, #14
 808bf0e:	2000      	movs	r0, #0
 808bf10:	f6c0 0209 	movt	r2, #2057	; 0x809
 808bf14:	f000 faf0 	bl	808c4f8 <GLCD_DrawString>

	while (KEYS_GetState(KEY_B) != KEY_PRESSED);
 808bf18:	2001      	movs	r0, #1
 808bf1a:	f000 fbdb 	bl	808c6d4 <KEYS_GetState>
 808bf1e:	2801      	cmp	r0, #1
 808bf20:	d1fa      	bne.n	808bf18 <PANIC_SoftwarePanic+0x34>

		/* Redemarrage de la carte */
	NVIC_SystemReset();
 808bf22:	f7ff fec7 	bl	808bcb4 <NVIC_SystemReset>
 808bf26:	bf00      	nop

0808bf28 <RETARGET_Init>:
FILE __console;
FILE __lcd;
FILE __stderr;

void RETARGET_Init (void)
{
 808bf28:	b430      	push	{r4, r5}
	__stdout._file=1;
	__stdin._file=1;
 808bf2a:	f64d 206c 	movw	r0, #55916	; 0xda6c
	__stdout._file=1;
 808bf2e:	f64d 34a4 	movw	r4, #56228	; 0xdba4
 808bf32:	2501      	movs	r5, #1
	__console._file=10;
 808bf34:	f64d 313c 	movw	r1, #56124	; 0xdb3c
	__stdout._file=1;
 808bf38:	f2c2 0402 	movt	r4, #8194	; 0x2002
	__stdin._file=1;
 808bf3c:	f2c2 0002 	movt	r0, #8194	; 0x2002
	__lcd._file=10;
 808bf40:	f64d 22d4 	movw	r2, #56020	; 0xdad4
	__stderr._file=2;
 808bf44:	f64d 2304 	movw	r3, #55812	; 0xda04
	__stdout._file=1;
 808bf48:	81e5      	strh	r5, [r4, #14]
	__console._file=10;
 808bf4a:	f2c2 0102 	movt	r1, #8194	; 0x2002
 808bf4e:	240a      	movs	r4, #10
	__stdin._file=1;
 808bf50:	81c5      	strh	r5, [r0, #14]
	__lcd._file=10;
 808bf52:	f2c2 0202 	movt	r2, #8194	; 0x2002
	__stderr._file=2;
 808bf56:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808bf5a:	2002      	movs	r0, #2
	__console._file=10;
 808bf5c:	81cc      	strh	r4, [r1, #14]
	__lcd._file=10;
 808bf5e:	81d4      	strh	r4, [r2, #14]
	__stderr._file=2;
 808bf60:	81d8      	strh	r0, [r3, #14]
}
 808bf62:	bc30      	pop	{r4, r5}
 808bf64:	4770      	bx	lr
 808bf66:	bf00      	nop

0808bf68 <_write>:
/* Functions */

int _write (int fd, char *ptr, int len)
{
 808bf68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	for (i=0; i<len; i++)
 808bf6c:	1e16      	subs	r6, r2, #0
 808bf6e:	dd18      	ble.n	808bfa2 <_write+0x3a>
 808bf70:	4605      	mov	r5, r0
 808bf72:	460f      	mov	r7, r1
 808bf74:	2400      	movs	r4, #0
	{
		if (fd == 1)  BSP_STDIO_SendData((uint8_t *)&ptr[i],1);
		if (fd == 2) // used for ADA exception
		{
			BSP_STDIO_SendData((uint8_t *)&ptr[1],1);
 808bf76:	f101 0801 	add.w	r8, r1, #1
 808bf7a:	e009      	b.n	808bf90 <_write+0x28>
		if (fd == 2) // used for ADA exception
 808bf7c:	2d02      	cmp	r5, #2
 808bf7e:	d013      	beq.n	808bfa8 <_write+0x40>
			CONSOLE_PrintChar(ptr[i]);
		}
		if (fd == 10) CONSOLE_PrintChar(ptr[i]);
 808bf80:	2d0a      	cmp	r5, #10
 808bf82:	d102      	bne.n	808bf8a <_write+0x22>
 808bf84:	5d38      	ldrb	r0, [r7, r4]
 808bf86:	f7ff fe55 	bl	808bc34 <CONSOLE_PrintChar>
	for (i=0; i<len; i++)
 808bf8a:	3401      	adds	r4, #1
 808bf8c:	42a6      	cmp	r6, r4
 808bf8e:	d008      	beq.n	808bfa2 <_write+0x3a>
		if (fd == 1)  BSP_STDIO_SendData((uint8_t *)&ptr[i],1);
 808bf90:	2d01      	cmp	r5, #1
 808bf92:	d1f3      	bne.n	808bf7c <_write+0x14>
 808bf94:	1938      	adds	r0, r7, r4
	for (i=0; i<len; i++)
 808bf96:	3401      	adds	r4, #1
		if (fd == 1)  BSP_STDIO_SendData((uint8_t *)&ptr[i],1);
 808bf98:	4629      	mov	r1, r5
 808bf9a:	f7f9 f9e5 	bl	8085368 <BSP_STDIO_SendData>
	for (i=0; i<len; i++)
 808bf9e:	42a6      	cmp	r6, r4
 808bfa0:	d1f6      	bne.n	808bf90 <_write+0x28>
	}

	return len;
}
 808bfa2:	4630      	mov	r0, r6
 808bfa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			BSP_STDIO_SendData((uint8_t *)&ptr[1],1);
 808bfa8:	2101      	movs	r1, #1
 808bfaa:	4640      	mov	r0, r8
 808bfac:	f7f9 f9dc 	bl	8085368 <BSP_STDIO_SendData>
			CONSOLE_PrintChar(ptr[i]);
 808bfb0:	5d38      	ldrb	r0, [r7, r4]
 808bfb2:	f7ff fe3f 	bl	808bc34 <CONSOLE_PrintChar>
 808bfb6:	e7e8      	b.n	808bf8a <_write+0x22>

0808bfb8 <_read>:
int _read (int fd, char *ptr, int len)
{
	int count=-1;
	int i;

	for (i=0; i<len; i++)
 808bfb8:	2a00      	cmp	r2, #0
{
 808bfba:	4601      	mov	r1, r0
	for (i=0; i<len; i++)
 808bfbc:	dd0a      	ble.n	808bfd4 <_read+0x1c>
 808bfbe:	2300      	movs	r3, #0
	int count=-1;
 808bfc0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	{
		if (fd == 1)
 808bfc4:	2901      	cmp	r1, #1
	for (i=0; i<len; i++)
 808bfc6:	f103 0301 	add.w	r3, r3, #1
		{
			//USART_Receive(USART1, &ptr[i]);
			count++;
 808bfca:	bf08      	it	eq
 808bfcc:	3001      	addeq	r0, #1
	for (i=0; i<len; i++)
 808bfce:	429a      	cmp	r2, r3
 808bfd0:	d1f8      	bne.n	808bfc4 <_read+0xc>
 808bfd2:	4770      	bx	lr
	int count=-1;
 808bfd4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		}
	}

	return (count);
}
 808bfd8:	4770      	bx	lr
 808bfda:	bf00      	nop

0808bfdc <_sbrk>:
 *_sbrk
 * Increase program data space. Malloc and related functions depend on this
 */

caddr_t _sbrk(int incr)
{
 808bfdc:	b508      	push	{r3, lr}
	#define HEAP_END_ADDRESS	_dynamicsram_end

	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 808bfde:	f64b 23a8 	movw	r3, #47784	; 0xbaa8
 808bfe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808bfe6:	681a      	ldr	r2, [r3, #0]
 808bfe8:	b152      	cbz	r2, 808c000 <_sbrk+0x24>
		heap_end = (char*)HEAP_BASE_ADDRESS;

	prev_heap_end = heap_end;

	if (heap_end + incr > (char*)HEAP_END_ADDRESS)
 808bfea:	f240 0100 	movw	r1, #0
 808bfee:	4410      	add	r0, r2
 808bff0:	f2cc 0130 	movt	r1, #49200	; 0xc030
 808bff4:	6809      	ldr	r1, [r1, #0]
 808bff6:	4288      	cmp	r0, r1
 808bff8:	d809      	bhi.n	808c00e <_sbrk+0x32>
	{
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 808bffa:	6018      	str	r0, [r3, #0]

	return (caddr_t) prev_heap_end;
}
 808bffc:	4610      	mov	r0, r2
 808bffe:	bd08      	pop	{r3, pc}
		heap_end = (char*)HEAP_BASE_ADDRESS;
 808c000:	f240 0200 	movw	r2, #0
 808c004:	f2cc 0230 	movt	r2, #49200	; 0xc030
 808c008:	6812      	ldr	r2, [r2, #0]
 808c00a:	601a      	str	r2, [r3, #0]
 808c00c:	e7ed      	b.n	808bfea <_sbrk+0xe>
		errno = ENOMEM;
 808c00e:	f006 f823 	bl	8092058 <__errno>
 808c012:	230c      	movs	r3, #12
		return (caddr_t) -1;
 808c014:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		errno = ENOMEM;
 808c018:	6003      	str	r3, [r0, #0]
}
 808c01a:	4610      	mov	r0, r2
 808c01c:	bd08      	pop	{r3, pc}
 808c01e:	bf00      	nop

0808c020 <SYSTEM_RunApp>:
 * @brief  Peripheral Reset.
 * @param  None
 * @retval None
 */
int SYSTEM_RunApp(void)
{
 808c020:	b5b0      	push	{r4, r5, r7, lr}
	TestEntryPoint = (uint32_t*)APPLICATION_FIRST_ADDR;
 808c022:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 808c026:	f64d 444c 	movw	r4, #56396	; 0xdc4c
{
 808c02a:	b08e      	sub	sp, #56	; 0x38
	GLCD_SetTextColor(Black);
 808c02c:	2000      	movs	r0, #0
	TestEntryPoint = (uint32_t*)APPLICATION_FIRST_ADDR;
 808c02e:	f6c0 0300 	movt	r3, #2048	; 0x800
 808c032:	f2c2 0402 	movt	r4, #8194	; 0x2002
{
 808c036:	af00      	add	r7, sp, #0
	TestEntryPoint = (uint32_t*)APPLICATION_FIRST_ADDR;
 808c038:	6023      	str	r3, [r4, #0]
	GLCD_SetTextColor(Black);
 808c03a:	f000 f9f1 	bl	808c420 <GLCD_SetTextColor>
	GLCD_SetBackColor(White);
 808c03e:	20ff      	movs	r0, #255	; 0xff
 808c040:	f000 fa04 	bl	808c44c <GLCD_SetBackColor>

	if (*TestEntryPoint == 0xFFFFFFFF)
 808c044:	6823      	ldr	r3, [r4, #0]
 808c046:	681a      	ldr	r2, [r3, #0]
 808c048:	3201      	adds	r2, #1
 808c04a:	f000 80c6 	beq.w	808c1da <SYSTEM_RunApp+0x1ba>

		return BAD_APPLICATION_RETURN_CODE;
	}
	else 
	{
		mh=(magicHeader*)TestEntryPoint;
 808c04e:	f64d 5438 	movw	r4, #56632	; 0xdd38

		if ((mh->magic_str[0] == 'I') && 
 808c052:	f644 6249 	movw	r2, #20041	; 0x4e49
		mh=(magicHeader*)TestEntryPoint;
 808c056:	f2c2 0402 	movt	r4, #8194	; 0x2002
		if ((mh->magic_str[0] == 'I') && 
 808c05a:	f2c4 1253 	movt	r2, #16723	; 0x4153
		mh=(magicHeader*)TestEntryPoint;
 808c05e:	6023      	str	r3, [r4, #0]
		if ((mh->magic_str[0] == 'I') && 
 808c060:	6819      	ldr	r1, [r3, #0]
 808c062:	4291      	cmp	r1, r2
 808c064:	f040 8081 	bne.w	808c16a <SYSTEM_RunApp+0x14a>
				(mh->magic_str[1] == 'N') &&
				(mh->magic_str[2] == 'S') &&
				(mh->magic_str[3] == 'A'))
		{
			/* Verification de la version d'abi */
			if (mh->abi_version <= ABI_VERSION)
 808c068:	685b      	ldr	r3, [r3, #4]
 808c06a:	2bf0      	cmp	r3, #240	; 0xf0
 808c06c:	f200 8097 	bhi.w	808c19e <SYSTEM_RunApp+0x17e>
  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 808c070:	f3ef 8208 	mrs	r2, MSP
			{
				/* Lancement de l'appli */
				/* Sauvegarde de la stack systeme */
				SYSTEM_Stack = __get_MSP();
 808c074:	f64d 4388 	movw	r3, #56456	; 0xdc88

				/* On remet la console à 0 */
				CONSOLE_GotoXY(0,0);
 808c078:	2100      	movs	r1, #0
				SYSTEM_Stack = __get_MSP();
 808c07a:	f2c2 0302 	movt	r3, #8194	; 0x2002
				CONSOLE_GotoXY(0,0);
 808c07e:	4608      	mov	r0, r1
				SYSTEM_Stack = __get_MSP();
 808c080:	601a      	str	r2, [r3, #0]
				CONSOLE_GotoXY(0,0);
 808c082:	f7ff fdc7 	bl	808bc14 <CONSOLE_GotoXY>
  __ASM volatile ("cpsid i" : : : "memory");
 808c086:	b672      	cpsid	i
				/* Bascule vers la stack applicative */
				/* La stack appli va de 0x20009000 à 0x2000A000, la stack systeme de 0x10000000 à 0x10000400,
				   le reste (0x1600) est reservée pour les données (data et bss) du systeme et le vecteur d'IT */

				//__set_PSP((uint32_t)(0x2000A000-0x4));
				__set_PSP((uint32_t)((uint32_t)&__app_stack_end__-0x4));
 808c088:	f640 73fc 	movw	r3, #4092	; 0xffc
 808c08c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 808c090:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 808c094:	2302      	movs	r3, #2
 808c096:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
 808c09a:	f3bf 8f6f 	isb	sy
  __ASM volatile ("cpsie i" : : : "memory");
 808c09e:	b662      	cpsie	i
				__set_CONTROL(0x2); // bascule en mode thread + psp
				__ISB();			// Vide le cache
				__enable_irq(); 	// réactive les IT

				/* Appelle l'applicatif ADA */
				AppEntryPoint = (int (*)(void))(mh->ep);
 808c0a0:	f64d 430c 	movw	r3, #56332	; 0xdc0c
 808c0a4:	6822      	ldr	r2, [r4, #0]
				return_val=AppEntryPoint();
 808c0a6:	f64d 452c 	movw	r5, #56364	; 0xdc2c
				AppEntryPoint = (int (*)(void))(mh->ep);
 808c0aa:	6892      	ldr	r2, [r2, #8]
 808c0ac:	f2c2 0302 	movt	r3, #8194	; 0x2002
				return_val=AppEntryPoint();
 808c0b0:	f2c2 0502 	movt	r5, #8194	; 0x2002
				AppEntryPoint = (int (*)(void))(mh->ep);
 808c0b4:	601a      	str	r2, [r3, #0]
				return_val=AppEntryPoint();
 808c0b6:	4790      	blx	r2
 808c0b8:	6028      	str	r0, [r5, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 808c0ba:	b672      	cpsid	i
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 808c0bc:	2400      	movs	r4, #0
 808c0be:	f384 8814 	msr	CONTROL, r4
  __ASM volatile ("isb 0xF":::"memory");
 808c0c2:	f3bf 8f6f 	isb	sy
  __ASM volatile ("cpsie i" : : : "memory");
 808c0c6:	b662      	cpsie	i
				__disable_irq(); 	// Desactive les IT, le temps de changer la stack */
				__set_CONTROL(0x0); // bascule en mode thread + msp
				__ISB();			// Vide le cache
				__enable_irq(); 	// réactive les IT

				GLCD_SetTextColor(Black);
 808c0c8:	4620      	mov	r0, r4
 808c0ca:	f000 f9a9 	bl	808c420 <GLCD_SetTextColor>
				GLCD_SetBackColor(White);
 808c0ce:	20ff      	movs	r0, #255	; 0xff
 808c0d0:	f000 f9bc 	bl	808c44c <GLCD_SetBackColor>

				if (return_val == 0xDEAD0001)
 808c0d4:	2301      	movs	r3, #1
 808c0d6:	682a      	ldr	r2, [r5, #0]
 808c0d8:	f6cd 63ad 	movt	r3, #57005	; 0xdead
 808c0dc:	429a      	cmp	r2, r3
 808c0de:	f000 8092 	beq.w	808c206 <SYSTEM_RunApp+0x1e6>
				else
				{
					char buffer[50];
					int i;

					sprintf(buffer,"Program terminated with exit code 0x%08X\n",return_val);
 808c0e2:	f642 3194 	movw	r1, #11156	; 0x2b94
 808c0e6:	1d38      	adds	r0, r7, #4
 808c0e8:	f6c0 0109 	movt	r1, #2057	; 0x809
 808c0ec:	f005 fff2 	bl	80920d4 <siprintf>
					for (i=0; i<strlen(buffer); i++)
 808c0f0:	e001      	b.n	808c0f6 <SYSTEM_RunApp+0xd6>
					{
						BSP_STDIO_SendData((uint8_t *)&buffer[i],1);
 808c0f2:	f7f9 f939 	bl	8085368 <BSP_STDIO_SendData>
					for (i=0; i<strlen(buffer); i++)
 808c0f6:	1d38      	adds	r0, r7, #4
 808c0f8:	f7f3 ffa2 	bl	8080040 <strlen>
						BSP_STDIO_SendData((uint8_t *)&buffer[i],1);
 808c0fc:	1d3b      	adds	r3, r7, #4
					for (i=0; i<strlen(buffer); i++)
 808c0fe:	42a0      	cmp	r0, r4
						BSP_STDIO_SendData((uint8_t *)&buffer[i],1);
 808c100:	f04f 0101 	mov.w	r1, #1
 808c104:	eb03 0004 	add.w	r0, r3, r4
					for (i=0; i<strlen(buffer); i++)
 808c108:	f104 0401 	add.w	r4, r4, #1
 808c10c:	d8f1      	bhi.n	808c0f2 <SYSTEM_RunApp+0xd2>
					}

					GLCD_DrawString(1,14, "A -> Run again");
 808c10e:	f642 32c0 	movw	r2, #11200	; 0x2bc0
 808c112:	210e      	movs	r1, #14
 808c114:	2001      	movs	r0, #1
 808c116:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c11a:	f000 f9ed 	bl	808c4f8 <GLCD_DrawString>
 808c11e:	e003      	b.n	808c128 <SYSTEM_RunApp+0x108>
				}

				while ((KEYS_GetState(KEY_A)!=KEY_PRESSED) && (KEYS_GetState(KEY_B)!=KEY_PRESSED));
 808c120:	f000 fad8 	bl	808c6d4 <KEYS_GetState>
 808c124:	2801      	cmp	r0, #1
 808c126:	d006      	beq.n	808c136 <SYSTEM_RunApp+0x116>
 808c128:	2000      	movs	r0, #0
 808c12a:	f000 fad3 	bl	808c6d4 <KEYS_GetState>
 808c12e:	2801      	cmp	r0, #1
 808c130:	f04f 0001 	mov.w	r0, #1
 808c134:	d1f4      	bne.n	808c120 <SYSTEM_RunApp+0x100>
				while ((KEYS_GetState(KEY_A)==KEY_PRESSED) || (KEYS_GetState(KEY_B)==KEY_PRESSED));
 808c136:	2000      	movs	r0, #0
 808c138:	f000 facc 	bl	808c6d4 <KEYS_GetState>
 808c13c:	2801      	cmp	r0, #1
 808c13e:	d0fa      	beq.n	808c136 <SYSTEM_RunApp+0x116>
 808c140:	2001      	movs	r0, #1
 808c142:	f000 fac7 	bl	808c6d4 <KEYS_GetState>
 808c146:	2801      	cmp	r0, #1
 808c148:	d0f5      	beq.n	808c136 <SYSTEM_RunApp+0x116>

				BSP_LCD_Clear(Black);
 808c14a:	2000      	movs	r0, #0
 808c14c:	f7f7 f93e 	bl	80833cc <BSP_LCD_Clear>
				GLCD_Clear(White);
 808c150:	20ff      	movs	r0, #255	; 0xff
 808c152:	f000 f941 	bl	808c3d8 <GLCD_Clear>
				GLCD_SetTextColor(Black);
 808c156:	2000      	movs	r0, #0
 808c158:	f000 f962 	bl	808c420 <GLCD_SetTextColor>
				GLCD_SetBackColor(White);
 808c15c:	20ff      	movs	r0, #255	; 0xff
 808c15e:	f000 f975 	bl	808c44c <GLCD_SetBackColor>

				return 0;
 808c162:	2000      	movs	r0, #0
			return BAD_APPLICATION_RETURN_CODE;
		}
	}

	return BAD_APPLICATION_RETURN_CODE;
}
 808c164:	3738      	adds	r7, #56	; 0x38
 808c166:	46bd      	mov	sp, r7
 808c168:	bdb0      	pop	{r4, r5, r7, pc}
			GLCD_DrawString(1,12, "Invalid or corrupted program");
 808c16a:	f642 32d0 	movw	r2, #11216	; 0x2bd0
 808c16e:	210c      	movs	r1, #12
 808c170:	2001      	movs	r0, #1
 808c172:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c176:	f000 f9bf 	bl	808c4f8 <GLCD_DrawString>
			GLCD_DrawString(1,14, "Please, update your program");
 808c17a:	f642 32f0 	movw	r2, #11248	; 0x2bf0
 808c17e:	210e      	movs	r1, #14
 808c180:	2001      	movs	r0, #1
 808c182:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c186:	f000 f9b7 	bl	808c4f8 <GLCD_DrawString>
			while (KEYS_GetState(KEY_CENTER)!=KEY_PRESSED);
 808c18a:	2005      	movs	r0, #5
 808c18c:	f000 faa2 	bl	808c6d4 <KEYS_GetState>
 808c190:	2801      	cmp	r0, #1
 808c192:	d1fa      	bne.n	808c18a <SYSTEM_RunApp+0x16a>
		return BAD_APPLICATION_RETURN_CODE;
 808c194:	f64d 60ad 	movw	r0, #57005	; 0xdead
}
 808c198:	3738      	adds	r7, #56	; 0x38
 808c19a:	46bd      	mov	sp, r7
 808c19c:	bdb0      	pop	{r4, r5, r7, pc}
				GLCD_DrawString(1,11, "Invalid ABI");
 808c19e:	f642 3248 	movw	r2, #11080	; 0x2b48
 808c1a2:	210b      	movs	r1, #11
 808c1a4:	2001      	movs	r0, #1
 808c1a6:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c1aa:	f000 f9a5 	bl	808c4f8 <GLCD_DrawString>
				GLCD_DrawString(1,12, "Program requires a more recent system");
 808c1ae:	f642 3254 	movw	r2, #11092	; 0x2b54
 808c1b2:	210c      	movs	r1, #12
 808c1b4:	2001      	movs	r0, #1
 808c1b6:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c1ba:	f000 f99d 	bl	808c4f8 <GLCD_DrawString>
				GLCD_DrawString(1,14, "Please, upgrade system");
 808c1be:	f642 327c 	movw	r2, #11132	; 0x2b7c
 808c1c2:	210e      	movs	r1, #14
 808c1c4:	2001      	movs	r0, #1
 808c1c6:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c1ca:	f000 f995 	bl	808c4f8 <GLCD_DrawString>
				while (KEYS_GetState(KEY_CENTER)!=KEY_PRESSED);
 808c1ce:	2005      	movs	r0, #5
 808c1d0:	f000 fa80 	bl	808c6d4 <KEYS_GetState>
 808c1d4:	2801      	cmp	r0, #1
 808c1d6:	d1fa      	bne.n	808c1ce <SYSTEM_RunApp+0x1ae>
 808c1d8:	e7dc      	b.n	808c194 <SYSTEM_RunApp+0x174>
		GLCD_DrawString(1,12, "No program loaded");
 808c1da:	f642 3218 	movw	r2, #11032	; 0x2b18
 808c1de:	210c      	movs	r1, #12
 808c1e0:	2001      	movs	r0, #1
 808c1e2:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c1e6:	f000 f987 	bl	808c4f8 <GLCD_DrawString>
		GLCD_DrawString(1,14, "Please, flash a program.");
 808c1ea:	f642 322c 	movw	r2, #11052	; 0x2b2c
 808c1ee:	210e      	movs	r1, #14
 808c1f0:	2001      	movs	r0, #1
 808c1f2:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c1f6:	f000 f97f 	bl	808c4f8 <GLCD_DrawString>
		while (KEYS_GetState(KEY_CENTER)!=KEY_PRESSED);
 808c1fa:	2005      	movs	r0, #5
 808c1fc:	f000 fa6a 	bl	808c6d4 <KEYS_GetState>
 808c200:	2801      	cmp	r0, #1
 808c202:	d1fa      	bne.n	808c1fa <SYSTEM_RunApp+0x1da>
 808c204:	e7c6      	b.n	808c194 <SYSTEM_RunApp+0x174>
					GLCD_DrawString(1,11, "Invalid ABI");
 808c206:	f642 3248 	movw	r2, #11080	; 0x2b48
 808c20a:	210b      	movs	r1, #11
 808c20c:	2001      	movs	r0, #1
 808c20e:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c212:	f000 f971 	bl	808c4f8 <GLCD_DrawString>
					GLCD_DrawString(1,12, "Program requires a more recent system");
 808c216:	f642 3254 	movw	r2, #11092	; 0x2b54
 808c21a:	210c      	movs	r1, #12
 808c21c:	2001      	movs	r0, #1
 808c21e:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c222:	f000 f969 	bl	808c4f8 <GLCD_DrawString>
					GLCD_DrawString(1,14, "Please, upgrade system");
 808c226:	f642 327c 	movw	r2, #11132	; 0x2b7c
 808c22a:	210e      	movs	r1, #14
 808c22c:	2001      	movs	r0, #1
 808c22e:	f6c0 0209 	movt	r2, #2057	; 0x809
 808c232:	f000 f961 	bl	808c4f8 <GLCD_DrawString>
 808c236:	e777      	b.n	808c128 <SYSTEM_RunApp+0x108>

0808c238 <LEGACY_System>:
	SetStack((uint32_t)&__system_stack_end__,(uint32_t)&__app_stack_end__);
 808c238:	f241 0100 	movw	r1, #4096	; 0x1000
 808c23c:	f241 4000 	movw	r0, #5120	; 0x1400
	while (SYSTEM_RunApp()!= BAD_APPLICATION_RETURN_CODE);
 808c240:	f64d 64ad 	movw	r4, #57005	; 0xdead
	SetStack((uint32_t)&__system_stack_end__,(uint32_t)&__app_stack_end__);
 808c244:	f2c2 0100 	movt	r1, #8192	; 0x2000
 808c248:	f2c2 0000 	movt	r0, #8192	; 0x2000
{
 808c24c:	b500      	push	{lr}
 808c24e:	b085      	sub	sp, #20
	SetStack((uint32_t)&__system_stack_end__,(uint32_t)&__app_stack_end__);
 808c250:	f005 fe38 	bl	8091ec4 <SetStack>
	RETARGET_Init();
 808c254:	f7ff fe68 	bl	808bf28 <RETARGET_Init>
	WRAPPER_Init();
 808c258:	f000 f84e 	bl	808c2f8 <WRAPPER_Init>
	BSP_LCD_ResetScreen();
 808c25c:	f7f7 f8ce 	bl	80833fc <BSP_LCD_ResetScreen>
	GLCD_SetBackColor(White);
 808c260:	20ff      	movs	r0, #255	; 0xff
 808c262:	f000 f8f3 	bl	808c44c <GLCD_SetBackColor>
	GLCD_SetTextColor(Black);
 808c266:	2000      	movs	r0, #0
 808c268:	f000 f8da 	bl	808c420 <GLCD_SetTextColor>
	PRG_ReprogPatternAddr = PRG_SOFTRESET_PATTERN;
 808c26c:	f241 6300 	movw	r3, #5632	; 0x1600
 808c270:	f64b 62ef 	movw	r2, #48879	; 0xbeef
	BSP_LCD_Clear(Black);
 808c274:	2000      	movs	r0, #0
	PRG_ReprogPatternAddr = PRG_SOFTRESET_PATTERN;
 808c276:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808c27a:	f6cd 62ad 	movt	r2, #57005	; 0xdead
 808c27e:	601a      	str	r2, [r3, #0]
	BSP_LCD_Clear(Black);
 808c280:	f7f7 f8a4 	bl	80833cc <BSP_LCD_Clear>
	GLCD_Clear(White);
 808c284:	20ff      	movs	r0, #255	; 0xff
 808c286:	f000 f8a7 	bl	808c3d8 <GLCD_Clear>
	GLCD_SetBackColor(White);
 808c28a:	20ff      	movs	r0, #255	; 0xff
 808c28c:	f000 f8de 	bl	808c44c <GLCD_SetBackColor>
	GLCD_SetTextColor(Black);
 808c290:	2000      	movs	r0, #0
 808c292:	f000 f8c5 	bl	808c420 <GLCD_SetTextColor>
	sprintf (str, "System ver. %d.%d", BL_MAJOR_VERSION, BL_MINOR_VERSION);
 808c296:	2301      	movs	r3, #1
 808c298:	f642 3104 	movw	r1, #11012	; 0x2b04
 808c29c:	4668      	mov	r0, sp
 808c29e:	461a      	mov	r2, r3
 808c2a0:	f6c0 0109 	movt	r1, #2057	; 0x809
 808c2a4:	f005 ff16 	bl	80920d4 <siprintf>
	GLCD_DrawString((40-strlen(str))/2, 13, str);
 808c2a8:	4668      	mov	r0, sp
 808c2aa:	f7f3 fec9 	bl	8080040 <strlen>
 808c2ae:	f1c0 0028 	rsb	r0, r0, #40	; 0x28
 808c2b2:	466a      	mov	r2, sp
 808c2b4:	210d      	movs	r1, #13
 808c2b6:	0840      	lsrs	r0, r0, #1
 808c2b8:	f000 f91e 	bl	808c4f8 <GLCD_DrawString>
	Delay(2000);
 808c2bc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 808c2c0:	f000 f884 	bl	808c3cc <Delay>
	GLCD_Clear(White);
 808c2c4:	20ff      	movs	r0, #255	; 0xff
 808c2c6:	f000 f887 	bl	808c3d8 <GLCD_Clear>
	while (SYSTEM_RunApp()!= BAD_APPLICATION_RETURN_CODE);
 808c2ca:	f7ff fea9 	bl	808c020 <SYSTEM_RunApp>
 808c2ce:	42a0      	cmp	r0, r4
 808c2d0:	d1fb      	bne.n	808c2ca <LEGACY_System+0x92>
  __ASM volatile ("dsb 0xF":::"memory");
 808c2d2:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 808c2d6:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 808c2da:	2304      	movs	r3, #4
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 808c2dc:	f2ce 0200 	movt	r2, #57344	; 0xe000
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 808c2e0:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 808c2e4:	68d1      	ldr	r1, [r2, #12]
 808c2e6:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 808c2ea:	430b      	orrs	r3, r1
 808c2ec:	60d3      	str	r3, [r2, #12]
 808c2ee:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 808c2f2:	bf00      	nop
 808c2f4:	e7fd      	b.n	808c2f2 <LEGACY_System+0xba>
 808c2f6:	bf00      	nop

0808c2f8 <WRAPPER_Init>:
MELODY_Status MELODY_Init(void);

/**
 * Init function for legacy wrapper, in charge of initializing Timer 7, for example
 */
void WRAPPER_Init (void) {
 808c2f8:	b530      	push	{r4, r5, lr}
	uint32_t              uwPrescalerValue = 0U;
	uint32_t              pFLatency;
	uint8_t  			  status = 0;

	/* Configure the TIM7 IRQ priority */
	HAL_NVIC_SetPriority(TIM7_IRQn, 0xFU ,0U);
 808c2fa:	2200      	movs	r2, #0
void WRAPPER_Init (void) {
 808c2fc:	b089      	sub	sp, #36	; 0x24
	HAL_NVIC_SetPriority(TIM7_IRQn, 0xFU ,0U);
 808c2fe:	210f      	movs	r1, #15
 808c300:	2037      	movs	r0, #55	; 0x37
 808c302:	f7f9 fa85 	bl	8085810 <HAL_NVIC_SetPriority>

	/* Enable the TIM7 global Interrupt */
	HAL_NVIC_EnableIRQ(TIM7_IRQn);
 808c306:	2037      	movs	r0, #55	; 0x37
 808c308:	f7f9 fabe 	bl	8085888 <HAL_NVIC_EnableIRQ>

	/* Enable TIM7 clock */
	__HAL_RCC_TIM7_CLK_ENABLE();
 808c30c:	f44f 5360 	mov.w	r3, #14336	; 0x3800

	/* Get clock configuration */
	HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 808c310:	a901      	add	r1, sp, #4
 808c312:	a803      	add	r0, sp, #12
	__HAL_RCC_TIM7_CLK_ENABLE();
 808c314:	f2c4 0302 	movt	r3, #16386	; 0x4002
 808c318:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 808c31a:	f042 0220 	orr.w	r2, r2, #32
 808c31e:	641a      	str	r2, [r3, #64]	; 0x40
 808c320:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 808c322:	f003 0320 	and.w	r3, r3, #32
 808c326:	9302      	str	r3, [sp, #8]
 808c328:	9b02      	ldr	r3, [sp, #8]
	HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 808c32a:	f7fb fcf3 	bl	8087d14 <HAL_RCC_GetClockConfig>

	/* Get APB1 prescaler */
	uwAPB1Prescaler = clkconfig.APB1CLKDivider;

	/* Compute TIM7 clock */
	if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 808c32e:	9b06      	ldr	r3, [sp, #24]
 808c330:	bb63      	cbnz	r3, 808c38c <WRAPPER_Init+0x94>
	{
		uwTimclock = HAL_RCC_GetPCLK1Freq();
 808c332:	f7fb fcc7 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
	{
		uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
	}

	/* Compute the prescaler value to have TIM7 counter clock equal to 1MHz */
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808c336:	f64d 6383 	movw	r3, #56963	; 0xde83

	/* Initialize TIM7 */
	LegacyTimHandle.Instance = TIM7;
 808c33a:	f64e 54d0 	movw	r4, #60880	; 0xedd0
 808c33e:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
	  + ClockDivision = 0
	  + Counter direction = Up
	 */
	LegacyTimHandle.Init.Period = (1000000U / 100U) - 1U;
	LegacyTimHandle.Init.Prescaler = uwPrescalerValue*10;
	LegacyTimHandle.Init.ClockDivision = 0;
 808c342:	2200      	movs	r2, #0
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808c344:	f2c4 331b 	movt	r3, #17179	; 0x431b
	LegacyTimHandle.Instance = TIM7;
 808c348:	f2c2 0402 	movt	r4, #8194	; 0x2002
	LegacyTimHandle.Init.Period = (1000000U / 100U) - 1U;
 808c34c:	f242 750f 	movw	r5, #9999	; 0x270f
	LegacyTimHandle.Instance = TIM7;
 808c350:	f2c4 0100 	movt	r1, #16384	; 0x4000
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808c354:	fba3 0300 	umull	r0, r3, r3, r0
	LegacyTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
	LegacyTimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;

	if(HAL_TIM_Base_Init(&LegacyTimHandle) == HAL_OK)
 808c358:	4620      	mov	r0, r4
	LegacyTimHandle.Instance = TIM7;
 808c35a:	6021      	str	r1, [r4, #0]
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808c35c:	0c9b      	lsrs	r3, r3, #18
	LegacyTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
 808c35e:	60a2      	str	r2, [r4, #8]
	LegacyTimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 808c360:	61a2      	str	r2, [r4, #24]
	uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 808c362:	3b01      	subs	r3, #1
	LegacyTimHandle.Init.Prescaler = uwPrescalerValue*10;
 808c364:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 808c368:	005b      	lsls	r3, r3, #1
	LegacyTimHandle.Init.ClockDivision = 0;
 808c36a:	e9c4 5203 	strd	r5, r2, [r4, #12]
	LegacyTimHandle.Init.Prescaler = uwPrescalerValue*10;
 808c36e:	6063      	str	r3, [r4, #4]
	if(HAL_TIM_Base_Init(&LegacyTimHandle) == HAL_OK)
 808c370:	f7fe fa1e 	bl	808a7b0 <HAL_TIM_Base_Init>
 808c374:	b170      	cbz	r0, 808c394 <WRAPPER_Init+0x9c>
		/* Start the TIM time Base generation with interrupt disabled  */
		HAL_TIM_Base_Start(&LegacyTimHandle);
	}

	/* Init du Touchscreen */
	status = BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize());
 808c376:	f7f6 ff67 	bl	8083248 <BSP_LCD_GetXSize>
 808c37a:	4604      	mov	r4, r0
 808c37c:	f7f6 ff72 	bl	8083264 <BSP_LCD_GetYSize>
 808c380:	b281      	uxth	r1, r0
 808c382:	b2a0      	uxth	r0, r4
 808c384:	f7f9 f872 	bl	808546c <BSP_TS_Init>
	if (status != TS_OK) {
 808c388:	b140      	cbz	r0, 808c39c <WRAPPER_Init+0xa4>
 808c38a:	e7fe      	b.n	808c38a <WRAPPER_Init+0x92>
		uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 808c38c:	f7fb fc9a 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
 808c390:	0040      	lsls	r0, r0, #1
 808c392:	e7d0      	b.n	808c336 <WRAPPER_Init+0x3e>
		HAL_TIM_Base_Start(&LegacyTimHandle);
 808c394:	4620      	mov	r0, r4
 808c396:	f7fe f89d 	bl	808a4d4 <HAL_TIM_Base_Start>
 808c39a:	e7ec      	b.n	808c376 <WRAPPER_Init+0x7e>
		while (1);
	}

	/* Init audio */
	AUDIO_Callback =0x0;
 808c39c:	f64e 6310 	movw	r3, #60944	; 0xee10
 808c3a0:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c3a4:	6018      	str	r0, [r3, #0]

// Sound services
void AUDIO_Init(void) {
	uint32_t freq=44100;

	BSP_AUDIO_OUT_DeInit();
 808c3a6:	f7f6 fb63 	bl	8082a70 <BSP_AUDIO_OUT_DeInit>
	BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_BOTH, 92, freq);
 808c3aa:	f64a 4244 	movw	r2, #44100	; 0xac44
 808c3ae:	215c      	movs	r1, #92	; 0x5c
 808c3b0:	2003      	movs	r0, #3
 808c3b2:	f7f6 fb9f 	bl	8082af4 <BSP_AUDIO_OUT_Init>
	MELODY_Init();
 808c3b6:	f000 fb65 	bl	808ca84 <MELODY_Init>
	POT_LastVal=1;
 808c3ba:	f64e 53c0 	movw	r3, #60864	; 0xedc0
 808c3be:	2201      	movs	r2, #1
 808c3c0:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c3c4:	701a      	strb	r2, [r3, #0]
}
 808c3c6:	b009      	add	sp, #36	; 0x24
 808c3c8:	bd30      	pop	{r4, r5, pc}
 808c3ca:	bf00      	nop

0808c3cc <Delay>:
void Delay(volatile uint32_t nTime) {
 808c3cc:	b082      	sub	sp, #8
 808c3ce:	9001      	str	r0, [sp, #4]
	HAL_Delay(nTime);
 808c3d0:	9801      	ldr	r0, [sp, #4]
}
 808c3d2:	b002      	add	sp, #8
	HAL_Delay(nTime);
 808c3d4:	f7f9 b9f2 	b.w	80857bc <HAL_Delay>

0808c3d8 <GLCD_Clear>:
void GLCD_Clear (COLOR color) {
 808c3d8:	b538      	push	{r3, r4, r5, lr}
 808c3da:	4604      	mov	r4, r0
	color_save=BSP_LCD_GetTextColor();
 808c3dc:	f7f6 ffb8 	bl	8083350 <BSP_LCD_GetTextColor>
 808c3e0:	4605      	mov	r5, r0
	if (color == 0xFF) val = 0xFFFFFFFF;
 808c3e2:	2cff      	cmp	r4, #255	; 0xff
 808c3e4:	d019      	beq.n	808c41a <GLCD_Clear+0x42>
		val = (uint32_t)0xFF000000 | (((uint32_t)(color&0xE0))<<16) | (((uint32_t)(color&0x1C))<<11) | (((uint32_t)(color&0x03))<<6);
 808c3e6:	0420      	lsls	r0, r4, #16
 808c3e8:	02e3      	lsls	r3, r4, #11
 808c3ea:	f400 0060 	and.w	r0, r0, #14680064	; 0xe00000
 808c3ee:	01a4      	lsls	r4, r4, #6
 808c3f0:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 808c3f4:	b2e4      	uxtb	r4, r4
 808c3f6:	4318      	orrs	r0, r3
 808c3f8:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
 808c3fc:	4320      	orrs	r0, r4
	BSP_LCD_SetTextColor(WRAPPER_ColorConvertion_32bpp(color));
 808c3fe:	f7f6 ff99 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_FillRect(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1), ABS(x2-x1)+1, ABS(y2-y1)+1);
 808c402:	23f0      	movs	r3, #240	; 0xf0
 808c404:	2050      	movs	r0, #80	; 0x50
 808c406:	f44f 72a0 	mov.w	r2, #320	; 0x140
 808c40a:	2110      	movs	r1, #16
 808c40c:	f7f7 fc80 	bl	8083d10 <BSP_LCD_FillRect>
	BSP_LCD_SetTextColor(color_save);
 808c410:	4628      	mov	r0, r5
}
 808c412:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	BSP_LCD_SetTextColor(color_save);
 808c416:	f7f6 bf8d 	b.w	8083334 <BSP_LCD_SetTextColor>
	if (color == 0xFF) val = 0xFFFFFFFF;
 808c41a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808c41e:	e7ee      	b.n	808c3fe <GLCD_Clear+0x26>

0808c420 <GLCD_SetTextColor>:
 808c420:	28ff      	cmp	r0, #255	; 0xff
 808c422:	d00e      	beq.n	808c442 <GLCD_SetTextColor+0x22>
		val = (uint32_t)0xFF000000 | (((uint32_t)(color&0xE0))<<16) | (((uint32_t)(color&0x1C))<<11) | (((uint32_t)(color&0x03))<<6);
 808c424:	0403      	lsls	r3, r0, #16
 808c426:	02c1      	lsls	r1, r0, #11
 808c428:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
 808c42c:	0180      	lsls	r0, r0, #6
 808c42e:	f401 4160 	and.w	r1, r1, #57344	; 0xe000
 808c432:	b2c2      	uxtb	r2, r0
 808c434:	ea43 0001 	orr.w	r0, r3, r1
 808c438:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
 808c43c:	4310      	orrs	r0, r2
	BSP_LCD_SetTextColor(WRAPPER_ColorConvertion_32bpp(color));
 808c43e:	f7f6 bf79 	b.w	8083334 <BSP_LCD_SetTextColor>
	if (color == 0xFF) val = 0xFFFFFFFF;
 808c442:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	BSP_LCD_SetTextColor(WRAPPER_ColorConvertion_32bpp(color));
 808c446:	f7f6 bf75 	b.w	8083334 <BSP_LCD_SetTextColor>
 808c44a:	bf00      	nop

0808c44c <GLCD_SetBackColor>:
	if (color == 0xFF) val = 0xFFFFFFFF;
 808c44c:	28ff      	cmp	r0, #255	; 0xff
 808c44e:	d00e      	beq.n	808c46e <GLCD_SetBackColor+0x22>
		val = (uint32_t)0xFF000000 | (((uint32_t)(color&0xE0))<<16) | (((uint32_t)(color&0x1C))<<11) | (((uint32_t)(color&0x03))<<6);
 808c450:	0403      	lsls	r3, r0, #16
 808c452:	02c1      	lsls	r1, r0, #11
 808c454:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
 808c458:	0180      	lsls	r0, r0, #6
 808c45a:	f401 4160 	and.w	r1, r1, #57344	; 0xe000
 808c45e:	b2c2      	uxtb	r2, r0
 808c460:	ea43 0001 	orr.w	r0, r3, r1
 808c464:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
 808c468:	4310      	orrs	r0, r2
	BSP_LCD_SetBackColor(WRAPPER_ColorConvertion_32bpp(color));
 808c46a:	f7f6 bf7f 	b.w	808336c <BSP_LCD_SetBackColor>
	if (color == 0xFF) val = 0xFFFFFFFF;
 808c46e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	BSP_LCD_SetBackColor(WRAPPER_ColorConvertion_32bpp(color));
 808c472:	f7f6 bf7b 	b.w	808336c <BSP_LCD_SetBackColor>
 808c476:	bf00      	nop

0808c478 <GLCD_PutPixel>:
	BSP_LCD_DrawPixel(HORIZONTAL_COORD_CONVERSION(x),VERTICAL_COORD_CONVERSION(y),WRAPPER_ColorConvertion_16bpp(color));
 808c478:	3050      	adds	r0, #80	; 0x50
 808c47a:	3110      	adds	r1, #16
	if (color == 0xFF) val = 0xFFFF;
 808c47c:	2aff      	cmp	r2, #255	; 0xff
	BSP_LCD_DrawPixel(HORIZONTAL_COORD_CONVERSION(x),VERTICAL_COORD_CONVERSION(y),WRAPPER_ColorConvertion_16bpp(color));
 808c47e:	b280      	uxth	r0, r0
 808c480:	b289      	uxth	r1, r1
	if (color == 0xFF) val = 0xFFFF;
 808c482:	d011      	beq.n	808c4a8 <GLCD_PutPixel+0x30>
		val = (((uint16_t)(color&0xE0))<<8) | (((uint16_t)(color&0x1C))<<6) | (((uint16_t)(color&0x03))<<3);
 808c484:	f44f 4360 	mov.w	r3, #57344	; 0xe000
void GLCD_PutPixel (uint32_t x, uint32_t y, COLOR color) {
 808c488:	b430      	push	{r4, r5}
		val = (((uint16_t)(color&0xE0))<<8) | (((uint16_t)(color&0x1C))<<6) | (((uint16_t)(color&0x03))<<3);
 808c48a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 808c48e:	0195      	lsls	r5, r2, #6
 808c490:	00d4      	lsls	r4, r2, #3
 808c492:	f405 65e0 	and.w	r5, r5, #1792	; 0x700
 808c496:	ea03 2202 	and.w	r2, r3, r2, lsl #8
 808c49a:	f004 0418 	and.w	r4, r4, #24
 808c49e:	432a      	orrs	r2, r5
 808c4a0:	4322      	orrs	r2, r4
}
 808c4a2:	bc30      	pop	{r4, r5}
	BSP_LCD_DrawPixel(HORIZONTAL_COORD_CONVERSION(x),VERTICAL_COORD_CONVERSION(y),WRAPPER_ColorConvertion_16bpp(color));
 808c4a4:	f7f7 b838 	b.w	8083518 <BSP_LCD_DrawPixel>
	if (color == 0xFF) val = 0xFFFF;
 808c4a8:	f64f 72ff 	movw	r2, #65535	; 0xffff
	BSP_LCD_DrawPixel(HORIZONTAL_COORD_CONVERSION(x),VERTICAL_COORD_CONVERSION(y),WRAPPER_ColorConvertion_16bpp(color));
 808c4ac:	f7f7 b834 	b.w	8083518 <BSP_LCD_DrawPixel>

0808c4b0 <GLCD_DrawChar>:
void GLCD_DrawChar (uint32_t x,  uint32_t y, uint8_t c) {
 808c4b0:	b530      	push	{r4, r5, lr}
 808c4b2:	4604      	mov	r4, r0
	BSP_LCD_SetFont(&FontLegacy);
 808c4b4:	f24b 306c 	movw	r0, #45932	; 0xb36c
void GLCD_DrawChar (uint32_t x,  uint32_t y, uint8_t c) {
 808c4b8:	b083      	sub	sp, #12
	uint8_t str[2] = {c, 0};
 808c4ba:	2300      	movs	r3, #0
	BSP_LCD_SetFont(&FontLegacy);
 808c4bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
void GLCD_DrawChar (uint32_t x,  uint32_t y, uint8_t c) {
 808c4c0:	460d      	mov	r5, r1
	uint8_t str[2] = {c, 0};
 808c4c2:	f88d 2004 	strb.w	r2, [sp, #4]
 808c4c6:	f88d 3005 	strb.w	r3, [sp, #5]
	BSP_LCD_SetFont(&FontLegacy);
 808c4ca:	f7f6 ff5f 	bl	808338c <BSP_LCD_SetFont>
	col = x*8;
 808c4ce:	2c27      	cmp	r4, #39	; 0x27
	BSP_LCD_DisplayStringAt(HORIZONTAL_COORD_CONVERSION(col),VERTICAL_COORD_CONVERSION(row), (uint8_t *)str, LEFT_MODE);
 808c4d0:	f04f 0303 	mov.w	r3, #3
 808c4d4:	aa01      	add	r2, sp, #4
	col = x*8;
 808c4d6:	bf28      	it	cs
 808c4d8:	2427      	movcs	r4, #39	; 0x27
	row = (y*16)-1;
 808c4da:	2d0e      	cmp	r5, #14
 808c4dc:	bf28      	it	cs
 808c4de:	250e      	movcs	r5, #14
	col = x*8;
 808c4e0:	fa04 f003 	lsl.w	r0, r4, r3
	row = (y*16)-1;
 808c4e4:	0129      	lsls	r1, r5, #4
	BSP_LCD_DisplayStringAt(HORIZONTAL_COORD_CONVERSION(col),VERTICAL_COORD_CONVERSION(row), (uint8_t *)str, LEFT_MODE);
 808c4e6:	3050      	adds	r0, #80	; 0x50
 808c4e8:	310f      	adds	r1, #15
 808c4ea:	b280      	uxth	r0, r0
 808c4ec:	b289      	uxth	r1, r1
 808c4ee:	f7f7 f8a3 	bl	8083638 <BSP_LCD_DisplayStringAt>
}
 808c4f2:	b003      	add	sp, #12
 808c4f4:	bd30      	pop	{r4, r5, pc}
 808c4f6:	bf00      	nop

0808c4f8 <GLCD_DrawString>:
void GLCD_DrawString (uint32_t x,  uint32_t y, const char *str) {
 808c4f8:	b570      	push	{r4, r5, r6, lr}
 808c4fa:	4604      	mov	r4, r0
	BSP_LCD_SetFont(&FontLegacy);
 808c4fc:	f24b 306c 	movw	r0, #45932	; 0xb36c
void GLCD_DrawString (uint32_t x,  uint32_t y, const char *str) {
 808c500:	460d      	mov	r5, r1
 808c502:	4616      	mov	r6, r2
	BSP_LCD_SetFont(&FontLegacy);
 808c504:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808c508:	f7f6 ff40 	bl	808338c <BSP_LCD_SetFont>
	col = x*8;
 808c50c:	2c27      	cmp	r4, #39	; 0x27
	BSP_LCD_DisplayStringAt(HORIZONTAL_COORD_CONVERSION(col),VERTICAL_COORD_CONVERSION(row), (uint8_t *)str, LEFT_MODE);
 808c50e:	4632      	mov	r2, r6
 808c510:	f04f 0303 	mov.w	r3, #3
	col = x*8;
 808c514:	bf28      	it	cs
 808c516:	2427      	movcs	r4, #39	; 0x27
	row = (y*16)-1;
 808c518:	2d0e      	cmp	r5, #14
 808c51a:	bf28      	it	cs
 808c51c:	250e      	movcs	r5, #14
	col = x*8;
 808c51e:	00e0      	lsls	r0, r4, #3
	row = (y*16)-1;
 808c520:	0129      	lsls	r1, r5, #4
	BSP_LCD_DisplayStringAt(HORIZONTAL_COORD_CONVERSION(col),VERTICAL_COORD_CONVERSION(row), (uint8_t *)str, LEFT_MODE);
 808c522:	3050      	adds	r0, #80	; 0x50
 808c524:	310f      	adds	r1, #15
 808c526:	b280      	uxth	r0, r0
 808c528:	b289      	uxth	r1, r1
}
 808c52a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	BSP_LCD_DisplayStringAt(HORIZONTAL_COORD_CONVERSION(col),VERTICAL_COORD_CONVERSION(row), (uint8_t *)str, LEFT_MODE);
 808c52e:	f7f7 b883 	b.w	8083638 <BSP_LCD_DisplayStringAt>
 808c532:	bf00      	nop

0808c534 <GLCD_DrawADAString>:
void GLCD_DrawADAString (uint32_t x, uint32_t y, uint32_t len, const char *str) {
 808c534:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 808c536:	460e      	mov	r6, r1
	memcpy(buf,str,len);
 808c538:	4619      	mov	r1, r3
	uint8_t buf[len+1];
 808c53a:	f102 0308 	add.w	r3, r2, #8
void GLCD_DrawADAString (uint32_t x, uint32_t y, uint32_t len, const char *str) {
 808c53e:	af00      	add	r7, sp, #0
 808c540:	4605      	mov	r5, r0
 808c542:	4614      	mov	r4, r2
	uint8_t buf[len+1];
 808c544:	f023 0307 	bic.w	r3, r3, #7
 808c548:	ebad 0d03 	sub.w	sp, sp, r3
	memcpy(buf,str,len);
 808c54c:	4668      	mov	r0, sp
 808c54e:	f005 fdad 	bl	80920ac <memcpy>
	buf[len]=0;
 808c552:	2300      	movs	r3, #0
	GLCD_DrawString (x,  y, (const char*)buf);
 808c554:	4631      	mov	r1, r6
 808c556:	4628      	mov	r0, r5
 808c558:	466a      	mov	r2, sp
	buf[len]=0;
 808c55a:	f80d 3004 	strb.w	r3, [sp, r4]
	GLCD_DrawString (x,  y, (const char*)buf);
 808c55e:	f7ff ffcb 	bl	808c4f8 <GLCD_DrawString>
}
 808c562:	46bd      	mov	sp, r7
 808c564:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808c566:	bf00      	nop

0808c568 <GLCD_DrawLine>:
	BSP_LCD_DrawLine(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1),HORIZONTAL_COORD_CONVERSION(x2),VERTICAL_COORD_CONVERSION(y2));
 808c568:	3310      	adds	r3, #16
 808c56a:	3250      	adds	r2, #80	; 0x50
 808c56c:	3110      	adds	r1, #16
 808c56e:	3050      	adds	r0, #80	; 0x50
 808c570:	b29b      	uxth	r3, r3
 808c572:	b292      	uxth	r2, r2
 808c574:	b289      	uxth	r1, r1
 808c576:	b280      	uxth	r0, r0
 808c578:	f7f7 b8d8 	b.w	808372c <BSP_LCD_DrawLine>

0808c57c <GLCD_DrawRectangle>:
	BSP_LCD_DrawRect(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1), ABS(x2-x1)+1, ABS(y2-y1)+1);
 808c57c:	b280      	uxth	r0, r0
 808c57e:	3301      	adds	r3, #1
 808c580:	b289      	uxth	r1, r1
 808c582:	3201      	adds	r2, #1
void GLCD_DrawRectangle (uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2) {
 808c584:	b410      	push	{r4}
	BSP_LCD_DrawRect(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1), ABS(x2-x1)+1, ABS(y2-y1)+1);
 808c586:	1a5b      	subs	r3, r3, r1
 808c588:	f100 0450 	add.w	r4, r0, #80	; 0x50
 808c58c:	1a12      	subs	r2, r2, r0
 808c58e:	3110      	adds	r1, #16
 808c590:	b2a0      	uxth	r0, r4
}
 808c592:	f85d 4b04 	ldr.w	r4, [sp], #4
	BSP_LCD_DrawRect(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1), ABS(x2-x1)+1, ABS(y2-y1)+1);
 808c596:	b29b      	uxth	r3, r3
 808c598:	b289      	uxth	r1, r1
 808c59a:	b292      	uxth	r2, r2
 808c59c:	f7f6 bfa2 	b.w	80834e4 <BSP_LCD_DrawRect>

0808c5a0 <GLCD_DrawFillRectangle>:
	BSP_LCD_FillRect(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1), ABS(x2-x1)+1, ABS(y2-y1)+1);
 808c5a0:	b280      	uxth	r0, r0
 808c5a2:	3301      	adds	r3, #1
 808c5a4:	b289      	uxth	r1, r1
 808c5a6:	3201      	adds	r2, #1
void GLCD_DrawFillRectangle (uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2) {
 808c5a8:	b410      	push	{r4}
	BSP_LCD_FillRect(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1), ABS(x2-x1)+1, ABS(y2-y1)+1);
 808c5aa:	1a5b      	subs	r3, r3, r1
 808c5ac:	f100 0450 	add.w	r4, r0, #80	; 0x50
 808c5b0:	1a12      	subs	r2, r2, r0
 808c5b2:	3110      	adds	r1, #16
 808c5b4:	b2a0      	uxth	r0, r4
}
 808c5b6:	f85d 4b04 	ldr.w	r4, [sp], #4
	BSP_LCD_FillRect(HORIZONTAL_COORD_CONVERSION(x1),VERTICAL_COORD_CONVERSION(y1), ABS(x2-x1)+1, ABS(y2-y1)+1);
 808c5ba:	b29b      	uxth	r3, r3
 808c5bc:	b289      	uxth	r1, r1
 808c5be:	b292      	uxth	r2, r2
 808c5c0:	f7f7 bba6 	b.w	8083d10 <BSP_LCD_FillRect>

0808c5c4 <GLCD_DrawCircle>:
	BSP_LCD_DrawCircle(HORIZONTAL_COORD_CONVERSION(x),VERTICAL_COORD_CONVERSION(y), radius);
 808c5c4:	3110      	adds	r1, #16
 808c5c6:	3050      	adds	r0, #80	; 0x50
 808c5c8:	b292      	uxth	r2, r2
 808c5ca:	b289      	uxth	r1, r1
 808c5cc:	b280      	uxth	r0, r0
 808c5ce:	f7f7 b9b7 	b.w	8083940 <BSP_LCD_DrawCircle>
 808c5d2:	bf00      	nop

0808c5d4 <GLCD_DrawFillCircle>:
	BSP_LCD_FillCircle(HORIZONTAL_COORD_CONVERSION(x),VERTICAL_COORD_CONVERSION(y), radius);
 808c5d4:	3110      	adds	r1, #16
 808c5d6:	3050      	adds	r0, #80	; 0x50
 808c5d8:	b292      	uxth	r2, r2
 808c5da:	b289      	uxth	r1, r1
 808c5dc:	b280      	uxth	r0, r0
 808c5de:	f7f7 bbc9 	b.w	8083d74 <BSP_LCD_FillCircle>
 808c5e2:	bf00      	nop

0808c5e4 <GLCD_DrawImage>:
void GLCD_DrawImage (COLOR* data, uint32_t x, uint32_t y, uint32_t w, int32_t h) {
 808c5e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 808c5e8:	9e08      	ldr	r6, [sp, #32]
	for (counter_y=0; counter_y<h; counter_y++)
 808c5ea:	b1ae      	cbz	r6, 808c618 <GLCD_DrawImage+0x34>
 808c5ec:	eb02 0806 	add.w	r8, r2, r6
 808c5f0:	4615      	mov	r5, r2
 808c5f2:	461f      	mov	r7, r3
 808c5f4:	4604      	mov	r4, r0
 808c5f6:	1a0e      	subs	r6, r1, r0
		for (counter_x=0; counter_x<w; counter_x++)
 808c5f8:	b187      	cbz	r7, 808c61c <GLCD_DrawImage+0x38>
 808c5fa:	eb07 0904 	add.w	r9, r7, r4
 808c5fe:	19a0      	adds	r0, r4, r6
			GLCD_PutPixel(x+counter_x, y+counter_y, data[(counter_y*w)+counter_x]);
 808c600:	f814 2b01 	ldrb.w	r2, [r4], #1
 808c604:	4629      	mov	r1, r5
 808c606:	f7ff ff37 	bl	808c478 <GLCD_PutPixel>
		for (counter_x=0; counter_x<w; counter_x++)
 808c60a:	454c      	cmp	r4, r9
 808c60c:	d1f7      	bne.n	808c5fe <GLCD_DrawImage+0x1a>
 808c60e:	3501      	adds	r5, #1
 808c610:	464c      	mov	r4, r9
 808c612:	1bf6      	subs	r6, r6, r7
	for (counter_y=0; counter_y<h; counter_y++)
 808c614:	4545      	cmp	r5, r8
 808c616:	d1ef      	bne.n	808c5f8 <GLCD_DrawImage+0x14>
}
 808c618:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 808c61c:	3501      	adds	r5, #1
 808c61e:	46a1      	mov	r9, r4
 808c620:	1bf6      	subs	r6, r6, r7
	for (counter_y=0; counter_y<h; counter_y++)
 808c622:	4545      	cmp	r5, r8
 808c624:	464c      	mov	r4, r9
 808c626:	d1e7      	bne.n	808c5f8 <GLCD_DrawImage+0x14>
 808c628:	e7f6      	b.n	808c618 <GLCD_DrawImage+0x34>
 808c62a:	bf00      	nop

0808c62c <GLCD_DrawImagefromSRAM>:
void GLCD_DrawImagefromSRAM (uint32_t SRAM_Ptr, uint32_t x, uint32_t y, uint32_t w, int32_t h) {
 808c62c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 808c630:	9c0a      	ldr	r4, [sp, #40]	; 0x28
	for (counter_y=0; counter_y<h; counter_y++)
 808c632:	b1f4      	cbz	r4, 808c672 <GLCD_DrawImagefromSRAM+0x46>
 808c634:	4699      	mov	r9, r3
 808c636:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
 808c63a:	468b      	mov	fp, r1
 808c63c:	4616      	mov	r6, r2
 808c63e:	f2cc 0307 	movt	r3, #49159	; 0xc007
 808c642:	eb02 0a04 	add.w	sl, r2, r4
 808c646:	eb09 0701 	add.w	r7, r9, r1
 808c64a:	eb00 0803 	add.w	r8, r0, r3
		for (counter_x=0; counter_x<w; counter_x++)
 808c64e:	f1b9 0f00 	cmp.w	r9, #0
 808c652:	d00a      	beq.n	808c66a <GLCD_DrawImagefromSRAM+0x3e>
 808c654:	465c      	mov	r4, fp
 808c656:	4645      	mov	r5, r8
			GLCD_PutPixel(x+counter_x, y+counter_y, (COLOR)SRAM_ReadByte(SRAM_Ptr + (counter_y*w) + counter_x));
 808c658:	4620      	mov	r0, r4
 808c65a:	3401      	adds	r4, #1
 808c65c:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 808c660:	4631      	mov	r1, r6
 808c662:	f7ff ff09 	bl	808c478 <GLCD_PutPixel>
		for (counter_x=0; counter_x<w; counter_x++)
 808c666:	42a7      	cmp	r7, r4
 808c668:	d1f6      	bne.n	808c658 <GLCD_DrawImagefromSRAM+0x2c>
 808c66a:	3601      	adds	r6, #1
 808c66c:	44c8      	add	r8, r9
	for (counter_y=0; counter_y<h; counter_y++)
 808c66e:	4556      	cmp	r6, sl
 808c670:	d1ed      	bne.n	808c64e <GLCD_DrawImagefromSRAM+0x22>
}
 808c672:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 808c676:	bf00      	nop

0808c678 <GLCD_LayerScrollMode>:
}
 808c678:	4770      	bx	lr
 808c67a:	bf00      	nop

0808c67c <GLCD_SetScrollWindow>:
}
 808c67c:	4770      	bx	lr
 808c67e:	bf00      	nop

0808c680 <GLCD_ScrollVertical>:
}
 808c680:	4770      	bx	lr
 808c682:	bf00      	nop

0808c684 <GLCD_ScrollHorizontal>:
 808c684:	4770      	bx	lr
 808c686:	bf00      	nop

0808c688 <GLCD_LayerDisplayMode>:
 808c688:	4770      	bx	lr
 808c68a:	bf00      	nop

0808c68c <GLCD_LayerTransparency>:
}
 808c68c:	4770      	bx	lr
 808c68e:	bf00      	nop

0808c690 <GLCD_SetLayer>:
 808c690:	4770      	bx	lr
 808c692:	bf00      	nop

0808c694 <GLCD_BTESetSource>:
}
 808c694:	4770      	bx	lr
 808c696:	bf00      	nop

0808c698 <GLCD_BTESetDestination>:
 808c698:	4770      	bx	lr
 808c69a:	bf00      	nop

0808c69c <GLCD_BTESetSize>:
}
 808c69c:	4770      	bx	lr
 808c69e:	bf00      	nop

0808c6a0 <GLCD_BTESetBackgroundColor>:
}
 808c6a0:	4770      	bx	lr
 808c6a2:	bf00      	nop

0808c6a4 <GLCD_BTESetForegroundColor>:
 808c6a4:	4770      	bx	lr
 808c6a6:	bf00      	nop

0808c6a8 <GLCD_BTESetPatternNumber>:
 808c6a8:	4770      	bx	lr
 808c6aa:	bf00      	nop

0808c6ac <GLCD_SetTransparentColor>:
 808c6ac:	4770      	bx	lr
 808c6ae:	bf00      	nop

0808c6b0 <GLCD_BTEStart>:
}
 808c6b0:	4770      	bx	lr
 808c6b2:	bf00      	nop

0808c6b4 <GLCD_BTEStartAndFillFromSRAM>:
}
 808c6b4:	4770      	bx	lr
 808c6b6:	bf00      	nop

0808c6b8 <GUI_ProgressBar>:
void GUI_ProgressBar(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t val, uint8_t maxval) {
 808c6b8:	b430      	push	{r4, r5}
 808c6ba:	f89d 5008 	ldrb.w	r5, [sp, #8]
 808c6be:	f89d 400c 	ldrb.w	r4, [sp, #12]
	LEGACY_GUI_ProgressBar(x, y, w, h, val, maxval);
 808c6c2:	e9cd 5402 	strd	r5, r4, [sp, #8]
}
 808c6c6:	bc30      	pop	{r4, r5}
	LEGACY_GUI_ProgressBar(x, y, w, h, val, maxval);
 808c6c8:	f7ff b938 	b.w	808b93c <LEGACY_GUI_ProgressBar>

0808c6cc <GUI_CenterBar>:
	LEGACY_GUI_CenterBar(x, y, w, h, val, absolutemaxval);
 808c6cc:	f7ff b986 	b.w	808b9dc <LEGACY_GUI_CenterBar>

0808c6d0 <GUI_CreateWindow>:
	LEGACY_GUI_CreateWindow(title, background, titlebarText, titlebarBgnd);
 808c6d0:	f7ff b9e6 	b.w	808baa0 <LEGACY_GUI_CreateWindow>

0808c6d4 <KEYS_GetState>:
KEY_STATE KEYS_GetState(KEY_ID key)  {
 808c6d4:	b508      	push	{r3, lr}
	switch (key)
 808c6d6:	280b      	cmp	r0, #11
 808c6d8:	d83f      	bhi.n	808c75a <KEYS_GetState+0x86>
 808c6da:	e8df f000 	tbb	[pc, r0]
 808c6de:	574f      	.short	0x574f
 808c6e0:	20183028 	.word	0x20183028
 808c6e4:	4013380b 	.word	0x4013380b
 808c6e8:	4706      	.short	0x4706
		if (BSP_PB_GetState(BUTTON_DOWN) && BSP_PB_GetState(BUTTON_RIGHT)) state = KEY_PRESSED;
 808c6ea:	f44f 70a0 	mov.w	r0, #320	; 0x140
 808c6ee:	f7f5 fd07 	bl	8082100 <BSP_PB_GetState>
 808c6f2:	b390      	cbz	r0, 808c75a <KEYS_GetState+0x86>
 808c6f4:	f44f 7088 	mov.w	r0, #272	; 0x110
 808c6f8:	f7f5 fd02 	bl	8082100 <BSP_PB_GetState>
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c6fc:	3000      	adds	r0, #0
 808c6fe:	bf18      	it	ne
 808c700:	2001      	movne	r0, #1
}
 808c702:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_DOWN) && BSP_PB_GetState(BUTTON_LEFT)) state = KEY_PRESSED;
 808c704:	f44f 70a0 	mov.w	r0, #320	; 0x140
 808c708:	f7f5 fcfa 	bl	8082100 <BSP_PB_GetState>
 808c70c:	b328      	cbz	r0, 808c75a <KEYS_GetState+0x86>
 808c70e:	f44f 7090 	mov.w	r0, #288	; 0x120
 808c712:	f7f5 fcf5 	bl	8082100 <BSP_PB_GetState>
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c716:	3000      	adds	r0, #0
 808c718:	bf18      	it	ne
 808c71a:	2001      	movne	r0, #1
}
 808c71c:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_Y)) state = KEY_PRESSED;
 808c71e:	f240 1001 	movw	r0, #257	; 0x101
 808c722:	f7f5 fced 	bl	8082100 <BSP_PB_GetState>
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c726:	3000      	adds	r0, #0
 808c728:	bf18      	it	ne
 808c72a:	2001      	movne	r0, #1
}
 808c72c:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_UP)) state = KEY_PRESSED;
 808c72e:	f44f 70c0 	mov.w	r0, #384	; 0x180
 808c732:	f7f5 fce5 	bl	8082100 <BSP_PB_GetState>
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c736:	3000      	adds	r0, #0
 808c738:	bf18      	it	ne
 808c73a:	2001      	movne	r0, #1
}
 808c73c:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_DOWN)) state = KEY_PRESSED;
 808c73e:	f44f 70a0 	mov.w	r0, #320	; 0x140
 808c742:	f7f5 fcdd 	bl	8082100 <BSP_PB_GetState>
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c746:	3000      	adds	r0, #0
 808c748:	bf18      	it	ne
 808c74a:	2001      	movne	r0, #1
}
 808c74c:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_UP) && BSP_PB_GetState(BUTTON_LEFT)) state = KEY_PRESSED;
 808c74e:	f44f 70c0 	mov.w	r0, #384	; 0x180
 808c752:	f7f5 fcd5 	bl	8082100 <BSP_PB_GetState>
 808c756:	2800      	cmp	r0, #0
 808c758:	d1d9      	bne.n	808c70e <KEYS_GetState+0x3a>
	KEY_STATE state=KEY_RELEASED;
 808c75a:	2000      	movs	r0, #0
}
 808c75c:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_UP) && BSP_PB_GetState(BUTTON_RIGHT)) state = KEY_PRESSED;
 808c75e:	f44f 70c0 	mov.w	r0, #384	; 0x180
 808c762:	f7f5 fccd 	bl	8082100 <BSP_PB_GetState>
 808c766:	2800      	cmp	r0, #0
 808c768:	d0f7      	beq.n	808c75a <KEYS_GetState+0x86>
 808c76a:	e7c3      	b.n	808c6f4 <KEYS_GetState+0x20>
		if (BSP_PB_GetState(BUTTON_X)) state = KEY_PRESSED;
 808c76c:	f44f 7081 	mov.w	r0, #258	; 0x102
 808c770:	f7f5 fcc6 	bl	8082100 <BSP_PB_GetState>
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c774:	3000      	adds	r0, #0
 808c776:	bf18      	it	ne
 808c778:	2001      	movne	r0, #1
}
 808c77a:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c77c:	f44f 7084 	mov.w	r0, #264	; 0x108
 808c780:	f7f5 fcbe 	bl	8082100 <BSP_PB_GetState>
 808c784:	3000      	adds	r0, #0
 808c786:	bf18      	it	ne
 808c788:	2001      	movne	r0, #1
}
 808c78a:	bd08      	pop	{r3, pc}
		if (BSP_PB_GetState(BUTTON_B)) state = KEY_PRESSED;
 808c78c:	f44f 7082 	mov.w	r0, #260	; 0x104
 808c790:	f7f5 fcb6 	bl	8082100 <BSP_PB_GetState>
		if (BSP_PB_GetState(BUTTON_A)) state = KEY_PRESSED;
 808c794:	3000      	adds	r0, #0
 808c796:	bf18      	it	ne
 808c798:	2001      	movne	r0, #1
}
 808c79a:	bd08      	pop	{r3, pc}

0808c79c <POT_GetValue>:
uint8_t POT_GetValue(POT_ID pot)  {
 808c79c:	b500      	push	{lr}
 808c79e:	b08d      	sub	sp, #52	; 0x34
	BSP_TS_GetState(&TS_State);
 808c7a0:	a801      	add	r0, sp, #4
 808c7a2:	f7f8 fed5 	bl	8085550 <BSP_TS_GetState>
	if (TS_State.touchDetected) {
 808c7a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 808c7aa:	b95b      	cbnz	r3, 808c7c4 <POT_GetValue+0x28>
 808c7ac:	f64e 53c0 	movw	r3, #60864	; 0xedc0
 808c7b0:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c7b4:	7818      	ldrb	r0, [r3, #0]
	if (POT_LastVal ==0) POT_LastVal=1;
 808c7b6:	b910      	cbnz	r0, 808c7be <POT_GetValue+0x22>
 808c7b8:	2201      	movs	r2, #1
 808c7ba:	4610      	mov	r0, r2
 808c7bc:	701a      	strb	r2, [r3, #0]
}
 808c7be:	b00d      	add	sp, #52	; 0x34
 808c7c0:	f85d fb04 	ldr.w	pc, [sp], #4
		ts_x = TS_State.touchX[0];
 808c7c4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
		if (ts_x<=HORIZONTAL_COORD_CONVERSION(50)) POT_LastVal=0;
 808c7c8:	2b82      	cmp	r3, #130	; 0x82
 808c7ca:	d804      	bhi.n	808c7d6 <POT_GetValue+0x3a>
 808c7cc:	f64e 53c0 	movw	r3, #60864	; 0xedc0
 808c7d0:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c7d4:	e7f0      	b.n	808c7b8 <POT_GetValue+0x1c>
		else if (ts_x>=HORIZONTAL_COORD_CONVERSION(270)) POT_LastVal=255;
 808c7d6:	f5b3 7faf 	cmp.w	r3, #350	; 0x15e
 808c7da:	d309      	bcc.n	808c7f0 <POT_GetValue+0x54>
 808c7dc:	22ff      	movs	r2, #255	; 0xff
 808c7de:	f64e 53c0 	movw	r3, #60864	; 0xedc0
 808c7e2:	4610      	mov	r0, r2
 808c7e4:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c7e8:	701a      	strb	r2, [r3, #0]
}
 808c7ea:	b00d      	add	sp, #52	; 0x34
 808c7ec:	f85d fb04 	ldr.w	pc, [sp], #4
			POT_LastVal = ((ts_x-HORIZONTAL_COORD_CONVERSION(50))*255)/(HORIZONTAL_COORD_CONVERSION(270)-HORIZONTAL_COORD_CONVERSION(50));
 808c7f0:	3b82      	subs	r3, #130	; 0x82
 808c7f2:	f242 0195 	movw	r1, #8341	; 0x2095
 808c7f6:	f64e 52c0 	movw	r2, #60864	; 0xedc0
 808c7fa:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
 808c7fe:	f6c0 114f 	movt	r1, #2383	; 0x94f
 808c802:	f2c2 0202 	movt	r2, #8194	; 0x2002
 808c806:	0898      	lsrs	r0, r3, #2
 808c808:	fba1 3000 	umull	r3, r0, r1, r0
 808c80c:	f3c0 0047 	ubfx	r0, r0, #1, #8
 808c810:	7010      	strb	r0, [r2, #0]
}
 808c812:	b00d      	add	sp, #52	; 0x34
 808c814:	f85d fb04 	ldr.w	pc, [sp], #4

0808c818 <LED_Set>:
 808c818:	4770      	bx	lr
 808c81a:	bf00      	nop

0808c81c <RNG_GetValue>:
uint16_t RNG_GetValue(void) {
 808c81c:	b508      	push	{r3, lr}
	return (uint16_t)(BSP_RNG_GetNumber());
 808c81e:	f7f8 fa3f 	bl	8084ca0 <BSP_RNG_GetNumber>
}
 808c822:	b280      	uxth	r0, r0
 808c824:	bd08      	pop	{r3, pc}
 808c826:	bf00      	nop

0808c828 <AUDIO_Start>:
*/
__STATIC_INLINE void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)
{
  #if (__DCACHE_PRESENT == 1)
     int32_t op_size = dsize;
    uint32_t op_addr = (uint32_t) addr;
 808c828:	f64d 53c0 	movw	r3, #56768	; 0xddc0
 808c82c:	f2c2 0302 	movt	r3, #8194	; 0x2002
  __ASM volatile ("dsb 0xF":::"memory");
 808c830:	f3bf 8f4f 	dsb	sy
     int32_t linesize = 32U;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */

    __DSB();

    while (op_size > 0) {
      SCB->DCCMVAC = op_addr;
 808c834:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 808c838:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
 808c83c:	f2ce 0200 	movt	r2, #57344	; 0xe000
 808c840:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += linesize;
 808c844:	3320      	adds	r3, #32
    while (op_size > 0) {
 808c846:	428b      	cmp	r3, r1
 808c848:	d1fa      	bne.n	808c840 <AUDIO_Start+0x18>
 808c84a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 808c84e:	f3bf 8f6f 	isb	sy

void AUDIO_Start(void) {
	/* Clean Data Cache to update the content of the SRAM */
	SCB_CleanDCache_by_Addr((uint32_t*)&AUDIO_Buffer.buffer1[0], AUDIO_BUFFER_SIZE*8);

	BSP_AUDIO_OUT_Play((uint16_t*)&AUDIO_Buffer.buffer1[0], AUDIO_BUFFER_SIZE*8);
 808c852:	f64d 50c0 	movw	r0, #56768	; 0xddc0
 808c856:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 808c85a:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808c85e:	f7f5 bf85 	b.w	808276c <BSP_AUDIO_OUT_Play>
 808c862:	bf00      	nop

0808c864 <AUDIO_Stop>:
}

void AUDIO_Stop(void) {
	BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 808c864:	2002      	movs	r0, #2
 808c866:	f7f5 bfcd 	b.w	8082804 <BSP_AUDIO_OUT_Stop>
 808c86a:	bf00      	nop

0808c86c <AUDIO_FillBuffer>:
void AUDIO_FillBuffer(int buffer_nbr, uint8_t* buffer) {
	int i;
	int16_t *ptr;
	int16_t tmp;

	if (buffer_nbr == 1) ptr = &AUDIO_Buffer.buffer1[0];
 808c86c:	2801      	cmp	r0, #1
void AUDIO_FillBuffer(int buffer_nbr, uint8_t* buffer) {
 808c86e:	b430      	push	{r4, r5}
	if (buffer_nbr == 1) ptr = &AUDIO_Buffer.buffer1[0];
 808c870:	d02d      	beq.n	808c8ce <AUDIO_FillBuffer+0x62>
	else ptr =  &AUDIO_Buffer.buffer2[0];
 808c872:	f24e 55c0 	movw	r5, #58816	; 0xe5c0
 808c876:	f2c2 0502 	movt	r5, #8194	; 0x2002
 808c87a:	462c      	mov	r4, r5
 808c87c:	1d22      	adds	r2, r4, #4
 808c87e:	3901      	subs	r1, #1
 808c880:	f604 0404 	addw	r4, r4, #2052	; 0x804

	for (i=0; i<AUDIO_BUFFER_SIZE; i++)
	{
		tmp = buffer[i];
		tmp = tmp -128;
 808c884:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 808c888:	3204      	adds	r2, #4
 808c88a:	3b80      	subs	r3, #128	; 0x80
		tmp = tmp *256;
 808c88c:	021b      	lsls	r3, r3, #8
 808c88e:	b21b      	sxth	r3, r3

		*ptr=tmp;
 808c890:	f822 3c08 	strh.w	r3, [r2, #-8]
		ptr++;
		*ptr=tmp;
 808c894:	f822 3c06 	strh.w	r3, [r2, #-6]
	for (i=0; i<AUDIO_BUFFER_SIZE; i++)
 808c898:	4294      	cmp	r4, r2
 808c89a:	d1f3      	bne.n	808c884 <AUDIO_FillBuffer+0x18>
		ptr++;
	}

	if (buffer_nbr == 1) SCB_CleanDCache_by_Addr((uint32_t*)&AUDIO_Buffer.buffer1[0], AUDIO_BUFFER_SIZE*4);
 808c89c:	2801      	cmp	r0, #1
 808c89e:	d01d      	beq.n	808c8dc <AUDIO_FillBuffer+0x70>
    uint32_t op_addr = (uint32_t) addr;
 808c8a0:	f24e 53c0 	movw	r3, #58816	; 0xe5c0
 808c8a4:	f2c2 0302 	movt	r3, #8194	; 0x2002
  __ASM volatile ("dsb 0xF":::"memory");
 808c8a8:	f3bf 8f4f 	dsb	sy
      SCB->DCCMVAC = op_addr;
 808c8ac:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 808c8b0:	f503 6100 	add.w	r1, r3, #2048	; 0x800
 808c8b4:	f2ce 0200 	movt	r2, #57344	; 0xe000
 808c8b8:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += linesize;
 808c8bc:	3320      	adds	r3, #32
    while (op_size > 0) {
 808c8be:	4299      	cmp	r1, r3
 808c8c0:	d1fa      	bne.n	808c8b8 <AUDIO_FillBuffer+0x4c>
 808c8c2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 808c8c6:	f3bf 8f6f 	isb	sy
	else SCB_CleanDCache_by_Addr((uint32_t*)&AUDIO_Buffer.buffer2[0], AUDIO_BUFFER_SIZE*4);
}
 808c8ca:	bc30      	pop	{r4, r5}
 808c8cc:	4770      	bx	lr
	if (buffer_nbr == 1) ptr = &AUDIO_Buffer.buffer1[0];
 808c8ce:	f64d 54c0 	movw	r4, #56768	; 0xddc0
 808c8d2:	f2c2 0402 	movt	r4, #8194	; 0x2002
 808c8d6:	f504 6500 	add.w	r5, r4, #2048	; 0x800
 808c8da:	e7cf      	b.n	808c87c <AUDIO_FillBuffer+0x10>
    uint32_t op_addr = (uint32_t) addr;
 808c8dc:	f64d 53c0 	movw	r3, #56768	; 0xddc0
 808c8e0:	f2c2 0302 	movt	r3, #8194	; 0x2002
  __ASM volatile ("dsb 0xF":::"memory");
 808c8e4:	f3bf 8f4f 	dsb	sy
      SCB->DCCMVAC = op_addr;
 808c8e8:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 808c8ec:	f2ce 0200 	movt	r2, #57344	; 0xe000
 808c8f0:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += linesize;
 808c8f4:	3320      	adds	r3, #32
    while (op_size > 0) {
 808c8f6:	429d      	cmp	r5, r3
 808c8f8:	d1fa      	bne.n	808c8f0 <AUDIO_FillBuffer+0x84>
 808c8fa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 808c8fe:	f3bf 8f6f 	isb	sy
}
 808c902:	bc30      	pop	{r4, r5}
 808c904:	4770      	bx	lr
 808c906:	bf00      	nop

0808c908 <AUDIO_SetEventCallback>:
	if (buffer_nbr == 1) SCB_CleanDCache_by_Addr((uint32_t*)&AUDIO_Buffer.buffer1[0], AUDIO_BUFFER_SIZE*4);
	else SCB_CleanDCache_by_Addr((uint32_t*)&AUDIO_Buffer.buffer2[0], AUDIO_BUFFER_SIZE*4);
}

void AUDIO_SetEventCallback(AUDIO_EventCallback callback) {
	if (callback != 0x00)
 808c908:	b120      	cbz	r0, 808c914 <AUDIO_SetEventCallback+0xc>
	{
		AUDIO_Callback= callback;
 808c90a:	f64e 6310 	movw	r3, #60944	; 0xee10
 808c90e:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c912:	6018      	str	r0, [r3, #0]
	}
}
 808c914:	4770      	bx	lr
 808c916:	bf00      	nop

0808c918 <BSP_AUDIO_OUT_TransferComplete_CallBack>:
 * @param  None
 * @retval None
 */
void BSP_AUDIO_OUT_TransferComplete_CallBack(void)
{
	if (AUDIO_Callback != 0x00)
 808c918:	f64e 6310 	movw	r3, #60944	; 0xee10
 808c91c:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c920:	681b      	ldr	r3, [r3, #0]
 808c922:	b10b      	cbz	r3, 808c928 <BSP_AUDIO_OUT_TransferComplete_CallBack+0x10>
	{
		AUDIO_Callback(2);
 808c924:	2002      	movs	r0, #2
 808c926:	4718      	bx	r3
	}
}
 808c928:	4770      	bx	lr
 808c92a:	bf00      	nop

0808c92c <BSP_AUDIO_OUT_HalfTransfer_CallBack>:
 * @param  None
 * @retval None
 */
void BSP_AUDIO_OUT_HalfTransfer_CallBack(void)
{
	if (AUDIO_Callback != 0x00)
 808c92c:	f64e 6310 	movw	r3, #60944	; 0xee10
 808c930:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808c934:	681b      	ldr	r3, [r3, #0]
 808c936:	b10b      	cbz	r3, 808c93c <BSP_AUDIO_OUT_HalfTransfer_CallBack+0x10>
	{
		AUDIO_Callback(1);
 808c938:	2001      	movs	r0, #1
 808c93a:	4718      	bx	r3
	}
}
 808c93c:	4770      	bx	lr
 808c93e:	bf00      	nop

0808c940 <L3GD20_GetGyroscopicValues>:

// Sensors services
float* L3GD20_GetGyroscopicValues (void) {
	if (BSP_GYRO_ReadValues(&ang)==ACC_OK) return (float*)&ang;
 808c940:	f64e 50c4 	movw	r0, #60868	; 0xedc4
float* L3GD20_GetGyroscopicValues (void) {
 808c944:	b508      	push	{r3, lr}
	if (BSP_GYRO_ReadValues(&ang)==ACC_OK) return (float*)&ang;
 808c946:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808c94a:	f7f5 fd77 	bl	808243c <BSP_GYRO_ReadValues>
	else return val;
 808c94e:	f64e 52c4 	movw	r2, #60868	; 0xedc4
 808c952:	f64b 23b0 	movw	r3, #47792	; 0xbab0
 808c956:	f2c2 0202 	movt	r2, #8194	; 0x2002
 808c95a:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 808c95e:	2800      	cmp	r0, #0
 808c960:	bf0c      	ite	eq
 808c962:	4610      	moveq	r0, r2
 808c964:	4618      	movne	r0, r3
 808c966:	bd08      	pop	{r3, pc}

0808c968 <LSM303DLHC_GetMagneticValues>:

float* LSM303DLHC_GetMagneticValues (void) {
	if (BSP_MAG_ReadValues(&mag) == MAG_OK) return (float*)&mag;
 808c968:	f64e 6014 	movw	r0, #60948	; 0xee14
float* LSM303DLHC_GetMagneticValues (void) {
 808c96c:	b508      	push	{r3, lr}
	if (BSP_MAG_ReadValues(&mag) == MAG_OK) return (float*)&mag;
 808c96e:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808c972:	f7f7 fc93 	bl	808429c <BSP_MAG_ReadValues>
	else return val;
 808c976:	f64e 6214 	movw	r2, #60948	; 0xee14
 808c97a:	f64b 23b0 	movw	r3, #47792	; 0xbab0
 808c97e:	f2c2 0202 	movt	r2, #8194	; 0x2002
 808c982:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 808c986:	2800      	cmp	r0, #0
 808c988:	bf0c      	ite	eq
 808c98a:	4610      	moveq	r0, r2
 808c98c:	4618      	movne	r0, r3
 808c98e:	bd08      	pop	{r3, pc}

0808c990 <LSM303DLHC_GetAccelerometerValues>:

float* LSM303DLHC_GetAccelerometerValues(void) {
 808c990:	b538      	push	{r3, r4, r5, lr}
 808c992:	f64d 54a0 	movw	r4, #56736	; 0xdda0
	float tmp;
	//	char str[20];
	//	volatile int val;

	HAL_Delay(25);
 808c996:	2019      	movs	r0, #25
 808c998:	f7f8 ff10 	bl	80857bc <HAL_Delay>
 808c99c:	f2c2 0402 	movt	r4, #8194	; 0x2002

	while (BSP_ACC_ReadValues(&acc) != ACC_OK) {
 808c9a0:	4625      	mov	r5, r4
 808c9a2:	4628      	mov	r0, r5
 808c9a4:	f7f5 fd1c 	bl	80823e0 <BSP_ACC_ReadValues>
 808c9a8:	2800      	cmp	r0, #0
 808c9aa:	d1fa      	bne.n	808c9a2 <LSM303DLHC_GetAccelerometerValues+0x12>
	//	val = (int)acc.y;
	//	sprintf (str, "Y= %i     ", val);
	//	GLCD_DrawString(1,14, str);

	// invert X and Y
	tmp = -acc.y;
 808c9ac:	edd4 7a01 	vldr	s15, [r4, #4]
	acc.y=acc.x;
	acc.x=tmp;

	return (float*)&acc;
}
 808c9b0:	f64d 50a0 	movw	r0, #56736	; 0xdda0
	acc.y=acc.x;
 808c9b4:	6823      	ldr	r3, [r4, #0]
	tmp = -acc.y;
 808c9b6:	eef1 7a67 	vneg.f32	s15, s15
}
 808c9ba:	f2c2 0002 	movt	r0, #8194	; 0x2002
	acc.y=acc.x;
 808c9be:	6063      	str	r3, [r4, #4]
	acc.x=tmp;
 808c9c0:	edc4 7a00 	vstr	s15, [r4]
}
 808c9c4:	bd38      	pop	{r3, r4, r5, pc}
 808c9c6:	bf00      	nop

0808c9c8 <SRAM_ReadByte>:

// External RAM
uint8_t SRAM_ReadByte(uint32_t addr) {
	uint8_t *p=(uint8_t*)(&_legacysram_start);
	p+=addr;
	return *p;
 808c9c8:	f64f 0300 	movw	r3, #63488	; 0xf800
 808c9cc:	f2cc 0307 	movt	r3, #49159	; 0xc007
}
 808c9d0:	5c18      	ldrb	r0, [r3, r0]
 808c9d2:	4770      	bx	lr

0808c9d4 <SRAM_WriteByte>:

void SRAM_WriteByte(uint32_t addr, uint8_t data) {
	uint8_t *p=(uint8_t*)(&_legacysram_start);
	p+=addr;
	*p = data;
 808c9d4:	f64f 0300 	movw	r3, #63488	; 0xf800
 808c9d8:	f2cc 0307 	movt	r3, #49159	; 0xc007
 808c9dc:	5419      	strb	r1, [r3, r0]
}
 808c9de:	4770      	bx	lr

0808c9e0 <SRAM_ReadBuffer>:

void SRAM_ReadBuffer(uint32_t addr, uint8_t *buffer, int length) {
	uint8_t *p=(uint8_t*)(&_legacysram_start);
	p+=addr;
 808c9e0:	f64f 0300 	movw	r3, #63488	; 0xf800

	for (int i=0;i < length; i++)
 808c9e4:	2a00      	cmp	r2, #0
	p+=addr;
 808c9e6:	f2cc 0307 	movt	r3, #49159	; 0xc007
 808c9ea:	4418      	add	r0, r3
	for (int i=0;i < length; i++)
 808c9ec:	dd07      	ble.n	808c9fe <SRAM_ReadBuffer+0x1e>
 808c9ee:	3901      	subs	r1, #1
 808c9f0:	4402      	add	r2, r0
	{
		*(buffer++)= *(p++);
 808c9f2:	f810 3b01 	ldrb.w	r3, [r0], #1
	for (int i=0;i < length; i++)
 808c9f6:	4290      	cmp	r0, r2
		*(buffer++)= *(p++);
 808c9f8:	f801 3f01 	strb.w	r3, [r1, #1]!
	for (int i=0;i < length; i++)
 808c9fc:	d1f9      	bne.n	808c9f2 <SRAM_ReadBuffer+0x12>
	}
}
 808c9fe:	4770      	bx	lr

0808ca00 <SRAM_WriteBuffer>:

void SRAM_WriteBuffer(uint32_t addr, uint8_t *buffer, int length) {
	uint8_t *p=(uint8_t*)(&_legacysram_start);
	p+=addr;

	for (int i=0;i < length; i++)
 808ca00:	2a00      	cmp	r2, #0
 808ca02:	dd0b      	ble.n	808ca1c <SRAM_WriteBuffer+0x1c>
 808ca04:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
 808ca08:	440a      	add	r2, r1
 808ca0a:	f2cc 0307 	movt	r3, #49159	; 0xc007
 808ca0e:	4418      	add	r0, r3
	{
		*(p++) = *(buffer++);
 808ca10:	f811 3b01 	ldrb.w	r3, [r1], #1
	for (int i=0;i < length; i++)
 808ca14:	4291      	cmp	r1, r2
		*(p++) = *(buffer++);
 808ca16:	f800 3f01 	strb.w	r3, [r0, #1]!
	for (int i=0;i < length; i++)
 808ca1a:	d1f9      	bne.n	808ca10 <SRAM_WriteBuffer+0x10>
	}
}
 808ca1c:	4770      	bx	lr
 808ca1e:	bf00      	nop

0808ca20 <TIM7_IRQHandler>:
 * @brief  This function handles TIM7 interrupt request.
 * @retval None
 */
void TIM7_IRQHandler (void)
{
	HAL_TIM_IRQHandler(&LegacyTimHandle);
 808ca20:	f64e 50d0 	movw	r0, #60880	; 0xedd0
{
 808ca24:	b510      	push	{r4, lr}
	HAL_TIM_IRQHandler(&LegacyTimHandle);
 808ca26:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808ca2a:	f7fd fd8d 	bl	808a548 <HAL_TIM_IRQHandler>

	if (LegacyTimerCallback != 0x0) LegacyTimerCallback();
 808ca2e:	f64b 23ac 	movw	r3, #47788	; 0xbaac
 808ca32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808ca36:	681b      	ldr	r3, [r3, #0]
 808ca38:	b113      	cbz	r3, 808ca40 <TIM7_IRQHandler+0x20>
}
 808ca3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if (LegacyTimerCallback != 0x0) LegacyTimerCallback();
 808ca3e:	4718      	bx	r3
}
 808ca40:	bd10      	pop	{r4, pc}
 808ca42:	bf00      	nop

0808ca44 <TIMER_Start>:

int TIMER_Start(void) {
	if (LegacyTimerCallback != 0x0) {
 808ca44:	f64b 23ac 	movw	r3, #47788	; 0xbaac
 808ca48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808ca4c:	6818      	ldr	r0, [r3, #0]
 808ca4e:	b140      	cbz	r0, 808ca62 <TIMER_Start+0x1e>
		/* Enable TIM7 Update interrupt */
		__HAL_TIM_ENABLE_IT(&LegacyTimHandle, TIM_IT_UPDATE);
 808ca50:	f64e 53d0 	movw	r3, #60880	; 0xedd0
		return 1;
 808ca54:	2001      	movs	r0, #1
		__HAL_TIM_ENABLE_IT(&LegacyTimHandle, TIM_IT_UPDATE);
 808ca56:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808ca5a:	681a      	ldr	r2, [r3, #0]
 808ca5c:	68d3      	ldr	r3, [r2, #12]
 808ca5e:	4303      	orrs	r3, r0
 808ca60:	60d3      	str	r3, [r2, #12]
	} else
		return 0;
}
 808ca62:	4770      	bx	lr

0808ca64 <TIMER_Stop>:

void TIMER_Stop(void) {

	/* Disable TIM7 update Interrupt */
	__HAL_TIM_DISABLE_IT(&LegacyTimHandle, TIM_IT_UPDATE);
 808ca64:	f64e 53d0 	movw	r3, #60880	; 0xedd0
 808ca68:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808ca6c:	681a      	ldr	r2, [r3, #0]
 808ca6e:	68d3      	ldr	r3, [r2, #12]
 808ca70:	f023 0301 	bic.w	r3, r3, #1
 808ca74:	60d3      	str	r3, [r2, #12]
}
 808ca76:	4770      	bx	lr

0808ca78 <TIMER_SetEventCallback>:

void TIMER_SetEventCallback(TIMER_EventCallback callback) {
	LegacyTimerCallback = callback;
 808ca78:	f64b 23ac 	movw	r3, #47788	; 0xbaac
 808ca7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808ca80:	6018      	str	r0, [r3, #0]
}
 808ca82:	4770      	bx	lr

0808ca84 <MELODY_Init>:
uint32_t MELODY_Length;

TIM_HandleTypeDef MelodyTimHandle;

MELODY_Status MELODY_Init(void)
{
 808ca84:	b530      	push	{r4, r5, lr}
	uint32_t              uwTimclock, uwAPB1Prescaler = 0U;
	uint32_t              uwPrescalerValue = 0U;
	uint32_t              pFLatency;

	/* Configure the TIM4 IRQ priority */
	HAL_NVIC_SetPriority(TIM4_IRQn, 0x4U ,0U);
 808ca86:	2200      	movs	r2, #0
{
 808ca88:	b089      	sub	sp, #36	; 0x24
	HAL_NVIC_SetPriority(TIM4_IRQn, 0x4U ,0U);
 808ca8a:	2104      	movs	r1, #4
 808ca8c:	201e      	movs	r0, #30
 808ca8e:	f7f8 febf 	bl	8085810 <HAL_NVIC_SetPriority>

	/* Enable the TIM4 global Interrupt */
	HAL_NVIC_EnableIRQ(TIM4_IRQn);
 808ca92:	201e      	movs	r0, #30
 808ca94:	f7f8 fef8 	bl	8085888 <HAL_NVIC_EnableIRQ>

	/* Enable TIM4 clock */
	__HAL_RCC_TIM4_CLK_ENABLE();
 808ca98:	f44f 5360 	mov.w	r3, #14336	; 0x3800

	/* Get clock configuration */
	HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 808ca9c:	a901      	add	r1, sp, #4
 808ca9e:	a803      	add	r0, sp, #12
	__HAL_RCC_TIM4_CLK_ENABLE();
 808caa0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 808caa4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 808caa6:	f042 0204 	orr.w	r2, r2, #4
 808caaa:	641a      	str	r2, [r3, #64]	; 0x40
 808caac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 808caae:	f003 0304 	and.w	r3, r3, #4
 808cab2:	9302      	str	r3, [sp, #8]
 808cab4:	9b02      	ldr	r3, [sp, #8]
	HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 808cab6:	f7fb f92d 	bl	8087d14 <HAL_RCC_GetClockConfig>

	/* Get APB1 prescaler */
	uwAPB1Prescaler = clkconfig.APB1CLKDivider;

	/* Compute TIM4 clock */
	if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 808caba:	9b06      	ldr	r3, [sp, #24]
 808cabc:	b30b      	cbz	r3, 808cb02 <MELODY_Init+0x7e>
	{
		uwTimclock = HAL_RCC_GetPCLK1Freq();
	}
	else
	{
		uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 808cabe:	f7fb f901 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
 808cac2:	0040      	lsls	r0, r0, #1
	}

	/* Compute the prescaler value to have TIM4 counter clock equal to 10KHz */
	uwPrescalerValue = (uint32_t) ((uwTimclock / 10000U) - 1U);
 808cac4:	f241 7259 	movw	r2, #5977	; 0x1759

	/* Initialize TIM4 */
	MelodyTimHandle.Instance = TIM4;
 808cac8:	f64e 6324 	movw	r3, #60964	; 0xee24
 808cacc:	f44f 6100 	mov.w	r1, #2048	; 0x800
			  + ClockDivision = 0
			  + Counter direction = Up
	 */
	MelodyTimHandle.Init.Period = 65535;
	MelodyTimHandle.Init.Prescaler = uwPrescalerValue;
	MelodyTimHandle.Init.ClockDivision = 0;
 808cad0:	2400      	movs	r4, #0
	uwPrescalerValue = (uint32_t) ((uwTimclock / 10000U) - 1U);
 808cad2:	f2cd 12b7 	movt	r2, #53687	; 0xd1b7
	MelodyTimHandle.Instance = TIM4;
 808cad6:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808cada:	f2c4 0100 	movt	r1, #16384	; 0x4000
	MelodyTimHandle.Init.Period = 65535;
 808cade:	f64f 75ff 	movw	r5, #65535	; 0xffff
	uwPrescalerValue = (uint32_t) ((uwTimclock / 10000U) - 1U);
 808cae2:	fba2 0200 	umull	r0, r2, r2, r0
	MelodyTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
	MelodyTimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;

	if(HAL_TIM_Base_Init(&MelodyTimHandle) == HAL_OK)
 808cae6:	4618      	mov	r0, r3
	MelodyTimHandle.Instance = TIM4;
 808cae8:	6019      	str	r1, [r3, #0]
	uwPrescalerValue = (uint32_t) ((uwTimclock / 10000U) - 1U);
 808caea:	0b52      	lsrs	r2, r2, #13
	MelodyTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
 808caec:	609c      	str	r4, [r3, #8]
	MelodyTimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 808caee:	619c      	str	r4, [r3, #24]
	uwPrescalerValue = (uint32_t) ((uwTimclock / 10000U) - 1U);
 808caf0:	3a01      	subs	r2, #1
	MelodyTimHandle.Init.ClockDivision = 0;
 808caf2:	e9c3 5403 	strd	r5, r4, [r3, #12]
	MelodyTimHandle.Init.Prescaler = uwPrescalerValue;
 808caf6:	605a      	str	r2, [r3, #4]
	if(HAL_TIM_Base_Init(&MelodyTimHandle) == HAL_OK)
 808caf8:	f7fd fe5a 	bl	808a7b0 <HAL_TIM_Base_Init>
		/* Start the TIM time Base generation with interrupt disabled  */
		//HAL_TIM_Base_Start(&MelodyTimHandle);
	}

	return MELODY_SUCCESS;
}
 808cafc:	4620      	mov	r0, r4
 808cafe:	b009      	add	sp, #36	; 0x24
 808cb00:	bd30      	pop	{r4, r5, pc}
		uwTimclock = HAL_RCC_GetPCLK1Freq();
 808cb02:	f7fb f8df 	bl	8087cc4 <HAL_RCC_GetPCLK1Freq>
 808cb06:	e7dd      	b.n	808cac4 <MELODY_Init+0x40>

0808cb08 <MELODY_Start>:

MELODY_Status MELODY_Start(MELODY_Notes *music, uint32_t length)
{
 808cb08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	//	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
	//	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	//	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	//	NVIC_Init(&NVIC_InitStructure);

	MELODY_CurrentMusic = music;
 808cb0a:	f64e 6320 	movw	r3, #60960	; 0xee20
	MELODY_CurrentPtr = 0;
 808cb0e:	f64e 6768 	movw	r7, #61032	; 0xee68
 808cb12:	2600      	movs	r6, #0
	MELODY_Length = length;
 808cb14:	f64e 6264 	movw	r2, #61028	; 0xee64
	MELODY_CurrentMusic = music;
 808cb18:	f2c2 0302 	movt	r3, #8194	; 0x2002
	do {
		SYNTH_NoteOn(music[MELODY_CurrentPtr].channel, music[MELODY_CurrentPtr].note);

		//if (music[MELODY_CurrentPtr].duree != 0) TIM_SetAutoreload(TIM4, music[MELODY_CurrentPtr].duree);
		if (music[MELODY_CurrentPtr].duree != 0) {
			__HAL_TIM_SET_AUTORELOAD(&MelodyTimHandle, music[MELODY_CurrentPtr].duree);
 808cb1c:	f64e 6524 	movw	r5, #60964	; 0xee24
	MELODY_CurrentPtr = 0;
 808cb20:	f2c2 0702 	movt	r7, #8194	; 0x2002
	MELODY_Length = length;
 808cb24:	f2c2 0202 	movt	r2, #8194	; 0x2002
	MELODY_CurrentMusic = music;
 808cb28:	6018      	str	r0, [r3, #0]
{
 808cb2a:	4604      	mov	r4, r0
	MELODY_Length = length;
 808cb2c:	4633      	mov	r3, r6
	MELODY_CurrentPtr = 0;
 808cb2e:	803e      	strh	r6, [r7, #0]
			__HAL_TIM_SET_AUTORELOAD(&MelodyTimHandle, music[MELODY_CurrentPtr].duree);
 808cb30:	f2c2 0502 	movt	r5, #8194	; 0x2002
		}

		MELODY_CurrentPtr++;
	} while (music[MELODY_CurrentPtr-1].duree == 0);
 808cb34:	f06f 4640 	mvn.w	r6, #3221225472	; 0xc0000000
	MELODY_Length = length;
 808cb38:	6011      	str	r1, [r2, #0]
		SYNTH_NoteOn(music[MELODY_CurrentPtr].channel, music[MELODY_CurrentPtr].note);
 808cb3a:	eb04 0283 	add.w	r2, r4, r3, lsl #2
 808cb3e:	f814 1023 	ldrb.w	r1, [r4, r3, lsl #2]
 808cb42:	7850      	ldrb	r0, [r2, #1]
 808cb44:	f000 fa1a 	bl	808cf7c <SYNTH_NoteOn>
		if (music[MELODY_CurrentPtr].duree != 0) {
 808cb48:	883a      	ldrh	r2, [r7, #0]
		MELODY_CurrentPtr++;
 808cb4a:	1c53      	adds	r3, r2, #1
		if (music[MELODY_CurrentPtr].duree != 0) {
 808cb4c:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		MELODY_CurrentPtr++;
 808cb50:	b29b      	uxth	r3, r3
		if (music[MELODY_CurrentPtr].duree != 0) {
 808cb52:	8851      	ldrh	r1, [r2, #2]
	} while (music[MELODY_CurrentPtr-1].duree == 0);
 808cb54:	199a      	adds	r2, r3, r6
		if (music[MELODY_CurrentPtr].duree != 0) {
 808cb56:	b111      	cbz	r1, 808cb5e <MELODY_Start+0x56>
			__HAL_TIM_SET_AUTORELOAD(&MelodyTimHandle, music[MELODY_CurrentPtr].duree);
 808cb58:	6828      	ldr	r0, [r5, #0]
 808cb5a:	60e9      	str	r1, [r5, #12]
 808cb5c:	62c1      	str	r1, [r0, #44]	; 0x2c
	} while (music[MELODY_CurrentPtr-1].duree == 0);
 808cb5e:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		MELODY_CurrentPtr++;
 808cb62:	803b      	strh	r3, [r7, #0]
	} while (music[MELODY_CurrentPtr-1].duree == 0);
 808cb64:	8852      	ldrh	r2, [r2, #2]
 808cb66:	2a00      	cmp	r2, #0
 808cb68:	d0e7      	beq.n	808cb3a <MELODY_Start+0x32>

	/* Lance le timer4 */
	/* Enable Up IT */
	HAL_TIM_Base_Start_IT(&MelodyTimHandle);
 808cb6a:	f64e 6024 	movw	r0, #60964	; 0xee24
 808cb6e:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808cb72:	f7fd fcbf 	bl	808a4f4 <HAL_TIM_Base_Start_IT>
//	TIM_ClearFlag(TIM4, TIM_FLAG_Update);
//	TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);
//	TIM_Cmd(TIM4, ENABLE);

	return MELODY_SUCCESS;
}
 808cb76:	2000      	movs	r0, #0
 808cb78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808cb7a:	bf00      	nop

0808cb7c <MELODY_Stop>:

MELODY_Status MELODY_Stop(void)
{
	/* arret du Timer 4 */
	HAL_TIM_Base_Stop_IT(&MelodyTimHandle);
 808cb7c:	f64e 6024 	movw	r0, #60964	; 0xee24
{
 808cb80:	b508      	push	{r3, lr}
	HAL_TIM_Base_Stop_IT(&MelodyTimHandle);
 808cb82:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808cb86:	f7fd fcc1 	bl	808a50c <HAL_TIM_Base_Stop_IT>
//	TIM_Cmd(TIM4, DISABLE);
//	TIM_ClearFlag(TIM4, TIM_FLAG_Update);
//	RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
//	RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);

	MELODY_CurrentPtr=0;
 808cb8a:	f64e 6168 	movw	r1, #61032	; 0xee68
	MELODY_CurrentMusic = 0;
 808cb8e:	f64e 6320 	movw	r3, #60960	; 0xee20
	MELODY_CurrentPtr=0;
 808cb92:	2200      	movs	r2, #0
 808cb94:	f2c2 0102 	movt	r1, #8194	; 0x2002
	MELODY_CurrentMusic = 0;
 808cb98:	f2c2 0302 	movt	r3, #8194	; 0x2002

	return MELODY_SUCCESS;
}
 808cb9c:	4610      	mov	r0, r2
	MELODY_CurrentPtr=0;
 808cb9e:	800a      	strh	r2, [r1, #0]
	MELODY_CurrentMusic = 0;
 808cba0:	601a      	str	r2, [r3, #0]
}
 808cba2:	bd08      	pop	{r3, pc}

0808cba4 <MELODY_GetPosition>:

MELODY_Status MELODY_GetPosition(uint8_t *pos)
{
	*pos = (uint8_t)(MELODY_CurrentPtr*255/MELODY_Length);
 808cba4:	f64e 6368 	movw	r3, #61032	; 0xee68
 808cba8:	f64e 6264 	movw	r2, #61028	; 0xee64
 808cbac:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808cbb0:	f2c2 0202 	movt	r2, #8194	; 0x2002
 808cbb4:	881b      	ldrh	r3, [r3, #0]
 808cbb6:	6812      	ldr	r2, [r2, #0]
 808cbb8:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
 808cbbc:	fbb3 f3f2 	udiv	r3, r3, r2
 808cbc0:	7003      	strb	r3, [r0, #0]
	return MELODY_SUCCESS;
}
 808cbc2:	2000      	movs	r0, #0
 808cbc4:	4770      	bx	lr
 808cbc6:	bf00      	nop

0808cbc8 <TIM4_IRQHandler>:
 * @brief  This function handles TIM4 interrupt request.
 * @retval None
 */

void TIM4_IRQHandler(void)
{
 808cbc8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	/* Acquitement du timer 4 */
	HAL_TIM_IRQHandler(&MelodyTimHandle);
 808cbcc:	f64e 6724 	movw	r7, #60964	; 0xee24
 808cbd0:	f2c2 0702 	movt	r7, #8194	; 0x2002
 808cbd4:	4638      	mov	r0, r7
 808cbd6:	f7fd fcb7 	bl	808a548 <HAL_TIM_IRQHandler>

	__HAL_TIM_DISABLE(&MelodyTimHandle);
 808cbda:	683b      	ldr	r3, [r7, #0]
 808cbdc:	f241 1211 	movw	r2, #4369	; 0x1111
 808cbe0:	6a19      	ldr	r1, [r3, #32]
 808cbe2:	4211      	tst	r1, r2
 808cbe4:	d104      	bne.n	808cbf0 <TIM4_IRQHandler+0x28>
 808cbe6:	6a19      	ldr	r1, [r3, #32]
 808cbe8:	f240 4244 	movw	r2, #1092	; 0x444
 808cbec:	4211      	tst	r1, r2
 808cbee:	d039      	beq.n	808cc64 <TIM4_IRQHandler+0x9c>
	/* arret du Timer 4 */
//	TIM_Cmd(TIM4, DISABLE);
//	TIM_ClearFlag(TIM4, TIM_FLAG_Update);

	if (MELODY_CurrentPtr<MELODY_Length)
 808cbf0:	f64e 6468 	movw	r4, #61032	; 0xee68
 808cbf4:	f64e 6864 	movw	r8, #61028	; 0xee64
 808cbf8:	f2c2 0402 	movt	r4, #8194	; 0x2002
 808cbfc:	f2c2 0802 	movt	r8, #8194	; 0x2002
 808cc00:	8823      	ldrh	r3, [r4, #0]
 808cc02:	f8d8 2000 	ldr.w	r2, [r8]
 808cc06:	4293      	cmp	r3, r2
 808cc08:	d231      	bcs.n	808cc6e <TIM4_IRQHandler+0xa6>
 808cc0a:	f64e 6520 	movw	r5, #60960	; 0xee20
			if (MELODY_CurrentMusic[MELODY_CurrentPtr].duree != 0) {
				__HAL_TIM_SET_AUTORELOAD(&MelodyTimHandle, MELODY_CurrentMusic[MELODY_CurrentPtr].duree);
			}

			MELODY_CurrentPtr++;
		} while ((MELODY_CurrentMusic[MELODY_CurrentPtr-1].duree == 0) && (MELODY_CurrentPtr<MELODY_Length));
 808cc0e:	f06f 4940 	mvn.w	r9, #3221225472	; 0xc0000000
 808cc12:	f2c2 0502 	movt	r5, #8194	; 0x2002
 808cc16:	682a      	ldr	r2, [r5, #0]
 808cc18:	e003      	b.n	808cc22 <TIM4_IRQHandler+0x5a>
 808cc1a:	f8d8 1000 	ldr.w	r1, [r8]
 808cc1e:	428b      	cmp	r3, r1
 808cc20:	d219      	bcs.n	808cc56 <TIM4_IRQHandler+0x8e>
					MELODY_CurrentMusic[MELODY_CurrentPtr].channel,
 808cc22:	eb02 0083 	add.w	r0, r2, r3, lsl #2
			SYNTH_NoteOn(
 808cc26:	f812 1023 	ldrb.w	r1, [r2, r3, lsl #2]
 808cc2a:	7840      	ldrb	r0, [r0, #1]
 808cc2c:	f000 f9a6 	bl	808cf7c <SYNTH_NoteOn>
			if (MELODY_CurrentMusic[MELODY_CurrentPtr].duree != 0) {
 808cc30:	8821      	ldrh	r1, [r4, #0]
 808cc32:	682a      	ldr	r2, [r5, #0]
			MELODY_CurrentPtr++;
 808cc34:	1c4b      	adds	r3, r1, #1
			if (MELODY_CurrentMusic[MELODY_CurrentPtr].duree != 0) {
 808cc36:	eb02 0181 	add.w	r1, r2, r1, lsl #2
			MELODY_CurrentPtr++;
 808cc3a:	b29b      	uxth	r3, r3
			if (MELODY_CurrentMusic[MELODY_CurrentPtr].duree != 0) {
 808cc3c:	8848      	ldrh	r0, [r1, #2]
		} while ((MELODY_CurrentMusic[MELODY_CurrentPtr-1].duree == 0) && (MELODY_CurrentPtr<MELODY_Length));
 808cc3e:	eb03 0109 	add.w	r1, r3, r9
			if (MELODY_CurrentMusic[MELODY_CurrentPtr].duree != 0) {
 808cc42:	b110      	cbz	r0, 808cc4a <TIM4_IRQHandler+0x82>
				__HAL_TIM_SET_AUTORELOAD(&MelodyTimHandle, MELODY_CurrentMusic[MELODY_CurrentPtr].duree);
 808cc44:	683e      	ldr	r6, [r7, #0]
 808cc46:	60f8      	str	r0, [r7, #12]
 808cc48:	62f0      	str	r0, [r6, #44]	; 0x2c
		} while ((MELODY_CurrentMusic[MELODY_CurrentPtr-1].duree == 0) && (MELODY_CurrentPtr<MELODY_Length));
 808cc4a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
			MELODY_CurrentPtr++;
 808cc4e:	8023      	strh	r3, [r4, #0]
		} while ((MELODY_CurrentMusic[MELODY_CurrentPtr-1].duree == 0) && (MELODY_CurrentPtr<MELODY_Length));
 808cc50:	8849      	ldrh	r1, [r1, #2]
 808cc52:	2900      	cmp	r1, #0
 808cc54:	d0e1      	beq.n	808cc1a <TIM4_IRQHandler+0x52>

		/* reconfigure le timer4 */
		__HAL_TIM_ENABLE(&MelodyTimHandle);
 808cc56:	683a      	ldr	r2, [r7, #0]
 808cc58:	6813      	ldr	r3, [r2, #0]
 808cc5a:	f043 0301 	orr.w	r3, r3, #1
 808cc5e:	6013      	str	r3, [r2, #0]

	}
	else HAL_TIM_Base_Stop_IT(&MelodyTimHandle);
}
 808cc60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__HAL_TIM_DISABLE(&MelodyTimHandle);
 808cc64:	681a      	ldr	r2, [r3, #0]
 808cc66:	f022 0201 	bic.w	r2, r2, #1
 808cc6a:	601a      	str	r2, [r3, #0]
 808cc6c:	e7c0      	b.n	808cbf0 <TIM4_IRQHandler+0x28>
	else HAL_TIM_Base_Stop_IT(&MelodyTimHandle);
 808cc6e:	f64e 6024 	movw	r0, #60964	; 0xee24
}
 808cc72:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	else HAL_TIM_Base_Stop_IT(&MelodyTimHandle);
 808cc76:	f2c2 0002 	movt	r0, #8194	; 0x2002
 808cc7a:	f7fd bc47 	b.w	808a50c <HAL_TIM_Base_Stop_IT>
 808cc7e:	bf00      	nop

0808cc80 <SYNTH_FillBuffer.constprop.0>:

			for (i=0; i< AUDIO_BUFFER_SIZE; i++) {
				cnt_int = (int)counter;
				tmp = (SYNTH_Wave)(((uint32_t)wave[cnt_int]*volume)>>8);
				counter = counter + increment;
				if (counter >= (float)WaveTableLength) counter = counter - (float)WaveTableLength;
 808cc80:	2300      	movs	r3, #0
static void SYNTH_FillBuffer(int buffer_nbr, SYNTH_Channel *channels)
 808cc82:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 808cc86:	f64e 686c 	movw	r8, #61036	; 0xee6c
	for (channel_nbr=0; channel_nbr<SYNTH_ChannelsNbr; channel_nbr++)
 808cc8a:	461d      	mov	r5, r3
 808cc8c:	f64e 67ec 	movw	r7, #61164	; 0xeeec
				if (counter >= (float)WaveTableLength) counter = counter - (float)WaveTableLength;
 808cc90:	f2c4 235c 	movt	r3, #16988	; 0x425c
 808cc94:	f24f 04ef 	movw	r4, #61679	; 0xf0ef
static void SYNTH_FillBuffer(int buffer_nbr, SYNTH_Channel *channels)
 808cc98:	4683      	mov	fp, r0
 808cc9a:	f2c2 0802 	movt	r8, #8194	; 0x2002
 808cc9e:	f2c2 0702 	movt	r7, #8194	; 0x2002
 808cca2:	f2c2 0402 	movt	r4, #8194	; 0x2002
 808cca6:	ed2d 8b02 	vpush	{d8}
				if (counter >= (float)WaveTableLength) counter = counter - (float)WaveTableLength;
 808ccaa:	ee08 3a10 	vmov	s16, r3
static void SYNTH_FillBuffer(int buffer_nbr, SYNTH_Channel *channels)
 808ccae:	b085      	sub	sp, #20
		increment = channels[channel_nbr].increment;
 808ccb0:	ed98 6a03 	vldr	s12, [r8, #12]
		if ((increment == 0.0f) || (channels[channel_nbr].AHDSR_state==AHDSR_IDLE)) {
 808ccb4:	eeb5 6a40 	vcmp.f32	s12, #0.0
 808ccb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 808ccbc:	d002      	beq.n	808ccc4 <SYNTH_FillBuffer.constprop.0+0x44>
 808ccbe:	f898 101d 	ldrb.w	r1, [r8, #29]
 808ccc2:	bb09      	cbnz	r1, 808cd08 <SYNTH_FillBuffer.constprop.0+0x88>
			if (channel_nbr==0) { // Si le canal est le canal 0 (premier canal), on rempli le buffer avec des zeros, sinon, on ne fait rien
 808ccc4:	2d00      	cmp	r5, #0
 808ccc6:	f000 80ce 	beq.w	808ce66 <SYNTH_FillBuffer.constprop.0+0x1e6>
 808ccca:	f64e 62ef 	movw	r2, #61167	; 0xeeef
			channels[channel_nbr].AHDSR_increment = AHDSR_increment;
		}

		/* Application du volume principal */
		for (i=0; i< AUDIO_BUFFER_SIZE; i++) {
			tmp = ((uint32_t)SYNTH_LocalBuffer[i]*(uint32_t)SYNTH_MainVolume)>>8;
 808ccce:	7839      	ldrb	r1, [r7, #0]
 808ccd0:	f2c2 0202 	movt	r2, #8194	; 0x2002
 808ccd4:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 808ccd8:	fb13 f301 	smulbb	r3, r3, r1
		for (i=0; i< AUDIO_BUFFER_SIZE; i++) {
 808ccdc:	4294      	cmp	r4, r2
			tmp = ((uint32_t)SYNTH_LocalBuffer[i]*(uint32_t)SYNTH_MainVolume)>>8;
 808ccde:	ea4f 2313 	mov.w	r3, r3, lsr #8
			if (tmp >=256) tmp=255;
			SYNTH_LocalBuffer[i] = (uint8_t)tmp;
 808cce2:	7013      	strb	r3, [r2, #0]
		for (i=0; i< AUDIO_BUFFER_SIZE; i++) {
 808cce4:	d1f6      	bne.n	808ccd4 <SYNTH_FillBuffer.constprop.0+0x54>
		}

		/* Recopie des echantillons */
		AUDIO_FillBuffer(buffer_nbr, SYNTH_LocalBuffer);
 808cce6:	f64e 61f0 	movw	r1, #61168	; 0xeef0
	for (channel_nbr=0; channel_nbr<SYNTH_ChannelsNbr; channel_nbr++)
 808ccea:	3501      	adds	r5, #1
		AUDIO_FillBuffer(buffer_nbr, SYNTH_LocalBuffer);
 808ccec:	4658      	mov	r0, fp
 808ccee:	f108 0820 	add.w	r8, r8, #32
 808ccf2:	f2c2 0102 	movt	r1, #8194	; 0x2002
 808ccf6:	f7ff fdb9 	bl	808c86c <AUDIO_FillBuffer>
	for (channel_nbr=0; channel_nbr<SYNTH_ChannelsNbr; channel_nbr++)
 808ccfa:	2d04      	cmp	r5, #4
 808ccfc:	d1d8      	bne.n	808ccb0 <SYNTH_FillBuffer.constprop.0+0x30>
	}
}
 808ccfe:	b005      	add	sp, #20
 808cd00:	ecbd 8b02 	vpop	{d8}
 808cd04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 808cd08:	f64e 62f0 	movw	r2, #61168	; 0xeef0
			wave = channels[channel_nbr].instrument->wavetable;
 808cd0c:	f8d8 c000 	ldr.w	ip, [r8]
					if (AHDSR_increment >= 1.0f)
 808cd10:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
			counter = channels[channel_nbr].counter;
 808cd14:	edd8 7a02 	vldr	s15, [r8, #8]
 808cd18:	f2c2 0202 	movt	r2, #8194	; 0x2002
			wave = channels[channel_nbr].instrument->wavetable;
 808cd1c:	f8dc a018 	ldr.w	sl, [ip, #24]
			volume = channels[channel_nbr].volume;
 808cd20:	f898 9010 	ldrb.w	r9, [r8, #16]
 808cd24:	f502 7e00 	add.w	lr, r2, #512	; 0x200
			AHDSR_increment=channels[channel_nbr].AHDSR_increment;
 808cd28:	edd8 6a06 	vldr	s13, [r8, #24]
			AHDSR_counter=channels[channel_nbr].AHDSR_counter;
 808cd2c:	f8d8 0014 	ldr.w	r0, [r8, #20]
 808cd30:	9701      	str	r7, [sp, #4]
				cnt_int = (int)counter;
 808cd32:	eebd 7ae7 	vcvt.s32.f32	s14, s15
				switch (AHDSR_state)
 808cd36:	1e4e      	subs	r6, r1, #1
				counter = counter + increment;
 808cd38:	ee77 7a86 	vadd.f32	s15, s15, s12
				cnt_int = (int)counter;
 808cd3c:	ed8d 7a03 	vstr	s14, [sp, #12]
				if (counter >= (float)WaveTableLength) counter = counter - (float)WaveTableLength;
 808cd40:	eef4 7ac8 	vcmpe.f32	s15, s16
				tmp = (SYNTH_Wave)(((uint32_t)wave[cnt_int]*volume)>>8);
 808cd44:	9b03      	ldr	r3, [sp, #12]
 808cd46:	f81a 3003 	ldrb.w	r3, [sl, r3]
				if (counter >= (float)WaveTableLength) counter = counter - (float)WaveTableLength;
 808cd4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				tmp = (SYNTH_Wave)(((uint32_t)wave[cnt_int]*volume)>>8);
 808cd4e:	fb13 f309 	smulbb	r3, r3, r9
				if (counter >= (float)WaveTableLength) counter = counter - (float)WaveTableLength;
 808cd52:	bfa8      	it	ge
 808cd54:	ee77 7ac8 	vsubge.f32	s15, s15, s16
				tmp = (SYNTH_Wave)(((uint32_t)wave[cnt_int]*volume)>>8);
 808cd58:	0a1b      	lsrs	r3, r3, #8
				switch (AHDSR_state)
 808cd5a:	2e04      	cmp	r6, #4
 808cd5c:	f200 808e 	bhi.w	808ce7c <SYNTH_FillBuffer.constprop.0+0x1fc>
 808cd60:	e8df f006 	tbb	[pc, r6]
 808cd64:	29334d64 	.word	0x29334d64
 808cd68:	03          	.byte	0x03
 808cd69:	00          	.byte	0x00
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cd6a:	ee07 3a10 	vmov	s14, r3
					AHDSR_increment -= instrument->release_increment;
 808cd6e:	eddc 5a05 	vldr	s11, [ip, #20]
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cd72:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 808cd76:	ee27 7a26 	vmul.f32	s14, s14, s13
					AHDSR_increment -= instrument->release_increment;
 808cd7a:	ee76 6ae5 	vsub.f32	s13, s13, s11
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cd7e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
					if (AHDSR_increment <= 0.0f)
 808cd82:	eef5 6ac0 	vcmpe.f32	s13, #0.0
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cd86:	ed8d 7a00 	vstr	s14, [sp]
					if (AHDSR_increment <= 0.0f)
 808cd8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 808cd8e:	f89d 3000 	ldrb.w	r3, [sp]
 808cd92:	d963      	bls.n	808ce5c <SYNTH_FillBuffer.constprop.0+0x1dc>
				if (channel_nbr == 0)
 808cd94:	b10d      	cbz	r5, 808cd9a <SYNTH_FillBuffer.constprop.0+0x11a>
					SYNTH_LocalBuffer[i]+=(SYNTH_Wave)tmp; // si on ajoute aux valeur déjà ecrites
 808cd96:	7816      	ldrb	r6, [r2, #0]
 808cd98:	4433      	add	r3, r6
 808cd9a:	7013      	strb	r3, [r2, #0]
 808cd9c:	3201      	adds	r2, #1
			for (i=0; i< AUDIO_BUFFER_SIZE; i++) {
 808cd9e:	4596      	cmp	lr, r2
 808cda0:	d1c7      	bne.n	808cd32 <SYNTH_FillBuffer.constprop.0+0xb2>
 808cda2:	9f01      	ldr	r7, [sp, #4]
			channels[channel_nbr].counter = counter;
 808cda4:	edc8 7a02 	vstr	s15, [r8, #8]
			channels[channel_nbr].AHDSR_state = AHDSR_state;
 808cda8:	f888 101d 	strb.w	r1, [r8, #29]
			channels[channel_nbr].AHDSR_counter = AHDSR_counter;
 808cdac:	f8c8 0014 	str.w	r0, [r8, #20]
			channels[channel_nbr].AHDSR_increment = AHDSR_increment;
 808cdb0:	edc8 6a06 	vstr	s13, [r8, #24]
 808cdb4:	e789      	b.n	808ccca <SYNTH_FillBuffer.constprop.0+0x4a>
					AHDSR_counter++;
 808cdb6:	3001      	adds	r0, #1
					if (AHDSR_counter>=instrument->hold_time)
 808cdb8:	f8dc 6000 	ldr.w	r6, [ip]
 808cdbc:	b2db      	uxtb	r3, r3
 808cdbe:	42b0      	cmp	r0, r6
 808cdc0:	d3e8      	bcc.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
						AHDSR_state = AHDSR_DECAY;
 808cdc2:	2103      	movs	r1, #3
						AHDSR_increment = 1.0f;
 808cdc4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 808cdc8:	e7e4      	b.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cdca:	ee07 3a10 	vmov	s14, r3
					AHDSR_increment -= instrument->decay_increment;
 808cdce:	ed9c 5a03 	vldr	s10, [ip, #12]
					if (AHDSR_increment <= instrument->decay_level)
 808cdd2:	eddc 5a04 	vldr	s11, [ip, #16]
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cdd6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 808cdda:	ee27 7a26 	vmul.f32	s14, s14, s13
					AHDSR_increment -= instrument->decay_increment;
 808cdde:	ee76 6ac5 	vsub.f32	s13, s13, s10
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cde2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
					if (AHDSR_increment <= instrument->decay_level)
 808cde6:	eef4 6ae5 	vcmpe.f32	s13, s11
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808cdea:	ed8d 7a00 	vstr	s14, [sp]
					if (AHDSR_increment <= instrument->decay_level)
 808cdee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 808cdf2:	f89d 3000 	ldrb.w	r3, [sp]
 808cdf6:	d8cd      	bhi.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
						AHDSR_state = AHDSR_SUSTAIN;
 808cdf8:	2102      	movs	r1, #2
						AHDSR_counter=0;
 808cdfa:	2000      	movs	r0, #0
 808cdfc:	e7ca      	b.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
					tmp = (uint32_t)(tmp * instrument->decay_level);
 808cdfe:	ee07 3a10 	vmov	s14, r3
 808ce02:	eddc 5a04 	vldr	s11, [ip, #16]
					AHDSR_counter++;
 808ce06:	3001      	adds	r0, #1
					if (AHDSR_counter>=instrument->sustain_time)
 808ce08:	f8dc 6004 	ldr.w	r6, [ip, #4]
					tmp = (uint32_t)(tmp * instrument->decay_level);
 808ce0c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
					if (AHDSR_counter>=instrument->sustain_time)
 808ce10:	42b0      	cmp	r0, r6
					tmp = (uint32_t)(tmp * instrument->decay_level);
 808ce12:	ee27 7a25 	vmul.f32	s14, s14, s11
 808ce16:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 808ce1a:	ed8d 7a00 	vstr	s14, [sp]
 808ce1e:	f89d 3000 	ldrb.w	r3, [sp]
					if (AHDSR_counter>=instrument->sustain_time)
 808ce22:	d3b7      	bcc.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
						AHDSR_increment = instrument->decay_level;
 808ce24:	eef0 6a65 	vmov.f32	s13, s11
						AHDSR_state = AHDSR_RELEASE;
 808ce28:	2105      	movs	r1, #5
 808ce2a:	e7b3      	b.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808ce2c:	ee07 3a10 	vmov	s14, r3
					AHDSR_increment += instrument->attack_increment;
 808ce30:	eddc 5a02 	vldr	s11, [ip, #8]
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808ce34:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 808ce38:	ee27 7a26 	vmul.f32	s14, s14, s13
					AHDSR_increment += instrument->attack_increment;
 808ce3c:	ee76 6aa5 	vadd.f32	s13, s13, s11
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808ce40:	eebc 7ac7 	vcvt.u32.f32	s14, s14
					if (AHDSR_increment >= 1.0f)
 808ce44:	eef4 6ae4 	vcmpe.f32	s13, s9
					tmp = (uint32_t)(tmp * AHDSR_increment);
 808ce48:	ed8d 7a00 	vstr	s14, [sp]
					if (AHDSR_increment >= 1.0f)
 808ce4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 808ce50:	f89d 3000 	ldrb.w	r3, [sp]
 808ce54:	db9e      	blt.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
						AHDSR_state = AHDSR_HOLD;
 808ce56:	2104      	movs	r1, #4
						AHDSR_counter=0;
 808ce58:	2000      	movs	r0, #0
 808ce5a:	e79b      	b.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
						AHDSR_state = AHDSR_IDLE;
 808ce5c:	2100      	movs	r1, #0
						AHDSR_counter=0;
 808ce5e:	4608      	mov	r0, r1
						AHDSR_increment=0;
 808ce60:	ee06 1a90 	vmov	s13, r1
 808ce64:	e796      	b.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>
 808ce66:	f64e 63ef 	movw	r3, #61167	; 0xeeef
 808ce6a:	f2c2 0302 	movt	r3, #8194	; 0x2002
					SYNTH_LocalBuffer[i]=0;
 808ce6e:	f04f 0200 	mov.w	r2, #0
 808ce72:	f803 2f01 	strb.w	r2, [r3, #1]!
				for (i=0; i< AUDIO_BUFFER_SIZE; i++) {
 808ce76:	42a3      	cmp	r3, r4
 808ce78:	d1f9      	bne.n	808ce6e <SYNTH_FillBuffer.constprop.0+0x1ee>
 808ce7a:	e726      	b.n	808ccca <SYNTH_FillBuffer.constprop.0+0x4a>
				switch (AHDSR_state)
 808ce7c:	2300      	movs	r3, #0
 808ce7e:	e789      	b.n	808cd94 <SYNTH_FillBuffer.constprop.0+0x114>

0808ce80 <SYNTH_AudioCallback>:
//	}
//}

static void SYNTH_AudioCallback(int buffer_nbr)
{
	SYNTH_FillBuffer(buffer_nbr, SYNTH_Channels);
 808ce80:	f7ff befe 	b.w	808cc80 <SYNTH_FillBuffer.constprop.0>

0808ce84 <SYNTH_Start>:
SYNTH_Status SYNTH_Start(void) {
 808ce84:	b538      	push	{r3, r4, r5, lr}
	AUDIO_Stop();
 808ce86:	f7ff fced 	bl	808c864 <AUDIO_Stop>
	AUDIO_SetEventCallback(SYNTH_AudioCallback);
 808ce8a:	f64c 6081 	movw	r0, #52865	; 0xce81
		SYNTH_Channels[i].note = MUTE;
 808ce8e:	24ff      	movs	r4, #255	; 0xff
	AUDIO_SetEventCallback(SYNTH_AudioCallback);
 808ce90:	f6c0 0008 	movt	r0, #2056	; 0x808
 808ce94:	f7ff fd38 	bl	808c908 <AUDIO_SetEventCallback>
 808ce98:	f64e 636c 	movw	r3, #61036	; 0xee6c
 808ce9c:	f642 400c 	movw	r0, #11276	; 0x2c0c
		SYNTH_Channels[i].counter=0.0f;
 808cea0:	2200      	movs	r2, #0
 808cea2:	f2c2 0302 	movt	r3, #8194	; 0x2002
		SYNTH_Channels[i].volume=0;
 808cea6:	4611      	mov	r1, r2
 808cea8:	f6c0 0009 	movt	r0, #2057	; 0x809
 808ceac:	f103 0580 	add.w	r5, r3, #128	; 0x80
		SYNTH_Channels[i].counter=0.0f;
 808ceb0:	609a      	str	r2, [r3, #8]
 808ceb2:	3320      	adds	r3, #32
		SYNTH_Channels[i].increment=0.0f;
 808ceb4:	f843 2c14 	str.w	r2, [r3, #-20]
		SYNTH_Channels[i].volume=0;
 808ceb8:	f803 1c10 	strb.w	r1, [r3, #-16]
		SYNTH_Channels[i].note = MUTE;
 808cebc:	f803 4c1c 	strb.w	r4, [r3, #-28]
		SYNTH_Channels[i].instrument = (SYNTH_Instrument*)&SYNTH_Inst_Piano;
 808cec0:	f843 0c20 	str.w	r0, [r3, #-32]
		SYNTH_Channels[i].AHDSR_state = AHDSR_IDLE;
 808cec4:	f803 1c03 	strb.w	r1, [r3, #-3]
	for (i=0; i<SYNTH_ChannelsNbr; i++)
 808cec8:	42ab      	cmp	r3, r5
 808ceca:	d1f1      	bne.n	808ceb0 <SYNTH_Start+0x2c>
	SYNTH_FillBuffer(1, SYNTH_Channels);
 808cecc:	2001      	movs	r0, #1
 808cece:	f7ff fed7 	bl	808cc80 <SYNTH_FillBuffer.constprop.0>
	SYNTH_FillBuffer(2, SYNTH_Channels);
 808ced2:	2002      	movs	r0, #2
 808ced4:	f7ff fed4 	bl	808cc80 <SYNTH_FillBuffer.constprop.0>
	AUDIO_Start();
 808ced8:	f7ff fca6 	bl	808c828 <AUDIO_Start>
}
 808cedc:	2000      	movs	r0, #0
 808cede:	bd38      	pop	{r3, r4, r5, pc}

0808cee0 <SYNTH_Stop>:
SYNTH_Status SYNTH_Stop(void) {
 808cee0:	b538      	push	{r3, r4, r5, lr}
	AUDIO_Stop();
 808cee2:	f7ff fcbf 	bl	808c864 <AUDIO_Stop>
	AUDIO_SetEventCallback((AUDIO_EventCallback)0x0);
 808cee6:	2000      	movs	r0, #0
 808cee8:	f7ff fd0e 	bl	808c908 <AUDIO_SetEventCallback>
 808ceec:	f64e 636c 	movw	r3, #61036	; 0xee6c
 808cef0:	f642 400c 	movw	r0, #11276	; 0x2c0c
		SYNTH_Channels[i].counter=0.0f;
 808cef4:	2200      	movs	r2, #0
 808cef6:	f2c2 0302 	movt	r3, #8194	; 0x2002
		SYNTH_Channels[i].note = MUTE;
 808cefa:	24ff      	movs	r4, #255	; 0xff
		SYNTH_Channels[i].volume=0;
 808cefc:	4611      	mov	r1, r2
 808cefe:	f6c0 0009 	movt	r0, #2057	; 0x809
 808cf02:	f103 0580 	add.w	r5, r3, #128	; 0x80
		SYNTH_Channels[i].counter=0.0f;
 808cf06:	609a      	str	r2, [r3, #8]
 808cf08:	3320      	adds	r3, #32
		SYNTH_Channels[i].increment=0.0f;
 808cf0a:	f843 2c14 	str.w	r2, [r3, #-20]
		SYNTH_Channels[i].volume=0;
 808cf0e:	f803 1c10 	strb.w	r1, [r3, #-16]
		SYNTH_Channels[i].note = MUTE;
 808cf12:	f803 4c1c 	strb.w	r4, [r3, #-28]
		SYNTH_Channels[i].instrument = (SYNTH_Instrument*)&SYNTH_Inst_Piano;
 808cf16:	f843 0c20 	str.w	r0, [r3, #-32]
		SYNTH_Channels[i].AHDSR_state = AHDSR_IDLE;
 808cf1a:	f803 1c03 	strb.w	r1, [r3, #-3]
	for (i=0; i<SYNTH_ChannelsNbr; i++)
 808cf1e:	42ab      	cmp	r3, r5
 808cf20:	d1f1      	bne.n	808cf06 <SYNTH_Stop+0x26>
	SYNTH_FillBuffer(1, SYNTH_Channels);
 808cf22:	2001      	movs	r0, #1
 808cf24:	f7ff feac 	bl	808cc80 <SYNTH_FillBuffer.constprop.0>
	SYNTH_FillBuffer(2, SYNTH_Channels);
 808cf28:	2002      	movs	r0, #2
 808cf2a:	f7ff fea9 	bl	808cc80 <SYNTH_FillBuffer.constprop.0>
}
 808cf2e:	2000      	movs	r0, #0
 808cf30:	bd38      	pop	{r3, r4, r5, pc}
 808cf32:	bf00      	nop

0808cf34 <SYNTH_SetMainVolume>:
	SYNTH_MainVolume = volume;
 808cf34:	f64e 63ec 	movw	r3, #61164	; 0xeeec
 808cf38:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808cf3c:	7018      	strb	r0, [r3, #0]
}
 808cf3e:	2000      	movs	r0, #0
 808cf40:	4770      	bx	lr
 808cf42:	bf00      	nop

0808cf44 <SYNTH_SetVolume>:
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808cf44:	2803      	cmp	r0, #3
 808cf46:	d809      	bhi.n	808cf5c <SYNTH_SetVolume+0x18>
	SYNTH_Channels[channel].volume=volume;
 808cf48:	f64e 636c 	movw	r3, #61036	; 0xee6c
	return SYNTH_SUCCESS;
 808cf4c:	2200      	movs	r2, #0
	SYNTH_Channels[channel].volume=volume;
 808cf4e:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808cf52:	eb03 1340 	add.w	r3, r3, r0, lsl #5
}
 808cf56:	4610      	mov	r0, r2
	SYNTH_Channels[channel].volume=volume;
 808cf58:	7419      	strb	r1, [r3, #16]
}
 808cf5a:	4770      	bx	lr
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808cf5c:	2202      	movs	r2, #2
}
 808cf5e:	4610      	mov	r0, r2
 808cf60:	4770      	bx	lr
 808cf62:	bf00      	nop

0808cf64 <SYNTH_SetInstrument>:
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808cf64:	2803      	cmp	r0, #3
 808cf66:	d807      	bhi.n	808cf78 <SYNTH_SetInstrument+0x14>
	SYNTH_Channels[channel].instrument=instrument;
 808cf68:	f64e 626c 	movw	r2, #61036	; 0xee6c
 808cf6c:	0143      	lsls	r3, r0, #5
	return SYNTH_SUCCESS;
 808cf6e:	2000      	movs	r0, #0
	SYNTH_Channels[channel].instrument=instrument;
 808cf70:	f2c2 0202 	movt	r2, #8194	; 0x2002
 808cf74:	50d1      	str	r1, [r2, r3]
	return SYNTH_SUCCESS;
 808cf76:	4770      	bx	lr
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808cf78:	2002      	movs	r0, #2
}
 808cf7a:	4770      	bx	lr

0808cf7c <SYNTH_NoteOn>:
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808cf7c:	2803      	cmp	r0, #3
 808cf7e:	d83d      	bhi.n	808cffc <SYNTH_NoteOn+0x80>
	if (note!=MUTE)
 808cf80:	29ff      	cmp	r1, #255	; 0xff
SYNTH_Status SYNTH_NoteOn(int channel, SYNTH_Note note) {
 808cf82:	b430      	push	{r4, r5}
	if (note!=MUTE)
 808cf84:	d02d      	beq.n	808cfe2 <SYNTH_NoteOn+0x66>
		if ((note<C0) || (note>=B7)) return SYNTH_INVALID_NOTE;
 808cf86:	295e      	cmp	r1, #94	; 0x5e
 808cf88:	d83b      	bhi.n	808d002 <SYNTH_NoteOn+0x86>
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cf8a:	f642 4528 	movw	r5, #11304	; 0x2c28
 808cf8e:	f247 74ee 	movw	r4, #30702	; 0x77ee
 808cf92:	2200      	movs	r2, #0
		SYNTH_Channels[channel].note = note;
 808cf94:	f64e 636c 	movw	r3, #61036	; 0xee6c
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cf98:	f6c0 0509 	movt	r5, #2057	; 0x809
 808cf9c:	f6c3 24a3 	movt	r4, #15011	; 0x3aa3
 808cfa0:	f2c4 22c8 	movt	r2, #17096	; 0x42c8
		SYNTH_Channels[channel].note = note;
 808cfa4:	f2c2 0302 	movt	r3, #8194	; 0x2002
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cfa8:	f855 5021 	ldr.w	r5, [r5, r1, lsl #2]
 808cfac:	ee06 4a90 	vmov	s13, r4
 808cfb0:	ee07 2a10 	vmov	s14, r2
		SYNTH_Channels[channel].note = note;
 808cfb4:	eb03 1340 	add.w	r3, r3, r0, lsl #5
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cfb8:	ee07 5a90 	vmov	s15, r5
		SYNTH_Channels[channel].counter = 0.0f;
 808cfbc:	2200      	movs	r2, #0
		SYNTH_Channels[channel].AHDSR_state = AHDSR_ATTACK;
 808cfbe:	2501      	movs	r5, #1
		SYNTH_Channels[channel].note = note;
 808cfc0:	7119      	strb	r1, [r3, #4]
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cfc2:	eef8 7a67 	vcvt.f32.u32	s15, s15
		SYNTH_Channels[channel].AHDSR_level=0;
 808cfc6:	771a      	strb	r2, [r3, #28]
		SYNTH_Channels[channel].AHDSR_state = AHDSR_ATTACK;
 808cfc8:	775d      	strb	r5, [r3, #29]
}
 808cfca:	4610      	mov	r0, r2
		SYNTH_Channels[channel].counter = 0.0f;
 808cfcc:	609a      	str	r2, [r3, #8]
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cfce:	ee67 7aa6 	vmul.f32	s15, s15, s13
		SYNTH_Channels[channel].AHDSR_increment=0.0f;
 808cfd2:	619a      	str	r2, [r3, #24]
		SYNTH_Channels[channel].AHDSR_counter = 0;
 808cfd4:	615a      	str	r2, [r3, #20]
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cfd6:	eec7 6a87 	vdiv.f32	s13, s15, s14
}
 808cfda:	bc30      	pop	{r4, r5}
		SYNTH_Channels[channel].increment = ((55.0f/44100.0f)*SYNTH_NoteFrequencies[note])/100;
 808cfdc:	edc3 6a03 	vstr	s13, [r3, #12]
}
 808cfe0:	4770      	bx	lr
		SYNTH_Channels[channel].increment = 0.0f;
 808cfe2:	f64e 636c 	movw	r3, #61036	; 0xee6c
 808cfe6:	2100      	movs	r1, #0
 808cfe8:	f2c2 0302 	movt	r3, #8194	; 0x2002
	return SYNTH_SUCCESS;
 808cfec:	460a      	mov	r2, r1
		SYNTH_Channels[channel].increment = 0.0f;
 808cfee:	eb03 1340 	add.w	r3, r3, r0, lsl #5
}
 808cff2:	4610      	mov	r0, r2
		SYNTH_Channels[channel].increment = 0.0f;
 808cff4:	60d9      	str	r1, [r3, #12]
		SYNTH_Channels[channel].AHDSR_state = AHDSR_IDLE;
 808cff6:	7759      	strb	r1, [r3, #29]
}
 808cff8:	bc30      	pop	{r4, r5}
 808cffa:	4770      	bx	lr
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808cffc:	2202      	movs	r2, #2
}
 808cffe:	4610      	mov	r0, r2
 808d000:	4770      	bx	lr
		if ((note<C0) || (note>=B7)) return SYNTH_INVALID_NOTE;
 808d002:	2203      	movs	r2, #3
}
 808d004:	bc30      	pop	{r4, r5}
 808d006:	4610      	mov	r0, r2
 808d008:	4770      	bx	lr
 808d00a:	bf00      	nop

0808d00c <SYNTH_NoteOff>:
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808d00c:	2803      	cmp	r0, #3
{
 808d00e:	b410      	push	{r4}
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808d010:	d80e      	bhi.n	808d030 <SYNTH_NoteOff+0x24>
	SYNTH_Channels[channel].counter=0.0f;
 808d012:	f64e 636c 	movw	r3, #61036	; 0xee6c
 808d016:	2200      	movs	r2, #0
 808d018:	f2c2 0302 	movt	r3, #8194	; 0x2002
	return SYNTH_SUCCESS;
 808d01c:	4614      	mov	r4, r2
	SYNTH_Channels[channel].counter=0.0f;
 808d01e:	eb03 1340 	add.w	r3, r3, r0, lsl #5
}
 808d022:	4620      	mov	r0, r4
 808d024:	f85d 4b04 	ldr.w	r4, [sp], #4
	SYNTH_Channels[channel].counter=0.0f;
 808d028:	609a      	str	r2, [r3, #8]
	SYNTH_Channels[channel].increment=0.0f;
 808d02a:	60da      	str	r2, [r3, #12]
	SYNTH_Channels[channel].AHDSR_state = AHDSR_IDLE;
 808d02c:	775a      	strb	r2, [r3, #29]
}
 808d02e:	4770      	bx	lr
	if ((channel <0) || (channel >= SYNTH_ChannelsNbr)) return SYNTH_INVALID_CHANNEL;
 808d030:	2402      	movs	r4, #2
}
 808d032:	4620      	mov	r0, r4
 808d034:	f85d 4b04 	ldr.w	r4, [sp], #4
 808d038:	4770      	bx	lr
 808d03a:	bf00      	nop

0808d03c <get_fattime>:
/* RTC Functions                                                         */
/*-----------------------------------------------------------------------*/

DWORD get_fattime (void) {
	return 0;
}
 808d03c:	2000      	movs	r0, #0
 808d03e:	4770      	bx	lr

0808d040 <disk_initialize>:
	BYTE drv		/* Physical drive number (0) */
)
{
	uint8_t status;

	if (drv) return STA_NOINIT;			/* Supports only drive 0 */
 808d040:	b108      	cbz	r0, 808d046 <disk_initialize+0x6>
 808d042:	2001      	movs	r0, #1
	if (status == MSD_OK) Stat = 0;
	else if (status == MSD_ERROR_SD_NOT_PRESENT) Stat= STA_NODISK;
	else Stat= STA_NOINIT;

	return Stat;
}
 808d044:	4770      	bx	lr
{
 808d046:	b508      	push	{r3, lr}
	status = BSP_SD_Init();
 808d048:	f7f7 ffa0 	bl	8084f8c <BSP_SD_Init>
	if (status == MSD_OK) Stat = 0;
 808d04c:	f24b 0388 	movw	r3, #45192	; 0xb088
 808d050:	b928      	cbnz	r0, 808d05e <disk_initialize+0x1e>
	else if (status == MSD_ERROR_SD_NOT_PRESENT) Stat= STA_NODISK;
 808d052:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808d056:	7018      	strb	r0, [r3, #0]
	return Stat;
 808d058:	7818      	ldrb	r0, [r3, #0]
 808d05a:	b2c0      	uxtb	r0, r0
}
 808d05c:	bd08      	pop	{r3, pc}
	else if (status == MSD_ERROR_SD_NOT_PRESENT) Stat= STA_NODISK;
 808d05e:	2802      	cmp	r0, #2
 808d060:	d0f7      	beq.n	808d052 <disk_initialize+0x12>
	else Stat= STA_NOINIT;
 808d062:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808d066:	2201      	movs	r2, #1
 808d068:	701a      	strb	r2, [r3, #0]
	return Stat;
 808d06a:	7818      	ldrb	r0, [r3, #0]
 808d06c:	b2c0      	uxtb	r0, r0
}
 808d06e:	bd08      	pop	{r3, pc}

0808d070 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only drive 0 */
 808d070:	b108      	cbz	r0, 808d076 <disk_status+0x6>
 808d072:	2001      	movs	r0, #1

	if (BSP_SD_IsDetected()!= SD_NOT_PRESENT) Stat &= ~STA_NODISK;
	else Stat |= (STA_NODISK + STA_NOINIT);
	return Stat;	/* Return disk status */
}
 808d074:	4770      	bx	lr
{
 808d076:	b508      	push	{r3, lr}
	if (BSP_SD_IsDetected()!= SD_NOT_PRESENT) Stat &= ~STA_NODISK;
 808d078:	f7f7 fe42 	bl	8084d00 <BSP_SD_IsDetected>
 808d07c:	f24b 0388 	movw	r3, #45192	; 0xb088
 808d080:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808d084:	781a      	ldrb	r2, [r3, #0]
 808d086:	b928      	cbnz	r0, 808d094 <disk_status+0x24>
	else Stat |= (STA_NODISK + STA_NOINIT);
 808d088:	f042 0203 	orr.w	r2, r2, #3
 808d08c:	701a      	strb	r2, [r3, #0]
	return Stat;	/* Return disk status */
 808d08e:	7818      	ldrb	r0, [r3, #0]
 808d090:	b2c0      	uxtb	r0, r0
}
 808d092:	bd08      	pop	{r3, pc}
	if (BSP_SD_IsDetected()!= SD_NOT_PRESENT) Stat &= ~STA_NODISK;
 808d094:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
 808d098:	701a      	strb	r2, [r3, #0]
	return Stat;	/* Return disk status */
 808d09a:	7818      	ldrb	r0, [r3, #0]
 808d09c:	b2c0      	uxtb	r0, r0
}
 808d09e:	bd08      	pop	{r3, pc}

0808d0a0 <disk_read>:
	BYTE *buff,		/* Pointer to the data buffer to store read data */
	DWORD sector,	/* Start sector number (LBA) */
	UINT count		/* Number of sectors to read (1..128) */
)
{
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 808d0a0:	b9c0      	cbnz	r0, 808d0d4 <disk_read+0x34>
 808d0a2:	b1bb      	cbz	r3, 808d0d4 <disk_read+0x34>
{
 808d0a4:	b510      	push	{r4, lr}
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 808d0a6:	f24b 0488 	movw	r4, #45192	; 0xb088
 808d0aa:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808d0ae:	7820      	ldrb	r0, [r4, #0]
 808d0b0:	07c0      	lsls	r0, r0, #31
 808d0b2:	d40d      	bmi.n	808d0d0 <disk_read+0x30>
 808d0b4:	4614      	mov	r4, r2
 808d0b6:	4608      	mov	r0, r1
//			} while (--count);
//			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
//		}
//	}

	if (BSP_SD_ReadBlocks((uint32_t *)buff, sector, count, 10000) == MSD_ERROR) return RES_ERROR;
 808d0b8:	461a      	mov	r2, r3
 808d0ba:	f242 7310 	movw	r3, #10000	; 0x2710
 808d0be:	4621      	mov	r1, r4
 808d0c0:	f7f7 fe36 	bl	8084d30 <BSP_SD_ReadBlocks>
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 808d0c4:	f1a0 0001 	sub.w	r0, r0, #1
 808d0c8:	fab0 f080 	clz	r0, r0
 808d0cc:	0940      	lsrs	r0, r0, #5
	else return RES_OK;
}
 808d0ce:	bd10      	pop	{r4, pc}
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 808d0d0:	2003      	movs	r0, #3
}
 808d0d2:	bd10      	pop	{r4, pc}
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 808d0d4:	2004      	movs	r0, #4
}
 808d0d6:	4770      	bx	lr

0808d0d8 <disk_write>:
	const BYTE *buff,	/* Ponter to the data to write */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Number of sectors to write (1..128) */
)
{
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 808d0d8:	bba8      	cbnz	r0, 808d146 <disk_write+0x6e>
 808d0da:	b3a3      	cbz	r3, 808d146 <disk_write+0x6e>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
 808d0dc:	f24b 0088 	movw	r0, #45192	; 0xb088
 808d0e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
{
 808d0e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
 808d0e6:	7804      	ldrb	r4, [r0, #0]
 808d0e8:	07e4      	lsls	r4, r4, #31
 808d0ea:	d42a      	bmi.n	808d142 <disk_write+0x6a>
	if (Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */
 808d0ec:	7800      	ldrb	r0, [r0, #0]
 808d0ee:	0740      	lsls	r0, r0, #29
 808d0f0:	d42b      	bmi.n	808d14a <disk_write+0x72>
 808d0f2:	f64b 24b8 	movw	r4, #47800	; 0xbab8
 808d0f6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808d0fa:	f504 7c00 	add.w	ip, r4, #512	; 0x200
		acc = ((uint32_t)inBuf[offset]) + ((uint32_t)inBuf[offset+1]<<8) + ((uint32_t)inBuf[offset+2]<<16) + ((uint32_t)inBuf[offset+3]<<24);
 808d0fe:	7888      	ldrb	r0, [r1, #2]
 808d100:	3104      	adds	r1, #4
 808d102:	f811 7c03 	ldrb.w	r7, [r1, #-3]
 808d106:	0400      	lsls	r0, r0, #16
 808d108:	f811 6c04 	ldrb.w	r6, [r1, #-4]
 808d10c:	f811 5c01 	ldrb.w	r5, [r1, #-1]
 808d110:	eb00 2007 	add.w	r0, r0, r7, lsl #8
 808d114:	4430      	add	r0, r6
 808d116:	eb00 6005 	add.w	r0, r0, r5, lsl #24
		outBuf[counter]=acc;
 808d11a:	f844 0f04 	str.w	r0, [r4, #4]!
	for (counter=0; counter <BUFFER_WORDS_SIZE; counter++)
 808d11e:	45a4      	cmp	ip, r4
 808d120:	d1ed      	bne.n	808d0fe <disk_write+0x26>

//	return count ? RES_ERROR : RES_OK;	/* Return result */

	//if (BSP_SD_WriteBlocks((uint32_t *)buff, sector, count, 500) == MSD_ERROR) return RES_ERROR;
	CopyBuffer(aTxBuffer, buff);
	if (BSP_SD_WriteBlocks(aTxBuffer, sector, count, 10000) == MSD_ERROR) return RES_ERROR;
 808d122:	f64b 20bc 	movw	r0, #47804	; 0xbabc
 808d126:	4611      	mov	r1, r2
 808d128:	461a      	mov	r2, r3
 808d12a:	f242 7310 	movw	r3, #10000	; 0x2710
 808d12e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808d132:	f7f7 fe0f 	bl	8084d54 <BSP_SD_WriteBlocks>
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 808d136:	f1a0 0001 	sub.w	r0, r0, #1
 808d13a:	fab0 f080 	clz	r0, r0
 808d13e:	0940      	lsrs	r0, r0, #5
	else return RES_OK;
}
 808d140:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
 808d142:	2003      	movs	r0, #3
}
 808d144:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 808d146:	2004      	movs	r0, #4
}
 808d148:	4770      	bx	lr
	if (Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */
 808d14a:	2002      	movs	r0, #2
}
 808d14c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808d14e:	bf00      	nop

0808d150 <disk_ioctl>:
	DRESULT res;
	//BYTE n, csd[16];
	DWORD *dp; //, st, ed, csize;
	HAL_SD_CardInfoTypeDef CardInfo;

	if (drv) return RES_PARERR;					/* Check parameter */
 808d150:	b9d0      	cbnz	r0, 808d188 <disk_ioctl+0x38>
{
 808d152:	b570      	push	{r4, r5, r6, lr}
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 808d154:	f24b 0488 	movw	r4, #45192	; 0xb088
{
 808d158:	b088      	sub	sp, #32
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 808d15a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 808d15e:	7823      	ldrb	r3, [r4, #0]
 808d160:	07db      	lsls	r3, r3, #31
 808d162:	d40e      	bmi.n	808d182 <disk_ioctl+0x32>
 808d164:	4616      	mov	r6, r2
 808d166:	460d      	mov	r5, r1
	if (BSP_SD_IsDetected()!= SD_NOT_PRESENT)
 808d168:	f7f7 fdca 	bl	8084d00 <BSP_SD_IsDetected>
 808d16c:	b970      	cbnz	r0, 808d18c <disk_ioctl+0x3c>
		return RES_NOTRDY;
	}

	res = RES_ERROR;

	BSP_SD_GetCardInfo(&CardInfo);
 808d16e:	4668      	mov	r0, sp
 808d170:	f7f7 ff58 	bl	8085024 <BSP_SD_GetCardInfo>

	switch (cmd) {
 808d174:	2d04      	cmp	r5, #4
 808d176:	d822      	bhi.n	808d1be <disk_ioctl+0x6e>
 808d178:	e8df f005 	tbb	[pc, r5]
 808d17c:	19211d0f 	.word	0x19211d0f
 808d180:	11          	.byte	0x11
 808d181:	00          	.byte	0x00
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 808d182:	2003      	movs	r0, #3
	}

	//deselect();

	return res;
}
 808d184:	b008      	add	sp, #32
 808d186:	bd70      	pop	{r4, r5, r6, pc}
	if (drv) return RES_PARERR;					/* Check parameter */
 808d188:	2004      	movs	r0, #4
}
 808d18a:	4770      	bx	lr
		Stat &= ~STA_NODISK;
 808d18c:	7823      	ldrb	r3, [r4, #0]
		return RES_NOTRDY;
 808d18e:	2003      	movs	r0, #3
		Stat &= ~STA_NODISK;
 808d190:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 808d194:	7023      	strb	r3, [r4, #0]
}
 808d196:	b008      	add	sp, #32
 808d198:	bd70      	pop	{r4, r5, r6, pc}
		res = RES_OK;
 808d19a:	2000      	movs	r0, #0
 808d19c:	e7f2      	b.n	808d184 <disk_ioctl+0x34>
		if (BSP_SD_Erase(dp[0], dp[1]) == MSD_OK) res=RES_OK;
 808d19e:	e9d6 0100 	ldrd	r0, r1, [r6]
 808d1a2:	f7f7 fde9 	bl	8084d78 <BSP_SD_Erase>
	if (drv) return RES_PARERR;					/* Check parameter */
 808d1a6:	3000      	adds	r0, #0
 808d1a8:	bf18      	it	ne
 808d1aa:	2001      	movne	r0, #1
 808d1ac:	e7ea      	b.n	808d184 <disk_ioctl+0x34>
		*(DWORD*)buff = CardInfo.BlockSize;
 808d1ae:	9b05      	ldr	r3, [sp, #20]
		res = RES_OK;
 808d1b0:	2000      	movs	r0, #0
		*(DWORD*)buff = CardInfo.BlockSize;
 808d1b2:	6033      	str	r3, [r6, #0]
		break;
 808d1b4:	e7e6      	b.n	808d184 <disk_ioctl+0x34>
		*(DWORD*)buff = CardInfo.BlockNbr;
 808d1b6:	9b04      	ldr	r3, [sp, #16]
		res = RES_OK;
 808d1b8:	2000      	movs	r0, #0
		*(DWORD*)buff = CardInfo.BlockNbr;
 808d1ba:	6033      	str	r3, [r6, #0]
		break;
 808d1bc:	e7e2      	b.n	808d184 <disk_ioctl+0x34>
		res = RES_PARERR;
 808d1be:	2004      	movs	r0, #4
 808d1c0:	e7e0      	b.n	808d184 <disk_ioctl+0x34>
 808d1c2:	bf00      	nop

0808d1c4 <get_ldnumber>:
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
	char c;
#endif

	tt = tp = *path;
 808d1c4:	6801      	ldr	r1, [r0, #0]
	if (!tp) return vol;	/* Invalid path name? */
 808d1c6:	b311      	cbz	r1, 808d20e <get_ldnumber+0x4a>
 808d1c8:	460a      	mov	r2, r1
 808d1ca:	e001      	b.n	808d1d0 <get_ldnumber+0xc>
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
 808d1cc:	2b3a      	cmp	r3, #58	; 0x3a
 808d1ce:	d003      	beq.n	808d1d8 <get_ldnumber+0x14>
 808d1d0:	f812 3b01 	ldrb.w	r3, [r2], #1
 808d1d4:	2b1f      	cmp	r3, #31
 808d1d6:	d8f9      	bhi.n	808d1cc <get_ldnumber+0x8>

	if (tc == ':') {	/* DOS/Windows style volume ID? */
 808d1d8:	2b3a      	cmp	r3, #58	; 0x3a
 808d1da:	d005      	beq.n	808d1e8 <get_ldnumber+0x24>
		}
	}
#endif
	/* No drive prefix is found */
#if FF_FS_RPATH != 0
	vol = CurrVol;	/* Default drive is current drive */
 808d1dc:	f64b 43bc 	movw	r3, #48316	; 0xbcbc
 808d1e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808d1e4:	7818      	ldrb	r0, [r3, #0]
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
 808d1e6:	4770      	bx	lr
{
 808d1e8:	b410      	push	{r4}
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 808d1ea:	780b      	ldrb	r3, [r1, #0]
 808d1ec:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 808d1f0:	2c09      	cmp	r4, #9
 808d1f2:	d809      	bhi.n	808d208 <get_ldnumber+0x44>
 808d1f4:	3102      	adds	r1, #2
 808d1f6:	428a      	cmp	r2, r1
 808d1f8:	d106      	bne.n	808d208 <get_ldnumber+0x44>
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
 808d1fa:	2b30      	cmp	r3, #48	; 0x30
 808d1fc:	d104      	bne.n	808d208 <get_ldnumber+0x44>
			*path = tt;		/* Snip the drive prefix off */
 808d1fe:	6002      	str	r2, [r0, #0]
 808d200:	2000      	movs	r0, #0
}
 808d202:	f85d 4b04 	ldr.w	r4, [sp], #4
 808d206:	4770      	bx	lr
	if (!tp) return vol;	/* Invalid path name? */
 808d208:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808d20c:	e7f9      	b.n	808d202 <get_ldnumber+0x3e>
 808d20e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 808d212:	4770      	bx	lr

0808d214 <validate>:
)
{
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 808d214:	b1d8      	cbz	r0, 808d24e <validate+0x3a>
 808d216:	6803      	ldr	r3, [r0, #0]
{
 808d218:	b510      	push	{r4, lr}
 808d21a:	4604      	mov	r4, r0
 808d21c:	b082      	sub	sp, #8
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 808d21e:	b12b      	cbz	r3, 808d22c <validate+0x18>
 808d220:	781a      	ldrb	r2, [r3, #0]
 808d222:	b11a      	cbz	r2, 808d22c <validate+0x18>
 808d224:	8880      	ldrh	r0, [r0, #4]
 808d226:	88da      	ldrh	r2, [r3, #6]
 808d228:	4290      	cmp	r0, r2
 808d22a:	d004      	beq.n	808d236 <validate+0x22>
	FRESULT res = FR_INVALID_OBJECT;
 808d22c:	2009      	movs	r0, #9
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 808d22e:	2300      	movs	r3, #0
 808d230:	600b      	str	r3, [r1, #0]
	return res;
}
 808d232:	b002      	add	sp, #8
 808d234:	bd10      	pop	{r4, pc}
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 808d236:	7858      	ldrb	r0, [r3, #1]
 808d238:	9101      	str	r1, [sp, #4]
 808d23a:	f7ff ff19 	bl	808d070 <disk_status>
 808d23e:	f010 0001 	ands.w	r0, r0, #1
 808d242:	9901      	ldr	r1, [sp, #4]
 808d244:	d1f2      	bne.n	808d22c <validate+0x18>
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 808d246:	6823      	ldr	r3, [r4, #0]
 808d248:	600b      	str	r3, [r1, #0]
}
 808d24a:	b002      	add	sp, #8
 808d24c:	bd10      	pop	{r4, pc}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 808d24e:	2300      	movs	r3, #0
	FRESULT res = FR_INVALID_OBJECT;
 808d250:	2009      	movs	r0, #9
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 808d252:	600b      	str	r3, [r1, #0]
}
 808d254:	4770      	bx	lr
 808d256:	bf00      	nop

0808d258 <tchar2uni>:
{
 808d258:	b538      	push	{r3, r4, r5, lr}
	const TCHAR *p = *str;
 808d25a:	6804      	ldr	r4, [r0, #0]
{
 808d25c:	4605      	mov	r5, r0
	wc = (BYTE)*p++;			/* Get a byte */
 808d25e:	7820      	ldrb	r0, [r4, #0]
 808d260:	3401      	adds	r4, #1
	if (wc != 0) {
 808d262:	b908      	cbnz	r0, 808d268 <tchar2uni+0x10>
	*str = p;	/* Next read pointer */
 808d264:	602c      	str	r4, [r5, #0]
}
 808d266:	bd38      	pop	{r3, r4, r5, pc}
		wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
 808d268:	f240 11b5 	movw	r1, #437	; 0x1b5
 808d26c:	f001 fd50 	bl	808ed10 <ff_oem2uni>
		if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
 808d270:	2800      	cmp	r0, #0
 808d272:	d1f7      	bne.n	808d264 <tchar2uni+0xc>
 808d274:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 808d278:	bd38      	pop	{r3, r4, r5, pc}
 808d27a:	bf00      	nop

0808d27c <mem_cpy.part.0>:
static void mem_cpy (void* dst, const void* src, UINT cnt)
 808d27c:	3801      	subs	r0, #1
 808d27e:	440a      	add	r2, r1
			*d++ = *s++;
 808d280:	f811 3b01 	ldrb.w	r3, [r1], #1
		} while (--cnt);
 808d284:	4291      	cmp	r1, r2
			*d++ = *s++;
 808d286:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
 808d28a:	d1f9      	bne.n	808d280 <mem_cpy.part.0+0x4>
}
 808d28c:	4770      	bx	lr
 808d28e:	bf00      	nop

0808d290 <sync_window.part.5>:
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 808d290:	b570      	push	{r4, r5, r6, lr}
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 808d292:	f100 0638 	add.w	r6, r0, #56	; 0x38
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 808d296:	4604      	mov	r4, r0
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 808d298:	6b42      	ldr	r2, [r0, #52]	; 0x34
 808d29a:	2301      	movs	r3, #1
 808d29c:	7840      	ldrb	r0, [r0, #1]
 808d29e:	4631      	mov	r1, r6
 808d2a0:	f7ff ff1a 	bl	808d0d8 <disk_write>
 808d2a4:	b960      	cbnz	r0, 808d2c0 <sync_window.part.5+0x30>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 808d2a6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 808d2a8:	4605      	mov	r5, r0
 808d2aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 808d2ac:	6a22      	ldr	r2, [r4, #32]
 808d2ae:	1acb      	subs	r3, r1, r3
			fs->wflag = 0;	/* Clear window dirty flag */
 808d2b0:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 808d2b2:	4293      	cmp	r3, r2
 808d2b4:	d202      	bcs.n	808d2bc <sync_window.part.5+0x2c>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 808d2b6:	78a3      	ldrb	r3, [r4, #2]
 808d2b8:	2b02      	cmp	r3, #2
 808d2ba:	d003      	beq.n	808d2c4 <sync_window.part.5+0x34>
	FRESULT res = FR_OK;
 808d2bc:	4628      	mov	r0, r5
}
 808d2be:	bd70      	pop	{r4, r5, r6, pc}
			res = FR_DISK_ERR;
 808d2c0:	2001      	movs	r0, #1
}
 808d2c2:	bd70      	pop	{r4, r5, r6, pc}
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 808d2c4:	440a      	add	r2, r1
 808d2c6:	7860      	ldrb	r0, [r4, #1]
 808d2c8:	4631      	mov	r1, r6
 808d2ca:	2301      	movs	r3, #1
 808d2cc:	f7ff ff04 	bl	808d0d8 <disk_write>
	FRESULT res = FR_OK;
 808d2d0:	4628      	mov	r0, r5
}
 808d2d2:	bd70      	pop	{r4, r5, r6, pc}

0808d2d4 <dir_clear>:
{
 808d2d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 808d2d6:	78c3      	ldrb	r3, [r0, #3]
{
 808d2d8:	4605      	mov	r5, r0
 808d2da:	460e      	mov	r6, r1
	if (fs->wflag) {	/* Is the disk access window dirty */
 808d2dc:	bb53      	cbnz	r3, 808d334 <dir_clear+0x60>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808d2de:	69ea      	ldr	r2, [r5, #28]
	clst -= 2;		/* Cluster number is origin from 2 */
 808d2e0:	1eb3      	subs	r3, r6, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808d2e2:	3a02      	subs	r2, #2
 808d2e4:	4293      	cmp	r3, r2
 808d2e6:	d223      	bcs.n	808d330 <dir_clear+0x5c>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 808d2e8:	896e      	ldrh	r6, [r5, #10]
 808d2ea:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 808d2ec:	fb03 2606 	mla	r6, r3, r6, r2
	mem_set(fs->win, 0, SS(fs));	/* Clear window buffer */
 808d2f0:	f105 0738 	add.w	r7, r5, #56	; 0x38
 808d2f4:	f505 710e 	add.w	r1, r5, #568	; 0x238
		*d++ = (BYTE)val;
 808d2f8:	2200      	movs	r2, #0
	fs->winsect = sect;				/* Set window to top of the cluster */
 808d2fa:	636e      	str	r6, [r5, #52]	; 0x34
	BYTE *d = (BYTE*)dst;
 808d2fc:	463b      	mov	r3, r7
		*d++ = (BYTE)val;
 808d2fe:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 808d302:	428b      	cmp	r3, r1
 808d304:	d1fb      	bne.n	808d2fe <dir_clear+0x2a>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 808d306:	8968      	ldrh	r0, [r5, #10]
 808d308:	b1d0      	cbz	r0, 808d340 <dir_clear+0x6c>
 808d30a:	2400      	movs	r4, #0
 808d30c:	e003      	b.n	808d316 <dir_clear+0x42>
 808d30e:	3401      	adds	r4, #1
 808d310:	8968      	ldrh	r0, [r5, #10]
 808d312:	42a0      	cmp	r0, r4
 808d314:	d908      	bls.n	808d328 <dir_clear+0x54>
 808d316:	2301      	movs	r3, #1
 808d318:	1932      	adds	r2, r6, r4
 808d31a:	4639      	mov	r1, r7
 808d31c:	7868      	ldrb	r0, [r5, #1]
 808d31e:	f7ff fedb 	bl	808d0d8 <disk_write>
 808d322:	2800      	cmp	r0, #0
 808d324:	d0f3      	beq.n	808d30e <dir_clear+0x3a>
 808d326:	8968      	ldrh	r0, [r5, #10]
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 808d328:	1a20      	subs	r0, r4, r0
 808d32a:	bf18      	it	ne
 808d32c:	2001      	movne	r0, #1
}
 808d32e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808d330:	2600      	movs	r6, #0
 808d332:	e7dd      	b.n	808d2f0 <dir_clear+0x1c>
 808d334:	f7ff ffac 	bl	808d290 <sync_window.part.5>
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 808d338:	2800      	cmp	r0, #0
 808d33a:	d0d0      	beq.n	808d2de <dir_clear+0xa>
 808d33c:	2001      	movs	r0, #1
}
 808d33e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 808d340:	4604      	mov	r4, r0
 808d342:	e7f1      	b.n	808d328 <dir_clear+0x54>

0808d344 <sync_fs>:
{
 808d344:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 808d346:	78c3      	ldrb	r3, [r0, #3]
{
 808d348:	4605      	mov	r5, r0
	if (fs->wflag) {	/* Is the disk access window dirty */
 808d34a:	b95b      	cbnz	r3, 808d364 <sync_fs+0x20>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 808d34c:	782b      	ldrb	r3, [r5, #0]
 808d34e:	2b03      	cmp	r3, #3
 808d350:	d00f      	beq.n	808d372 <sync_fs+0x2e>
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 808d352:	2200      	movs	r2, #0
 808d354:	7868      	ldrb	r0, [r5, #1]
 808d356:	4611      	mov	r1, r2
 808d358:	f7ff fefa 	bl	808d150 <disk_ioctl>
 808d35c:	3000      	adds	r0, #0
 808d35e:	bf18      	it	ne
 808d360:	2001      	movne	r0, #1
}
 808d362:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808d364:	f7ff ff94 	bl	808d290 <sync_window.part.5>
	if (res == FR_OK) {
 808d368:	2800      	cmp	r0, #0
 808d36a:	d1fa      	bne.n	808d362 <sync_fs+0x1e>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 808d36c:	782b      	ldrb	r3, [r5, #0]
 808d36e:	2b03      	cmp	r3, #3
 808d370:	d1ef      	bne.n	808d352 <sync_fs+0xe>
 808d372:	792b      	ldrb	r3, [r5, #4]
 808d374:	2b01      	cmp	r3, #1
 808d376:	d1ec      	bne.n	808d352 <sync_fs+0xe>
			mem_set(fs->win, 0, SS(fs));
 808d378:	f105 0138 	add.w	r1, r5, #56	; 0x38
 808d37c:	f505 720e 	add.w	r2, r5, #568	; 0x238
		*d++ = (BYTE)val;
 808d380:	2400      	movs	r4, #0
	BYTE *d = (BYTE*)dst;
 808d382:	460b      	mov	r3, r1
		*d++ = (BYTE)val;
 808d384:	f803 4b01 	strb.w	r4, [r3], #1
	} while (--cnt);
 808d388:	429a      	cmp	r2, r3
 808d38a:	d1fb      	bne.n	808d384 <sync_fs+0x40>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 808d38c:	6968      	ldr	r0, [r5, #20]
	*ptr++ = (BYTE)val; val >>= 8;
 808d38e:	2655      	movs	r6, #85	; 0x55
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 808d390:	692b      	ldr	r3, [r5, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 808d392:	0a07      	lsrs	r7, r0, #8
 808d394:	f885 0220 	strb.w	r0, [r5, #544]	; 0x220
			fs->winsect = fs->volbase + 1;
 808d398:	6a6a      	ldr	r2, [r5, #36]	; 0x24
	*ptr++ = (BYTE)val; val >>= 8;
 808d39a:	f885 7221 	strb.w	r7, [r5, #545]	; 0x221
 808d39e:	0c07      	lsrs	r7, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 808d3a0:	0e00      	lsrs	r0, r0, #24
	*ptr++ = (BYTE)val; val >>= 8;
 808d3a2:	f885 3224 	strb.w	r3, [r5, #548]	; 0x224
	*ptr++ = (BYTE)val; val >>= 8;
 808d3a6:	f885 7222 	strb.w	r7, [r5, #546]	; 0x222
	*ptr++ = (BYTE)val; val >>= 8;
 808d3aa:	0a1f      	lsrs	r7, r3, #8
	*ptr++ = (BYTE)val;
 808d3ac:	f885 0223 	strb.w	r0, [r5, #547]	; 0x223
	*ptr++ = (BYTE)val; val >>= 8;
 808d3b0:	0c18      	lsrs	r0, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 808d3b2:	0e1b      	lsrs	r3, r3, #24
			fs->winsect = fs->volbase + 1;
 808d3b4:	3201      	adds	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 808d3b6:	f885 0226 	strb.w	r0, [r5, #550]	; 0x226
	*ptr++ = (BYTE)val;
 808d3ba:	20aa      	movs	r0, #170	; 0xaa
	*ptr++ = (BYTE)val; val >>= 8;
 808d3bc:	f885 7225 	strb.w	r7, [r5, #549]	; 0x225
	*ptr++ = (BYTE)val; val >>= 8;
 808d3c0:	2761      	movs	r7, #97	; 0x61
	*ptr++ = (BYTE)val;
 808d3c2:	f885 3227 	strb.w	r3, [r5, #551]	; 0x227
	*ptr++ = (BYTE)val; val >>= 8;
 808d3c6:	2352      	movs	r3, #82	; 0x52
	*ptr++ = (BYTE)val; val >>= 8;
 808d3c8:	f885 6236 	strb.w	r6, [r5, #566]	; 0x236
	*ptr++ = (BYTE)val;
 808d3cc:	2641      	movs	r6, #65	; 0x41
	*ptr++ = (BYTE)val;
 808d3ce:	f885 0237 	strb.w	r0, [r5, #567]	; 0x237
	*ptr++ = (BYTE)val; val >>= 8;
 808d3d2:	2072      	movs	r0, #114	; 0x72
 808d3d4:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
	*ptr++ = (BYTE)val; val >>= 8;
 808d3d8:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 808d3dc:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val; val >>= 8;
 808d3de:	f885 021c 	strb.w	r0, [r5, #540]	; 0x21c
	*ptr++ = (BYTE)val; val >>= 8;
 808d3e2:	f885 021d 	strb.w	r0, [r5, #541]	; 0x21d
			fs->winsect = fs->volbase + 1;
 808d3e6:	636a      	str	r2, [r5, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 808d3e8:	f885 703a 	strb.w	r7, [r5, #58]	; 0x3a
	*ptr++ = (BYTE)val;
 808d3ec:	f885 721f 	strb.w	r7, [r5, #543]	; 0x21f
 808d3f0:	f885 603b 	strb.w	r6, [r5, #59]	; 0x3b
	*ptr++ = (BYTE)val; val >>= 8;
 808d3f4:	f885 621e 	strb.w	r6, [r5, #542]	; 0x21e
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 808d3f8:	7868      	ldrb	r0, [r5, #1]
 808d3fa:	f7ff fe6d 	bl	808d0d8 <disk_write>
			fs->fsi_flag = 0;
 808d3fe:	712c      	strb	r4, [r5, #4]
 808d400:	e7a7      	b.n	808d352 <sync_fs+0xe>
 808d402:	bf00      	nop

0808d404 <move_window.part.6>:
static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 808d404:	b538      	push	{r3, r4, r5, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 808d406:	78c3      	ldrb	r3, [r0, #3]
static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 808d408:	4604      	mov	r4, r0
 808d40a:	460d      	mov	r5, r1
	if (fs->wflag) {	/* Is the disk access window dirty */
 808d40c:	b113      	cbz	r3, 808d414 <move_window.part.6+0x10>
 808d40e:	f7ff ff3f 	bl	808d290 <sync_window.part.5>
		if (res == FR_OK) {			/* Fill sector window with new data */
 808d412:	b968      	cbnz	r0, 808d430 <move_window.part.6+0x2c>
			if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
 808d414:	462a      	mov	r2, r5
 808d416:	2301      	movs	r3, #1
 808d418:	f104 0138 	add.w	r1, r4, #56	; 0x38
 808d41c:	7860      	ldrb	r0, [r4, #1]
 808d41e:	f7ff fe3f 	bl	808d0a0 <disk_read>
				res = FR_DISK_ERR;
 808d422:	2800      	cmp	r0, #0
 808d424:	bf16      	itet	ne
 808d426:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
 808d42a:	2000      	moveq	r0, #0
 808d42c:	2001      	movne	r0, #1
			fs->winsect = sector;
 808d42e:	6365      	str	r5, [r4, #52]	; 0x34
}
 808d430:	bd38      	pop	{r3, r4, r5, pc}
 808d432:	bf00      	nop

0808d434 <check_fs>:
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 808d434:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 808d438:	2200      	movs	r2, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d43a:	4299      	cmp	r1, r3
{
 808d43c:	b510      	push	{r4, lr}
 808d43e:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 808d440:	70c2      	strb	r2, [r0, #3]
 808d442:	6343      	str	r3, [r0, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d444:	d122      	bne.n	808d48c <check_fs+0x58>
	rv = rv << 8 | ptr[0];
 808d446:	f894 1237 	ldrb.w	r1, [r4, #567]	; 0x237
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 808d44a:	f64a 2255 	movw	r2, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 808d44e:	f894 3236 	ldrb.w	r3, [r4, #566]	; 0x236
 808d452:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 808d456:	4293      	cmp	r3, r2
 808d458:	d116      	bne.n	808d488 <check_fs+0x54>
	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
 808d45a:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 808d45e:	f102 0318 	add.w	r3, r2, #24
 808d462:	b2db      	uxtb	r3, r3
 808d464:	2b01      	cmp	r3, #1
 808d466:	d901      	bls.n	808d46c <check_fs+0x38>
 808d468:	2aeb      	cmp	r2, #235	; 0xeb
 808d46a:	d12d      	bne.n	808d4c8 <check_fs+0x94>
	} while (--cnt && r == 0);
 808d46c:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
 808d470:	2b46      	cmp	r3, #70	; 0x46
 808d472:	d111      	bne.n	808d498 <check_fs+0x64>
 808d474:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
 808d478:	2b41      	cmp	r3, #65	; 0x41
 808d47a:	d10d      	bne.n	808d498 <check_fs+0x64>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 808d47c:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
 808d480:	2b54      	cmp	r3, #84	; 0x54
 808d482:	d109      	bne.n	808d498 <check_fs+0x64>
 808d484:	2000      	movs	r0, #0
}
 808d486:	bd10      	pop	{r4, pc}
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 808d488:	2003      	movs	r0, #3
}
 808d48a:	bd10      	pop	{r4, pc}
 808d48c:	f7ff ffba 	bl	808d404 <move_window.part.6>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 808d490:	2800      	cmp	r0, #0
 808d492:	d0d8      	beq.n	808d446 <check_fs+0x12>
 808d494:	2004      	movs	r0, #4
}
 808d496:	bd10      	pop	{r4, pc}
		r = *d++ - *s++;
 808d498:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
 808d49c:	f642 6170 	movw	r1, #11888	; 0x2e70
 808d4a0:	f104 028b 	add.w	r2, r4, #139	; 0x8b
 808d4a4:	348f      	adds	r4, #143	; 0x8f
 808d4a6:	3b46      	subs	r3, #70	; 0x46
 808d4a8:	f6c0 0109 	movt	r1, #2057	; 0x809
	} while (--cnt && r == 0);
 808d4ac:	b963      	cbnz	r3, 808d4c8 <check_fs+0x94>
		r = *d++ - *s++;
 808d4ae:	f812 3b01 	ldrb.w	r3, [r2], #1
 808d4b2:	f811 0f01 	ldrb.w	r0, [r1, #1]!
	} while (--cnt && r == 0);
 808d4b6:	42a2      	cmp	r2, r4
		r = *d++ - *s++;
 808d4b8:	eba3 0300 	sub.w	r3, r3, r0
	} while (--cnt && r == 0);
 808d4bc:	d1f6      	bne.n	808d4ac <check_fs+0x78>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 808d4be:	2b00      	cmp	r3, #0
 808d4c0:	bf14      	ite	ne
 808d4c2:	2002      	movne	r0, #2
 808d4c4:	2000      	moveq	r0, #0
}
 808d4c6:	bd10      	pop	{r4, pc}
	return 2;	/* Valid BS but not FAT */
 808d4c8:	2002      	movs	r0, #2
}
 808d4ca:	bd10      	pop	{r4, pc}

0808d4cc <find_volume>:
	*rfs = 0;
 808d4cc:	2300      	movs	r3, #0
{
 808d4ce:	b5f0      	push	{r4, r5, r6, r7, lr}
	*rfs = 0;
 808d4d0:	600b      	str	r3, [r1, #0]
{
 808d4d2:	b085      	sub	sp, #20
 808d4d4:	460f      	mov	r7, r1
 808d4d6:	4615      	mov	r5, r2
	vol = get_ldnumber(path);
 808d4d8:	f7ff fe74 	bl	808d1c4 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 808d4dc:	1e06      	subs	r6, r0, #0
 808d4de:	f2c0 80cf 	blt.w	808d680 <find_volume+0x1b4>
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 808d4e2:	f64b 43c0 	movw	r3, #48320	; 0xbcc0
 808d4e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808d4ea:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 808d4ee:	2c00      	cmp	r4, #0
 808d4f0:	f000 80f1 	beq.w	808d6d6 <find_volume+0x20a>
	*rfs = fs;							/* Return pointer to the filesystem object */
 808d4f4:	603c      	str	r4, [r7, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 808d4f6:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 808d4fa:	7823      	ldrb	r3, [r4, #0]
 808d4fc:	b173      	cbz	r3, 808d51c <find_volume+0x50>
		stat = disk_status(fs->pdrv);
 808d4fe:	7860      	ldrb	r0, [r4, #1]
 808d500:	f7ff fdb6 	bl	808d070 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 808d504:	07c7      	lsls	r7, r0, #31
 808d506:	d409      	bmi.n	808d51c <find_volume+0x50>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 808d508:	2d00      	cmp	r5, #0
 808d50a:	f000 80f0 	beq.w	808d6ee <find_volume+0x222>
 808d50e:	f010 0004 	ands.w	r0, r0, #4
 808d512:	f000 80b6 	beq.w	808d682 <find_volume+0x1b6>
				return FR_WRITE_PROTECTED;
 808d516:	200a      	movs	r0, #10
}
 808d518:	b005      	add	sp, #20
 808d51a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 808d51c:	b2f0      	uxtb	r0, r6
	fs->fs_type = 0;					/* Clear the filesystem object */
 808d51e:	2300      	movs	r3, #0
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 808d520:	7060      	strb	r0, [r4, #1]
	fs->fs_type = 0;					/* Clear the filesystem object */
 808d522:	7023      	strb	r3, [r4, #0]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 808d524:	f7ff fd8c 	bl	808d040 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 808d528:	07c6      	lsls	r6, r0, #31
 808d52a:	f100 80ac 	bmi.w	808d686 <find_volume+0x1ba>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 808d52e:	b10d      	cbz	r5, 808d534 <find_volume+0x68>
 808d530:	0745      	lsls	r5, r0, #29
 808d532:	d4f0      	bmi.n	808d516 <find_volume+0x4a>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 808d534:	2100      	movs	r1, #0
 808d536:	4620      	mov	r0, r4
 808d538:	f7ff ff7c 	bl	808d434 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 808d53c:	2802      	cmp	r0, #2
 808d53e:	f000 80a5 	beq.w	808d68c <find_volume+0x1c0>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 808d542:	2804      	cmp	r0, #4
 808d544:	f000 80d1 	beq.w	808d6ea <find_volume+0x21e>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 808d548:	2801      	cmp	r0, #1
 808d54a:	f200 80c1 	bhi.w	808d6d0 <find_volume+0x204>
	bsect = 0;
 808d54e:	2600      	movs	r6, #0
	rv = rv << 8 | ptr[0];
 808d550:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 808d554:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 808d558:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 808d55c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 808d560:	f040 80b6 	bne.w	808d6d0 <find_volume+0x204>
	rv = rv << 8 | ptr[0];
 808d564:	f894 204f 	ldrb.w	r2, [r4, #79]	; 0x4f
 808d568:	f894 304e 	ldrb.w	r3, [r4, #78]	; 0x4e
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 808d56c:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 808d570:	d109      	bne.n	808d586 <find_volume+0xba>
	rv = rv << 8 | ptr[2];
 808d572:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
	rv = rv << 8 | ptr[1];
 808d576:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
	rv = rv << 8 | ptr[0];
 808d57a:	f894 205c 	ldrb.w	r2, [r4, #92]	; 0x5c
	rv = rv << 8 | ptr[1];
 808d57e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 808d582:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 808d586:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
		fs->fsize = fasize;
 808d58a:	6223      	str	r3, [r4, #32]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 808d58c:	1e51      	subs	r1, r2, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 808d58e:	70a2      	strb	r2, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 808d590:	2901      	cmp	r1, #1
 808d592:	f200 809d 	bhi.w	808d6d0 <find_volume+0x204>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 808d596:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 808d59a:	b288      	uxth	r0, r1
 808d59c:	8160      	strh	r0, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 808d59e:	2800      	cmp	r0, #0
 808d5a0:	f000 8096 	beq.w	808d6d0 <find_volume+0x204>
 808d5a4:	1e48      	subs	r0, r1, #1
 808d5a6:	4208      	tst	r0, r1
 808d5a8:	f040 8092 	bne.w	808d6d0 <find_volume+0x204>
	rv = rv << 8 | ptr[0];
 808d5ac:	f894 004a 	ldrb.w	r0, [r4, #74]	; 0x4a
 808d5b0:	f894 5049 	ldrb.w	r5, [r4, #73]	; 0x49
 808d5b4:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 808d5b8:	0728      	lsls	r0, r5, #28
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 808d5ba:	8125      	strh	r5, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 808d5bc:	f040 8088 	bne.w	808d6d0 <find_volume+0x204>
	rv = rv << 8 | ptr[0];
 808d5c0:	f894 704c 	ldrb.w	r7, [r4, #76]	; 0x4c
 808d5c4:	f894 004b 	ldrb.w	r0, [r4, #75]	; 0x4b
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 808d5c8:	ea50 2007 	orrs.w	r0, r0, r7, lsl #8
 808d5cc:	d109      	bne.n	808d5e2 <find_volume+0x116>
	rv = rv << 8 | ptr[2];
 808d5ce:	f8b4 c05a 	ldrh.w	ip, [r4, #90]	; 0x5a
	rv = rv << 8 | ptr[1];
 808d5d2:	f894 7059 	ldrb.w	r7, [r4, #89]	; 0x59
	rv = rv << 8 | ptr[0];
 808d5d6:	f894 0058 	ldrb.w	r0, [r4, #88]	; 0x58
	rv = rv << 8 | ptr[1];
 808d5da:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
	rv = rv << 8 | ptr[0];
 808d5de:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
	rv = rv << 8 | ptr[0];
 808d5e2:	f894 c047 	ldrb.w	ip, [r4, #71]	; 0x47
 808d5e6:	f894 7046 	ldrb.w	r7, [r4, #70]	; 0x46
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 808d5ea:	ea57 2c0c 	orrs.w	ip, r7, ip, lsl #8
 808d5ee:	d06f      	beq.n	808d6d0 <find_volume+0x204>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 808d5f0:	fb03 f202 	mul.w	r2, r3, r2
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 808d5f4:	eb0c 1715 	add.w	r7, ip, r5, lsr #4
 808d5f8:	4417      	add	r7, r2
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 808d5fa:	42b8      	cmp	r0, r7
 808d5fc:	d368      	bcc.n	808d6d0 <find_volume+0x204>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 808d5fe:	1bc0      	subs	r0, r0, r7
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 808d600:	f64f 7ef4 	movw	lr, #65524	; 0xfff4
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 808d604:	fbb0 f1f1 	udiv	r1, r0, r1
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 808d608:	f6c0 7eff 	movt	lr, #4095	; 0xfff
 808d60c:	1e48      	subs	r0, r1, #1
 808d60e:	4570      	cmp	r0, lr
 808d610:	d85e      	bhi.n	808d6d0 <find_volume+0x204>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 808d612:	f64f 7ef5 	movw	lr, #65525	; 0xfff5
 808d616:	19b8      	adds	r0, r7, r6
 808d618:	44b4      	add	ip, r6
 808d61a:	1c8f      	adds	r7, r1, #2
 808d61c:	4571      	cmp	r1, lr
 808d61e:	d870      	bhi.n	808d702 <find_volume+0x236>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 808d620:	f640 7ef5 	movw	lr, #4085	; 0xff5
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 808d624:	61e7      	str	r7, [r4, #28]
		fs->database = bsect + sysect;					/* Data start sector */
 808d626:	6320      	str	r0, [r4, #48]	; 0x30
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 808d628:	4571      	cmp	r1, lr
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 808d62a:	e9c4 6c09 	strd	r6, ip, [r4, #36]	; 0x24
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 808d62e:	d860      	bhi.n	808d6f2 <find_volume+0x226>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 808d630:	2d00      	cmp	r5, #0
 808d632:	d04d      	beq.n	808d6d0 <find_volume+0x204>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 808d634:	4462      	add	r2, ip
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 808d636:	eb07 0047 	add.w	r0, r7, r7, lsl #1
 808d63a:	f007 0101 	and.w	r1, r7, #1
 808d63e:	2501      	movs	r5, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 808d640:	62e2      	str	r2, [r4, #44]	; 0x2c
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 808d642:	eb01 0250 	add.w	r2, r1, r0, lsr #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 808d646:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
 808d64a:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
 808d64e:	d33f      	bcc.n	808d6d0 <find_volume+0x204>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 808d650:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		fs->fsi_flag = 0x80;
 808d654:	2280      	movs	r2, #128	; 0x80
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 808d656:	e9c4 3304 	strd	r3, r3, [r4, #16]
		fs->fsi_flag = 0x80;
 808d65a:	7122      	strb	r2, [r4, #4]
	fs->id = ++Fsid;		/* Volume mount ID */
 808d65c:	f64b 42c4 	movw	r2, #48324	; 0xbcc4
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 808d660:	f64b 41c8 	movw	r1, #48328	; 0xbcc8
	fs->cdir = 0;			/* Initialize current directory */
 808d664:	2000      	movs	r0, #0
	fs->fs_type = fmt;		/* FAT sub-type */
 808d666:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 808d668:	f2c2 0200 	movt	r2, #8192	; 0x2000
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 808d66c:	f2c2 0100 	movt	r1, #8192	; 0x2000
	fs->cdir = 0;			/* Initialize current directory */
 808d670:	61a0      	str	r0, [r4, #24]
	fs->id = ++Fsid;		/* Volume mount ID */
 808d672:	8813      	ldrh	r3, [r2, #0]
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 808d674:	60e1      	str	r1, [r4, #12]
	fs->id = ++Fsid;		/* Volume mount ID */
 808d676:	3301      	adds	r3, #1
 808d678:	b29b      	uxth	r3, r3
 808d67a:	8013      	strh	r3, [r2, #0]
 808d67c:	80e3      	strh	r3, [r4, #6]
	return FR_OK;
 808d67e:	e000      	b.n	808d682 <find_volume+0x1b6>
	if (vol < 0) return FR_INVALID_DRIVE;
 808d680:	200b      	movs	r0, #11
}
 808d682:	b005      	add	sp, #20
 808d684:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 808d686:	2003      	movs	r0, #3
}
 808d688:	b005      	add	sp, #20
 808d68a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808d68c:	466d      	mov	r5, sp
 808d68e:	f504 7300 	add.w	r3, r4, #512	; 0x200
 808d692:	f504 7610 	add.w	r6, r4, #576	; 0x240
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 808d696:	4628      	mov	r0, r5
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 808d698:	f813 1c06 	ldrb.w	r1, [r3, #-6]
 808d69c:	460a      	mov	r2, r1
 808d69e:	b141      	cbz	r1, 808d6b2 <find_volume+0x1e6>
	rv = rv << 8 | ptr[2];
 808d6a0:	881f      	ldrh	r7, [r3, #0]
	rv = rv << 8 | ptr[1];
 808d6a2:	f813 1c01 	ldrb.w	r1, [r3, #-1]
	rv = rv << 8 | ptr[0];
 808d6a6:	f813 2c02 	ldrb.w	r2, [r3, #-2]
	rv = rv << 8 | ptr[1];
 808d6aa:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
	rv = rv << 8 | ptr[0];
 808d6ae:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 808d6b2:	3310      	adds	r3, #16
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 808d6b4:	f840 2b04 	str.w	r2, [r0], #4
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 808d6b8:	42b3      	cmp	r3, r6
 808d6ba:	d1ed      	bne.n	808d698 <find_volume+0x1cc>
 808d6bc:	f105 0710 	add.w	r7, r5, #16
			bsect = br[i];
 808d6c0:	f855 6b04 	ldr.w	r6, [r5], #4
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 808d6c4:	2003      	movs	r0, #3
 808d6c6:	b94e      	cbnz	r6, 808d6dc <find_volume+0x210>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 808d6c8:	42af      	cmp	r7, r5
 808d6ca:	d1f9      	bne.n	808d6c0 <find_volume+0x1f4>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 808d6cc:	2804      	cmp	r0, #4
 808d6ce:	d00c      	beq.n	808d6ea <find_volume+0x21e>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 808d6d0:	200d      	movs	r0, #13
}
 808d6d2:	b005      	add	sp, #20
 808d6d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 808d6d6:	200c      	movs	r0, #12
}
 808d6d8:	b005      	add	sp, #20
 808d6da:	bdf0      	pop	{r4, r5, r6, r7, pc}
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 808d6dc:	4631      	mov	r1, r6
 808d6de:	4620      	mov	r0, r4
 808d6e0:	f7ff fea8 	bl	808d434 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 808d6e4:	2801      	cmp	r0, #1
 808d6e6:	d8ef      	bhi.n	808d6c8 <find_volume+0x1fc>
 808d6e8:	e732      	b.n	808d550 <find_volume+0x84>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 808d6ea:	2001      	movs	r0, #1
 808d6ec:	e7c9      	b.n	808d682 <find_volume+0x1b6>
			return FR_OK;				/* The filesystem object is valid */
 808d6ee:	4628      	mov	r0, r5
 808d6f0:	e7c7      	b.n	808d682 <find_volume+0x1b6>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 808d6f2:	2d00      	cmp	r5, #0
 808d6f4:	d0ec      	beq.n	808d6d0 <find_volume+0x204>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 808d6f6:	4494      	add	ip, r2
 808d6f8:	2502      	movs	r5, #2
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 808d6fa:	007a      	lsls	r2, r7, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 808d6fc:	f8c4 c02c 	str.w	ip, [r4, #44]	; 0x2c
 808d700:	e7a1      	b.n	808d646 <find_volume+0x17a>
	rv = rv << 8 | ptr[0];
 808d702:	f894 1063 	ldrb.w	r1, [r4, #99]	; 0x63
 808d706:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 808d70a:	61e7      	str	r7, [r4, #28]
	rv = rv << 8 | ptr[0];
 808d70c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
		fs->database = bsect + sysect;					/* Data start sector */
 808d710:	6320      	str	r0, [r4, #48]	; 0x30
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 808d712:	432a      	orrs	r2, r5
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 808d714:	e9c4 6c09 	strd	r6, ip, [r4, #36]	; 0x24
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 808d718:	d1da      	bne.n	808d6d0 <find_volume+0x204>
	rv = rv << 8 | ptr[2];
 808d71a:	f8b4 5066 	ldrh.w	r5, [r4, #102]	; 0x66
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 808d71e:	00ba      	lsls	r2, r7, #2
	rv = rv << 8 | ptr[1];
 808d720:	f894 0065 	ldrb.w	r0, [r4, #101]	; 0x65
	rv = rv << 8 | ptr[0];
 808d724:	f894 1064 	ldrb.w	r1, [r4, #100]	; 0x64
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 808d728:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
	rv = rv << 8 | ptr[1];
 808d72c:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 808d730:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
	rv = rv << 8 | ptr[0];
 808d734:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 808d738:	62e1      	str	r1, [r4, #44]	; 0x2c
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 808d73a:	d3c9      	bcc.n	808d6d0 <find_volume+0x204>
	rv = rv << 8 | ptr[0];
 808d73c:	f894 0069 	ldrb.w	r0, [r4, #105]	; 0x69
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 808d740:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	rv = rv << 8 | ptr[0];
 808d744:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
		fs->fsi_flag = 0x80;
 808d748:	2180      	movs	r1, #128	; 0x80
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 808d74a:	6162      	str	r2, [r4, #20]
	rv = rv << 8 | ptr[0];
 808d74c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 808d750:	6122      	str	r2, [r4, #16]
		fs->fsi_flag = 0x80;
 808d752:	7121      	strb	r1, [r4, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 808d754:	2b01      	cmp	r3, #1
 808d756:	d001      	beq.n	808d75c <find_volume+0x290>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 808d758:	2503      	movs	r5, #3
 808d75a:	e77f      	b.n	808d65c <find_volume+0x190>
			&& move_window(fs, bsect + 1) == FR_OK)
 808d75c:	1c71      	adds	r1, r6, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d75e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 808d760:	4299      	cmp	r1, r3
 808d762:	d004      	beq.n	808d76e <find_volume+0x2a2>
 808d764:	4620      	mov	r0, r4
 808d766:	f7ff fe4d 	bl	808d404 <move_window.part.6>
			&& move_window(fs, bsect + 1) == FR_OK)
 808d76a:	2800      	cmp	r0, #0
 808d76c:	d1f4      	bne.n	808d758 <find_volume+0x28c>
	rv = rv << 8 | ptr[0];
 808d76e:	f894 1237 	ldrb.w	r1, [r4, #567]	; 0x237
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 808d772:	f64a 2255 	movw	r2, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 808d776:	f894 3236 	ldrb.w	r3, [r4, #566]	; 0x236
			fs->fsi_flag = 0;
 808d77a:	2000      	movs	r0, #0
	rv = rv << 8 | ptr[0];
 808d77c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			fs->fsi_flag = 0;
 808d780:	7120      	strb	r0, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 808d782:	4293      	cmp	r3, r2
 808d784:	d1e8      	bne.n	808d758 <find_volume+0x28c>
	rv = rv << 8 | ptr[2];
 808d786:	8f60      	ldrh	r0, [r4, #58]	; 0x3a
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 808d788:	f245 2152 	movw	r1, #21074	; 0x5252
	rv = rv << 8 | ptr[1];
 808d78c:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
	rv = rv << 8 | ptr[0];
 808d790:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 808d794:	f2c4 1161 	movt	r1, #16737	; 0x4161
	rv = rv << 8 | ptr[1];
 808d798:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 808d79c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 808d7a0:	428b      	cmp	r3, r1
 808d7a2:	d1d9      	bne.n	808d758 <find_volume+0x28c>
	rv = rv << 8 | ptr[2];
 808d7a4:	f8b4 021e 	ldrh.w	r0, [r4, #542]	; 0x21e
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 808d7a8:	f247 2172 	movw	r1, #29298	; 0x7272
	rv = rv << 8 | ptr[1];
 808d7ac:	f894 221d 	ldrb.w	r2, [r4, #541]	; 0x21d
	rv = rv << 8 | ptr[0];
 808d7b0:	f894 321c 	ldrb.w	r3, [r4, #540]	; 0x21c
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 808d7b4:	f2c6 1141 	movt	r1, #24897	; 0x6141
	rv = rv << 8 | ptr[1];
 808d7b8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 808d7bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 808d7c0:	428b      	cmp	r3, r1
 808d7c2:	d1c9      	bne.n	808d758 <find_volume+0x28c>
	rv = rv << 8 | ptr[1];
 808d7c4:	f894 2221 	ldrb.w	r2, [r4, #545]	; 0x221
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 808d7c8:	2503      	movs	r5, #3
	rv = rv << 8 | ptr[1];
 808d7ca:	f894 3225 	ldrb.w	r3, [r4, #549]	; 0x225
	rv = rv << 8 | ptr[2];
 808d7ce:	f8b4 0222 	ldrh.w	r0, [r4, #546]	; 0x222
 808d7d2:	f8b4 1226 	ldrh.w	r1, [r4, #550]	; 0x226
	rv = rv << 8 | ptr[1];
 808d7d6:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 808d7da:	f894 2220 	ldrb.w	r2, [r4, #544]	; 0x220
	rv = rv << 8 | ptr[1];
 808d7de:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 808d7e2:	f894 3224 	ldrb.w	r3, [r4, #548]	; 0x224
 808d7e6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 808d7ea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 808d7ee:	e9c4 3204 	strd	r3, r2, [r4, #16]
 808d7f2:	e733      	b.n	808d65c <find_volume+0x190>

0808d7f4 <put_fat.part.8>:
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 808d7f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		switch (fs->fs_type) {
 808d7f8:	7803      	ldrb	r3, [r0, #0]
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 808d7fa:	4604      	mov	r4, r0
 808d7fc:	460d      	mov	r5, r1
 808d7fe:	4616      	mov	r6, r2
		switch (fs->fs_type) {
 808d800:	2b02      	cmp	r3, #2
 808d802:	d057      	beq.n	808d8b4 <put_fat.part.8+0xc0>
 808d804:	2b03      	cmp	r3, #3
 808d806:	d036      	beq.n	808d876 <put_fat.part.8+0x82>
 808d808:	2b01      	cmp	r3, #1
 808d80a:	d002      	beq.n	808d812 <put_fat.part.8+0x1e>
	FRESULT res = FR_INT_ERR;
 808d80c:	2002      	movs	r0, #2
}
 808d80e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 808d812:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 808d816:	6a81      	ldr	r1, [r0, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d818:	6b43      	ldr	r3, [r0, #52]	; 0x34
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 808d81a:	eb01 2157 	add.w	r1, r1, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d81e:	4299      	cmp	r1, r3
 808d820:	d161      	bne.n	808d8e6 <put_fat.part.8+0xf2>
			p = fs->win + bc++ % SS(fs);
 808d822:	f107 0801 	add.w	r8, r7, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 808d826:	07eb      	lsls	r3, r5, #31
			p = fs->win + bc++ % SS(fs);
 808d828:	f3c7 0708 	ubfx	r7, r7, #0, #9
 808d82c:	f104 0938 	add.w	r9, r4, #56	; 0x38
 808d830:	ea4f 2158 	mov.w	r1, r8, lsr #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 808d834:	d561      	bpl.n	808d8fa <put_fat.part.8+0x106>
 808d836:	f819 3007 	ldrb.w	r3, [r9, r7]
			fs->wflag = 1;
 808d83a:	2201      	movs	r2, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 808d83c:	f003 030f 	and.w	r3, r3, #15
 808d840:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 808d844:	f809 3007 	strb.w	r3, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 808d848:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d84a:	6b63      	ldr	r3, [r4, #52]	; 0x34
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 808d84c:	4401      	add	r1, r0
			fs->wflag = 1;
 808d84e:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d850:	4299      	cmp	r1, r3
 808d852:	d004      	beq.n	808d85e <put_fat.part.8+0x6a>
 808d854:	4620      	mov	r0, r4
 808d856:	f7ff fdd5 	bl	808d404 <move_window.part.6>
			if (res != FR_OK) break;
 808d85a:	2800      	cmp	r0, #0
 808d85c:	d1d7      	bne.n	808d80e <put_fat.part.8+0x1a>
			p = fs->win + bc % SS(fs);
 808d85e:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 808d862:	f3c6 1607 	ubfx	r6, r6, #4, #8
			p = fs->win + bc % SS(fs);
 808d866:	44c8      	add	r8, r9
			fs->wflag = 1;
 808d868:	2301      	movs	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 808d86a:	f888 6000 	strb.w	r6, [r8]
			fs->wflag = 1;
 808d86e:	2000      	movs	r0, #0
 808d870:	70e3      	strb	r3, [r4, #3]
}
 808d872:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 808d876:	6a81      	ldr	r1, [r0, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d878:	6b43      	ldr	r3, [r0, #52]	; 0x34
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 808d87a:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d87e:	4299      	cmp	r1, r3
 808d880:	d136      	bne.n	808d8f0 <put_fat.part.8+0xfc>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 808d882:	00ad      	lsls	r5, r5, #2
 808d884:	f104 0138 	add.w	r1, r4, #56	; 0x38
 808d888:	f026 4670 	bic.w	r6, r6, #4026531840	; 0xf0000000
			fs->wflag = 1;
 808d88c:	2701      	movs	r7, #1
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 808d88e:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
			fs->wflag = 1;
 808d892:	2000      	movs	r0, #0
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 808d894:	194b      	adds	r3, r1, r5
	rv = rv << 8 | ptr[2];
 808d896:	885a      	ldrh	r2, [r3, #2]
	rv = rv << 8 | ptr[0];
 808d898:	0412      	lsls	r2, r2, #16
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 808d89a:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 808d89e:	4332      	orrs	r2, r6
	*ptr++ = (BYTE)val; val >>= 8;
 808d8a0:	554a      	strb	r2, [r1, r5]
 808d8a2:	0a15      	lsrs	r5, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 808d8a4:	0c11      	lsrs	r1, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 808d8a6:	0e12      	lsrs	r2, r2, #24
	*ptr++ = (BYTE)val; val >>= 8;
 808d8a8:	705d      	strb	r5, [r3, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 808d8aa:	7099      	strb	r1, [r3, #2]
	*ptr++ = (BYTE)val;
 808d8ac:	70da      	strb	r2, [r3, #3]
			fs->wflag = 1;
 808d8ae:	70e7      	strb	r7, [r4, #3]
}
 808d8b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 808d8b4:	6a81      	ldr	r1, [r0, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d8b6:	6b43      	ldr	r3, [r0, #52]	; 0x34
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 808d8b8:	eb01 2115 	add.w	r1, r1, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d8bc:	4299      	cmp	r1, r3
 808d8be:	d003      	beq.n	808d8c8 <put_fat.part.8+0xd4>
 808d8c0:	f7ff fda0 	bl	808d404 <move_window.part.6>
			if (res != FR_OK) break;
 808d8c4:	2800      	cmp	r0, #0
 808d8c6:	d1a2      	bne.n	808d80e <put_fat.part.8+0x1a>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 808d8c8:	006d      	lsls	r5, r5, #1
 808d8ca:	f104 0338 	add.w	r3, r4, #56	; 0x38
	*ptr++ = (BYTE)val; val >>= 8;
 808d8ce:	f3c6 2107 	ubfx	r1, r6, #8, #8
			fs->wflag = 1;
 808d8d2:	2201      	movs	r2, #1
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 808d8d4:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			fs->wflag = 1;
 808d8d8:	2000      	movs	r0, #0
	*ptr++ = (BYTE)val; val >>= 8;
 808d8da:	555e      	strb	r6, [r3, r5]
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 808d8dc:	442b      	add	r3, r5
	*ptr++ = (BYTE)val;
 808d8de:	7059      	strb	r1, [r3, #1]
			fs->wflag = 1;
 808d8e0:	70e2      	strb	r2, [r4, #3]
}
 808d8e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 808d8e6:	f7ff fd8d 	bl	808d404 <move_window.part.6>
			if (res != FR_OK) break;
 808d8ea:	2800      	cmp	r0, #0
 808d8ec:	d099      	beq.n	808d822 <put_fat.part.8+0x2e>
 808d8ee:	e78e      	b.n	808d80e <put_fat.part.8+0x1a>
 808d8f0:	f7ff fd88 	bl	808d404 <move_window.part.6>
			if (res != FR_OK) break;
 808d8f4:	2800      	cmp	r0, #0
 808d8f6:	d0c4      	beq.n	808d882 <put_fat.part.8+0x8e>
 808d8f8:	e789      	b.n	808d80e <put_fat.part.8+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 808d8fa:	f809 6007 	strb.w	r6, [r9, r7]
			fs->wflag = 1;
 808d8fe:	2201      	movs	r2, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 808d900:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d902:	6b63      	ldr	r3, [r4, #52]	; 0x34
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 808d904:	4401      	add	r1, r0
			fs->wflag = 1;
 808d906:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d908:	4299      	cmp	r1, r3
 808d90a:	d10a      	bne.n	808d922 <put_fat.part.8+0x12e>
			p = fs->win + bc % SS(fs);
 808d90c:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 808d910:	f3c6 2203 	ubfx	r2, r6, #8, #4
			p = fs->win + bc % SS(fs);
 808d914:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 808d916:	f898 3000 	ldrb.w	r3, [r8]
 808d91a:	f023 060f 	bic.w	r6, r3, #15
 808d91e:	4316      	orrs	r6, r2
 808d920:	e7a2      	b.n	808d868 <put_fat.part.8+0x74>
 808d922:	4620      	mov	r0, r4
 808d924:	f7ff fd6e 	bl	808d404 <move_window.part.6>
			if (res != FR_OK) break;
 808d928:	2800      	cmp	r0, #0
 808d92a:	f47f af70 	bne.w	808d80e <put_fat.part.8+0x1a>
 808d92e:	e7ed      	b.n	808d90c <put_fat.part.8+0x118>

0808d930 <get_fat.isra.9>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 808d930:	2901      	cmp	r1, #1
 808d932:	d92c      	bls.n	808d98e <get_fat.isra.9+0x5e>
 808d934:	69c2      	ldr	r2, [r0, #28]
 808d936:	4291      	cmp	r1, r2
static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 808d938:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 808d93a:	4606      	mov	r6, r0
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 808d93c:	d225      	bcs.n	808d98a <get_fat.isra.9+0x5a>
		switch (fs->fs_type) {
 808d93e:	7803      	ldrb	r3, [r0, #0]
 808d940:	460c      	mov	r4, r1
 808d942:	2b02      	cmp	r3, #2
 808d944:	d03b      	beq.n	808d9be <get_fat.isra.9+0x8e>
 808d946:	2b03      	cmp	r3, #3
 808d948:	d023      	beq.n	808d992 <get_fat.isra.9+0x62>
 808d94a:	2b01      	cmp	r3, #1
 808d94c:	d11d      	bne.n	808d98a <get_fat.isra.9+0x5a>
			bc = (UINT)clst; bc += bc / 2;
 808d94e:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 808d952:	6a83      	ldr	r3, [r0, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d954:	f8d0 c034 	ldr.w	ip, [r0, #52]	; 0x34
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 808d958:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d95c:	4561      	cmp	r1, ip
 808d95e:	d14a      	bne.n	808d9f6 <get_fat.isra.9+0xc6>
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 808d960:	f3c7 0208 	ubfx	r2, r7, #0, #9
 808d964:	3701      	adds	r7, #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 808d966:	eb03 2157 	add.w	r1, r3, r7, lsr #9
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 808d96a:	4432      	add	r2, r6
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d96c:	4561      	cmp	r1, ip
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 808d96e:	f892 5038 	ldrb.w	r5, [r2, #56]	; 0x38
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d972:	d148      	bne.n	808da06 <get_fat.isra.9+0xd6>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 808d974:	f3c7 0308 	ubfx	r3, r7, #0, #9
 808d978:	4433      	add	r3, r6
 808d97a:	f893 0038 	ldrb.w	r0, [r3, #56]	; 0x38
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 808d97e:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 808d980:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 808d984:	d545      	bpl.n	808da12 <get_fat.isra.9+0xe2>
 808d986:	0900      	lsrs	r0, r0, #4
}
 808d988:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = 1;	/* Internal error */
 808d98a:	2001      	movs	r0, #1
}
 808d98c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;	/* Internal error */
 808d98e:	2001      	movs	r0, #1
}
 808d990:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 808d992:	6a81      	ldr	r1, [r0, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d994:	6b43      	ldr	r3, [r0, #52]	; 0x34
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 808d996:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d99a:	4299      	cmp	r1, r3
 808d99c:	d126      	bne.n	808d9ec <get_fat.isra.9+0xbc>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 808d99e:	00a1      	lsls	r1, r4, #2
 808d9a0:	f106 0338 	add.w	r3, r6, #56	; 0x38
 808d9a4:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 808d9a8:	185a      	adds	r2, r3, r1
	rv = rv << 8 | ptr[0];
 808d9aa:	5c58      	ldrb	r0, [r3, r1]
	rv = rv << 8 | ptr[2];
 808d9ac:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 808d9ae:	7853      	ldrb	r3, [r2, #1]
 808d9b0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 808d9b4:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 808d9b8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 808d9bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 808d9be:	6a81      	ldr	r1, [r0, #40]	; 0x28
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d9c0:	6b43      	ldr	r3, [r0, #52]	; 0x34
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 808d9c2:	eb01 2114 	add.w	r1, r1, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 808d9c6:	4299      	cmp	r1, r3
 808d9c8:	d005      	beq.n	808d9d6 <get_fat.isra.9+0xa6>
 808d9ca:	f7ff fd1b 	bl	808d404 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 808d9ce:	b110      	cbz	r0, 808d9d6 <get_fat.isra.9+0xa6>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 808d9d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 808d9d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 808d9d6:	0061      	lsls	r1, r4, #1
 808d9d8:	f106 0338 	add.w	r3, r6, #56	; 0x38
 808d9dc:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
 808d9e0:	185a      	adds	r2, r3, r1
	rv = rv << 8 | ptr[0];
 808d9e2:	5c58      	ldrb	r0, [r3, r1]
 808d9e4:	7853      	ldrb	r3, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 808d9e6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
 808d9ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808d9ec:	f7ff fd0a 	bl	808d404 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 808d9f0:	2800      	cmp	r0, #0
 808d9f2:	d0d4      	beq.n	808d99e <get_fat.isra.9+0x6e>
 808d9f4:	e7ec      	b.n	808d9d0 <get_fat.isra.9+0xa0>
 808d9f6:	f7ff fd05 	bl	808d404 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 808d9fa:	2800      	cmp	r0, #0
 808d9fc:	d1e8      	bne.n	808d9d0 <get_fat.isra.9+0xa0>
 808d9fe:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 808da00:	f8d6 c034 	ldr.w	ip, [r6, #52]	; 0x34
 808da04:	e7ac      	b.n	808d960 <get_fat.isra.9+0x30>
 808da06:	4630      	mov	r0, r6
 808da08:	f7ff fcfc 	bl	808d404 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 808da0c:	2800      	cmp	r0, #0
 808da0e:	d0b1      	beq.n	808d974 <get_fat.isra.9+0x44>
 808da10:	e7de      	b.n	808d9d0 <get_fat.isra.9+0xa0>
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 808da12:	f3c0 000b 	ubfx	r0, r0, #0, #12
}
 808da16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0808da18 <dir_sdi>:
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 808da18:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 808da1c:	d229      	bcs.n	808da72 <dir_sdi+0x5a>
 808da1e:	06ca      	lsls	r2, r1, #27
{
 808da20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 808da22:	460c      	mov	r4, r1
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 808da24:	d123      	bne.n	808da6e <dir_sdi+0x56>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 808da26:	6881      	ldr	r1, [r0, #8]
 808da28:	4605      	mov	r5, r0
	dp->dptr = ofs;				/* Set current offset */
 808da2a:	6104      	str	r4, [r0, #16]
	FATFS *fs = dp->obj.fs;
 808da2c:	6806      	ldr	r6, [r0, #0]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 808da2e:	bb19      	cbnz	r1, 808da78 <dir_sdi+0x60>
 808da30:	7833      	ldrb	r3, [r6, #0]
 808da32:	2b02      	cmp	r3, #2
 808da34:	d901      	bls.n	808da3a <dir_sdi+0x22>
		clst = fs->dirbase;
 808da36:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 808da38:	b9eb      	cbnz	r3, 808da76 <dir_sdi+0x5e>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 808da3a:	8933      	ldrh	r3, [r6, #8]
 808da3c:	ebb3 1f54 	cmp.w	r3, r4, lsr #5
 808da40:	d915      	bls.n	808da6e <dir_sdi+0x56>
		dp->sect = fs->dirbase;
 808da42:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 808da44:	61ab      	str	r3, [r5, #24]
	dp->clust = clst;					/* Current cluster# */
 808da46:	6169      	str	r1, [r5, #20]
	if (dp->sect == 0) return FR_INT_ERR;
 808da48:	b18b      	cbz	r3, 808da6e <dir_sdi+0x56>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 808da4a:	f3c4 0208 	ubfx	r2, r4, #0, #9
 808da4e:	3638      	adds	r6, #56	; 0x38
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 808da50:	eb03 2454 	add.w	r4, r3, r4, lsr #9
	return FR_OK;
 808da54:	2000      	movs	r0, #0
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 808da56:	4416      	add	r6, r2
 808da58:	e9c5 4606 	strd	r4, r6, [r5, #24]
}
 808da5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808da5e:	69f3      	ldr	r3, [r6, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808da60:	3b02      	subs	r3, #2
	clst -= 2;		/* Cluster number is origin from 2 */
 808da62:	1e8a      	subs	r2, r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808da64:	429a      	cmp	r2, r3
 808da66:	d31e      	bcc.n	808daa6 <dir_sdi+0x8e>
		dp->sect = clst2sect(fs, clst);
 808da68:	2300      	movs	r3, #0
 808da6a:	e9c5 1305 	strd	r1, r3, [r5, #20]
		return FR_INT_ERR;
 808da6e:	2002      	movs	r0, #2
}
 808da70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return FR_INT_ERR;
 808da72:	2002      	movs	r0, #2
}
 808da74:	4770      	bx	lr
 808da76:	4619      	mov	r1, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 808da78:	8977      	ldrh	r7, [r6, #10]
 808da7a:	027f      	lsls	r7, r7, #9
		while (ofs >= csz) {				/* Follow cluster chain */
 808da7c:	42bc      	cmp	r4, r7
 808da7e:	d3ee      	bcc.n	808da5e <dir_sdi+0x46>
 808da80:	4630      	mov	r0, r6
 808da82:	e007      	b.n	808da94 <dir_sdi+0x7c>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 808da84:	2801      	cmp	r0, #1
 808da86:	d9f2      	bls.n	808da6e <dir_sdi+0x56>
 808da88:	69f3      	ldr	r3, [r6, #28]
 808da8a:	4283      	cmp	r3, r0
 808da8c:	d9ef      	bls.n	808da6e <dir_sdi+0x56>
		while (ofs >= csz) {				/* Follow cluster chain */
 808da8e:	42a7      	cmp	r7, r4
 808da90:	d8e6      	bhi.n	808da60 <dir_sdi+0x48>
 808da92:	6828      	ldr	r0, [r5, #0]
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 808da94:	f7ff ff4c 	bl	808d930 <get_fat.isra.9>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 808da98:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 808da9a:	4601      	mov	r1, r0
			ofs -= csz;
 808da9c:	eba4 0407 	sub.w	r4, r4, r7
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 808daa0:	d1f0      	bne.n	808da84 <dir_sdi+0x6c>
 808daa2:	2001      	movs	r0, #1
}
 808daa4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 808daa6:	8973      	ldrh	r3, [r6, #10]
 808daa8:	6b30      	ldr	r0, [r6, #48]	; 0x30
 808daaa:	fb02 0303 	mla	r3, r2, r3, r0
		dp->sect = clst2sect(fs, clst);
 808daae:	61ab      	str	r3, [r5, #24]
 808dab0:	e7c9      	b.n	808da46 <dir_sdi+0x2e>
 808dab2:	bf00      	nop

0808dab4 <create_chain>:
{
 808dab4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 808dab8:	4607      	mov	r7, r0
	if (clst == 0) {	/* Create a new chain */
 808daba:	4688      	mov	r8, r1
	FATFS *fs = obj->fs;
 808dabc:	6806      	ldr	r6, [r0, #0]
	if (clst == 0) {	/* Create a new chain */
 808dabe:	bb69      	cbnz	r1, 808db1c <create_chain+0x68>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 808dac0:	6935      	ldr	r5, [r6, #16]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 808dac2:	b145      	cbz	r5, 808dad6 <create_chain+0x22>
 808dac4:	69f3      	ldr	r3, [r6, #28]
 808dac6:	42ab      	cmp	r3, r5
 808dac8:	bf98      	it	ls
 808daca:	2501      	movls	r5, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 808dacc:	6973      	ldr	r3, [r6, #20]
 808dace:	b933      	cbnz	r3, 808dade <create_chain+0x2a>
					if (ncl > scl) return 0;	/* No free cluster found? */
 808dad0:	2000      	movs	r0, #0
}
 808dad2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 808dad6:	6973      	ldr	r3, [r6, #20]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 808dad8:	2501      	movs	r5, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 808dada:	2b00      	cmp	r3, #0
 808dadc:	d0f8      	beq.n	808dad0 <create_chain+0x1c>
 808dade:	69f3      	ldr	r3, [r6, #28]
 808dae0:	462c      	mov	r4, r5
 808dae2:	e006      	b.n	808daf2 <create_chain+0x3e>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 808dae4:	2801      	cmp	r0, #1
 808dae6:	d0f4      	beq.n	808dad2 <create_chain+0x1e>
 808dae8:	1c43      	adds	r3, r0, #1
 808daea:	d0f2      	beq.n	808dad2 <create_chain+0x1e>
				if (ncl == scl) return 0;		/* No free cluster found? */
 808daec:	42ac      	cmp	r4, r5
 808daee:	d0ef      	beq.n	808dad0 <create_chain+0x1c>
 808daf0:	69f3      	ldr	r3, [r6, #28]
				ncl++;							/* Next cluster */
 808daf2:	3401      	adds	r4, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 808daf4:	429c      	cmp	r4, r3
 808daf6:	d303      	bcc.n	808db00 <create_chain+0x4c>
					if (ncl > scl) return 0;	/* No free cluster found? */
 808daf8:	2d01      	cmp	r5, #1
					ncl = 2;
 808dafa:	f04f 0402 	mov.w	r4, #2
					if (ncl > scl) return 0;	/* No free cluster found? */
 808dafe:	d9e7      	bls.n	808dad0 <create_chain+0x1c>
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 808db00:	4621      	mov	r1, r4
 808db02:	6838      	ldr	r0, [r7, #0]
 808db04:	f7ff ff14 	bl	808d930 <get_fat.isra.9>
				if (cs == 0) break;				/* Found a free cluster? */
 808db08:	2800      	cmp	r0, #0
 808db0a:	d1eb      	bne.n	808dae4 <create_chain+0x30>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 808db0c:	2c01      	cmp	r4, #1
 808db0e:	d902      	bls.n	808db16 <create_chain+0x62>
 808db10:	69f3      	ldr	r3, [r6, #28]
 808db12:	429c      	cmp	r4, r3
 808db14:	d32f      	bcc.n	808db76 <create_chain+0xc2>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 808db16:	2001      	movs	r0, #1
}
 808db18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cs = get_fat(obj, clst);			/* Check the cluster status */
 808db1c:	4630      	mov	r0, r6
 808db1e:	f7ff ff07 	bl	808d930 <get_fat.isra.9>
		if (cs < 2) return 1;				/* Test for insanity */
 808db22:	2801      	cmp	r0, #1
 808db24:	d9f7      	bls.n	808db16 <create_chain+0x62>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 808db26:	1c41      	adds	r1, r0, #1
 808db28:	d01d      	beq.n	808db66 <create_chain+0xb2>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 808db2a:	69f3      	ldr	r3, [r6, #28]
 808db2c:	4283      	cmp	r3, r0
 808db2e:	d8d0      	bhi.n	808dad2 <create_chain+0x1e>
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 808db30:	6972      	ldr	r2, [r6, #20]
 808db32:	2a00      	cmp	r2, #0
 808db34:	d0cc      	beq.n	808dad0 <create_chain+0x1c>
			ncl = scl + 1;						/* Test if next cluster is free */
 808db36:	f108 0401 	add.w	r4, r8, #1
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 808db3a:	6838      	ldr	r0, [r7, #0]
			if (ncl >= fs->n_fatent) ncl = 2;
 808db3c:	42a3      	cmp	r3, r4
 808db3e:	bf98      	it	ls
 808db40:	2402      	movls	r4, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 808db42:	4621      	mov	r1, r4
 808db44:	f7ff fef4 	bl	808d930 <get_fat.isra.9>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 808db48:	2801      	cmp	r0, #1
 808db4a:	d0c2      	beq.n	808dad2 <create_chain+0x1e>
 808db4c:	1c42      	adds	r2, r0, #1
 808db4e:	d0c0      	beq.n	808dad2 <create_chain+0x1e>
			if (cs != 0) {						/* Not free? */
 808db50:	b160      	cbz	r0, 808db6c <create_chain+0xb8>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 808db52:	6935      	ldr	r5, [r6, #16]
 808db54:	69f3      	ldr	r3, [r6, #28]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 808db56:	2d01      	cmp	r5, #1
 808db58:	d932      	bls.n	808dbc0 <create_chain+0x10c>
 808db5a:	429d      	cmp	r5, r3
 808db5c:	bf28      	it	cs
 808db5e:	4645      	movcs	r5, r8
 808db60:	e7be      	b.n	808dae0 <create_chain+0x2c>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 808db62:	2801      	cmp	r0, #1
 808db64:	d1d7      	bne.n	808db16 <create_chain+0x62>
 808db66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808db6a:	e7b2      	b.n	808dad2 <create_chain+0x1e>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 808db6c:	2c00      	cmp	r4, #0
 808db6e:	d1cd      	bne.n	808db0c <create_chain+0x58>
 808db70:	69f3      	ldr	r3, [r6, #28]
 808db72:	4645      	mov	r5, r8
 808db74:	e7b4      	b.n	808dae0 <create_chain+0x2c>
 808db76:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 808db7a:	4621      	mov	r1, r4
 808db7c:	4630      	mov	r0, r6
 808db7e:	f7ff fe39 	bl	808d7f4 <put_fat.part.8>
		if (res == FR_OK && clst != 0) {
 808db82:	b968      	cbnz	r0, 808dba0 <create_chain+0xec>
 808db84:	f1b8 0f00 	cmp.w	r8, #0
 808db88:	d00a      	beq.n	808dba0 <create_chain+0xec>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 808db8a:	f1b8 0f01 	cmp.w	r8, #1
 808db8e:	d9c2      	bls.n	808db16 <create_chain+0x62>
 808db90:	69f3      	ldr	r3, [r6, #28]
 808db92:	4598      	cmp	r8, r3
 808db94:	d2bf      	bcs.n	808db16 <create_chain+0x62>
 808db96:	4641      	mov	r1, r8
 808db98:	4622      	mov	r2, r4
 808db9a:	4630      	mov	r0, r6
 808db9c:	f7ff fe2a 	bl	808d7f4 <put_fat.part.8>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 808dba0:	2800      	cmp	r0, #0
 808dba2:	d1de      	bne.n	808db62 <create_chain+0xae>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 808dba4:	69f3      	ldr	r3, [r6, #28]
 808dba6:	6972      	ldr	r2, [r6, #20]
 808dba8:	3b02      	subs	r3, #2
		fs->last_clst = ncl;
 808dbaa:	6134      	str	r4, [r6, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 808dbac:	429a      	cmp	r2, r3
 808dbae:	d801      	bhi.n	808dbb4 <create_chain+0x100>
 808dbb0:	3a01      	subs	r2, #1
 808dbb2:	6172      	str	r2, [r6, #20]
		fs->fsi_flag |= 1;
 808dbb4:	7933      	ldrb	r3, [r6, #4]
 808dbb6:	4620      	mov	r0, r4
 808dbb8:	f043 0301 	orr.w	r3, r3, #1
 808dbbc:	7133      	strb	r3, [r6, #4]
 808dbbe:	e788      	b.n	808dad2 <create_chain+0x1e>
 808dbc0:	4645      	mov	r5, r8
 808dbc2:	e78d      	b.n	808dae0 <create_chain+0x2c>

0808dbc4 <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 808dbc4:	2901      	cmp	r1, #1
 808dbc6:	d93e      	bls.n	808dc46 <remove_chain+0x82>
{
 808dbc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = obj->fs;
 808dbca:	6805      	ldr	r5, [r0, #0]
 808dbcc:	460c      	mov	r4, r1
 808dbce:	4607      	mov	r7, r0
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 808dbd0:	69eb      	ldr	r3, [r5, #28]
 808dbd2:	428b      	cmp	r3, r1
 808dbd4:	d92a      	bls.n	808dc2c <remove_chain+0x68>
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 808dbd6:	bb3a      	cbnz	r2, 808dc28 <remove_chain+0x64>
 808dbd8:	4628      	mov	r0, r5
 808dbda:	e01b      	b.n	808dc14 <remove_chain+0x50>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 808dbdc:	2801      	cmp	r0, #1
 808dbde:	4628      	mov	r0, r5
 808dbe0:	d024      	beq.n	808dc2c <remove_chain+0x68>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 808dbe2:	1c73      	adds	r3, r6, #1
 808dbe4:	d031      	beq.n	808dc4a <remove_chain+0x86>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 808dbe6:	2c01      	cmp	r4, #1
 808dbe8:	d920      	bls.n	808dc2c <remove_chain+0x68>
 808dbea:	69eb      	ldr	r3, [r5, #28]
 808dbec:	429c      	cmp	r4, r3
 808dbee:	4634      	mov	r4, r6
 808dbf0:	d21c      	bcs.n	808dc2c <remove_chain+0x68>
 808dbf2:	f7ff fdff 	bl	808d7f4 <put_fat.part.8>
			if (res != FR_OK) return res;
 808dbf6:	b9b0      	cbnz	r0, 808dc26 <remove_chain+0x62>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 808dbf8:	69eb      	ldr	r3, [r5, #28]
 808dbfa:	696a      	ldr	r2, [r5, #20]
 808dbfc:	1e99      	subs	r1, r3, #2
			fs->free_clst++;
 808dbfe:	1c50      	adds	r0, r2, #1
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 808dc00:	428a      	cmp	r2, r1
 808dc02:	d204      	bcs.n	808dc0e <remove_chain+0x4a>
			fs->fsi_flag |= 1;
 808dc04:	792a      	ldrb	r2, [r5, #4]
			fs->free_clst++;
 808dc06:	6168      	str	r0, [r5, #20]
			fs->fsi_flag |= 1;
 808dc08:	f042 0201 	orr.w	r2, r2, #1
 808dc0c:	712a      	strb	r2, [r5, #4]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 808dc0e:	42b3      	cmp	r3, r6
 808dc10:	d908      	bls.n	808dc24 <remove_chain+0x60>
 808dc12:	6838      	ldr	r0, [r7, #0]
		nxt = get_fat(obj, clst);			/* Get cluster status */
 808dc14:	4621      	mov	r1, r4
 808dc16:	f7ff fe8b 	bl	808d930 <get_fat.isra.9>
 808dc1a:	4621      	mov	r1, r4
		if (nxt == 0) break;				/* Empty cluster? */
 808dc1c:	4606      	mov	r6, r0
 808dc1e:	2200      	movs	r2, #0
 808dc20:	2800      	cmp	r0, #0
 808dc22:	d1db      	bne.n	808dbdc <remove_chain+0x18>
	return FR_OK;
 808dc24:	2000      	movs	r0, #0
}
 808dc26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 808dc28:	4293      	cmp	r3, r2
 808dc2a:	d801      	bhi.n	808dc30 <remove_chain+0x6c>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 808dc2c:	2002      	movs	r0, #2
}
 808dc2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 808dc30:	2a01      	cmp	r2, #1
 808dc32:	d9fb      	bls.n	808dc2c <remove_chain+0x68>
 808dc34:	4611      	mov	r1, r2
 808dc36:	4628      	mov	r0, r5
 808dc38:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 808dc3c:	f7ff fdda 	bl	808d7f4 <put_fat.part.8>
		if (res != FR_OK) return res;
 808dc40:	2800      	cmp	r0, #0
 808dc42:	d0e6      	beq.n	808dc12 <remove_chain+0x4e>
}
 808dc44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 808dc46:	2002      	movs	r0, #2
}
 808dc48:	4770      	bx	lr
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 808dc4a:	2001      	movs	r0, #1
}
 808dc4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 808dc4e:	bf00      	nop

0808dc50 <dir_next>:
	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 808dc50:	6983      	ldr	r3, [r0, #24]
{
 808dc52:	b5f0      	push	{r4, r5, r6, r7, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 808dc54:	6905      	ldr	r5, [r0, #16]
{
 808dc56:	b083      	sub	sp, #12
	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 808dc58:	b1c3      	cbz	r3, 808dc8c <dir_next+0x3c>
 808dc5a:	3520      	adds	r5, #32
 808dc5c:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 808dc60:	d214      	bcs.n	808dc8c <dir_next+0x3c>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 808dc62:	f3c5 0208 	ubfx	r2, r5, #0, #9
 808dc66:	460f      	mov	r7, r1
 808dc68:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 808dc6a:	6806      	ldr	r6, [r0, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 808dc6c:	b93a      	cbnz	r2, 808dc7e <dir_next+0x2e>
		dp->sect++;				/* Next sector */
 808dc6e:	3301      	adds	r3, #1
		if (dp->clust == 0) {	/* Static table */
 808dc70:	6941      	ldr	r1, [r0, #20]
		dp->sect++;				/* Next sector */
 808dc72:	6183      	str	r3, [r0, #24]
		if (dp->clust == 0) {	/* Static table */
 808dc74:	b969      	cbnz	r1, 808dc92 <dir_next+0x42>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 808dc76:	8933      	ldrh	r3, [r6, #8]
 808dc78:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 808dc7c:	d93a      	bls.n	808dcf4 <dir_next+0xa4>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 808dc7e:	3638      	adds	r6, #56	; 0x38
	return FR_OK;
 808dc80:	2000      	movs	r0, #0
	dp->dptr = ofs;						/* Current entry */
 808dc82:	6125      	str	r5, [r4, #16]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 808dc84:	4416      	add	r6, r2
 808dc86:	61e6      	str	r6, [r4, #28]
}
 808dc88:	b003      	add	sp, #12
 808dc8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 808dc8c:	2004      	movs	r0, #4
}
 808dc8e:	b003      	add	sp, #12
 808dc90:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 808dc92:	8973      	ldrh	r3, [r6, #10]
 808dc94:	3b01      	subs	r3, #1
 808dc96:	ea13 2355 	ands.w	r3, r3, r5, lsr #9
 808dc9a:	d1f0      	bne.n	808dc7e <dir_next+0x2e>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 808dc9c:	4630      	mov	r0, r6
 808dc9e:	9200      	str	r2, [sp, #0]
 808dca0:	f7ff fe46 	bl	808d930 <get_fat.isra.9>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 808dca4:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 808dca6:	4603      	mov	r3, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 808dca8:	9a00      	ldr	r2, [sp, #0]
 808dcaa:	d929      	bls.n	808dd00 <dir_next+0xb0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 808dcac:	1c41      	adds	r1, r0, #1
 808dcae:	d025      	beq.n	808dcfc <dir_next+0xac>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 808dcb0:	69f1      	ldr	r1, [r6, #28]
 808dcb2:	4281      	cmp	r1, r0
 808dcb4:	d813      	bhi.n	808dcde <dir_next+0x8e>
 808dcb6:	9200      	str	r2, [sp, #0]
					if (!stretch) {								/* If no stretch, report EOT */
 808dcb8:	b1e7      	cbz	r7, 808dcf4 <dir_next+0xa4>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 808dcba:	6961      	ldr	r1, [r4, #20]
 808dcbc:	4620      	mov	r0, r4
 808dcbe:	f7ff fef9 	bl	808dab4 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 808dcc2:	b308      	cbz	r0, 808dd08 <dir_next+0xb8>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 808dcc4:	2801      	cmp	r0, #1
 808dcc6:	d01b      	beq.n	808dd00 <dir_next+0xb0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 808dcc8:	1c42      	adds	r2, r0, #1
 808dcca:	d017      	beq.n	808dcfc <dir_next+0xac>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 808dccc:	4601      	mov	r1, r0
 808dcce:	9001      	str	r0, [sp, #4]
 808dcd0:	4630      	mov	r0, r6
 808dcd2:	f7ff faff 	bl	808d2d4 <dir_clear>
 808dcd6:	b988      	cbnz	r0, 808dcfc <dir_next+0xac>
 808dcd8:	69f1      	ldr	r1, [r6, #28]
 808dcda:	e9dd 2300 	ldrd	r2, r3, [sp]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808dcde:	3902      	subs	r1, #2
	clst -= 2;		/* Cluster number is origin from 2 */
 808dce0:	1e98      	subs	r0, r3, #2
				dp->clust = clst;		/* Initialize data for new cluster */
 808dce2:	6163      	str	r3, [r4, #20]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808dce4:	4288      	cmp	r0, r1
 808dce6:	d20d      	bcs.n	808dd04 <dir_next+0xb4>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 808dce8:	8973      	ldrh	r3, [r6, #10]
 808dcea:	6b31      	ldr	r1, [r6, #48]	; 0x30
 808dcec:	fb00 1303 	mla	r3, r0, r3, r1
				dp->sect = clst2sect(fs, clst);
 808dcf0:	61a3      	str	r3, [r4, #24]
 808dcf2:	e7c4      	b.n	808dc7e <dir_next+0x2e>
				dp->sect = 0; return FR_NO_FILE;
 808dcf4:	2300      	movs	r3, #0
 808dcf6:	2004      	movs	r0, #4
 808dcf8:	61a3      	str	r3, [r4, #24]
 808dcfa:	e7c8      	b.n	808dc8e <dir_next+0x3e>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 808dcfc:	2001      	movs	r0, #1
 808dcfe:	e7c6      	b.n	808dc8e <dir_next+0x3e>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 808dd00:	2002      	movs	r0, #2
 808dd02:	e7c4      	b.n	808dc8e <dir_next+0x3e>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808dd04:	2300      	movs	r3, #0
 808dd06:	e7f3      	b.n	808dcf0 <dir_next+0xa0>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 808dd08:	2007      	movs	r0, #7
 808dd0a:	e7c0      	b.n	808dc8e <dir_next+0x3e>

0808dd0c <dir_alloc>:
{
 808dd0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 808dd10:	4688      	mov	r8, r1
	res = dir_sdi(dp, 0);
 808dd12:	2100      	movs	r1, #0
{
 808dd14:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 808dd16:	6806      	ldr	r6, [r0, #0]
	res = dir_sdi(dp, 0);
 808dd18:	f7ff fe7e 	bl	808da18 <dir_sdi>
	if (res == FR_OK) {
 808dd1c:	4607      	mov	r7, r0
 808dd1e:	bb08      	cbnz	r0, 808dd64 <dir_alloc+0x58>
		n = 0;
 808dd20:	4605      	mov	r5, r0
 808dd22:	e005      	b.n	808dd30 <dir_alloc+0x24>
				n = 0;					/* Not a blank entry. Restart to search */
 808dd24:	461d      	mov	r5, r3
			res = dir_next(dp, 1);
 808dd26:	2101      	movs	r1, #1
 808dd28:	4620      	mov	r0, r4
 808dd2a:	f7ff ff91 	bl	808dc50 <dir_next>
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 808dd2e:	b9c0      	cbnz	r0, 808dd62 <dir_alloc+0x56>
			res = move_window(fs, dp->sect);
 808dd30:	69a3      	ldr	r3, [r4, #24]
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 808dd32:	3501      	adds	r5, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 808dd34:	6b72      	ldr	r2, [r6, #52]	; 0x34
 808dd36:	4630      	mov	r0, r6
 808dd38:	4619      	mov	r1, r3
 808dd3a:	4293      	cmp	r3, r2
 808dd3c:	d002      	beq.n	808dd44 <dir_alloc+0x38>
 808dd3e:	f7ff fb61 	bl	808d404 <move_window.part.6>
			if (res != FR_OK) break;
 808dd42:	b970      	cbnz	r0, 808dd62 <dir_alloc+0x56>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 808dd44:	69e3      	ldr	r3, [r4, #28]
 808dd46:	781a      	ldrb	r2, [r3, #0]
 808dd48:	fab2 f382 	clz	r3, r2
 808dd4c:	2ae5      	cmp	r2, #229	; 0xe5
 808dd4e:	ea4f 1353 	mov.w	r3, r3, lsr #5
 808dd52:	d001      	beq.n	808dd58 <dir_alloc+0x4c>
 808dd54:	2b00      	cmp	r3, #0
 808dd56:	d0e5      	beq.n	808dd24 <dir_alloc+0x18>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 808dd58:	4545      	cmp	r5, r8
 808dd5a:	d1e4      	bne.n	808dd26 <dir_alloc+0x1a>
}
 808dd5c:	4638      	mov	r0, r7
 808dd5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 808dd62:	4607      	mov	r7, r0
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 808dd64:	2f04      	cmp	r7, #4
 808dd66:	bf08      	it	eq
 808dd68:	2707      	moveq	r7, #7
}
 808dd6a:	4638      	mov	r0, r7
 808dd6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0808dd70 <dir_find>:
{
 808dd70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 808dd74:	2100      	movs	r1, #0
{
 808dd76:	b087      	sub	sp, #28
 808dd78:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 808dd7a:	6807      	ldr	r7, [r0, #0]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 808dd7c:	f7ff fe4c 	bl	808da18 <dir_sdi>
	if (res != FR_OK) return res;
 808dd80:	4682      	mov	sl, r0
 808dd82:	2800      	cmp	r0, #0
 808dd84:	d145      	bne.n	808de12 <dir_find+0xa2>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 808dd86:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 808dd8a:	f04f 0bff 	mov.w	fp, #255	; 0xff
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 808dd8e:	4698      	mov	r8, r3
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 808dd90:	46d9      	mov	r9, fp
 808dd92:	62eb      	str	r3, [r5, #44]	; 0x2c
 808dd94:	e00b      	b.n	808ddae <dir_find+0x3e>
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 808dd96:	2b0f      	cmp	r3, #15
 808dd98:	d03f      	beq.n	808de1a <dir_find+0xaa>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 808dd9a:	f04f 09ff 	mov.w	r9, #255	; 0xff
 808dd9e:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
		res = dir_next(dp, 0);	/* Next entry */
 808dda2:	2100      	movs	r1, #0
 808dda4:	4628      	mov	r0, r5
 808dda6:	f7ff ff53 	bl	808dc50 <dir_next>
	} while (res == FR_OK);
 808ddaa:	2800      	cmp	r0, #0
 808ddac:	d14c      	bne.n	808de48 <dir_find+0xd8>
		res = move_window(fs, dp->sect);
 808ddae:	69a9      	ldr	r1, [r5, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 808ddb0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 808ddb2:	4299      	cmp	r1, r3
 808ddb4:	d004      	beq.n	808ddc0 <dir_find+0x50>
 808ddb6:	4638      	mov	r0, r7
 808ddb8:	f7ff fb24 	bl	808d404 <move_window.part.6>
		if (res != FR_OK) break;
 808ddbc:	2800      	cmp	r0, #0
 808ddbe:	d143      	bne.n	808de48 <dir_find+0xd8>
		c = dp->dir[DIR_Name];
 808ddc0:	69ec      	ldr	r4, [r5, #28]
 808ddc2:	7826      	ldrb	r6, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 808ddc4:	2e00      	cmp	r6, #0
 808ddc6:	d05b      	beq.n	808de80 <dir_find+0x110>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 808ddc8:	7ae2      	ldrb	r2, [r4, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 808ddca:	2ee5      	cmp	r6, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 808ddcc:	f002 033f 	and.w	r3, r2, #63	; 0x3f
 808ddd0:	71ab      	strb	r3, [r5, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 808ddd2:	d0e2      	beq.n	808dd9a <dir_find+0x2a>
 808ddd4:	0711      	lsls	r1, r2, #28
 808ddd6:	d4de      	bmi.n	808dd96 <dir_find+0x26>
			if (a == AM_LFN) {			/* An LFN entry is found */
 808ddd8:	2b0f      	cmp	r3, #15
 808ddda:	d01e      	beq.n	808de1a <dir_find+0xaa>
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 808dddc:	f1b9 0f00 	cmp.w	r9, #0
 808dde0:	d037      	beq.n	808de52 <dir_find+0xe2>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 808dde2:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 808dde6:	07db      	lsls	r3, r3, #31
 808dde8:	d4d7      	bmi.n	808dd9a <dir_find+0x2a>
		r = *d++ - *s++;
 808ddea:	4620      	mov	r0, r4
 808ddec:	4629      	mov	r1, r5
 808ddee:	3401      	adds	r4, #1
 808ddf0:	f810 3b0b 	ldrb.w	r3, [r0], #11
 808ddf4:	f811 2f20 	ldrb.w	r2, [r1, #32]!
 808ddf8:	1a9b      	subs	r3, r3, r2
	} while (--cnt && r == 0);
 808ddfa:	2b00      	cmp	r3, #0
 808ddfc:	d1cd      	bne.n	808dd9a <dir_find+0x2a>
		r = *d++ - *s++;
 808ddfe:	f814 3b01 	ldrb.w	r3, [r4], #1
 808de02:	f811 2f01 	ldrb.w	r2, [r1, #1]!
	} while (--cnt && r == 0);
 808de06:	42a0      	cmp	r0, r4
		r = *d++ - *s++;
 808de08:	eba3 0302 	sub.w	r3, r3, r2
	} while (--cnt && r == 0);
 808de0c:	d1f5      	bne.n	808ddfa <dir_find+0x8a>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 808de0e:	2b00      	cmp	r3, #0
 808de10:	d1c3      	bne.n	808dd9a <dir_find+0x2a>
}
 808de12:	4650      	mov	r0, sl
 808de14:	b007      	add	sp, #28
 808de16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 808de1a:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 808de1e:	065a      	lsls	r2, r3, #25
 808de20:	d4bf      	bmi.n	808dda2 <dir_find+0x32>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 808de22:	0673      	lsls	r3, r6, #25
 808de24:	d527      	bpl.n	808de76 <dir_find+0x106>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 808de26:	692b      	ldr	r3, [r5, #16]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 808de28:	f006 06bf 	and.w	r6, r6, #191	; 0xbf
						sum = dp->dir[LDIR_Chksum];
 808de2c:	f894 b00d 	ldrb.w	fp, [r4, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 808de30:	62eb      	str	r3, [r5, #44]	; 0x2c
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 808de32:	7b63      	ldrb	r3, [r4, #13]
 808de34:	455b      	cmp	r3, fp
 808de36:	d029      	beq.n	808de8c <dir_find+0x11c>
 808de38:	f04f 09ff 	mov.w	r9, #255	; 0xff
		res = dir_next(dp, 0);	/* Next entry */
 808de3c:	2100      	movs	r1, #0
 808de3e:	4628      	mov	r0, r5
 808de40:	f7ff ff06 	bl	808dc50 <dir_next>
	} while (res == FR_OK);
 808de44:	2800      	cmp	r0, #0
 808de46:	d0b2      	beq.n	808ddae <dir_find+0x3e>
 808de48:	4682      	mov	sl, r0
}
 808de4a:	4650      	mov	r0, sl
 808de4c:	b007      	add	sp, #28
 808de4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 808de52:	f104 000b 	add.w	r0, r4, #11
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 808de56:	4621      	mov	r1, r4
		sum = (sum >> 1) + (sum << 7) + *dir++;
 808de58:	ea4f 13c9 	mov.w	r3, r9, lsl #7
 808de5c:	f811 2b01 	ldrb.w	r2, [r1], #1
 808de60:	ea43 0959 	orr.w	r9, r3, r9, lsr #1
	} while (--n);
 808de64:	4288      	cmp	r0, r1
		sum = (sum >> 1) + (sum << 7) + *dir++;
 808de66:	fa52 f989 	uxtab	r9, r2, r9
 808de6a:	fa5f f989 	uxtb.w	r9, r9
	} while (--n);
 808de6e:	d1f3      	bne.n	808de58 <dir_find+0xe8>
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 808de70:	45cb      	cmp	fp, r9
 808de72:	d1b6      	bne.n	808dde2 <dir_find+0x72>
 808de74:	e7cd      	b.n	808de12 <dir_find+0xa2>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 808de76:	45b1      	cmp	r9, r6
 808de78:	d0db      	beq.n	808de32 <dir_find+0xc2>
 808de7a:	f04f 09ff 	mov.w	r9, #255	; 0xff
 808de7e:	e7dd      	b.n	808de3c <dir_find+0xcc>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 808de80:	f04f 0a04 	mov.w	sl, #4
}
 808de84:	4650      	mov	r0, sl
 808de86:	b007      	add	sp, #28
 808de88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	rv = rv << 8 | ptr[0];
 808de8c:	7ee2      	ldrb	r2, [r4, #27]
 808de8e:	7ea3      	ldrb	r3, [r4, #26]
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 808de90:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 808de94:	d1d0      	bne.n	808de38 <dir_find+0xc8>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 808de96:	7820      	ldrb	r0, [r4, #0]
 808de98:	f642 6360 	movw	r3, #11872	; 0x2e60
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 808de9c:	68f9      	ldr	r1, [r7, #12]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 808de9e:	2201      	movs	r2, #1
 808dea0:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 808dea4:	f6c0 0309 	movt	r3, #2057	; 0x809
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 808dea8:	9104      	str	r1, [sp, #16]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 808deaa:	4611      	mov	r1, r2
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 808deac:	3801      	subs	r0, #1
 808deae:	9605      	str	r6, [sp, #20]
 808deb0:	4699      	mov	r9, r3
 808deb2:	eb00 0c40 	add.w	ip, r0, r0, lsl #1
 808deb6:	eb00 008c 	add.w	r0, r0, ip, lsl #2
 808deba:	e9cd b700 	strd	fp, r7, [sp]
 808debe:	e9cd a502 	strd	sl, r5, [sp, #8]
 808dec2:	9f04      	ldr	r7, [sp, #16]
 808dec4:	4625      	mov	r5, r4
 808dec6:	4604      	mov	r4, r0
 808dec8:	e015      	b.n	808def6 <dir_find+0x186>
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 808deca:	2c7f      	cmp	r4, #127	; 0x7f
 808decc:	4630      	mov	r0, r6
 808dece:	d81f      	bhi.n	808df10 <dir_find+0x1a0>
 808ded0:	f000 ff34 	bl	808ed3c <ff_wtoupper>
 808ded4:	4682      	mov	sl, r0
 808ded6:	f837 0014 	ldrh.w	r0, [r7, r4, lsl #1]
 808deda:	465c      	mov	r4, fp
 808dedc:	f000 ff2e 	bl	808ed3c <ff_wtoupper>
 808dee0:	4582      	cmp	sl, r0
	rv = rv << 8 | ptr[0];
 808dee2:	4631      	mov	r1, r6
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 808dee4:	d114      	bne.n	808df10 <dir_find+0x1a0>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 808dee6:	f642 636c 	movw	r3, #11884	; 0x2e6c
 808deea:	f6c0 0309 	movt	r3, #2057	; 0x809
 808deee:	454b      	cmp	r3, r9
 808def0:	d015      	beq.n	808df1e <dir_find+0x1ae>
 808def2:	f819 2f01 	ldrb.w	r2, [r9, #1]!
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 808def6:	18a8      	adds	r0, r5, r2
	rv = rv << 8 | ptr[0];
 808def8:	5cae      	ldrb	r6, [r5, r2]
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 808defa:	f104 0b01 	add.w	fp, r4, #1
	rv = rv << 8 | ptr[0];
 808defe:	7840      	ldrb	r0, [r0, #1]
 808df00:	ea46 2600 	orr.w	r6, r6, r0, lsl #8
		if (wc != 0) {
 808df04:	2900      	cmp	r1, #0
 808df06:	d1e0      	bne.n	808deca <dir_find+0x15a>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 808df08:	f64f 73ff 	movw	r3, #65535	; 0xffff
 808df0c:	429e      	cmp	r6, r3
 808df0e:	d0ea      	beq.n	808dee6 <dir_find+0x176>
 808df10:	e9dd b700 	ldrd	fp, r7, [sp]
 808df14:	e9dd a502 	ldrd	sl, r5, [sp, #8]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 808df18:	f04f 09ff 	mov.w	r9, #255	; 0xff
 808df1c:	e741      	b.n	808dda2 <dir_find+0x32>
 808df1e:	4622      	mov	r2, r4
 808df20:	462c      	mov	r4, r5
 808df22:	9e05      	ldr	r6, [sp, #20]
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 808df24:	7823      	ldrb	r3, [r4, #0]
 808df26:	0658      	lsls	r0, r3, #25
 808df28:	e9dd b700 	ldrd	fp, r7, [sp]
 808df2c:	e9dd a502 	ldrd	sl, r5, [sp, #8]
 808df30:	d500      	bpl.n	808df34 <dir_find+0x1c4>
 808df32:	b919      	cbnz	r1, 808df3c <dir_find+0x1cc>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 808df34:	3e01      	subs	r6, #1
 808df36:	fa5f f986 	uxtb.w	r9, r6
 808df3a:	e732      	b.n	808dda2 <dir_find+0x32>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 808df3c:	9b04      	ldr	r3, [sp, #16]
 808df3e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 808df42:	2b00      	cmp	r3, #0
 808df44:	d0f6      	beq.n	808df34 <dir_find+0x1c4>
 808df46:	e777      	b.n	808de38 <dir_find+0xc8>

0808df48 <follow_path>:
{
 808df48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 808df4c:	780b      	ldrb	r3, [r1, #0]
{
 808df4e:	b087      	sub	sp, #28
 808df50:	460d      	mov	r5, r1
 808df52:	4680      	mov	r8, r0
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 808df54:	2b2f      	cmp	r3, #47	; 0x2f
	FATFS *fs = dp->obj.fs;
 808df56:	f8d0 b000 	ldr.w	fp, [r0]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
 808df5a:	f000 80ed 	beq.w	808e138 <follow_path+0x1f0>
 808df5e:	2b5c      	cmp	r3, #92	; 0x5c
 808df60:	f000 80ea 	beq.w	808e138 <follow_path+0x1f0>
		dp->obj.sclust = fs->cdir;				/* Start from current directory */
 808df64:	f8db 3018 	ldr.w	r3, [fp, #24]
 808df68:	6083      	str	r3, [r0, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 808df6a:	782b      	ldrb	r3, [r5, #0]
 808df6c:	2b1f      	cmp	r3, #31
 808df6e:	f240 80f4 	bls.w	808e15a <follow_path+0x212>
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 808df72:	f642 53e0 	movw	r3, #11744	; 0x2de0
 808df76:	461a      	mov	r2, r3
	FATFS *fs = dp->obj.fs;
 808df78:	465b      	mov	r3, fp
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 808df7a:	f6c0 0209 	movt	r2, #2057	; 0x809
 808df7e:	9200      	str	r2, [sp, #0]
	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
 808df80:	68de      	ldr	r6, [r3, #12]
 808df82:	2400      	movs	r4, #0
 808df84:	9505      	str	r5, [sp, #20]
 808df86:	e004      	b.n	808df92 <follow_path+0x4a>
		if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 808df88:	2c7f      	cmp	r4, #127	; 0x7f
 808df8a:	d826      	bhi.n	808dfda <follow_path+0x92>
		lfn[di++] = wc;					/* Store the Unicode character */
 808df8c:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
 808df90:	3401      	adds	r4, #1
		uc = tchar2uni(&p);			/* Get a character */
 808df92:	a805      	add	r0, sp, #20
 808df94:	f7ff f960 	bl	808d258 <tchar2uni>
		if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;		/* Invalid code or UTF decode error */
 808df98:	1c45      	adds	r5, r0, #1
 808df9a:	d01e      	beq.n	808dfda <follow_path+0x92>
		if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);	/* Store high surrogate if needed */
 808df9c:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 808dfa0:	d303      	bcc.n	808dfaa <follow_path+0x62>
 808dfa2:	0c03      	lsrs	r3, r0, #16
 808dfa4:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
 808dfa8:	3401      	adds	r4, #1
		wc = (WCHAR)uc;
 808dfaa:	b283      	uxth	r3, r0
		if (wc < ' ' || wc == '/' || wc == '\\') break;	/* Break if end of the path or a separator is found */
 808dfac:	2b1f      	cmp	r3, #31
 808dfae:	d918      	bls.n	808dfe2 <follow_path+0x9a>
 808dfb0:	2b2f      	cmp	r3, #47	; 0x2f
 808dfb2:	d016      	beq.n	808dfe2 <follow_path+0x9a>
 808dfb4:	2b5c      	cmp	r3, #92	; 0x5c
 808dfb6:	d014      	beq.n	808dfe2 <follow_path+0x9a>
		if (wc < 0x80 && chk_chr("\"*:<>\?|\x7F", wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 808dfb8:	2b7f      	cmp	r3, #127	; 0x7f
 808dfba:	d8e5      	bhi.n	808df88 <follow_path+0x40>
 808dfbc:	b280      	uxth	r0, r0
	while (*str && *str != chr) str++;
 808dfbe:	2822      	cmp	r0, #34	; 0x22
 808dfc0:	d00b      	beq.n	808dfda <follow_path+0x92>
 808dfc2:	f642 6179 	movw	r1, #11897	; 0x2e79
 808dfc6:	222a      	movs	r2, #42	; 0x2a
 808dfc8:	f6c0 0109 	movt	r1, #2057	; 0x809
 808dfcc:	e003      	b.n	808dfd6 <follow_path+0x8e>
 808dfce:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 808dfd2:	2a00      	cmp	r2, #0
 808dfd4:	d0d8      	beq.n	808df88 <follow_path+0x40>
 808dfd6:	4290      	cmp	r0, r2
 808dfd8:	d1f9      	bne.n	808dfce <follow_path+0x86>
 808dfda:	2006      	movs	r0, #6
}
 808dfdc:	b007      	add	sp, #28
 808dfde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (*p == '/' || *p == '\\') p++;	/* Skip duplicated separators if exist */
 808dfe2:	9d05      	ldr	r5, [sp, #20]
 808dfe4:	782a      	ldrb	r2, [r5, #0]
 808dfe6:	2a2f      	cmp	r2, #47	; 0x2f
 808dfe8:	d104      	bne.n	808dff4 <follow_path+0xac>
 808dfea:	3501      	adds	r5, #1
 808dfec:	9505      	str	r5, [sp, #20]
 808dfee:	782a      	ldrb	r2, [r5, #0]
 808dff0:	2a2f      	cmp	r2, #47	; 0x2f
 808dff2:	d0fa      	beq.n	808dfea <follow_path+0xa2>
 808dff4:	2a5c      	cmp	r2, #92	; 0x5c
 808dff6:	d0f8      	beq.n	808dfea <follow_path+0xa2>
	cf = (wc < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 808dff8:	2b1f      	cmp	r3, #31
 808dffa:	bf8c      	ite	hi
 808dffc:	f04f 0900 	movhi.w	r9, #0
 808e000:	f04f 0904 	movls.w	r9, #4
	if ((di == 1 && lfn[di - 1] == '.') ||
 808e004:	2c01      	cmp	r4, #1
 808e006:	f000 8134 	beq.w	808e272 <follow_path+0x32a>
 808e00a:	2c02      	cmp	r4, #2
 808e00c:	f000 80af 	beq.w	808e16e <follow_path+0x226>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 808e010:	2c00      	cmp	r4, #0
 808e012:	f000 8128 	beq.w	808e266 <follow_path+0x31e>
 808e016:	f64f 73ff 	movw	r3, #65535	; 0xffff
 808e01a:	f6c7 73ff 	movt	r3, #32767	; 0x7fff
 808e01e:	4423      	add	r3, r4
 808e020:	f836 3013 	ldrh.w	r3, [r6, r3, lsl #1]
		if (wc != ' ' && wc != '.') break;
 808e024:	2b20      	cmp	r3, #32
 808e026:	d001      	beq.n	808e02c <follow_path+0xe4>
 808e028:	2b2e      	cmp	r3, #46	; 0x2e
 808e02a:	d10f      	bne.n	808e04c <follow_path+0x104>
 808e02c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 808e030:	f6c7 73ff 	movt	r3, #32767	; 0x7fff
 808e034:	4423      	add	r3, r4
 808e036:	eb06 0343 	add.w	r3, r6, r3, lsl #1
	while (di) {						/* Snip off trailing spaces and dots if exist */
 808e03a:	3c01      	subs	r4, #1
 808e03c:	f000 8113 	beq.w	808e266 <follow_path+0x31e>
		wc = lfn[di - 1];
 808e040:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
		if (wc != ' ' && wc != '.') break;
 808e044:	2a20      	cmp	r2, #32
 808e046:	d0f8      	beq.n	808e03a <follow_path+0xf2>
 808e048:	2a2e      	cmp	r2, #46	; 0x2e
 808e04a:	d0f6      	beq.n	808e03a <follow_path+0xf2>
	lfn[di] = 0;							/* LFN is created into the working buffer */
 808e04c:	2700      	movs	r7, #0
 808e04e:	eb06 0344 	add.w	r3, r6, r4, lsl #1
 808e052:	f826 7014 	strh.w	r7, [r6, r4, lsl #1]
	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
 808e056:	8832      	ldrh	r2, [r6, #0]
 808e058:	2a20      	cmp	r2, #32
 808e05a:	f040 814c 	bne.w	808e2f6 <follow_path+0x3ae>
 808e05e:	4632      	mov	r2, r6
 808e060:	f832 1f02 	ldrh.w	r1, [r2, #2]!
 808e064:	3701      	adds	r7, #1
 808e066:	2920      	cmp	r1, #32
 808e068:	d0fa      	beq.n	808e060 <follow_path+0x118>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 808e06a:	f049 0903 	orr.w	r9, r9, #3
 808e06e:	fa5f f989 	uxtb.w	r9, r9
	while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
 808e072:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 808e076:	2a2e      	cmp	r2, #46	; 0x2e
 808e078:	d001      	beq.n	808e07e <follow_path+0x136>
 808e07a:	3c01      	subs	r4, #1
 808e07c:	d1f9      	bne.n	808e072 <follow_path+0x12a>
	mem_set(dp->fn, ' ', 11);
 808e07e:	f108 0320 	add.w	r3, r8, #32
 808e082:	f108 012b 	add.w	r1, r8, #43	; 0x2b
		*d++ = (BYTE)val;
 808e086:	2220      	movs	r2, #32
 808e088:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 808e08c:	428b      	cmp	r3, r1
 808e08e:	d1fb      	bne.n	808e088 <follow_path+0x140>
	i = b = 0; ni = 8;
 808e090:	f04f 0a00 	mov.w	sl, #0
 808e094:	2208      	movs	r2, #8
 808e096:	4653      	mov	r3, sl
		wc = lfn[si++];					/* Get an LFN character */
 808e098:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
 808e09c:	3701      	adds	r7, #1
		if (wc == 0) break;				/* Break on end of the LFN */
 808e09e:	b180      	cbz	r0, 808e0c2 <follow_path+0x17a>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 808e0a0:	2820      	cmp	r0, #32
 808e0a2:	d005      	beq.n	808e0b0 <follow_path+0x168>
 808e0a4:	282e      	cmp	r0, #46	; 0x2e
 808e0a6:	f040 80a5 	bne.w	808e1f4 <follow_path+0x2ac>
 808e0aa:	42a7      	cmp	r7, r4
 808e0ac:	f000 80a2 	beq.w	808e1f4 <follow_path+0x2ac>
			cf |= NS_LOSS | NS_LFN;
 808e0b0:	f049 0903 	orr.w	r9, r9, #3
		wc = lfn[si++];					/* Get an LFN character */
 808e0b4:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
 808e0b8:	3701      	adds	r7, #1
			cf |= NS_LOSS | NS_LFN;
 808e0ba:	fa5f f989 	uxtb.w	r9, r9
		if (wc == 0) break;				/* Break on end of the LFN */
 808e0be:	2800      	cmp	r0, #0
 808e0c0:	d1ee      	bne.n	808e0a0 <follow_path+0x158>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 808e0c2:	f898 1020 	ldrb.w	r1, [r8, #32]
 808e0c6:	29e5      	cmp	r1, #229	; 0xe5
 808e0c8:	d102      	bne.n	808e0d0 <follow_path+0x188>
 808e0ca:	2105      	movs	r1, #5
 808e0cc:	f888 1020 	strb.w	r1, [r8, #32]
	if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
 808e0d0:	2a08      	cmp	r2, #8
 808e0d2:	d101      	bne.n	808e0d8 <follow_path+0x190>
 808e0d4:	009b      	lsls	r3, r3, #2
 808e0d6:	b2db      	uxtb	r3, r3
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 808e0d8:	f003 020c 	and.w	r2, r3, #12
 808e0dc:	2a0c      	cmp	r2, #12
 808e0de:	f000 80cd 	beq.w	808e27c <follow_path+0x334>
 808e0e2:	f003 0203 	and.w	r2, r3, #3
 808e0e6:	2a03      	cmp	r2, #3
 808e0e8:	f000 80c8 	beq.w	808e27c <follow_path+0x334>
	if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
 808e0ec:	f019 0f02 	tst.w	r9, #2
 808e0f0:	d108      	bne.n	808e104 <follow_path+0x1bc>
		if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
 808e0f2:	07dc      	lsls	r4, r3, #31
 808e0f4:	d503      	bpl.n	808e0fe <follow_path+0x1b6>
 808e0f6:	f049 0910 	orr.w	r9, r9, #16
 808e0fa:	fa5f f989 	uxtb.w	r9, r9
		if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
 808e0fe:	0758      	lsls	r0, r3, #29
 808e100:	f100 80c1 	bmi.w	808e286 <follow_path+0x33e>
	dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
 808e104:	f888 902b 	strb.w	r9, [r8, #43]	; 0x2b
			res = dir_find(dp);				/* Find an object with the segment name */
 808e108:	4640      	mov	r0, r8
 808e10a:	f7ff fe31 	bl	808dd70 <dir_find>
			ns = dp->fn[NSFLAG];
 808e10e:	f898 302b 	ldrb.w	r3, [r8, #43]	; 0x2b
			if (res != FR_OK) {				/* Failed to find the object */
 808e112:	2800      	cmp	r0, #0
 808e114:	d04c      	beq.n	808e1b0 <follow_path+0x268>
				if (res == FR_NO_FILE) {	/* Object is not found */
 808e116:	2804      	cmp	r0, #4
 808e118:	f47f af60 	bne.w	808dfdc <follow_path+0x94>
					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
 808e11c:	0699      	lsls	r1, r3, #26
 808e11e:	f003 0204 	and.w	r2, r3, #4
 808e122:	f140 80ff 	bpl.w	808e324 <follow_path+0x3dc>
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
 808e126:	2a00      	cmp	r2, #0
 808e128:	d061      	beq.n	808e1ee <follow_path+0x2a6>
						dp->fn[NSFLAG] = NS_NONAME;
 808e12a:	2380      	movs	r3, #128	; 0x80
						res = FR_OK;
 808e12c:	2000      	movs	r0, #0
						dp->fn[NSFLAG] = NS_NONAME;
 808e12e:	f888 302b 	strb.w	r3, [r8, #43]	; 0x2b
}
 808e132:	b007      	add	sp, #28
 808e134:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 808e138:	2b5c      	cmp	r3, #92	; 0x5c
 808e13a:	d001      	beq.n	808e140 <follow_path+0x1f8>
 808e13c:	2b2f      	cmp	r3, #47	; 0x2f
 808e13e:	d105      	bne.n	808e14c <follow_path+0x204>
 808e140:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 808e144:	2b2f      	cmp	r3, #47	; 0x2f
 808e146:	d0fb      	beq.n	808e140 <follow_path+0x1f8>
 808e148:	2b5c      	cmp	r3, #92	; 0x5c
 808e14a:	d0f9      	beq.n	808e140 <follow_path+0x1f8>
		dp->obj.sclust = 0;					/* Start from root directory */
 808e14c:	2300      	movs	r3, #0
 808e14e:	f8c8 3008 	str.w	r3, [r8, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 808e152:	782b      	ldrb	r3, [r5, #0]
 808e154:	2b1f      	cmp	r3, #31
 808e156:	f63f af0c 	bhi.w	808df72 <follow_path+0x2a>
		dp->fn[NSFLAG] = NS_NONAME;
 808e15a:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 808e15c:	2100      	movs	r1, #0
 808e15e:	4640      	mov	r0, r8
		dp->fn[NSFLAG] = NS_NONAME;
 808e160:	f888 302b 	strb.w	r3, [r8, #43]	; 0x2b
		res = dir_sdi(dp, 0);
 808e164:	f7ff fc58 	bl	808da18 <dir_sdi>
}
 808e168:	b007      	add	sp, #28
 808e16a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
 808e16e:	8873      	ldrh	r3, [r6, #2]
 808e170:	2b2e      	cmp	r3, #46	; 0x2e
 808e172:	f47f af57 	bne.w	808e024 <follow_path+0xdc>
 808e176:	8832      	ldrh	r2, [r6, #0]
 808e178:	2a2e      	cmp	r2, #46	; 0x2e
 808e17a:	f47f af53 	bne.w	808e024 <follow_path+0xdc>
		lfn[di] = 0;
 808e17e:	2300      	movs	r3, #0
 808e180:	f108 021f 	add.w	r2, r8, #31
 808e184:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
			dp->fn[i] = (i < di) ? '.' : ' ';
 808e188:	429c      	cmp	r4, r3
 808e18a:	bf94      	ite	ls
 808e18c:	2120      	movls	r1, #32
 808e18e:	212e      	movhi	r1, #46	; 0x2e
		for (i = 0; i < 11; i++) {		/* Create dot name for SFN entry */
 808e190:	3301      	adds	r3, #1
 808e192:	2b0b      	cmp	r3, #11
			dp->fn[i] = (i < di) ? '.' : ' ';
 808e194:	f802 1f01 	strb.w	r1, [r2, #1]!
		for (i = 0; i < 11; i++) {		/* Create dot name for SFN entry */
 808e198:	d1f6      	bne.n	808e188 <follow_path+0x240>
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 808e19a:	f049 0920 	orr.w	r9, r9, #32
			res = dir_find(dp);				/* Find an object with the segment name */
 808e19e:	4640      	mov	r0, r8
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 808e1a0:	f888 902b 	strb.w	r9, [r8, #43]	; 0x2b
			res = dir_find(dp);				/* Find an object with the segment name */
 808e1a4:	f7ff fde4 	bl	808dd70 <dir_find>
			ns = dp->fn[NSFLAG];
 808e1a8:	f898 302b 	ldrb.w	r3, [r8, #43]	; 0x2b
			if (res != FR_OK) {				/* Failed to find the object */
 808e1ac:	2800      	cmp	r0, #0
 808e1ae:	d1b2      	bne.n	808e116 <follow_path+0x1ce>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 808e1b0:	075a      	lsls	r2, r3, #29
 808e1b2:	f53f af13 	bmi.w	808dfdc <follow_path+0x94>
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 808e1b6:	f898 3006 	ldrb.w	r3, [r8, #6]
 808e1ba:	06db      	lsls	r3, r3, #27
 808e1bc:	f140 80b6 	bpl.w	808e32c <follow_path+0x3e4>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 808e1c0:	f8d8 2010 	ldr.w	r2, [r8, #16]
 808e1c4:	f10b 0338 	add.w	r3, fp, #56	; 0x38
	if (fs->fs_type == FS_FAT32) {
 808e1c8:	f89b 1000 	ldrb.w	r1, [fp]
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 808e1cc:	f3c2 0208 	ubfx	r2, r2, #0, #9
	if (fs->fs_type == FS_FAT32) {
 808e1d0:	2903      	cmp	r1, #3
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 808e1d2:	4413      	add	r3, r2
	rv = rv << 8 | ptr[0];
 808e1d4:	7ed8      	ldrb	r0, [r3, #27]
 808e1d6:	7e9a      	ldrb	r2, [r3, #26]
	cl = ld_word(dir + DIR_FstClusLO);
 808e1d8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 808e1dc:	d105      	bne.n	808e1ea <follow_path+0x2a2>
	rv = rv << 8 | ptr[0];
 808e1de:	7d59      	ldrb	r1, [r3, #21]
 808e1e0:	7d1b      	ldrb	r3, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 808e1e2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 808e1e6:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 808e1ea:	f8c8 2008 	str.w	r2, [r8, #8]
 808e1ee:	f8d8 3000 	ldr.w	r3, [r8]
 808e1f2:	e6c5      	b.n	808df80 <follow_path+0x38>
		if (i >= ni || si == di) {		/* End of field? */
 808e1f4:	4592      	cmp	sl, r2
 808e1f6:	d225      	bcs.n	808e244 <follow_path+0x2fc>
 808e1f8:	42a7      	cmp	r7, r4
 808e1fa:	d023      	beq.n	808e244 <follow_path+0x2fc>
		if (wc >= 0x80) {	/* Is this a non-ASCII character? */
 808e1fc:	287f      	cmp	r0, #127	; 0x7f
 808e1fe:	d847      	bhi.n	808e290 <follow_path+0x348>
	while (*str && *str != chr) str++;
 808e200:	282b      	cmp	r0, #43	; 0x2b
 808e202:	d07f      	beq.n	808e304 <follow_path+0x3bc>
 808e204:	f642 6c85 	movw	ip, #11909	; 0x2e85
 808e208:	212c      	movs	r1, #44	; 0x2c
 808e20a:	f6c0 0c09 	movt	ip, #2057	; 0x809
 808e20e:	4281      	cmp	r1, r0
 808e210:	d078      	beq.n	808e304 <follow_path+0x3bc>
 808e212:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
 808e216:	2900      	cmp	r1, #0
 808e218:	d1f9      	bne.n	808e20e <follow_path+0x2c6>
				if (IsUpper(wc)) {		/* ASCII upper case? */
 808e21a:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 808e21e:	b289      	uxth	r1, r1
 808e220:	2919      	cmp	r1, #25
 808e222:	d96c      	bls.n	808e2fe <follow_path+0x3b6>
				if (IsLower(wc)) {		/* ASCII lower case? */
 808e224:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
 808e228:	b289      	uxth	r1, r1
 808e22a:	2919      	cmp	r1, #25
					b |= 1; wc -= 0x20;
 808e22c:	bf9c      	itt	ls
 808e22e:	3820      	subls	r0, #32
 808e230:	f043 0301 	orrls.w	r3, r3, #1
 808e234:	b2c0      	uxtb	r0, r0
		dp->fn[i++] = (BYTE)wc;
 808e236:	eb08 010a 	add.w	r1, r8, sl
 808e23a:	f10a 0a01 	add.w	sl, sl, #1
 808e23e:	f881 0020 	strb.w	r0, [r1, #32]
 808e242:	e729      	b.n	808e098 <follow_path+0x150>
			if (ni == 11) {				/* Name extension overflow? */
 808e244:	2a0b      	cmp	r2, #11
 808e246:	d060      	beq.n	808e30a <follow_path+0x3c2>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
 808e248:	42a7      	cmp	r7, r4
 808e24a:	d005      	beq.n	808e258 <follow_path+0x310>
 808e24c:	f049 0903 	orr.w	r9, r9, #3
 808e250:	fa5f f989 	uxtb.w	r9, r9
			if (si > di) break;						/* No name extension? */
 808e254:	f63f af35 	bhi.w	808e0c2 <follow_path+0x17a>
			si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
 808e258:	009b      	lsls	r3, r3, #2
 808e25a:	4627      	mov	r7, r4
 808e25c:	220b      	movs	r2, #11
 808e25e:	f04f 0a08 	mov.w	sl, #8
 808e262:	b2db      	uxtb	r3, r3
 808e264:	e718      	b.n	808e098 <follow_path+0x150>
	lfn[di] = 0;							/* LFN is created into the working buffer */
 808e266:	2300      	movs	r3, #0
	if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
 808e268:	2006      	movs	r0, #6
	lfn[di] = 0;							/* LFN is created into the working buffer */
 808e26a:	8033      	strh	r3, [r6, #0]
}
 808e26c:	b007      	add	sp, #28
 808e26e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if ((di == 1 && lfn[di - 1] == '.') ||
 808e272:	8833      	ldrh	r3, [r6, #0]
 808e274:	2b2e      	cmp	r3, #46	; 0x2e
 808e276:	f47f aed5 	bne.w	808e024 <follow_path+0xdc>
 808e27a:	e780      	b.n	808e17e <follow_path+0x236>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 808e27c:	f049 0902 	orr.w	r9, r9, #2
 808e280:	fa5f f989 	uxtb.w	r9, r9
 808e284:	e73e      	b.n	808e104 <follow_path+0x1bc>
		if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
 808e286:	f049 0908 	orr.w	r9, r9, #8
 808e28a:	fa5f f989 	uxtb.w	r9, r9
 808e28e:	e739      	b.n	808e104 <follow_path+0x1bc>
			cf |= NS_LFN;	/* LFN entry needs to be created */
 808e290:	f049 0c02 	orr.w	ip, r9, #2
			wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
 808e294:	f240 11b5 	movw	r1, #437	; 0x1b5
 808e298:	e9cd 2302 	strd	r2, r3, [sp, #8]
			cf |= NS_LFN;	/* LFN entry needs to be created */
 808e29c:	fa5f f38c 	uxtb.w	r3, ip
 808e2a0:	9301      	str	r3, [sp, #4]
			wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
 808e2a2:	f000 fd0f 	bl	808ecc4 <ff_uni2oem>
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 808e2a6:	f010 0f80 	tst.w	r0, #128	; 0x80
 808e2aa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 808e2ae:	d00b      	beq.n	808e2c8 <follow_path+0x380>
 808e2b0:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 808e2b4:	9900      	ldr	r1, [sp, #0]
 808e2b6:	5c08      	ldrb	r0, [r1, r0]
			if (wc == 0 || chk_chr("+,;=[]", wc)) {	/* Replace illegal characters for SFN if needed */
 808e2b8:	bbd0      	cbnz	r0, 808e330 <follow_path+0x3e8>
				wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 808e2ba:	9901      	ldr	r1, [sp, #4]
 808e2bc:	205f      	movs	r0, #95	; 0x5f
 808e2be:	f041 0903 	orr.w	r9, r1, #3
 808e2c2:	fa5f f989 	uxtb.w	r9, r9
 808e2c6:	e7b6      	b.n	808e236 <follow_path+0x2ee>
		if (wc >= 0x100) {				/* Is this a DBC? */
 808e2c8:	28ff      	cmp	r0, #255	; 0xff
 808e2ca:	d9f5      	bls.n	808e2b8 <follow_path+0x370>
			if (i >= ni - 1) {			/* Field overflow? */
 808e2cc:	1e51      	subs	r1, r2, #1
 808e2ce:	458a      	cmp	sl, r1
 808e2d0:	d20b      	bcs.n	808e2ea <follow_path+0x3a2>
			dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
 808e2d2:	eb08 010a 	add.w	r1, r8, sl
 808e2d6:	ea4f 2c10 	mov.w	ip, r0, lsr #8
 808e2da:	f8dd 9004 	ldr.w	r9, [sp, #4]
 808e2de:	f10a 0a01 	add.w	sl, sl, #1
 808e2e2:	f881 c020 	strb.w	ip, [r1, #32]
 808e2e6:	b2c0      	uxtb	r0, r0
 808e2e8:	e7a5      	b.n	808e236 <follow_path+0x2ee>
				cf |= NS_LOSS | NS_LFN;
 808e2ea:	f049 0903 	orr.w	r9, r9, #3
 808e2ee:	4692      	mov	sl, r2
 808e2f0:	fa5f f989 	uxtb.w	r9, r9
 808e2f4:	e6d0      	b.n	808e098 <follow_path+0x150>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 808e2f6:	2a2e      	cmp	r2, #46	; 0x2e
 808e2f8:	f47f aebb 	bne.w	808e072 <follow_path+0x12a>
 808e2fc:	e6b5      	b.n	808e06a <follow_path+0x122>
					b |= 2;
 808e2fe:	f043 0302 	orr.w	r3, r3, #2
 808e302:	e78f      	b.n	808e224 <follow_path+0x2dc>
	while (*str && *str != chr) str++;
 808e304:	f8cd 9004 	str.w	r9, [sp, #4]
 808e308:	e7d7      	b.n	808e2ba <follow_path+0x372>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 808e30a:	f898 2020 	ldrb.w	r2, [r8, #32]
				cf |= NS_LOSS | NS_LFN;
 808e30e:	f049 0903 	orr.w	r9, r9, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 808e312:	2ae5      	cmp	r2, #229	; 0xe5
				cf |= NS_LOSS | NS_LFN;
 808e314:	fa5f f989 	uxtb.w	r9, r9
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 808e318:	f47f aede 	bne.w	808e0d8 <follow_path+0x190>
 808e31c:	2205      	movs	r2, #5
 808e31e:	f888 2020 	strb.w	r2, [r8, #32]
 808e322:	e6d9      	b.n	808e0d8 <follow_path+0x190>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 808e324:	2a00      	cmp	r2, #0
 808e326:	bf08      	it	eq
 808e328:	2005      	moveq	r0, #5
 808e32a:	e657      	b.n	808dfdc <follow_path+0x94>
 808e32c:	2005      	movs	r0, #5
 808e32e:	e655      	b.n	808dfdc <follow_path+0x94>
			if (wc == 0 || chk_chr("+,;=[]", wc)) {	/* Replace illegal characters for SFN if needed */
 808e330:	f8dd 9004 	ldr.w	r9, [sp, #4]
 808e334:	e764      	b.n	808e200 <follow_path+0x2b8>
 808e336:	bf00      	nop

0808e338 <dir_register>:
{
 808e338:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 808e33c:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
{
 808e340:	b08b      	sub	sp, #44	; 0x2c
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 808e342:	f013 07a0 	ands.w	r7, r3, #160	; 0xa0
 808e346:	f040 814f 	bne.w	808e5e8 <dir_register+0x2b0>
	FATFS *fs = dp->obj.fs;
 808e34a:	f8d0 b000 	ldr.w	fp, [r0]
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 808e34e:	f8db 300c 	ldr.w	r3, [fp, #12]
 808e352:	881a      	ldrh	r2, [r3, #0]
 808e354:	2a00      	cmp	r2, #0
 808e356:	f000 815e 	beq.w	808e616 <dir_register+0x2de>
 808e35a:	f833 2f02 	ldrh.w	r2, [r3, #2]!
 808e35e:	3701      	adds	r7, #1
 808e360:	2a00      	cmp	r2, #0
 808e362:	d1fa      	bne.n	808e35a <dir_register+0x22>
	mem_cpy(sn, dp->fn, 12);
 808e364:	f100 0520 	add.w	r5, r0, #32
 808e368:	4604      	mov	r4, r0
 808e36a:	220c      	movs	r2, #12
 808e36c:	a807      	add	r0, sp, #28
 808e36e:	4629      	mov	r1, r5
 808e370:	f7fe ff84 	bl	808d27c <mem_cpy.part.0>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 808e374:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 808e378:	07d9      	lsls	r1, r3, #31
 808e37a:	d573      	bpl.n	808e464 <dir_register+0x12c>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 808e37c:	2340      	movs	r3, #64	; 0x40
		for (n = 1; n < 100; n++) {
 808e37e:	f04f 0801 	mov.w	r8, #1
				if (sr & 0x10000) sr ^= 0x11021;
 808e382:	f241 0621 	movw	r6, #4129	; 0x1021
 808e386:	220b      	movs	r2, #11
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 808e388:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
 808e38c:	a907      	add	r1, sp, #28
 808e38e:	4628      	mov	r0, r5
				if (sr & 0x10000) sr ^= 0x11021;
 808e390:	f2c0 0601 	movt	r6, #1
 808e394:	f7fe ff72 	bl	808d27c <mem_cpy.part.0>
		for (n = 1; n < 100; n++) {
 808e398:	4643      	mov	r3, r8
 808e39a:	f10d 0c1b 	add.w	ip, sp, #27
 808e39e:	2207      	movs	r2, #7
		c = (BYTE)((seq % 16) + '0');
 808e3a0:	f003 000f 	and.w	r0, r3, #15
		ns[i--] = c;
 808e3a4:	3a01      	subs	r2, #1
		c = (BYTE)((seq % 16) + '0');
 808e3a6:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
 808e3aa:	2939      	cmp	r1, #57	; 0x39
 808e3ac:	bf88      	it	hi
 808e3ae:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
	} while (seq);
 808e3b2:	091b      	lsrs	r3, r3, #4
		ns[i--] = c;
 808e3b4:	f80c 1901 	strb.w	r1, [ip], #-1
	} while (seq);
 808e3b8:	d1f2      	bne.n	808e3a0 <dir_register+0x68>
	ns[i] = '~';
 808e3ba:	a90a      	add	r1, sp, #40	; 0x28
 808e3bc:	207e      	movs	r0, #126	; 0x7e
 808e3be:	4411      	add	r1, r2
 808e3c0:	f801 0c14 	strb.w	r0, [r1, #-20]
	for (j = 0; j < i && dst[j] != ' '; j++) {
 808e3c4:	2a00      	cmp	r2, #0
 808e3c6:	f000 810d 	beq.w	808e5e4 <dir_register+0x2ac>
 808e3ca:	f894 1020 	ldrb.w	r1, [r4, #32]
 808e3ce:	2920      	cmp	r1, #32
 808e3d0:	d008      	beq.n	808e3e4 <dir_register+0xac>
 808e3d2:	4629      	mov	r1, r5
 808e3d4:	e003      	b.n	808e3de <dir_register+0xa6>
 808e3d6:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 808e3da:	2820      	cmp	r0, #32
 808e3dc:	d002      	beq.n	808e3e4 <dir_register+0xac>
 808e3de:	3301      	adds	r3, #1
 808e3e0:	429a      	cmp	r2, r3
 808e3e2:	d1f8      	bne.n	808e3d6 <dir_register+0x9e>
 808e3e4:	1e58      	subs	r0, r3, #1
 808e3e6:	4428      	add	r0, r5
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 808e3e8:	a90a      	add	r1, sp, #40	; 0x28
 808e3ea:	2a07      	cmp	r2, #7
 808e3ec:	eb01 0c02 	add.w	ip, r1, r2
 808e3f0:	f04f 0120 	mov.w	r1, #32
 808e3f4:	d802      	bhi.n	808e3fc <dir_register+0xc4>
 808e3f6:	f81c 1c14 	ldrb.w	r1, [ip, #-20]
 808e3fa:	3201      	adds	r2, #1
 808e3fc:	3301      	adds	r3, #1
 808e3fe:	f800 1f01 	strb.w	r1, [r0, #1]!
	} while (j < 8);
 808e402:	2b07      	cmp	r3, #7
 808e404:	d9f0      	bls.n	808e3e8 <dir_register+0xb0>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 808e406:	4620      	mov	r0, r4
 808e408:	f7ff fcb2 	bl	808dd70 <dir_find>
			if (res != FR_OK) break;
 808e40c:	bb18      	cbnz	r0, 808e456 <dir_register+0x11e>
		for (n = 1; n < 100; n++) {
 808e40e:	f108 0801 	add.w	r8, r8, #1
 808e412:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
 808e416:	f000 8100 	beq.w	808e61a <dir_register+0x2e2>
 808e41a:	220b      	movs	r2, #11
 808e41c:	a907      	add	r1, sp, #28
 808e41e:	4628      	mov	r0, r5
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 808e420:	f8db 900c 	ldr.w	r9, [fp, #12]
 808e424:	f7fe ff2a 	bl	808d27c <mem_cpy.part.0>
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 808e428:	f1b8 0f05 	cmp.w	r8, #5
 808e42c:	f240 80d8 	bls.w	808e5e0 <dir_register+0x2a8>
 808e430:	f1a9 0c02 	sub.w	ip, r9, #2
 808e434:	4643      	mov	r3, r8
		while (*lfn) {	/* Create a CRC as hash value */
 808e436:	f83c 1f02 	ldrh.w	r1, [ip, #2]!
 808e43a:	2900      	cmp	r1, #0
 808e43c:	d0ad      	beq.n	808e39a <dir_register+0x62>
 808e43e:	2010      	movs	r0, #16
				sr = (sr << 1) + (wc & 1);
 808e440:	f001 0201 	and.w	r2, r1, #1
 808e444:	0849      	lsrs	r1, r1, #1
 808e446:	eb02 0343 	add.w	r3, r2, r3, lsl #1
				if (sr & 0x10000) sr ^= 0x11021;
 808e44a:	03da      	lsls	r2, r3, #15
 808e44c:	bf48      	it	mi
 808e44e:	4073      	eormi	r3, r6
			for (i = 0; i < 16; i++) {
 808e450:	3801      	subs	r0, #1
 808e452:	d1f5      	bne.n	808e440 <dir_register+0x108>
 808e454:	e7ef      	b.n	808e436 <dir_register+0xfe>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 808e456:	2804      	cmp	r0, #4
 808e458:	f040 80bf 	bne.w	808e5da <dir_register+0x2a2>
		dp->fn[NSFLAG] = sn[NSFLAG];
 808e45c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 808e460:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 808e464:	079b      	lsls	r3, r3, #30
 808e466:	f140 80c3 	bpl.w	808e5f0 <dir_register+0x2b8>
 808e46a:	f64e 424f 	movw	r2, #60495	; 0xec4f
 808e46e:	f107 030c 	add.w	r3, r7, #12
	res = dir_alloc(dp, nent);		/* Allocate entries */
 808e472:	4620      	mov	r0, r4
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 808e474:	f6c4 62c4 	movt	r2, #20164	; 0x4ec4
 808e478:	fba2 2303 	umull	r2, r3, r2, r3
 808e47c:	089b      	lsrs	r3, r3, #2
	res = dir_alloc(dp, nent);		/* Allocate entries */
 808e47e:	1c59      	adds	r1, r3, #1
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 808e480:	461e      	mov	r6, r3
 808e482:	9300      	str	r3, [sp, #0]
	res = dir_alloc(dp, nent);		/* Allocate entries */
 808e484:	f7ff fc42 	bl	808dd0c <dir_alloc>
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 808e488:	2800      	cmp	r0, #0
 808e48a:	f040 80a6 	bne.w	808e5da <dir_register+0x2a2>
 808e48e:	2e00      	cmp	r6, #0
 808e490:	f000 8087 	beq.w	808e5a2 <dir_register+0x26a>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 808e494:	6921      	ldr	r1, [r4, #16]
 808e496:	4620      	mov	r0, r4
 808e498:	eba1 1146 	sub.w	r1, r1, r6, lsl #5
 808e49c:	f7ff fabc 	bl	808da18 <dir_sdi>
		if (res == FR_OK) {
 808e4a0:	2800      	cmp	r0, #0
 808e4a2:	f040 809a 	bne.w	808e5da <dir_register+0x2a2>
	BYTE sum = 0;
 808e4a6:	4602      	mov	r2, r0
		if (res == FR_OK) {
 808e4a8:	4629      	mov	r1, r5
 808e4aa:	f104 002b 	add.w	r0, r4, #43	; 0x2b
		sum = (sum >> 1) + (sum << 7) + *dir++;
 808e4ae:	01d3      	lsls	r3, r2, #7
 808e4b0:	f811 6b01 	ldrb.w	r6, [r1], #1
 808e4b4:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
	} while (--n);
 808e4b8:	4281      	cmp	r1, r0
		sum = (sum >> 1) + (sum << 7) + *dir++;
 808e4ba:	fa56 f383 	uxtab	r3, r6, r3
 808e4be:	b2da      	uxtb	r2, r3
	} while (--n);
 808e4c0:	d1f5      	bne.n	808e4ae <dir_register+0x176>
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 808e4c2:	f642 6a60 	movw	sl, #11872	; 0x2e60
 808e4c6:	9202      	str	r2, [sp, #8]
 808e4c8:	9503      	str	r5, [sp, #12]
 808e4ca:	f6c0 0a09 	movt	sl, #2057	; 0x809
				res = move_window(fs, dp->sect);
 808e4ce:	69a1      	ldr	r1, [r4, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 808e4d0:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 808e4d4:	4299      	cmp	r1, r3
 808e4d6:	d004      	beq.n	808e4e2 <dir_register+0x1aa>
 808e4d8:	4658      	mov	r0, fp
 808e4da:	f7fe ff93 	bl	808d404 <move_window.part.6>
				if (res != FR_OK) break;
 808e4de:	2800      	cmp	r0, #0
 808e4e0:	d17b      	bne.n	808e5da <dir_register+0x2a2>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 808e4e2:	f89d 3000 	ldrb.w	r3, [sp]
	dir[LDIR_Type] = 0;
 808e4e6:	2600      	movs	r6, #0
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 808e4e8:	69e1      	ldr	r1, [r4, #28]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 808e4ea:	2501      	movs	r5, #1
 808e4ec:	1e58      	subs	r0, r3, #1
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 808e4ee:	9a02      	ldr	r2, [sp, #8]
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 808e4f0:	f8db 800c 	ldr.w	r8, [fp, #12]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 808e4f4:	f64f 79ff 	movw	r9, #65535	; 0xffff
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 808e4f8:	eb00 0740 	add.w	r7, r0, r0, lsl #1
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 808e4fc:	9301      	str	r3, [sp, #4]
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 808e4fe:	734a      	strb	r2, [r1, #13]
	s = wc = 0;
 808e500:	4633      	mov	r3, r6
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 808e502:	eb00 0087 	add.w	r0, r0, r7, lsl #2
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 808e506:	f04f 070f 	mov.w	r7, #15
	dir[LDIR_Type] = 0;
 808e50a:	730e      	strb	r6, [r1, #12]
	s = wc = 0;
 808e50c:	4632      	mov	r2, r6
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 808e50e:	72cf      	strb	r7, [r1, #11]
	*ptr++ = (BYTE)val; val >>= 8;
 808e510:	f04f 0eff 	mov.w	lr, #255	; 0xff
 808e514:	768e      	strb	r6, [r1, #26]
	*ptr++ = (BYTE)val;
 808e516:	76ce      	strb	r6, [r1, #27]
 808e518:	e016      	b.n	808e548 <dir_register+0x210>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 808e51a:	f838 3010 	ldrh.w	r3, [r8, r0, lsl #1]
	*ptr++ = (BYTE)val; val >>= 8;
 808e51e:	0a18      	lsrs	r0, r3, #8
 808e520:	554b      	strb	r3, [r1, r5]
	*ptr++ = (BYTE)val;
 808e522:	7078      	strb	r0, [r7, #1]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 808e524:	2b00      	cmp	r3, #0
 808e526:	d174      	bne.n	808e612 <dir_register+0x2da>
	} while (++s < 13);
 808e528:	2e0c      	cmp	r6, #12
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 808e52a:	f64f 73ff 	movw	r3, #65535	; 0xffff
	} while (++s < 13);
 808e52e:	d825      	bhi.n	808e57c <dir_register+0x244>
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 808e530:	f81a 0006 	ldrb.w	r0, [sl, r6]
 808e534:	180d      	adds	r5, r1, r0
	*ptr++ = (BYTE)val; val >>= 8;
 808e536:	f801 e000 	strb.w	lr, [r1, r0]
	*ptr++ = (BYTE)val;
 808e53a:	f885 e001 	strb.w	lr, [r5, #1]
	} while (++s < 13);
 808e53e:	2a0c      	cmp	r2, #12
 808e540:	4660      	mov	r0, ip
 808e542:	d814      	bhi.n	808e56e <dir_register+0x236>
 808e544:	f81a 5002 	ldrb.w	r5, [sl, r2]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 808e548:	454b      	cmp	r3, r9
 808e54a:	f102 0601 	add.w	r6, r2, #1
 808e54e:	eb01 0705 	add.w	r7, r1, r5
 808e552:	f100 0c01 	add.w	ip, r0, #1
 808e556:	f102 0202 	add.w	r2, r2, #2
 808e55a:	d1de      	bne.n	808e51a <dir_register+0x1e2>
	*ptr++ = (BYTE)val;
 808e55c:	4632      	mov	r2, r6
 808e55e:	4684      	mov	ip, r0
	*ptr++ = (BYTE)val; val >>= 8;
 808e560:	f801 e005 	strb.w	lr, [r1, r5]
	} while (++s < 13);
 808e564:	2a0c      	cmp	r2, #12
	*ptr++ = (BYTE)val;
 808e566:	f887 e001 	strb.w	lr, [r7, #1]
	} while (++s < 13);
 808e56a:	4660      	mov	r0, ip
 808e56c:	d9ea      	bls.n	808e544 <dir_register+0x20c>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 808e56e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 808e572:	4293      	cmp	r3, r2
 808e574:	d002      	beq.n	808e57c <dir_register+0x244>
 808e576:	f838 301c 	ldrh.w	r3, [r8, ip, lsl #1]
 808e57a:	b91b      	cbnz	r3, 808e584 <dir_register+0x24c>
 808e57c:	9b01      	ldr	r3, [sp, #4]
 808e57e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 808e582:	9301      	str	r3, [sp, #4]
				fs->wflag = 1;
 808e584:	2301      	movs	r3, #1
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 808e586:	9a01      	ldr	r2, [sp, #4]
				res = dir_next(dp, 0);	/* Next entry */
 808e588:	4620      	mov	r0, r4
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 808e58a:	700a      	strb	r2, [r1, #0]
				res = dir_next(dp, 0);	/* Next entry */
 808e58c:	2100      	movs	r1, #0
				fs->wflag = 1;
 808e58e:	f88b 3003 	strb.w	r3, [fp, #3]
				res = dir_next(dp, 0);	/* Next entry */
 808e592:	f7ff fb5d 	bl	808dc50 <dir_next>
			} while (res == FR_OK && --nent);
 808e596:	bb00      	cbnz	r0, 808e5da <dir_register+0x2a2>
 808e598:	9b00      	ldr	r3, [sp, #0]
 808e59a:	3b01      	subs	r3, #1
 808e59c:	9300      	str	r3, [sp, #0]
 808e59e:	d196      	bne.n	808e4ce <dir_register+0x196>
 808e5a0:	9d03      	ldr	r5, [sp, #12]
		res = move_window(fs, dp->sect);
 808e5a2:	69a1      	ldr	r1, [r4, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 808e5a4:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 808e5a8:	4299      	cmp	r1, r3
 808e5aa:	d12c      	bne.n	808e606 <dir_register+0x2ce>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 808e5ac:	69e3      	ldr	r3, [r4, #28]
		*d++ = (BYTE)val;
 808e5ae:	2100      	movs	r1, #0
 808e5b0:	f103 0220 	add.w	r2, r3, #32
 808e5b4:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
 808e5b8:	4293      	cmp	r3, r2
 808e5ba:	d1fb      	bne.n	808e5b4 <dir_register+0x27c>
 808e5bc:	4629      	mov	r1, r5
 808e5be:	220b      	movs	r2, #11
 808e5c0:	69e0      	ldr	r0, [r4, #28]
 808e5c2:	f7fe fe5b 	bl	808d27c <mem_cpy.part.0>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 808e5c6:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 808e5ca:	69e1      	ldr	r1, [r4, #28]
			fs->wflag = 1;
 808e5cc:	2201      	movs	r2, #1
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 808e5ce:	f003 0318 	and.w	r3, r3, #24
			fs->wflag = 1;
 808e5d2:	2000      	movs	r0, #0
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 808e5d4:	730b      	strb	r3, [r1, #12]
			fs->wflag = 1;
 808e5d6:	f88b 2003 	strb.w	r2, [fp, #3]
}
 808e5da:	b00b      	add	sp, #44	; 0x2c
 808e5dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 808e5e0:	4643      	mov	r3, r8
 808e5e2:	e6da      	b.n	808e39a <dir_register+0x62>
	for (j = 0; j < i && dst[j] != ' '; j++) {
 808e5e4:	4613      	mov	r3, r2
 808e5e6:	e6fd      	b.n	808e3e4 <dir_register+0xac>
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 808e5e8:	2006      	movs	r0, #6
}
 808e5ea:	b00b      	add	sp, #44	; 0x2c
 808e5ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	res = dir_alloc(dp, nent);		/* Allocate entries */
 808e5f0:	2101      	movs	r1, #1
 808e5f2:	4620      	mov	r0, r4
 808e5f4:	f7ff fb8a 	bl	808dd0c <dir_alloc>
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 808e5f8:	2800      	cmp	r0, #0
 808e5fa:	d1ee      	bne.n	808e5da <dir_register+0x2a2>
		res = move_window(fs, dp->sect);
 808e5fc:	69a1      	ldr	r1, [r4, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 808e5fe:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 808e602:	4299      	cmp	r1, r3
 808e604:	d0d2      	beq.n	808e5ac <dir_register+0x274>
 808e606:	4658      	mov	r0, fp
 808e608:	f7fe fefc 	bl	808d404 <move_window.part.6>
		if (res == FR_OK) {
 808e60c:	2800      	cmp	r0, #0
 808e60e:	d0cd      	beq.n	808e5ac <dir_register+0x274>
 808e610:	e7e3      	b.n	808e5da <dir_register+0x2a2>
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 808e612:	4632      	mov	r2, r6
 808e614:	e793      	b.n	808e53e <dir_register+0x206>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 808e616:	4617      	mov	r7, r2
 808e618:	e6a4      	b.n	808e364 <dir_register+0x2c>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 808e61a:	2007      	movs	r0, #7
 808e61c:	e7dd      	b.n	808e5da <dir_register+0x2a2>
 808e61e:	bf00      	nop

0808e620 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 808e620:	b510      	push	{r4, lr}
 808e622:	b084      	sub	sp, #16
 808e624:	4614      	mov	r4, r2
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 808e626:	ab04      	add	r3, sp, #16
{
 808e628:	e9cd 1000 	strd	r1, r0, [sp]
	const TCHAR *rp = path;
 808e62c:	f843 1d04 	str.w	r1, [r3, #-4]!


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 808e630:	4618      	mov	r0, r3
 808e632:	f7fe fdc7 	bl	808d1c4 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 808e636:	2800      	cmp	r0, #0
 808e638:	db19      	blt.n	808e66e <f_mount+0x4e>
	cfs = FatFs[vol];					/* Pointer to fs object */
 808e63a:	f64b 43c0 	movw	r3, #48320	; 0xbcc0
 808e63e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808e642:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]

	if (cfs) {
 808e646:	b10a      	cbz	r2, 808e64c <f_mount+0x2c>
		clear_lock(cfs);
#endif
#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 808e648:	2100      	movs	r1, #0
 808e64a:	7011      	strb	r1, [r2, #0]
	}

	if (fs) {
 808e64c:	9a01      	ldr	r2, [sp, #4]
 808e64e:	b10a      	cbz	r2, 808e654 <f_mount+0x34>
		fs->fs_type = 0;				/* Clear new fs object */
 808e650:	2100      	movs	r1, #0
 808e652:	7011      	strb	r1, [r2, #0]
#if FF_FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 808e654:	f843 2020 	str.w	r2, [r3, r0, lsl #2]

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 808e658:	b914      	cbnz	r4, 808e660 <f_mount+0x40>
 808e65a:	4620      	mov	r0, r4

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 808e65c:	b004      	add	sp, #16
 808e65e:	bd10      	pop	{r4, pc}
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 808e660:	2200      	movs	r2, #0
 808e662:	a901      	add	r1, sp, #4
 808e664:	4668      	mov	r0, sp
 808e666:	f7fe ff31 	bl	808d4cc <find_volume>
}
 808e66a:	b004      	add	sp, #16
 808e66c:	bd10      	pop	{r4, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 808e66e:	200b      	movs	r0, #11
}
 808e670:	b004      	add	sp, #16
 808e672:	bd10      	pop	{r4, pc}

0808e674 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 808e674:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 808e678:	b090      	sub	sp, #64	; 0x40
 808e67a:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 808e67c:	b348      	cbz	r0, 808e6d2 <f_open+0x5e>

	/* Get logical drive number */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
 808e67e:	f002 073f 	and.w	r7, r2, #63	; 0x3f
 808e682:	4604      	mov	r4, r0
 808e684:	4615      	mov	r5, r2
	res = find_volume(&path, &fs, mode);
 808e686:	a903      	add	r1, sp, #12
 808e688:	a801      	add	r0, sp, #4
 808e68a:	463a      	mov	r2, r7
 808e68c:	f7fe ff1e 	bl	808d4cc <find_volume>
	if (res == FR_OK) {
 808e690:	4606      	mov	r6, r0
 808e692:	b128      	cbz	r0, 808e6a0 <f_open+0x2c>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 808e694:	2300      	movs	r3, #0
 808e696:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 808e698:	4630      	mov	r0, r6
 808e69a:	b010      	add	sp, #64	; 0x40
 808e69c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		dj.obj.fs = fs;
 808e6a0:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 808e6a2:	a804      	add	r0, sp, #16
 808e6a4:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 808e6a6:	9304      	str	r3, [sp, #16]
		res = follow_path(&dj, path);	/* Follow the file path */
 808e6a8:	f7ff fc4e 	bl	808df48 <follow_path>
 808e6ac:	f005 031c 	and.w	r3, r5, #28
		if (res == FR_OK) {
 808e6b0:	b9a0      	cbnz	r0, 808e6dc <f_open+0x68>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 808e6b2:	f99d 203b 	ldrsb.w	r2, [sp, #59]	; 0x3b
 808e6b6:	2a00      	cmp	r2, #0
 808e6b8:	f2c0 80d8 	blt.w	808e86c <f_open+0x1f8>
 808e6bc:	f89d 2016 	ldrb.w	r2, [sp, #22]
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 808e6c0:	b18b      	cbz	r3, 808e6e6 <f_open+0x72>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 808e6c2:	f012 0f11 	tst.w	r2, #17
 808e6c6:	d116      	bne.n	808e6f6 <f_open+0x82>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 808e6c8:	076b      	lsls	r3, r5, #29
 808e6ca:	f140 80d1 	bpl.w	808e870 <f_open+0x1fc>
 808e6ce:	2608      	movs	r6, #8
 808e6d0:	e7e0      	b.n	808e694 <f_open+0x20>
	if (!fp) return FR_INVALID_OBJECT;
 808e6d2:	2609      	movs	r6, #9
}
 808e6d4:	4630      	mov	r0, r6
 808e6d6:	b010      	add	sp, #64	; 0x40
 808e6d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 808e6dc:	b10b      	cbz	r3, 808e6e2 <f_open+0x6e>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 808e6de:	2804      	cmp	r0, #4
 808e6e0:	d00d      	beq.n	808e6fe <f_open+0x8a>
 808e6e2:	4606      	mov	r6, r0
 808e6e4:	e7d6      	b.n	808e694 <f_open+0x20>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 808e6e6:	06d3      	lsls	r3, r2, #27
 808e6e8:	d407      	bmi.n	808e6fa <f_open+0x86>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 808e6ea:	07a9      	lsls	r1, r5, #30
 808e6ec:	f140 80b3 	bpl.w	808e856 <f_open+0x1e2>
 808e6f0:	07d3      	lsls	r3, r2, #31
 808e6f2:	f140 80b0 	bpl.w	808e856 <f_open+0x1e2>
						res = FR_DENIED;
 808e6f6:	2607      	movs	r6, #7
 808e6f8:	e7cc      	b.n	808e694 <f_open+0x20>
					res = FR_NO_FILE;
 808e6fa:	2604      	movs	r6, #4
 808e6fc:	e7ca      	b.n	808e694 <f_open+0x20>
					res = dir_register(&dj);
 808e6fe:	a804      	add	r0, sp, #16
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 808e700:	f047 0708 	orr.w	r7, r7, #8
					res = dir_register(&dj);
 808e704:	f7ff fe18 	bl	808e338 <dir_register>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 808e708:	2800      	cmp	r0, #0
 808e70a:	d1ea      	bne.n	808e6e2 <f_open+0x6e>
 808e70c:	f8dd c00c 	ldr.w	ip, [sp, #12]
 808e710:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	if (fs->fs_type == FS_FAT32) {
 808e712:	f89c 2000 	ldrb.w	r2, [ip]
	rv = rv << 8 | ptr[0];
 808e716:	7ed9      	ldrb	r1, [r3, #27]
 808e718:	7e9d      	ldrb	r5, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 808e71a:	2a03      	cmp	r2, #3
	cl = ld_word(dir + DIR_FstClusLO);
 808e71c:	ea45 2501 	orr.w	r5, r5, r1, lsl #8
	if (fs->fs_type == FS_FAT32) {
 808e720:	f000 80b2 	beq.w	808e888 <f_open+0x214>
 808e724:	9300      	str	r3, [sp, #0]
					st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
 808e726:	f7fe fc89 	bl	808d03c <get_fattime>
	*ptr++ = (BYTE)val; val >>= 8;
 808e72a:	9b00      	ldr	r3, [sp, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 808e72c:	ea4f 4c10 	mov.w	ip, r0, lsr #16
	*ptr++ = (BYTE)val; val >>= 8;
 808e730:	ea4f 2e10 	mov.w	lr, r0, lsr #8
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 808e734:	2120      	movs	r1, #32
	*ptr++ = (BYTE)val; val >>= 8;
 808e736:	7398      	strb	r0, [r3, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 808e738:	0e00      	lsrs	r0, r0, #24
 808e73a:	f883 c010 	strb.w	ip, [r3, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 808e73e:	2200      	movs	r2, #0
	*ptr++ = (BYTE)val; val >>= 8;
 808e740:	f883 e00f 	strb.w	lr, [r3, #15]
	*ptr++ = (BYTE)val;
 808e744:	7458      	strb	r0, [r3, #17]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 808e746:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 808e748:	f8dd c00c 	ldr.w	ip, [sp, #12]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 808e74c:	72d9      	strb	r1, [r3, #11]
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 808e74e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 808e750:	769a      	strb	r2, [r3, #26]
	*ptr++ = (BYTE)val;
 808e752:	76da      	strb	r2, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 808e754:	f89c 1000 	ldrb.w	r1, [ip]
 808e758:	2903      	cmp	r1, #3
 808e75a:	f000 8092 	beq.w	808e882 <f_open+0x20e>
					st_dword(dj.dir + DIR_FileSize, 0);
 808e75e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 808e760:	2200      	movs	r2, #0
					fs->wflag = 1;
 808e762:	2101      	movs	r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
 808e764:	771a      	strb	r2, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 808e766:	775a      	strb	r2, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 808e768:	779a      	strb	r2, [r3, #30]
	*ptr++ = (BYTE)val;
 808e76a:	77da      	strb	r2, [r3, #31]
					fs->wflag = 1;
 808e76c:	f88c 1003 	strb.w	r1, [ip, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
 808e770:	b1cd      	cbz	r5, 808e7a6 <f_open+0x132>
						res = remove_chain(&dj.obj, cl, 0);
 808e772:	a804      	add	r0, sp, #16
 808e774:	4629      	mov	r1, r5
						dw = fs->winsect;
 808e776:	f8dc 8034 	ldr.w	r8, [ip, #52]	; 0x34
						res = remove_chain(&dj.obj, cl, 0);
 808e77a:	f7ff fa23 	bl	808dbc4 <remove_chain>
						if (res == FR_OK) {
 808e77e:	2800      	cmp	r0, #0
 808e780:	d1af      	bne.n	808e6e2 <f_open+0x6e>
							res = move_window(fs, dw);
 808e782:	f8dd c00c 	ldr.w	ip, [sp, #12]
 808e786:	3d01      	subs	r5, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 808e788:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
 808e78c:	4598      	cmp	r8, r3
 808e78e:	f000 80a1 	beq.w	808e8d4 <f_open+0x260>
 808e792:	4660      	mov	r0, ip
 808e794:	4641      	mov	r1, r8
 808e796:	f7fe fe35 	bl	808d404 <move_window.part.6>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 808e79a:	f8dd c00c 	ldr.w	ip, [sp, #12]
 808e79e:	f8cc 5010 	str.w	r5, [ip, #16]
		if (res == FR_OK) {
 808e7a2:	2800      	cmp	r0, #0
 808e7a4:	d19d      	bne.n	808e6e2 <f_open+0x6e>
 808e7a6:	f8dc 8034 	ldr.w	r8, [ip, #52]	; 0x34
 808e7aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 808e7ac:	f047 0740 	orr.w	r7, r7, #64	; 0x40
			fp->dir_ptr = dj.dir;
 808e7b0:	e9c4 8308 	strd	r8, r3, [r4, #32]
	if (fs->fs_type == FS_FAT32) {
 808e7b4:	f89c 1000 	ldrb.w	r1, [ip]
	rv = rv << 8 | ptr[0];
 808e7b8:	7ed8      	ldrb	r0, [r3, #27]
 808e7ba:	7e9a      	ldrb	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 808e7bc:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 808e7be:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 808e7c2:	d105      	bne.n	808e7d0 <f_open+0x15c>
	rv = rv << 8 | ptr[0];
 808e7c4:	7d58      	ldrb	r0, [r3, #21]
 808e7c6:	7d19      	ldrb	r1, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 808e7c8:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 808e7cc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 808e7d0:	60a2      	str	r2, [r4, #8]
			fp->err = 0;			/* Clear error flag */
 808e7d2:	2000      	movs	r0, #0
	rv = rv << 8 | ptr[2];
 808e7d4:	f8b3 e01e 	ldrh.w	lr, [r3, #30]
			mem_set(fp->buf, 0, FF_MAX_SS);	/* Clear sector buffer */
 808e7d8:	f104 0528 	add.w	r5, r4, #40	; 0x28
	rv = rv << 8 | ptr[1];
 808e7dc:	7f59      	ldrb	r1, [r3, #29]
	rv = rv << 8 | ptr[0];
 808e7de:	7f1a      	ldrb	r2, [r3, #28]
	rv = rv << 8 | ptr[1];
 808e7e0:	ea41 230e 	orr.w	r3, r1, lr, lsl #8
			fp->obj.id = fs->id;
 808e7e4:	f8bc e006 	ldrh.w	lr, [ip, #6]
		*d++ = (BYTE)val;
 808e7e8:	4601      	mov	r1, r0
			fp->obj.fs = fs;	 	/* Validate the file object */
 808e7ea:	f8c4 c000 	str.w	ip, [r4]
	rv = rv << 8 | ptr[0];
 808e7ee:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	BYTE *d = (BYTE*)dst;
 808e7f2:	462b      	mov	r3, r5
			fp->err = 0;			/* Clear error flag */
 808e7f4:	7460      	strb	r0, [r4, #17]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 808e7f6:	60e2      	str	r2, [r4, #12]
 808e7f8:	f504 720a 	add.w	r2, r4, #552	; 0x228
			fp->obj.id = fs->id;
 808e7fc:	f8a4 e004 	strh.w	lr, [r4, #4]
			fp->sect = 0;			/* Invalidate current data sector */
 808e800:	61e0      	str	r0, [r4, #28]
			fp->fptr = 0;			/* Set file pointer top of the file */
 808e802:	6160      	str	r0, [r4, #20]
			fp->flag = mode;		/* Set file access mode */
 808e804:	7427      	strb	r7, [r4, #16]
		*d++ = (BYTE)val;
 808e806:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
 808e80a:	4293      	cmp	r3, r2
 808e80c:	d1fb      	bne.n	808e806 <f_open+0x192>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 808e80e:	06b9      	lsls	r1, r7, #26
 808e810:	f57f af42 	bpl.w	808e698 <f_open+0x24>
 808e814:	68e7      	ldr	r7, [r4, #12]
 808e816:	2f00      	cmp	r7, #0
 808e818:	f43f af3e 	beq.w	808e698 <f_open+0x24>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 808e81c:	f8bc 800a 	ldrh.w	r8, [ip, #10]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 808e820:	68a1      	ldr	r1, [r4, #8]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 808e822:	ea4f 2848 	mov.w	r8, r8, lsl #9
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 808e826:	6167      	str	r7, [r4, #20]
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 808e828:	4547      	cmp	r7, r8
 808e82a:	d934      	bls.n	808e896 <f_open+0x222>
					clst = get_fat(&fp->obj, clst);
 808e82c:	6820      	ldr	r0, [r4, #0]
 808e82e:	eba7 0708 	sub.w	r7, r7, r8
 808e832:	f7ff f87d 	bl	808d930 <get_fat.isra.9>
					if (clst <= 1) res = FR_INT_ERR;
 808e836:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 808e838:	4601      	mov	r1, r0
					if (clst <= 1) res = FR_INT_ERR;
 808e83a:	d914      	bls.n	808e866 <f_open+0x1f2>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 808e83c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 808e840:	bf18      	it	ne
 808e842:	4547      	cmpne	r7, r8
 808e844:	d8f2      	bhi.n	808e82c <f_open+0x1b8>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 808e846:	1c42      	adds	r2, r0, #1
				fp->clust = clst;
 808e848:	61a0      	str	r0, [r4, #24]
					if (clst <= 1) res = FR_INT_ERR;
 808e84a:	bf0c      	ite	eq
 808e84c:	2301      	moveq	r3, #1
 808e84e:	2300      	movne	r3, #0
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 808e850:	d122      	bne.n	808e898 <f_open+0x224>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 808e852:	461e      	mov	r6, r3
 808e854:	e71e      	b.n	808e694 <f_open+0x20>
 808e856:	f8dd c00c 	ldr.w	ip, [sp, #12]
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 808e85a:	0728      	lsls	r0, r5, #28
 808e85c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 808e85e:	f8dc 8034 	ldr.w	r8, [ip, #52]	; 0x34
 808e862:	d5a5      	bpl.n	808e7b0 <f_open+0x13c>
 808e864:	e7a2      	b.n	808e7ac <f_open+0x138>
				fp->clust = clst;
 808e866:	61a0      	str	r0, [r4, #24]
					if (clst <= 1) res = FR_INT_ERR;
 808e868:	2602      	movs	r6, #2
 808e86a:	e713      	b.n	808e694 <f_open+0x20>
				res = FR_INVALID_NAME;
 808e86c:	2606      	movs	r6, #6
 808e86e:	e711      	b.n	808e694 <f_open+0x20>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 808e870:	0728      	lsls	r0, r5, #28
 808e872:	f8dd c00c 	ldr.w	ip, [sp, #12]
 808e876:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 808e878:	f53f af4b 	bmi.w	808e712 <f_open+0x9e>
 808e87c:	f8dc 8034 	ldr.w	r8, [ip, #52]	; 0x34
 808e880:	e796      	b.n	808e7b0 <f_open+0x13c>
	*ptr++ = (BYTE)val; val >>= 8;
 808e882:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 808e884:	755a      	strb	r2, [r3, #21]
 808e886:	e76a      	b.n	808e75e <f_open+0xea>
	rv = rv << 8 | ptr[0];
 808e888:	7d59      	ldrb	r1, [r3, #21]
 808e88a:	7d1a      	ldrb	r2, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 808e88c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 808e890:	ea45 4502 	orr.w	r5, r5, r2, lsl #16
 808e894:	e746      	b.n	808e724 <f_open+0xb0>
				fp->clust = clst;
 808e896:	61a1      	str	r1, [r4, #24]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 808e898:	f3c7 0308 	ubfx	r3, r7, #0, #9
 808e89c:	2b00      	cmp	r3, #0
 808e89e:	f43f aefb 	beq.w	808e698 <f_open+0x24>
					if ((sc = clst2sect(fs, clst)) == 0) {
 808e8a2:	9803      	ldr	r0, [sp, #12]
	clst -= 2;		/* Cluster number is origin from 2 */
 808e8a4:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808e8a6:	69c3      	ldr	r3, [r0, #28]
 808e8a8:	3b02      	subs	r3, #2
 808e8aa:	4299      	cmp	r1, r3
 808e8ac:	d2dc      	bcs.n	808e868 <f_open+0x1f4>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 808e8ae:	8942      	ldrh	r2, [r0, #10]
 808e8b0:	6b03      	ldr	r3, [r0, #48]	; 0x30
 808e8b2:	fb01 3202 	mla	r2, r1, r2, r3
					if ((sc = clst2sect(fs, clst)) == 0) {
 808e8b6:	2a00      	cmp	r2, #0
 808e8b8:	d0d6      	beq.n	808e868 <f_open+0x1f4>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 808e8ba:	eb02 2257 	add.w	r2, r2, r7, lsr #9
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 808e8be:	4629      	mov	r1, r5
 808e8c0:	2301      	movs	r3, #1
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 808e8c2:	61e2      	str	r2, [r4, #28]
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 808e8c4:	7840      	ldrb	r0, [r0, #1]
 808e8c6:	f7fe fbeb 	bl	808d0a0 <disk_read>
 808e8ca:	2800      	cmp	r0, #0
 808e8cc:	f43f aee4 	beq.w	808e698 <f_open+0x24>
 808e8d0:	2601      	movs	r6, #1
 808e8d2:	e6df      	b.n	808e694 <f_open+0x20>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 808e8d4:	f8cc 5010 	str.w	r5, [ip, #16]
 808e8d8:	e767      	b.n	808e7aa <f_open+0x136>
 808e8da:	bf00      	nop

0808e8dc <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 808e8dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 808e8e0:	4698      	mov	r8, r3
 808e8e2:	b085      	sub	sp, #20
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 808e8e4:	2300      	movs	r3, #0
{
 808e8e6:	4689      	mov	r9, r1
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 808e8e8:	a903      	add	r1, sp, #12
{
 808e8ea:	4614      	mov	r4, r2
	*br = 0;	/* Clear read byte counter */
 808e8ec:	f8c8 3000 	str.w	r3, [r8]
{
 808e8f0:	4605      	mov	r5, r0
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 808e8f2:	f7fe fc8f 	bl	808d214 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 808e8f6:	4607      	mov	r7, r0
 808e8f8:	2800      	cmp	r0, #0
 808e8fa:	d138      	bne.n	808e96e <f_read+0x92>
 808e8fc:	7c6f      	ldrb	r7, [r5, #17]
 808e8fe:	2f00      	cmp	r7, #0
 808e900:	d135      	bne.n	808e96e <f_read+0x92>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 808e902:	7c2b      	ldrb	r3, [r5, #16]
 808e904:	07da      	lsls	r2, r3, #31
 808e906:	d569      	bpl.n	808e9dc <f_read+0x100>
	remain = fp->obj.objsize - fp->fptr;
 808e908:	696b      	ldr	r3, [r5, #20]
 808e90a:	68ee      	ldr	r6, [r5, #12]
 808e90c:	1af6      	subs	r6, r6, r3
 808e90e:	42a6      	cmp	r6, r4
 808e910:	bf28      	it	cs
 808e912:	4626      	movcs	r6, r4
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until btr bytes read */
 808e914:	b35e      	cbz	r6, 808e96e <f_read+0x92>
 808e916:	f105 0a28 	add.w	sl, r5, #40	; 0x28
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 808e91a:	f3c3 0108 	ubfx	r1, r3, #0, #9
 808e91e:	2900      	cmp	r1, #0
 808e920:	d13d      	bne.n	808e99e <f_read+0xc2>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 808e922:	9903      	ldr	r1, [sp, #12]
 808e924:	894a      	ldrh	r2, [r1, #10]
 808e926:	3a01      	subs	r2, #1
			if (csect == 0) {					/* On the cluster boundary? */
 808e928:	ea12 2253 	ands.w	r2, r2, r3, lsr #9
 808e92c:	d04d      	beq.n	808e9ca <f_read+0xee>
 808e92e:	69a8      	ldr	r0, [r5, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808e930:	69cb      	ldr	r3, [r1, #28]
	clst -= 2;		/* Cluster number is origin from 2 */
 808e932:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808e934:	3b02      	subs	r3, #2
 808e936:	4298      	cmp	r0, r3
 808e938:	d279      	bcs.n	808ea2e <f_read+0x152>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 808e93a:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 808e93e:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 808e940:	fb0c 3000 	mla	r0, ip, r0, r3
				if (clst < 2) ABORT(fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 808e944:	2800      	cmp	r0, #0
 808e946:	d072      	beq.n	808ea2e <f_read+0x152>
			sect += csect;
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 808e948:	0a74      	lsrs	r4, r6, #9
			sect += csect;
 808e94a:	eb02 0b00 	add.w	fp, r2, r0
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 808e94e:	d012      	beq.n	808e976 <f_read+0x9a>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 808e950:	1913      	adds	r3, r2, r4
					cc = fs->csize - csect;
				}
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 808e952:	7848      	ldrb	r0, [r1, #1]
 808e954:	4649      	mov	r1, r9
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 808e956:	4563      	cmp	r3, ip
					cc = fs->csize - csect;
 808e958:	bf88      	it	hi
 808e95a:	ebac 0402 	subhi.w	r4, ip, r2
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 808e95e:	465a      	mov	r2, fp
 808e960:	4623      	mov	r3, r4
 808e962:	f7fe fb9d 	bl	808d0a0 <disk_read>
 808e966:	2800      	cmp	r0, #0
 808e968:	d03a      	beq.n	808e9e0 <f_read+0x104>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 808e96a:	2701      	movs	r7, #1
 808e96c:	746f      	strb	r7, [r5, #17]
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 808e96e:	4638      	mov	r0, r7
 808e970:	b005      	add	sp, #20
 808e972:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 808e976:	69ea      	ldr	r2, [r5, #28]
 808e978:	455a      	cmp	r2, fp
 808e97a:	d00b      	beq.n	808e994 <f_read+0xb8>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 808e97c:	f995 3010 	ldrsb.w	r3, [r5, #16]
 808e980:	7848      	ldrb	r0, [r1, #1]
 808e982:	2b00      	cmp	r3, #0
 808e984:	db39      	blt.n	808e9fa <f_read+0x11e>
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 808e986:	2301      	movs	r3, #1
 808e988:	465a      	mov	r2, fp
 808e98a:	4651      	mov	r1, sl
 808e98c:	f7fe fb88 	bl	808d0a0 <disk_read>
 808e990:	2800      	cmp	r0, #0
 808e992:	d1ea      	bne.n	808e96a <f_read+0x8e>
 808e994:	6969      	ldr	r1, [r5, #20]
			fp->sect = sect;
 808e996:	f8c5 b01c 	str.w	fp, [r5, #28]
 808e99a:	f3c1 0108 	ubfx	r1, r1, #0, #9
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 808e99e:	f5c1 7400 	rsb	r4, r1, #512	; 0x200
 808e9a2:	4648      	mov	r0, r9
 808e9a4:	4451      	add	r1, sl
 808e9a6:	42b4      	cmp	r4, r6
 808e9a8:	bf28      	it	cs
 808e9aa:	4634      	movcs	r4, r6
 808e9ac:	4622      	mov	r2, r4
 808e9ae:	f7fe fc65 	bl	808d27c <mem_cpy.part.0>
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 808e9b2:	f8d8 2000 	ldr.w	r2, [r8]
	for ( ;  btr;								/* Repeat until btr bytes read */
 808e9b6:	1b36      	subs	r6, r6, r4
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 808e9b8:	696b      	ldr	r3, [r5, #20]
 808e9ba:	44a1      	add	r9, r4
 808e9bc:	4422      	add	r2, r4
 808e9be:	4423      	add	r3, r4
 808e9c0:	f8c8 2000 	str.w	r2, [r8]
 808e9c4:	616b      	str	r3, [r5, #20]
	for ( ;  btr;								/* Repeat until btr bytes read */
 808e9c6:	d1a8      	bne.n	808e91a <f_read+0x3e>
 808e9c8:	e7d1      	b.n	808e96e <f_read+0x92>
				if (fp->fptr == 0) {			/* On the top of the file? */
 808e9ca:	b97b      	cbnz	r3, 808e9ec <f_read+0x110>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 808e9cc:	68a8      	ldr	r0, [r5, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 808e9ce:	2801      	cmp	r0, #1
 808e9d0:	d92d      	bls.n	808ea2e <f_read+0x152>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 808e9d2:	1c43      	adds	r3, r0, #1
 808e9d4:	d0c9      	beq.n	808e96a <f_read+0x8e>
 808e9d6:	9903      	ldr	r1, [sp, #12]
				fp->clust = clst;				/* Update current cluster */
 808e9d8:	61a8      	str	r0, [r5, #24]
 808e9da:	e7a9      	b.n	808e930 <f_read+0x54>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 808e9dc:	2707      	movs	r7, #7
 808e9de:	e7c6      	b.n	808e96e <f_read+0x92>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 808e9e0:	f995 3010 	ldrsb.w	r3, [r5, #16]
 808e9e4:	2b00      	cmp	r3, #0
 808e9e6:	db15      	blt.n	808ea14 <f_read+0x138>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 808e9e8:	0264      	lsls	r4, r4, #9
				continue;
 808e9ea:	e7e2      	b.n	808e9b2 <f_read+0xd6>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 808e9ec:	69a9      	ldr	r1, [r5, #24]
 808e9ee:	6828      	ldr	r0, [r5, #0]
 808e9f0:	9201      	str	r2, [sp, #4]
 808e9f2:	f7fe ff9d 	bl	808d930 <get_fat.isra.9>
 808e9f6:	9a01      	ldr	r2, [sp, #4]
 808e9f8:	e7e9      	b.n	808e9ce <f_read+0xf2>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 808e9fa:	2301      	movs	r3, #1
 808e9fc:	4651      	mov	r1, sl
 808e9fe:	f7fe fb6b 	bl	808d0d8 <disk_write>
 808ea02:	2800      	cmp	r0, #0
 808ea04:	d1b1      	bne.n	808e96a <f_read+0x8e>
					fp->flag &= (BYTE)~FA_DIRTY;
 808ea06:	7c2b      	ldrb	r3, [r5, #16]
 808ea08:	9a03      	ldr	r2, [sp, #12]
 808ea0a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 808ea0e:	742b      	strb	r3, [r5, #16]
 808ea10:	7850      	ldrb	r0, [r2, #1]
 808ea12:	e7b8      	b.n	808e986 <f_read+0xaa>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 808ea14:	69e8      	ldr	r0, [r5, #28]
 808ea16:	eba0 000b 	sub.w	r0, r0, fp
 808ea1a:	42a0      	cmp	r0, r4
 808ea1c:	d2e4      	bcs.n	808e9e8 <f_read+0x10c>
 808ea1e:	eb09 2040 	add.w	r0, r9, r0, lsl #9
 808ea22:	f44f 7200 	mov.w	r2, #512	; 0x200
 808ea26:	4651      	mov	r1, sl
 808ea28:	f7fe fc28 	bl	808d27c <mem_cpy.part.0>
 808ea2c:	e7dc      	b.n	808e9e8 <f_read+0x10c>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 808ea2e:	2702      	movs	r7, #2
 808ea30:	746f      	strb	r7, [r5, #17]
 808ea32:	e79c      	b.n	808e96e <f_read+0x92>

0808ea34 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 808ea34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 808ea38:	469a      	mov	sl, r3
 808ea3a:	b085      	sub	sp, #20
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 808ea3c:	2300      	movs	r3, #0
{
 808ea3e:	468b      	mov	fp, r1
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 808ea40:	a903      	add	r1, sp, #12
{
 808ea42:	4616      	mov	r6, r2
	*bw = 0;	/* Clear write byte counter */
 808ea44:	f8ca 3000 	str.w	r3, [sl]
{
 808ea48:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 808ea4a:	f7fe fbe3 	bl	808d214 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 808ea4e:	4680      	mov	r8, r0
 808ea50:	2800      	cmp	r0, #0
 808ea52:	d154      	bne.n	808eafe <f_write+0xca>
 808ea54:	f894 8011 	ldrb.w	r8, [r4, #17]
 808ea58:	f1b8 0f00 	cmp.w	r8, #0
 808ea5c:	d14f      	bne.n	808eafe <f_write+0xca>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 808ea5e:	7c22      	ldrb	r2, [r4, #16]
 808ea60:	0791      	lsls	r1, r2, #30
 808ea62:	f140 808c 	bpl.w	808eb7e <f_write+0x14a>

	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 808ea66:	6963      	ldr	r3, [r4, #20]
 808ea68:	42f3      	cmn	r3, r6
 808ea6a:	d300      	bcc.n	808ea6e <f_write+0x3a>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 808ea6c:	43de      	mvns	r6, r3
	}

	for ( ;  btw;							/* Repeat until all data written */
 808ea6e:	2e00      	cmp	r6, #0
 808ea70:	d073      	beq.n	808eb5a <f_write+0x126>
 808ea72:	f104 0228 	add.w	r2, r4, #40	; 0x28
 808ea76:	9201      	str	r2, [sp, #4]
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 808ea78:	f3c3 0008 	ubfx	r0, r3, #0, #9
 808ea7c:	2800      	cmp	r0, #0
 808ea7e:	d14c      	bne.n	808eb1a <f_write+0xe6>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 808ea80:	9a03      	ldr	r2, [sp, #12]
 808ea82:	f8b2 900a 	ldrh.w	r9, [r2, #10]
 808ea86:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
			if (csect == 0) {				/* On the cluster boundary? */
 808ea8a:	ea19 2953 	ands.w	r9, r9, r3, lsr #9
 808ea8e:	d10f      	bne.n	808eab0 <f_write+0x7c>
				if (fp->fptr == 0) {		/* On the top of the file? */
 808ea90:	2b00      	cmp	r3, #0
 808ea92:	d17d      	bne.n	808eb90 <f_write+0x15c>
					clst = fp->obj.sclust;	/* Follow from the origin */
 808ea94:	68a0      	ldr	r0, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 808ea96:	2800      	cmp	r0, #0
 808ea98:	f000 8082 	beq.w	808eba0 <f_write+0x16c>
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 808ea9c:	2801      	cmp	r0, #1
 808ea9e:	f000 809d 	beq.w	808ebdc <f_write+0x1a8>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 808eaa2:	1c43      	adds	r3, r0, #1
 808eaa4:	d027      	beq.n	808eaf6 <f_write+0xc2>
				fp->clust = clst;			/* Update current cluster */
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 808eaa6:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
 808eaa8:	61a0      	str	r0, [r4, #24]
 808eaaa:	9a03      	ldr	r2, [sp, #12]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 808eaac:	b903      	cbnz	r3, 808eab0 <f_write+0x7c>
 808eaae:	60a0      	str	r0, [r4, #8]
			}
#if FF_FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 808eab0:	f994 3010 	ldrsb.w	r3, [r4, #16]
 808eab4:	2b00      	cmp	r3, #0
 808eab6:	db54      	blt.n	808eb62 <f_write+0x12e>
	clst -= 2;		/* Cluster number is origin from 2 */
 808eab8:	69a7      	ldr	r7, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808eaba:	69d3      	ldr	r3, [r2, #28]
	clst -= 2;		/* Cluster number is origin from 2 */
 808eabc:	3f02      	subs	r7, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 808eabe:	3b02      	subs	r3, #2
 808eac0:	429f      	cmp	r7, r3
 808eac2:	f080 808b 	bcs.w	808ebdc <f_write+0x1a8>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 808eac6:	8953      	ldrh	r3, [r2, #10]
 808eac8:	6b11      	ldr	r1, [r2, #48]	; 0x30
 808eaca:	fb03 1707 	mla	r7, r3, r7, r1
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 808eace:	2f00      	cmp	r7, #0
 808ead0:	f000 8084 	beq.w	808ebdc <f_write+0x1a8>
			sect += csect;
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 808ead4:	0a75      	lsrs	r5, r6, #9
			sect += csect;
 808ead6:	444f      	add	r7, r9
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 808ead8:	d015      	beq.n	808eb06 <f_write+0xd2>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 808eada:	eb09 0105 	add.w	r1, r9, r5
					cc = fs->csize - csect;
				}
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 808eade:	7850      	ldrb	r0, [r2, #1]
 808eae0:	463a      	mov	r2, r7
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 808eae2:	4299      	cmp	r1, r3
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 808eae4:	4659      	mov	r1, fp
					cc = fs->csize - csect;
 808eae6:	bf88      	it	hi
 808eae8:	eba3 0509 	subhi.w	r5, r3, r9
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 808eaec:	462b      	mov	r3, r5
 808eaee:	f7fe faf3 	bl	808d0d8 <disk_write>
 808eaf2:	2800      	cmp	r0, #0
 808eaf4:	d046      	beq.n	808eb84 <f_write+0x150>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 808eaf6:	f04f 0801 	mov.w	r8, #1
 808eafa:	f884 8011 	strb.w	r8, [r4, #17]
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */

	LEAVE_FF(fs, FR_OK);
}
 808eafe:	4640      	mov	r0, r8
 808eb00:	b005      	add	sp, #20
 808eb02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 808eb06:	69e3      	ldr	r3, [r4, #28]
 808eb08:	6960      	ldr	r0, [r4, #20]
 808eb0a:	42bb      	cmp	r3, r7
 808eb0c:	d002      	beq.n	808eb14 <f_write+0xe0>
 808eb0e:	68e3      	ldr	r3, [r4, #12]
 808eb10:	4283      	cmp	r3, r0
 808eb12:	d84d      	bhi.n	808ebb0 <f_write+0x17c>
 808eb14:	f3c0 0008 	ubfx	r0, r0, #0, #9
			fp->sect = sect;
 808eb18:	61e7      	str	r7, [r4, #28]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 808eb1a:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
 808eb1e:	9b01      	ldr	r3, [sp, #4]
 808eb20:	4659      	mov	r1, fp
 808eb22:	42b5      	cmp	r5, r6
 808eb24:	4418      	add	r0, r3
 808eb26:	bf28      	it	cs
 808eb28:	4635      	movcs	r5, r6
 808eb2a:	462a      	mov	r2, r5
 808eb2c:	f7fe fba6 	bl	808d27c <mem_cpy.part.0>
		fp->flag |= FA_DIRTY;
 808eb30:	7c23      	ldrb	r3, [r4, #16]
 808eb32:	f063 037f 	orn	r3, r3, #127	; 0x7f
 808eb36:	7423      	strb	r3, [r4, #16]
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 808eb38:	6963      	ldr	r3, [r4, #20]
 808eb3a:	44ab      	add	fp, r5
 808eb3c:	68e2      	ldr	r2, [r4, #12]
 808eb3e:	442b      	add	r3, r5
 808eb40:	f8da 1000 	ldr.w	r1, [sl]
 808eb44:	429a      	cmp	r2, r3
 808eb46:	4429      	add	r1, r5
 808eb48:	bf38      	it	cc
 808eb4a:	461a      	movcc	r2, r3
	for ( ;  btw;							/* Repeat until all data written */
 808eb4c:	1b76      	subs	r6, r6, r5
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 808eb4e:	f8ca 1000 	str.w	r1, [sl]
 808eb52:	60e2      	str	r2, [r4, #12]
 808eb54:	6163      	str	r3, [r4, #20]
	for ( ;  btw;							/* Repeat until all data written */
 808eb56:	d18f      	bne.n	808ea78 <f_write+0x44>
 808eb58:	7c22      	ldrb	r2, [r4, #16]
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 808eb5a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 808eb5e:	7422      	strb	r2, [r4, #16]
	LEAVE_FF(fs, FR_OK);
 808eb60:	e7cd      	b.n	808eafe <f_write+0xca>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 808eb62:	7850      	ldrb	r0, [r2, #1]
 808eb64:	2301      	movs	r3, #1
 808eb66:	69e2      	ldr	r2, [r4, #28]
 808eb68:	9901      	ldr	r1, [sp, #4]
 808eb6a:	f7fe fab5 	bl	808d0d8 <disk_write>
 808eb6e:	2800      	cmp	r0, #0
 808eb70:	d1c1      	bne.n	808eaf6 <f_write+0xc2>
				fp->flag &= (BYTE)~FA_DIRTY;
 808eb72:	7c23      	ldrb	r3, [r4, #16]
 808eb74:	9a03      	ldr	r2, [sp, #12]
 808eb76:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 808eb7a:	7423      	strb	r3, [r4, #16]
 808eb7c:	e79c      	b.n	808eab8 <f_write+0x84>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 808eb7e:	f04f 0807 	mov.w	r8, #7
 808eb82:	e7bc      	b.n	808eafe <f_write+0xca>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 808eb84:	69e1      	ldr	r1, [r4, #28]
 808eb86:	1bc9      	subs	r1, r1, r7
 808eb88:	42a9      	cmp	r1, r5
 808eb8a:	d31b      	bcc.n	808ebc4 <f_write+0x190>
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 808eb8c:	026d      	lsls	r5, r5, #9
				continue;
 808eb8e:	e7d3      	b.n	808eb38 <f_write+0x104>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 808eb90:	69a1      	ldr	r1, [r4, #24]
 808eb92:	4620      	mov	r0, r4
 808eb94:	f7fe ff8e 	bl	808dab4 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 808eb98:	2800      	cmp	r0, #0
 808eb9a:	f47f af7f 	bne.w	808ea9c <f_write+0x68>
 808eb9e:	e7db      	b.n	808eb58 <f_write+0x124>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 808eba0:	4649      	mov	r1, r9
 808eba2:	4620      	mov	r0, r4
 808eba4:	f7fe ff86 	bl	808dab4 <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 808eba8:	2800      	cmp	r0, #0
 808ebaa:	f47f af77 	bne.w	808ea9c <f_write+0x68>
 808ebae:	e7d3      	b.n	808eb58 <f_write+0x124>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
 808ebb0:	7850      	ldrb	r0, [r2, #1]
 808ebb2:	2301      	movs	r3, #1
 808ebb4:	463a      	mov	r2, r7
 808ebb6:	9901      	ldr	r1, [sp, #4]
 808ebb8:	f7fe fa72 	bl	808d0a0 <disk_read>
				fp->fptr < fp->obj.objsize &&
 808ebbc:	2800      	cmp	r0, #0
 808ebbe:	d19a      	bne.n	808eaf6 <f_write+0xc2>
 808ebc0:	6960      	ldr	r0, [r4, #20]
 808ebc2:	e7a7      	b.n	808eb14 <f_write+0xe0>
 808ebc4:	eb0b 2141 	add.w	r1, fp, r1, lsl #9
 808ebc8:	f44f 7200 	mov.w	r2, #512	; 0x200
 808ebcc:	9801      	ldr	r0, [sp, #4]
 808ebce:	f7fe fb55 	bl	808d27c <mem_cpy.part.0>
					fp->flag &= (BYTE)~FA_DIRTY;
 808ebd2:	7c23      	ldrb	r3, [r4, #16]
 808ebd4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 808ebd8:	7423      	strb	r3, [r4, #16]
 808ebda:	e7d7      	b.n	808eb8c <f_write+0x158>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 808ebdc:	f04f 0802 	mov.w	r8, #2
 808ebe0:	f884 8011 	strb.w	r8, [r4, #17]
 808ebe4:	e78b      	b.n	808eafe <f_write+0xca>
 808ebe6:	bf00      	nop

0808ebe8 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 808ebe8:	b5f0      	push	{r4, r5, r6, r7, lr}
 808ebea:	b083      	sub	sp, #12
 808ebec:	4604      	mov	r4, r0
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 808ebee:	a901      	add	r1, sp, #4
 808ebf0:	f7fe fb10 	bl	808d214 <validate>
	if (res == FR_OK) {
 808ebf4:	2800      	cmp	r0, #0
 808ebf6:	d139      	bne.n	808ec6c <f_sync+0x84>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 808ebf8:	7c23      	ldrb	r3, [r4, #16]
 808ebfa:	065a      	lsls	r2, r3, #25
 808ebfc:	d536      	bpl.n	808ec6c <f_sync+0x84>
#if !FF_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 808ebfe:	061b      	lsls	r3, r3, #24
 808ec00:	d43d      	bmi.n	808ec7e <f_sync+0x96>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
				fp->flag &= (BYTE)~FA_DIRTY;
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 808ec02:	f7fe fa1b 	bl	808d03c <get_fattime>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 808ec06:	9e01      	ldr	r6, [sp, #4]
 808ec08:	6a21      	ldr	r1, [r4, #32]
			tm = GET_FATTIME();				/* Modified time */
 808ec0a:	4605      	mov	r5, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 808ec0c:	6b73      	ldr	r3, [r6, #52]	; 0x34
 808ec0e:	4299      	cmp	r1, r3
 808ec10:	d12e      	bne.n	808ec70 <f_sync+0x88>
				if (res == FR_OK) {
					dir = fp->dir_ptr;
 808ec12:	6a63      	ldr	r3, [r4, #36]	; 0x24
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 808ec14:	7ada      	ldrb	r2, [r3, #11]
 808ec16:	f042 0220 	orr.w	r2, r2, #32
 808ec1a:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 808ec1c:	68a2      	ldr	r2, [r4, #8]
 808ec1e:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 808ec20:	f3c2 2007 	ubfx	r0, r2, #8, #8
 808ec24:	769a      	strb	r2, [r3, #26]
	*ptr++ = (BYTE)val;
 808ec26:	76d8      	strb	r0, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 808ec28:	7809      	ldrb	r1, [r1, #0]
 808ec2a:	2903      	cmp	r1, #3
 808ec2c:	d103      	bne.n	808ec36 <f_sync+0x4e>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 808ec2e:	0c12      	lsrs	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 808ec30:	0a11      	lsrs	r1, r2, #8
 808ec32:	751a      	strb	r2, [r3, #20]
	*ptr++ = (BYTE)val;
 808ec34:	7559      	strb	r1, [r3, #21]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 808ec36:	68e2      	ldr	r2, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 808ec38:	0a2f      	lsrs	r7, r5, #8
	*ptr++ = (BYTE)val; val >>= 8;
 808ec3a:	0c29      	lsrs	r1, r5, #16
	*ptr++ = (BYTE)val; val >>= 8;
 808ec3c:	759d      	strb	r5, [r3, #22]
 808ec3e:	0a10      	lsrs	r0, r2, #8
 808ec40:	771a      	strb	r2, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 808ec42:	75df      	strb	r7, [r3, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 808ec44:	0e2d      	lsrs	r5, r5, #24
	*ptr++ = (BYTE)val; val >>= 8;
 808ec46:	7758      	strb	r0, [r3, #29]
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
					st_word(dir + DIR_LstAccDate, 0);
					fs->wflag = 1;
 808ec48:	2701      	movs	r7, #1
	*ptr++ = (BYTE)val; val >>= 8;
 808ec4a:	7619      	strb	r1, [r3, #24]
	*ptr++ = (BYTE)val; val >>= 8;
 808ec4c:	0c10      	lsrs	r0, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 808ec4e:	2100      	movs	r1, #0
	*ptr++ = (BYTE)val; val >>= 8;
 808ec50:	0e12      	lsrs	r2, r2, #24
 808ec52:	7798      	strb	r0, [r3, #30]
					res = sync_fs(fs);					/* Restore it to the directory */
 808ec54:	4630      	mov	r0, r6
	*ptr++ = (BYTE)val;
 808ec56:	77da      	strb	r2, [r3, #31]
 808ec58:	765d      	strb	r5, [r3, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 808ec5a:	7499      	strb	r1, [r3, #18]
	*ptr++ = (BYTE)val;
 808ec5c:	74d9      	strb	r1, [r3, #19]
					fs->wflag = 1;
 808ec5e:	70f7      	strb	r7, [r6, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 808ec60:	f7fe fb70 	bl	808d344 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 808ec64:	7c23      	ldrb	r3, [r4, #16]
 808ec66:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 808ec6a:	7423      	strb	r3, [r4, #16]
			}
		}
	}

	LEAVE_FF(fs, res);
}
 808ec6c:	b003      	add	sp, #12
 808ec6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808ec70:	4630      	mov	r0, r6
 808ec72:	f7fe fbc7 	bl	808d404 <move_window.part.6>
				if (res == FR_OK) {
 808ec76:	2800      	cmp	r0, #0
 808ec78:	d1f8      	bne.n	808ec6c <f_sync+0x84>
 808ec7a:	9e01      	ldr	r6, [sp, #4]
 808ec7c:	e7c9      	b.n	808ec12 <f_sync+0x2a>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 808ec7e:	9801      	ldr	r0, [sp, #4]
 808ec80:	2301      	movs	r3, #1
 808ec82:	69e2      	ldr	r2, [r4, #28]
 808ec84:	f104 0128 	add.w	r1, r4, #40	; 0x28
 808ec88:	7840      	ldrb	r0, [r0, #1]
 808ec8a:	f7fe fa25 	bl	808d0d8 <disk_write>
 808ec8e:	b920      	cbnz	r0, 808ec9a <f_sync+0xb2>
				fp->flag &= (BYTE)~FA_DIRTY;
 808ec90:	7c23      	ldrb	r3, [r4, #16]
 808ec92:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 808ec96:	7423      	strb	r3, [r4, #16]
 808ec98:	e7b3      	b.n	808ec02 <f_sync+0x1a>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 808ec9a:	2001      	movs	r0, #1
 808ec9c:	e7e6      	b.n	808ec6c <f_sync+0x84>
 808ec9e:	bf00      	nop

0808eca0 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 808eca0:	b510      	push	{r4, lr}
 808eca2:	b082      	sub	sp, #8
 808eca4:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 808eca6:	f7ff ff9f 	bl	808ebe8 <f_sync>
	if (res == FR_OK)
 808ecaa:	b108      	cbz	r0, 808ecb0 <f_close+0x10>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 808ecac:	b002      	add	sp, #8
 808ecae:	bd10      	pop	{r4, pc}
		res = validate(&fp->obj, &fs);	/* Lock volume */
 808ecb0:	a901      	add	r1, sp, #4
 808ecb2:	4620      	mov	r0, r4
 808ecb4:	f7fe faae 	bl	808d214 <validate>
		if (res == FR_OK) {
 808ecb8:	2800      	cmp	r0, #0
 808ecba:	d1f7      	bne.n	808ecac <f_close+0xc>
			fp->obj.fs = 0;	/* Invalidate file object */
 808ecbc:	6020      	str	r0, [r4, #0]
}
 808ecbe:	b002      	add	sp, #8
 808ecc0:	bd10      	pop	{r4, pc}
 808ecc2:	bf00      	nop

0808ecc4 <ff_uni2oem>:
{
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (uni < 0x80) {	/* ASCII? */
 808ecc4:	287f      	cmp	r0, #127	; 0x7f
 808ecc6:	d91f      	bls.n	808ed08 <ff_uni2oem+0x44>
		c = (WCHAR)uni;

	} else {			/* Non-ASCII */
		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
 808ecc8:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 808eccc:	d21a      	bcs.n	808ed04 <ff_uni2oem+0x40>
 808ecce:	f240 13b5 	movw	r3, #437	; 0x1b5
 808ecd2:	4299      	cmp	r1, r3
 808ecd4:	d116      	bne.n	808ed04 <ff_uni2oem+0x40>
 808ecd6:	f243 123c 	movw	r2, #12604	; 0x313c
 808ecda:	2300      	movs	r3, #0
 808ecdc:	21c7      	movs	r1, #199	; 0xc7
 808ecde:	f6c0 0209 	movt	r2, #2057	; 0x809
{
 808ece2:	b410      	push	{r4}
 808ece4:	e003      	b.n	808ecee <ff_uni2oem+0x2a>
			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
 808ece6:	2b80      	cmp	r3, #128	; 0x80
 808ece8:	d010      	beq.n	808ed0c <ff_uni2oem+0x48>
 808ecea:	f832 1f02 	ldrh.w	r1, [r2, #2]!
 808ecee:	4281      	cmp	r1, r0
 808ecf0:	b29c      	uxth	r4, r3
 808ecf2:	f103 0301 	add.w	r3, r3, #1
 808ecf6:	d1f6      	bne.n	808ece6 <ff_uni2oem+0x22>
 808ecf8:	f104 0080 	add.w	r0, r4, #128	; 0x80
 808ecfc:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 808ecfe:	f85d 4b04 	ldr.w	r4, [sp], #4
 808ed02:	4770      	bx	lr
	WCHAR c = 0;
 808ed04:	2000      	movs	r0, #0
}
 808ed06:	4770      	bx	lr
		c = (WCHAR)uni;
 808ed08:	b280      	uxth	r0, r0
 808ed0a:	4770      	bx	lr
 808ed0c:	2000      	movs	r0, #0
 808ed0e:	e7f6      	b.n	808ecfe <ff_uni2oem+0x3a>

0808ed10 <ff_oem2uni>:
{
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (oem < 0x80) {	/* ASCII? */
 808ed10:	287f      	cmp	r0, #127	; 0x7f
 808ed12:	d906      	bls.n	808ed22 <ff_oem2uni+0x12>
		c = oem;

	} else {			/* Extended char */
		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
			if (oem < 0x100) c = p[oem - 0x80];
 808ed14:	28ff      	cmp	r0, #255	; 0xff
 808ed16:	d803      	bhi.n	808ed20 <ff_oem2uni+0x10>
		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
 808ed18:	f240 13b5 	movw	r3, #437	; 0x1b5
			if (oem < 0x100) c = p[oem - 0x80];
 808ed1c:	4299      	cmp	r1, r3
 808ed1e:	d001      	beq.n	808ed24 <ff_oem2uni+0x14>
	WCHAR c = 0;
 808ed20:	2000      	movs	r0, #0
		}
	}

	return c;
}
 808ed22:	4770      	bx	lr
			if (oem < 0x100) c = p[oem - 0x80];
 808ed24:	f64f 7380 	movw	r3, #65408	; 0xff80
 808ed28:	f243 123c 	movw	r2, #12604	; 0x313c
 808ed2c:	f6c7 73ff 	movt	r3, #32767	; 0x7fff
 808ed30:	f6c0 0209 	movt	r2, #2057	; 0x809
 808ed34:	4403      	add	r3, r0
 808ed36:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
 808ed3a:	4770      	bx	lr

0808ed3c <ff_wtoupper>:

		0x0000	/* EOT */
	};


	if (uni < 0x10000) {	/* Is it in BMP? */
 808ed3c:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 808ed40:	d230      	bcs.n	808eda4 <ff_wtoupper+0x68>
		uc = (WORD)uni;
		p = uc < 0x1000 ? cvt1 : cvt2;
 808ed42:	f642 628c 	movw	r2, #11916	; 0x2e8c
 808ed46:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 808ed4a:	f243 0380 	movw	r3, #12416	; 0x3080
 808ed4e:	f641 517d 	movw	r1, #7549	; 0x1d7d
 808ed52:	f6c0 0209 	movt	r2, #2057	; 0x809
 808ed56:	bf38      	it	cc
 808ed58:	2161      	movcc	r1, #97	; 0x61
 808ed5a:	f6c0 0309 	movt	r3, #2057	; 0x809
 808ed5e:	bf38      	it	cc
 808ed60:	4613      	movcc	r3, r2
{
 808ed62:	b4f0      	push	{r4, r5, r6, r7}
		uc = (WORD)uni;
 808ed64:	b286      	uxth	r6, r0
 808ed66:	3304      	adds	r3, #4
 808ed68:	e003      	b.n	808ed72 <ff_wtoupper+0x36>
 808ed6a:	3304      	adds	r3, #4
				case 7: uc -= 80; break;			/* Shift -80 */
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
				}
				break;
			}
			if (cmd == 0) p += nc;	/* Skip table if needed */
 808ed6c:	b1da      	cbz	r2, 808eda6 <ff_wtoupper+0x6a>
 808ed6e:	f833 1c04 	ldrh.w	r1, [r3, #-4]
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 808ed72:	461f      	mov	r7, r3
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 808ed74:	b199      	cbz	r1, 808ed9e <ff_wtoupper+0x62>
 808ed76:	428e      	cmp	r6, r1
 808ed78:	d311      	bcc.n	808ed9e <ff_wtoupper+0x62>
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 808ed7a:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 808ed7e:	b2d4      	uxtb	r4, r2
 808ed80:	0a12      	lsrs	r2, r2, #8
			if (uc < bc + nc) {	/* In the block? */
 808ed82:	1865      	adds	r5, r4, r1
 808ed84:	42a8      	cmp	r0, r5
 808ed86:	daf0      	bge.n	808ed6a <ff_wtoupper+0x2e>
				switch (cmd) {
 808ed88:	2a08      	cmp	r2, #8
 808ed8a:	d808      	bhi.n	808ed9e <ff_wtoupper+0x62>
 808ed8c:	e8df f002 	tbb	[pc, r2]
 808ed90:	211e1814 	.word	0x211e1814
 808ed94:	052a2724 	.word	0x052a2724
 808ed98:	10          	.byte	0x10
 808ed99:	00          	.byte	0x00
				case 7: uc -= 80; break;			/* Shift -80 */
 808ed9a:	3e50      	subs	r6, #80	; 0x50
 808ed9c:	b2b6      	uxth	r6, r6
		}
		uni = uc;
 808ed9e:	4630      	mov	r0, r6
	}

	return uni;
}
 808eda0:	bcf0      	pop	{r4, r5, r6, r7}
 808eda2:	4770      	bx	lr
 808eda4:	4770      	bx	lr
			if (cmd == 0) p += nc;	/* Skip table if needed */
 808eda6:	eb07 0344 	add.w	r3, r7, r4, lsl #1
 808edaa:	f837 1014 	ldrh.w	r1, [r7, r4, lsl #1]
 808edae:	e7da      	b.n	808ed66 <ff_wtoupper+0x2a>
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
 808edb0:	f5a6 56e3 	sub.w	r6, r6, #7264	; 0x1c60
 808edb4:	b2b6      	uxth	r6, r6
 808edb6:	e7f2      	b.n	808ed9e <ff_wtoupper+0x62>
				case 0:	uc = p[uc - bc]; break;		/* Table conversion */
 808edb8:	1a40      	subs	r0, r0, r1
 808edba:	f833 6010 	ldrh.w	r6, [r3, r0, lsl #1]
 808edbe:	e7ee      	b.n	808ed9e <ff_wtoupper+0x62>
				case 1:	uc -= (uc - bc) & 1; break;	/* Case pairs */
 808edc0:	1a71      	subs	r1, r6, r1
 808edc2:	f001 0301 	and.w	r3, r1, #1
 808edc6:	1af6      	subs	r6, r6, r3
 808edc8:	b2b6      	uxth	r6, r6
 808edca:	e7e8      	b.n	808ed9e <ff_wtoupper+0x62>
				case 2: uc -= 16; break;			/* Shift -16 */
 808edcc:	3e10      	subs	r6, #16
 808edce:	b2b6      	uxth	r6, r6
 808edd0:	e7e5      	b.n	808ed9e <ff_wtoupper+0x62>
				case 3:	uc -= 32; break;			/* Shift -32 */
 808edd2:	3e20      	subs	r6, #32
 808edd4:	b2b6      	uxth	r6, r6
 808edd6:	e7e2      	b.n	808ed9e <ff_wtoupper+0x62>
				case 4:	uc -= 48; break;			/* Shift -48 */
 808edd8:	3e30      	subs	r6, #48	; 0x30
 808edda:	b2b6      	uxth	r6, r6
 808eddc:	e7df      	b.n	808ed9e <ff_wtoupper+0x62>
				case 5:	uc -= 26; break;			/* Shift -26 */
 808edde:	3e1a      	subs	r6, #26
 808ede0:	b2b6      	uxth	r6, r6
 808ede2:	e7dc      	b.n	808ed9e <ff_wtoupper+0x62>
				case 6:	uc += 8; break;				/* Shift +8 */
 808ede4:	3608      	adds	r6, #8
 808ede6:	b2b6      	uxth	r6, r6
 808ede8:	e7d9      	b.n	808ed9e <ff_wtoupper+0x62>
 808edea:	bf00      	nop

0808edec <AudioLoopback_demo>:
  * @brief  Audio Play demo
  * @param  None
  * @retval None
  */
void AudioLoopback_demo (void)
{
 808edec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  * @retval None
  */
static void AudioLoopback_SetHint(void)
{
  /* Clear the LCD */
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 808edf0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
{
 808edf4:	b083      	sub	sp, #12
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 808edf6:	f7f4 fae9 	bl	80833cc <BSP_LCD_Clear>

  /* Set Audio Demo description */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808edfa:	20ff      	movs	r0, #255	; 0xff
 808edfc:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808ee00:	f7f4 fa98 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 90);
 808ee04:	f7f4 fa20 	bl	8083248 <BSP_LCD_GetXSize>
 808ee08:	2100      	movs	r1, #0
 808ee0a:	b282      	uxth	r2, r0
 808ee0c:	235a      	movs	r3, #90	; 0x5a
 808ee0e:	4608      	mov	r0, r1
 808ee10:	f7f4 ff7e 	bl	8083d10 <BSP_LCD_FillRect>
  BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808ee14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808ee18:	f7f4 fa8c 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 808ee1c:	20ff      	movs	r0, #255	; 0xff
 808ee1e:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808ee22:	f7f4 faa3 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetFont(&Font24);
 808ee26:	f24b 3064 	movw	r0, #45924	; 0xb364
 808ee2a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808ee2e:	f7f4 faad 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"AUDIO LOOPBACK EXAMPLE", CENTER_MODE);
 808ee32:	2100      	movs	r1, #0
 808ee34:	f245 6218 	movw	r2, #22040	; 0x5618
 808ee38:	2301      	movs	r3, #1
 808ee3a:	4608      	mov	r0, r1
 808ee3c:	f6c0 0209 	movt	r2, #2057	; 0x809
 808ee40:	f7f4 fbfa 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetFont(&Font12);
 808ee44:	f24b 304c 	movw	r0, #45900	; 0xb34c
 808ee48:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808ee4c:	f7f4 fa9e 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"Press User button for next menu", CENTER_MODE);
 808ee50:	f245 6230 	movw	r2, #22064	; 0x5630
 808ee54:	2301      	movs	r3, #1
 808ee56:	211e      	movs	r1, #30
 808ee58:	f6c0 0209 	movt	r2, #2057	; 0x809
 808ee5c:	2000      	movs	r0, #0
 808ee5e:	f7f4 fbeb 	bl	8083638 <BSP_LCD_DisplayStringAt>

  /* Set the LCD Text Color */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808ee62:	20ff      	movs	r0, #255	; 0xff
 808ee64:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808ee68:	f7f4 fa64 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DrawRect(10, 100, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 110);
 808ee6c:	f7f4 f9ec 	bl	8083248 <BSP_LCD_GetXSize>
 808ee70:	4604      	mov	r4, r0
 808ee72:	f7f4 f9f7 	bl	8083264 <BSP_LCD_GetYSize>
 808ee76:	f1a0 036e 	sub.w	r3, r0, #110	; 0x6e
 808ee7a:	f1a4 0214 	sub.w	r2, r4, #20
 808ee7e:	2164      	movs	r1, #100	; 0x64
 808ee80:	b29b      	uxth	r3, r3
 808ee82:	200a      	movs	r0, #10
 808ee84:	b292      	uxth	r2, r2
 808ee86:	f7f4 fb2d 	bl	80834e4 <BSP_LCD_DrawRect>
  BSP_LCD_DrawRect(11, 101, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 112);
 808ee8a:	f7f4 f9dd 	bl	8083248 <BSP_LCD_GetXSize>
 808ee8e:	4604      	mov	r4, r0
 808ee90:	f7f4 f9e8 	bl	8083264 <BSP_LCD_GetYSize>
 808ee94:	f1a0 0370 	sub.w	r3, r0, #112	; 0x70
 808ee98:	f1a4 0216 	sub.w	r2, r4, #22
 808ee9c:	2165      	movs	r1, #101	; 0x65
 808ee9e:	b29b      	uxth	r3, r3
 808eea0:	200b      	movs	r0, #11
 808eea2:	b292      	uxth	r2, r2
 808eea4:	f7f4 fb1e 	bl	80834e4 <BSP_LCD_DrawRect>
  if (BSP_AUDIO_IN_OUT_Init(INPUT_DEVICE_DIGITAL_MICROPHONE_2, OUTPUT_DEVICE_HEADPHONE, DEFAULT_AUDIO_IN_FREQ, DEFAULT_AUDIO_IN_BIT_RESOLUTION, DEFAULT_AUDIO_IN_CHANNEL_NBR) == AUDIO_OK)
 808eea8:	2102      	movs	r1, #2
 808eeaa:	2310      	movs	r3, #16
 808eeac:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
 808eeb0:	9100      	str	r1, [sp, #0]
 808eeb2:	f44f 7000 	mov.w	r0, #512	; 0x200
 808eeb6:	f7f3 ffe7 	bl	8082e88 <BSP_AUDIO_IN_OUT_Init>
 808eeba:	2800      	cmp	r0, #0
 808eebc:	f040 8081 	bne.w	808efc2 <AudioLoopback_demo+0x1d6>
 808eec0:	4604      	mov	r4, r0
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808eec2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808eec6:	f7f4 fa51 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 808eeca:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
 808eece:	f7f4 fa31 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 95, (uint8_t *)"  AUDIO RECORD INIT OK  ", CENTER_MODE);
 808eed2:	f7f4 f9c7 	bl	8083264 <BSP_LCD_GetYSize>
 808eed6:	f245 6250 	movw	r2, #22096	; 0x5650
 808eeda:	f1a0 015f 	sub.w	r1, r0, #95	; 0x5f
 808eede:	2301      	movs	r3, #1
 808eee0:	4620      	mov	r0, r4
 808eee2:	f6c0 0209 	movt	r2, #2057	; 0x809
 808eee6:	b289      	uxth	r1, r1
 808eee8:	f7f4 fba6 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808eeec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  memset((uint16_t*)AUDIO_BUFFER_OUT, 0, AUDIO_BLOCK_SIZE*2);
 808eef0:	f64f 0600 	movw	r6, #63488	; 0xf800
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808eef4:	f7f4 fa3a 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808eef8:	20ff      	movs	r0, #255	; 0xff
  memset((uint16_t*)AUDIO_BUFFER_OUT, 0, AUDIO_BLOCK_SIZE*2);
 808eefa:	f2cc 0607 	movt	r6, #49159	; 0xc007
  audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808eefe:	2700      	movs	r7, #0
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808ef00:	f6cf 7000 	movt	r0, #65280	; 0xff00
  audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808ef04:	f24f 04f0 	movw	r4, #61680	; 0xf0f0
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808ef08:	f7f4 fa14 	bl	8083334 <BSP_LCD_SetTextColor>
  memset((uint16_t*)AUDIO_BUFFER_OUT, 0, AUDIO_BLOCK_SIZE*2);
 808ef0c:	f506 6880 	add.w	r8, r6, #1024	; 0x400
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"Microphones sound streamed to headphones", CENTER_MODE);
 808ef10:	f7f4 f9a8 	bl	8083264 <BSP_LCD_GetYSize>
 808ef14:	f245 62a0 	movw	r2, #22176	; 0x56a0
 808ef18:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808ef1c:	2301      	movs	r3, #1
 808ef1e:	f6c0 0209 	movt	r2, #2057	; 0x809
 808ef22:	4638      	mov	r0, r7
 808ef24:	b289      	uxth	r1, r1
  audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808ef26:	f2c2 0402 	movt	r4, #8194	; 0x2002
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"Microphones sound streamed to headphones", CENTER_MODE);
 808ef2a:	f7f4 fb85 	bl	8083638 <BSP_LCD_DisplayStringAt>
  memset((uint16_t*)AUDIO_BUFFER_IN, 0, AUDIO_BLOCK_SIZE*2);
 808ef2e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 808ef32:	4639      	mov	r1, r7
 808ef34:	4630      	mov	r0, r6
 808ef36:	f003 f8c4 	bl	80920c2 <memset>
  memset((uint16_t*)AUDIO_BUFFER_OUT, 0, AUDIO_BLOCK_SIZE*2);
 808ef3a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 808ef3e:	4639      	mov	r1, r7
 808ef40:	4640      	mov	r0, r8
 808ef42:	f003 f8be 	bl	80920c2 <memset>
  BSP_AUDIO_IN_Record((uint16_t*)AUDIO_BUFFER_IN, AUDIO_BLOCK_SIZE);
 808ef46:	f44f 7100 	mov.w	r1, #512	; 0x200
 808ef4a:	4630      	mov	r0, r6
  audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808ef4c:	6027      	str	r7, [r4, #0]
    memcpy((uint16_t *)(AUDIO_BUFFER_OUT),
 808ef4e:	46b1      	mov	r9, r6
  BSP_AUDIO_IN_Record((uint16_t*)AUDIO_BUFFER_IN, AUDIO_BLOCK_SIZE);
 808ef50:	f7f3 fe66 	bl	8082c20 <BSP_AUDIO_IN_Record>
  BSP_AUDIO_OUT_SetAudioFrameSlot(CODEC_AUDIOFRAME_SLOT_02);
 808ef54:	2005      	movs	r0, #5
 808ef56:	f7f3 fc81 	bl	808285c <BSP_AUDIO_OUT_SetAudioFrameSlot>
  BSP_AUDIO_OUT_Play((uint16_t*)AUDIO_BUFFER_OUT, AUDIO_BLOCK_SIZE * 2);
 808ef5a:	4640      	mov	r0, r8
 808ef5c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 808ef60:	f7f3 fc04 	bl	808276c <BSP_AUDIO_OUT_Play>
    while(audio_rec_buffer_state != BUFFER_OFFSET_HALF)
 808ef64:	6823      	ldr	r3, [r4, #0]
 808ef66:	2b01      	cmp	r3, #1
 808ef68:	d00c      	beq.n	808ef84 <AudioLoopback_demo+0x198>
      if (CheckForUserInput() > 0)
 808ef6a:	f002 f9fd 	bl	8091368 <CheckForUserInput>
 808ef6e:	2800      	cmp	r0, #0
 808ef70:	d0f8      	beq.n	808ef64 <AudioLoopback_demo+0x178>
        BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 808ef72:	2002      	movs	r0, #2
 808ef74:	f7f3 fc46 	bl	8082804 <BSP_AUDIO_OUT_Stop>
        BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 808ef78:	2002      	movs	r0, #2
}
 808ef7a:	b003      	add	sp, #12
 808ef7c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 808ef80:	f7f3 bc40 	b.w	8082804 <BSP_AUDIO_OUT_Stop>
    memcpy((uint16_t *)(AUDIO_BUFFER_OUT),
 808ef84:	f44f 7200 	mov.w	r2, #512	; 0x200
 808ef88:	4649      	mov	r1, r9
 808ef8a:	4640      	mov	r0, r8
    audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808ef8c:	6027      	str	r7, [r4, #0]
    memcpy((uint16_t *)(AUDIO_BUFFER_OUT),
 808ef8e:	f003 f88d 	bl	80920ac <memcpy>
    while(audio_rec_buffer_state != BUFFER_OFFSET_FULL)
 808ef92:	e003      	b.n	808ef9c <AudioLoopback_demo+0x1b0>
      if (CheckForUserInput() > 0)
 808ef94:	f002 f9e8 	bl	8091368 <CheckForUserInput>
 808ef98:	2800      	cmp	r0, #0
 808ef9a:	d1ea      	bne.n	808ef72 <AudioLoopback_demo+0x186>
    while(audio_rec_buffer_state != BUFFER_OFFSET_FULL)
 808ef9c:	6825      	ldr	r5, [r4, #0]
 808ef9e:	2d02      	cmp	r5, #2
 808efa0:	d1f8      	bne.n	808ef94 <AudioLoopback_demo+0x1a8>
    memcpy((uint16_t *)(AUDIO_BUFFER_OUT + (AUDIO_BLOCK_SIZE)),
 808efa2:	f44f 7200 	mov.w	r2, #512	; 0x200
 808efa6:	f506 60c0 	add.w	r0, r6, #1536	; 0x600
    audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808efaa:	6027      	str	r7, [r4, #0]
    memcpy((uint16_t *)(AUDIO_BUFFER_OUT + (AUDIO_BLOCK_SIZE)),
 808efac:	18b1      	adds	r1, r6, r2
 808efae:	f003 f87d 	bl	80920ac <memcpy>
    if (CheckForUserInput() > 0)
 808efb2:	f002 f9d9 	bl	8091368 <CheckForUserInput>
 808efb6:	2800      	cmp	r0, #0
 808efb8:	d0d4      	beq.n	808ef64 <AudioLoopback_demo+0x178>
      BSP_AUDIO_IN_Stop(CODEC_PDWN_SW);
 808efba:	4628      	mov	r0, r5
 808efbc:	f7f3 fe3c 	bl	8082c38 <BSP_AUDIO_IN_Stop>
 808efc0:	e7da      	b.n	808ef78 <AudioLoopback_demo+0x18c>
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808efc2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808efc6:	f7f4 f9d1 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_RED);
 808efca:	2000      	movs	r0, #0
 808efcc:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 808efd0:	f7f4 f9b0 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 95, (uint8_t *)"  AUDIO RECORD INIT FAIL", CENTER_MODE);
 808efd4:	f7f4 f946 	bl	8083264 <BSP_LCD_GetYSize>
 808efd8:	f245 626c 	movw	r2, #22124	; 0x566c
 808efdc:	f1a0 015f 	sub.w	r1, r0, #95	; 0x5f
 808efe0:	2301      	movs	r3, #1
 808efe2:	f6c0 0209 	movt	r2, #2057	; 0x809
 808efe6:	2000      	movs	r0, #0
 808efe8:	b289      	uxth	r1, r1
 808efea:	f7f4 fb25 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)" Try to reset board ", CENTER_MODE);
 808efee:	f7f4 f939 	bl	8083264 <BSP_LCD_GetYSize>
 808eff2:	f245 6288 	movw	r2, #22152	; 0x5688
 808eff6:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808effa:	2301      	movs	r3, #1
 808effc:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f000:	2000      	movs	r0, #0
 808f002:	b289      	uxth	r1, r1
 808f004:	f7f4 fb18 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808f008:	e770      	b.n	808eeec <AudioLoopback_demo+0x100>
 808f00a:	bf00      	nop

0808f00c <Audio_Test_Process.part.0>:
/**
  * @brief  Manages Audio process. 
  * @param  None
  * @retval Audio error
  */
uint8_t Audio_Test_Process(void)
 808f00c:	b4f0      	push	{r4, r5, r6, r7}
  
  switch(audio_state)
  {
  case AUDIO_STATE_PLAYING:
    
    if(buffer_ctl.fptr >= AudioFileSize)
 808f00e:	f64b 51e0 	movw	r1, #48608	; 0xbde0
 808f012:	f64b 57cc 	movw	r7, #48588	; 0xbdcc
 808f016:	f2c2 0100 	movt	r1, #8192	; 0x2000
 808f01a:	f2c2 0700 	movt	r7, #8192	; 0x2000
 808f01e:	f8d1 6800 	ldr.w	r6, [r1, #2048]	; 0x800
 808f022:	683d      	ldr	r5, [r7, #0]
 808f024:	42ae      	cmp	r6, r5
 808f026:	d345      	bcc.n	808f0b4 <Audio_Test_Process.part.0+0xa8>
      buffer_ctl.fptr = 0; 
      error_state = AUDIO_ERROR_EOF;
    }

    /* 1st half buffer played; so fill it and continue playing from bottom*/
    if(buffer_ctl.state == BUFFER_OFFSET_HALF)
 808f028:	f891 3804 	ldrb.w	r3, [r1, #2052]	; 0x804
      buffer_ctl.fptr = 0; 
 808f02c:	2600      	movs	r6, #0
    if(buffer_ctl.state == BUFFER_OFFSET_HALF)
 808f02e:	2b01      	cmp	r3, #1
      buffer_ctl.fptr = 0; 
 808f030:	f8c1 6800 	str.w	r6, [r1, #2048]	; 0x800
    if(buffer_ctl.state == BUFFER_OFFSET_HALF)
 808f034:	f000 8081 	beq.w	808f13a <Audio_Test_Process.part.0+0x12e>
        SCB_CleanDCache_by_Addr((uint32_t*)&buffer_ctl.buff[0], AUDIO_BUFFER_SIZE/2);
      }
    }
    
    /* 2nd half buffer played; so fill it and continue playing from top */    
    if(buffer_ctl.state == BUFFER_OFFSET_FULL)
 808f038:	2b02      	cmp	r3, #2
      error_state = AUDIO_ERROR_EOF;
 808f03a:	f04f 0003 	mov.w	r0, #3
    if(buffer_ctl.state == BUFFER_OFFSET_FULL)
 808f03e:	d140      	bne.n	808f0c2 <Audio_Test_Process.part.0+0xb6>
    {
      bytesread = GetData((void *)AudioStartAddress,
 808f040:	f64b 53d0 	movw	r3, #48592	; 0xbdd0
{
  uint8_t *lptr = pdata;
  uint32_t ReadDataNbr;
  
  ReadDataNbr = 0;
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f044:	683d      	ldr	r5, [r7, #0]
      bytesread = GetData((void *)AudioStartAddress,
 808f046:	f8d1 2800 	ldr.w	r2, [r1, #2048]	; 0x800
 808f04a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f04e:	42aa      	cmp	r2, r5
      bytesread = GetData((void *)AudioStartAddress,
 808f050:	681e      	ldr	r6, [r3, #0]
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f052:	d236      	bcs.n	808f0c2 <Audio_Test_Process.part.0+0xb6>
 808f054:	f24c 13df 	movw	r3, #49631	; 0xc1df
 808f058:	1aad      	subs	r5, r5, r2
 808f05a:	4416      	add	r6, r2
  ReadDataNbr = 0;
 808f05c:	2200      	movs	r2, #0
 808f05e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808f062:	e002      	b.n	808f06a <Audio_Test_Process.part.0+0x5e>
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f064:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 808f068:	d005      	beq.n	808f076 <Audio_Test_Process.part.0+0x6a>
  {
    pbuf[ReadDataNbr]= lptr [offset + ReadDataNbr];
 808f06a:	5cb4      	ldrb	r4, [r6, r2]
    ReadDataNbr++;
 808f06c:	3201      	adds	r2, #1
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f06e:	42aa      	cmp	r2, r5
    pbuf[ReadDataNbr]= lptr [offset + ReadDataNbr];
 808f070:	f803 4f01 	strb.w	r4, [r3, #1]!
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f074:	d1f6      	bne.n	808f064 <Audio_Test_Process.part.0+0x58>
        buffer_ctl.fptr += bytesread;
 808f076:	f8d1 4800 	ldr.w	r4, [r1, #2048]	; 0x800
        buffer_ctl.state = BUFFER_OFFSET_NONE;
 808f07a:	2500      	movs	r5, #0
    uint32_t op_addr = (uint32_t) addr;
 808f07c:	f24c 13e0 	movw	r3, #49632	; 0xc1e0
        buffer_ctl.fptr += bytesread;
 808f080:	4422      	add	r2, r4
        buffer_ctl.state = BUFFER_OFFSET_NONE;
 808f082:	f881 5804 	strb.w	r5, [r1, #2052]	; 0x804
 808f086:	f2c2 0300 	movt	r3, #8192	; 0x2000
        buffer_ctl.fptr += bytesread;
 808f08a:	f8c1 2800 	str.w	r2, [r1, #2048]	; 0x800
  __ASM volatile ("dsb 0xF":::"memory");
 808f08e:	f3bf 8f4f 	dsb	sy
      SCB->DCCMVAC = op_addr;
 808f092:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 808f096:	f503 6180 	add.w	r1, r3, #1024	; 0x400
 808f09a:	f2ce 0200 	movt	r2, #57344	; 0xe000
 808f09e:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += linesize;
 808f0a2:	3320      	adds	r3, #32
    while (op_size > 0) {
 808f0a4:	4299      	cmp	r1, r3
 808f0a6:	d1fa      	bne.n	808f09e <Audio_Test_Process.part.0+0x92>
 808f0a8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 808f0ac:	f3bf 8f6f 	isb	sy
}
 808f0b0:	bcf0      	pop	{r4, r5, r6, r7}
 808f0b2:	4770      	bx	lr
    if(buffer_ctl.state == BUFFER_OFFSET_HALF)
 808f0b4:	f891 3804 	ldrb.w	r3, [r1, #2052]	; 0x804
 808f0b8:	2b01      	cmp	r3, #1
 808f0ba:	d004      	beq.n	808f0c6 <Audio_Test_Process.part.0+0xba>
  AUDIO_ErrorTypeDef error_state = AUDIO_ERROR_NONE;  
 808f0bc:	2000      	movs	r0, #0
    if(buffer_ctl.state == BUFFER_OFFSET_FULL)
 808f0be:	2b02      	cmp	r3, #2
 808f0c0:	d0be      	beq.n	808f040 <Audio_Test_Process.part.0+0x34>
}
 808f0c2:	bcf0      	pop	{r4, r5, r6, r7}
 808f0c4:	4770      	bx	lr
      bytesread = GetData((void *)AudioStartAddress,
 808f0c6:	f64b 52d0 	movw	r2, #48592	; 0xbdd0
 808f0ca:	4633      	mov	r3, r6
  AUDIO_ErrorTypeDef error_state = AUDIO_ERROR_NONE;  
 808f0cc:	2000      	movs	r0, #0
      bytesread = GetData((void *)AudioStartAddress,
 808f0ce:	f2c2 0200 	movt	r2, #8192	; 0x2000
 808f0d2:	6816      	ldr	r6, [r2, #0]
  AUDIO_ErrorTypeDef error_state = AUDIO_ERROR_NONE;  
 808f0d4:	f64b 51e0 	movw	r1, #48608	; 0xbde0
 808f0d8:	1aed      	subs	r5, r5, r3
 808f0da:	441e      	add	r6, r3
  ReadDataNbr = 0;
 808f0dc:	2300      	movs	r3, #0
  AUDIO_ErrorTypeDef error_state = AUDIO_ERROR_NONE;  
 808f0de:	f2c2 0100 	movt	r1, #8192	; 0x2000
 808f0e2:	460a      	mov	r2, r1
 808f0e4:	e002      	b.n	808f0ec <Audio_Test_Process.part.0+0xe0>
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f0e6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 808f0ea:	d005      	beq.n	808f0f8 <Audio_Test_Process.part.0+0xec>
    pbuf[ReadDataNbr]= lptr [offset + ReadDataNbr];
 808f0ec:	5cf4      	ldrb	r4, [r6, r3]
    ReadDataNbr++;
 808f0ee:	3301      	adds	r3, #1
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f0f0:	42ab      	cmp	r3, r5
    pbuf[ReadDataNbr]= lptr [offset + ReadDataNbr];
 808f0f2:	f802 4b01 	strb.w	r4, [r2], #1
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f0f6:	d1f6      	bne.n	808f0e6 <Audio_Test_Process.part.0+0xda>
        buffer_ctl.fptr += bytesread; 
 808f0f8:	f8d1 2800 	ldr.w	r2, [r1, #2048]	; 0x800
        buffer_ctl.state = BUFFER_OFFSET_NONE;
 808f0fc:	2400      	movs	r4, #0
        buffer_ctl.fptr += bytesread; 
 808f0fe:	4413      	add	r3, r2
        buffer_ctl.state = BUFFER_OFFSET_NONE;
 808f100:	f881 4804 	strb.w	r4, [r1, #2052]	; 0x804
        buffer_ctl.fptr += bytesread; 
 808f104:	f8c1 3800 	str.w	r3, [r1, #2048]	; 0x800
    uint32_t op_addr = (uint32_t) addr;
 808f108:	f64b 51e0 	movw	r1, #48608	; 0xbde0
 808f10c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 808f110:	460b      	mov	r3, r1
  __ASM volatile ("dsb 0xF":::"memory");
 808f112:	f3bf 8f4f 	dsb	sy
      SCB->DCCMVAC = op_addr;
 808f116:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 808f11a:	f501 6480 	add.w	r4, r1, #1024	; 0x400
 808f11e:	f2ce 0200 	movt	r2, #57344	; 0xe000
 808f122:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += linesize;
 808f126:	3320      	adds	r3, #32
    while (op_size > 0) {
 808f128:	42a3      	cmp	r3, r4
 808f12a:	d1fa      	bne.n	808f122 <Audio_Test_Process.part.0+0x116>
 808f12c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 808f130:	f3bf 8f6f 	isb	sy
 808f134:	f891 3804 	ldrb.w	r3, [r1, #2052]	; 0x804
 808f138:	e7c1      	b.n	808f0be <Audio_Test_Process.part.0+0xb2>
      bytesread = GetData((void *)AudioStartAddress,
 808f13a:	f64b 52d0 	movw	r2, #48592	; 0xbdd0
 808f13e:	4633      	mov	r3, r6
      error_state = AUDIO_ERROR_EOF;
 808f140:	2003      	movs	r0, #3
      bytesread = GetData((void *)AudioStartAddress,
 808f142:	f2c2 0200 	movt	r2, #8192	; 0x2000
 808f146:	6816      	ldr	r6, [r2, #0]
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f148:	2d00      	cmp	r5, #0
 808f14a:	d1c3      	bne.n	808f0d4 <Audio_Test_Process.part.0+0xc8>
 808f14c:	e7b9      	b.n	808f0c2 <Audio_Test_Process.part.0+0xb6>
 808f14e:	bf00      	nop

0808f150 <Audio_Test_Start>:
{
 808f150:	b538      	push	{r3, r4, r5, lr}
  AudioStartAddress = audio_start_address;
 808f152:	f64b 52d0 	movw	r2, #48592	; 0xbdd0
  AudioFileSize = audio_file_size;
 808f156:	f64b 53cc 	movw	r3, #48588	; 0xbdcc
  buffer_ctl.state = BUFFER_OFFSET_NONE;
 808f15a:	f64b 55e0 	movw	r5, #48608	; 0xbde0
 808f15e:	2400      	movs	r4, #0
  AudioStartAddress = audio_start_address;
 808f160:	f2c2 0200 	movt	r2, #8192	; 0x2000
  AudioFileSize = audio_file_size;
 808f164:	f2c2 0300 	movt	r3, #8192	; 0x2000
  buffer_ctl.state = BUFFER_OFFSET_NONE;
 808f168:	f2c2 0500 	movt	r5, #8192	; 0x2000
  AudioStartAddress = audio_start_address;
 808f16c:	6010      	str	r0, [r2, #0]
  AudioFileSize = audio_file_size;
 808f16e:	6019      	str	r1, [r3, #0]
  buffer_ctl.state = BUFFER_OFFSET_NONE;
 808f170:	f885 4804 	strb.w	r4, [r5, #2052]	; 0x804
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f174:	b389      	cbz	r1, 808f1da <Audio_Test_Start+0x8a>
 808f176:	462b      	mov	r3, r5
 808f178:	e002      	b.n	808f180 <Audio_Test_Start+0x30>
 808f17a:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 808f17e:	d005      	beq.n	808f18c <Audio_Test_Start+0x3c>
    pbuf[ReadDataNbr]= lptr [offset + ReadDataNbr];
 808f180:	5d02      	ldrb	r2, [r0, r4]
    ReadDataNbr++;
 808f182:	3401      	adds	r4, #1
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f184:	42a1      	cmp	r1, r4
    pbuf[ReadDataNbr]= lptr [offset + ReadDataNbr];
 808f186:	f803 2b01 	strb.w	r2, [r3], #1
  while(((offset + ReadDataNbr) < AudioFileSize) && (ReadDataNbr < NbrOfData))
 808f18a:	d1f6      	bne.n	808f17a <Audio_Test_Start+0x2a>
    uint32_t op_addr = (uint32_t) addr;
 808f18c:	f64b 53e0 	movw	r3, #48608	; 0xbde0
 808f190:	f2c2 0300 	movt	r3, #8192	; 0x2000
  __ASM volatile ("dsb 0xF":::"memory");
 808f194:	f3bf 8f4f 	dsb	sy
      SCB->DCCMVAC = op_addr;
 808f198:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 808f19c:	f503 6180 	add.w	r1, r3, #1024	; 0x400
 808f1a0:	f2ce 0200 	movt	r2, #57344	; 0xe000
 808f1a4:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += linesize;
 808f1a8:	3320      	adds	r3, #32
    while (op_size > 0) {
 808f1aa:	428b      	cmp	r3, r1
 808f1ac:	d1fa      	bne.n	808f1a4 <Audio_Test_Start+0x54>
 808f1ae:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 808f1b2:	f3bf 8f6f 	isb	sy
    BSP_AUDIO_OUT_Play((uint16_t*)&buffer_ctl.buff[0], AUDIO_BUFFER_SIZE);
 808f1b6:	f64b 50e0 	movw	r0, #48608	; 0xbde0
 808f1ba:	f44f 6100 	mov.w	r1, #2048	; 0x800
 808f1be:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808f1c2:	f7f3 fad3 	bl	808276c <BSP_AUDIO_OUT_Play>
    audio_state = AUDIO_STATE_PLAYING;      
 808f1c6:	f64b 53d4 	movw	r3, #48596	; 0xbdd4
 808f1ca:	2202      	movs	r2, #2
    buffer_ctl.fptr = bytesread;
 808f1cc:	f8c5 4800 	str.w	r4, [r5, #2048]	; 0x800
    audio_state = AUDIO_STATE_PLAYING;      
 808f1d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    return AUDIO_ERROR_NONE;
 808f1d4:	2000      	movs	r0, #0
    audio_state = AUDIO_STATE_PLAYING;      
 808f1d6:	701a      	strb	r2, [r3, #0]
}
 808f1d8:	bd38      	pop	{r3, r4, r5, pc}
  return AUDIO_ERROR_IO;
 808f1da:	2002      	movs	r0, #2
}
 808f1dc:	bd38      	pop	{r3, r4, r5, pc}
 808f1de:	bf00      	nop

0808f1e0 <AudioPlay_Demo>:
{
 808f1e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 808f1e4:	b0cf      	sub	sp, #316	; 0x13c
  uwPauseEnabledStatus = 1; /* 0 when audio is running, 1 when Pause is on */
 808f1e6:	f24c 55e8 	movw	r5, #50664	; 0xc5e8
  uwVolume = 70;
 808f1ea:	f24b 04b0 	movw	r4, #45232	; 0xb0b0
  uint8_t FreqStr[256] = {0};
 808f1ee:	f44f 7280 	mov.w	r2, #256	; 0x100
 808f1f2:	2100      	movs	r1, #0
 808f1f4:	a80e      	add	r0, sp, #56	; 0x38
 808f1f6:	f002 ff64 	bl	80920c2 <memset>
  uwPauseEnabledStatus = 1; /* 0 when audio is running, 1 when Pause is on */
 808f1fa:	2601      	movs	r6, #1
  uwVolume = 70;
 808f1fc:	2346      	movs	r3, #70	; 0x46
 808f1fe:	f2c2 0400 	movt	r4, #8192	; 0x2000
  uwPauseEnabledStatus = 1; /* 0 when audio is running, 1 when Pause is on */
 808f202:	f2c2 0500 	movt	r5, #8192	; 0x2000
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 808f206:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  if (BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_BOTH, uwVolume, *AudioFreq_ptr) == 0)
 808f20a:	f24b 088c 	movw	r8, #45196	; 0xb08c
  uwPauseEnabledStatus = 1; /* 0 when audio is running, 1 when Pause is on */
 808f20e:	602e      	str	r6, [r5, #0]
  uwVolume = 70;
 808f210:	6023      	str	r3, [r4, #0]
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 808f212:	f7f4 f8db 	bl	80833cc <BSP_LCD_Clear>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f216:	20ff      	movs	r0, #255	; 0xff
  if (BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_BOTH, uwVolume, *AudioFreq_ptr) == 0)
 808f218:	f2c2 0800 	movt	r8, #8192	; 0x2000
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f21c:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f220:	f7f4 f888 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 90);
 808f224:	f7f4 f810 	bl	8083248 <BSP_LCD_GetXSize>
 808f228:	2100      	movs	r1, #0
 808f22a:	b282      	uxth	r2, r0
 808f22c:	235a      	movs	r3, #90	; 0x5a
 808f22e:	4608      	mov	r0, r1
 808f230:	f7f4 fd6e 	bl	8083d10 <BSP_LCD_FillRect>
  BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808f234:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f238:	f7f4 f87c 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 808f23c:	20ff      	movs	r0, #255	; 0xff
 808f23e:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f242:	f7f4 f893 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetFont(&Font24);
 808f246:	f24b 3064 	movw	r0, #45924	; 0xb364
 808f24a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808f24e:	f7f4 f89d 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"AUDIO EXAMPLE", CENTER_MODE);
 808f252:	2100      	movs	r1, #0
 808f254:	f245 62cc 	movw	r2, #22220	; 0x56cc
 808f258:	4633      	mov	r3, r6
 808f25a:	4608      	mov	r0, r1
 808f25c:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f260:	f7f4 f9ea 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetFont(&Font12);
 808f264:	f24b 304c 	movw	r0, #45900	; 0xb34c
 808f268:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808f26c:	f7f4 f88e 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"Press User button for next menu", CENTER_MODE);
 808f270:	f245 6230 	movw	r2, #22064	; 0x5630
 808f274:	4633      	mov	r3, r6
 808f276:	211e      	movs	r1, #30
 808f278:	2000      	movs	r0, #0
 808f27a:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f27e:	f7f4 f9db 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"Press Top/Bottom screen to change Volume   ", CENTER_MODE);
 808f282:	f245 62dc 	movw	r2, #22236	; 0x56dc
 808f286:	4633      	mov	r3, r6
 808f288:	212d      	movs	r1, #45	; 0x2d
 808f28a:	2000      	movs	r0, #0
 808f28c:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f290:	f7f4 f9d2 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 60, (uint8_t *)"Press Left/Right screen to change Frequency", CENTER_MODE);
 808f294:	f245 7208 	movw	r2, #22280	; 0x5708
 808f298:	4633      	mov	r3, r6
 808f29a:	213c      	movs	r1, #60	; 0x3c
 808f29c:	2000      	movs	r0, #0
 808f29e:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f2a2:	f7f4 f9c9 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 75, (uint8_t *)"Press 2 fingers for Pause/Resume           ", CENTER_MODE);
 808f2a6:	f245 7234 	movw	r2, #22324	; 0x5734
 808f2aa:	4633      	mov	r3, r6
 808f2ac:	214b      	movs	r1, #75	; 0x4b
 808f2ae:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f2b2:	2000      	movs	r0, #0
 808f2b4:	f7f4 f9c0 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f2b8:	20ff      	movs	r0, #255	; 0xff
 808f2ba:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f2be:	f7f4 f839 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DrawRect(10, 100, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 110);
 808f2c2:	f7f3 ffc1 	bl	8083248 <BSP_LCD_GetXSize>
 808f2c6:	4607      	mov	r7, r0
 808f2c8:	f7f3 ffcc 	bl	8083264 <BSP_LCD_GetYSize>
 808f2cc:	f1a0 036e 	sub.w	r3, r0, #110	; 0x6e
 808f2d0:	f1a7 0214 	sub.w	r2, r7, #20
 808f2d4:	2164      	movs	r1, #100	; 0x64
 808f2d6:	b29b      	uxth	r3, r3
 808f2d8:	200a      	movs	r0, #10
 808f2da:	b292      	uxth	r2, r2
 808f2dc:	f7f4 f902 	bl	80834e4 <BSP_LCD_DrawRect>
  BSP_LCD_DrawRect(11, 101, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 112);
 808f2e0:	f7f3 ffb2 	bl	8083248 <BSP_LCD_GetXSize>
 808f2e4:	4607      	mov	r7, r0
 808f2e6:	f7f3 ffbd 	bl	8083264 <BSP_LCD_GetYSize>
 808f2ea:	f1a0 0370 	sub.w	r3, r0, #112	; 0x70
 808f2ee:	f1a7 0216 	sub.w	r2, r7, #22
 808f2f2:	2165      	movs	r1, #101	; 0x65
 808f2f4:	200b      	movs	r0, #11
 808f2f6:	b29b      	uxth	r3, r3
 808f2f8:	b292      	uxth	r2, r2
 808f2fa:	f7f4 f8f3 	bl	80834e4 <BSP_LCD_DrawRect>
  if (BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_BOTH, uwVolume, *AudioFreq_ptr) == 0)
 808f2fe:	6821      	ldr	r1, [r4, #0]
 808f300:	f8d8 2018 	ldr.w	r2, [r8, #24]
 808f304:	2003      	movs	r0, #3
 808f306:	b2c9      	uxtb	r1, r1
 808f308:	f7f3 fbf4 	bl	8082af4 <BSP_AUDIO_OUT_Init>
 808f30c:	2800      	cmp	r0, #0
 808f30e:	f040 80fc 	bne.w	808f50a <AudioPlay_Demo+0x32a>
 808f312:	4607      	mov	r7, r0
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f314:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f318:	f7f4 f828 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 808f31c:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
 808f320:	f7f4 f808 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 95, (uint8_t *)"  AUDIO CODEC   OK  ", CENTER_MODE);
 808f324:	f7f3 ff9e 	bl	8083264 <BSP_LCD_GetYSize>
 808f328:	f245 7260 	movw	r2, #22368	; 0x5760
 808f32c:	f1a0 015f 	sub.w	r1, r0, #95	; 0x5f
 808f330:	4633      	mov	r3, r6
 808f332:	4638      	mov	r0, r7
 808f334:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f338:	b289      	uxth	r1, r1
 808f33a:	f7f4 f97d 	bl	8083638 <BSP_LCD_DisplayStringAt>
  if (BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize()) != TS_OK)
 808f33e:	f7f3 ff83 	bl	8083248 <BSP_LCD_GetXSize>
 808f342:	4606      	mov	r6, r0
 808f344:	f7f3 ff8e 	bl	8083264 <BSP_LCD_GetYSize>
 808f348:	b281      	uxth	r1, r0
 808f34a:	b2b0      	uxth	r0, r6
 808f34c:	f7f6 f88e 	bl	808546c <BSP_TS_Init>
 808f350:	2800      	cmp	r0, #0
 808f352:	f040 810e 	bne.w	808f572 <AudioPlay_Demo+0x392>
  Audio_Test_Start(AUDIO_FILE_ADDRESS, AUDIO_FILE_SIZE);
 808f356:	2000      	movs	r0, #0
 808f358:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 808f35c:	f64b 56d4 	movw	r6, #48596	; 0xbdd4
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PAUSE  ...     ", CENTER_MODE);
 808f360:	f645 0700 	movw	r7, #22528	; 0x5800
  Audio_Test_Start(AUDIO_FILE_ADDRESS, AUDIO_FILE_SIZE);
 808f364:	f6c0 0008 	movt	r0, #2056	; 0x808
        if (*AudioFreq_ptr != 96000)
 808f368:	f44f 49ee 	mov.w	r9, #30464	; 0x7700
  Audio_Test_Start(AUDIO_FILE_ADDRESS, AUDIO_FILE_SIZE);
 808f36c:	f7ff fef0 	bl	808f150 <Audio_Test_Start>
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f370:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f374:	f7f3 fffa 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f378:	20ff      	movs	r0, #255	; 0xff
  AudioFreq_ptr = AudioFreq+6; /*AF_48K*/
 808f37a:	f24b 0aa4 	movw	sl, #45220	; 0xb0a4
 808f37e:	f2c2 0600 	movt	r6, #8192	; 0x2000
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f382:	f6cf 7000 	movt	r0, #65280	; 0xff00
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PAUSE  ...     ", CENTER_MODE);
 808f386:	f6c0 0709 	movt	r7, #2057	; 0x809
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f38a:	f7f3 ffd3 	bl	8083334 <BSP_LCD_SetTextColor>
        if (*AudioFreq_ptr != 96000)
 808f38e:	f2c0 0901 	movt	r9, #1
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PLAYING...     ", CENTER_MODE);
 808f392:	f7f3 ff67 	bl	8083264 <BSP_LCD_GetYSize>
 808f396:	f245 72b4 	movw	r2, #22452	; 0x57b4
 808f39a:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808f39e:	2301      	movs	r3, #1
 808f3a0:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f3a4:	2000      	movs	r0, #0
 808f3a6:	b289      	uxth	r1, r1
  AudioFreq_ptr = AudioFreq+6; /*AF_48K*/
 808f3a8:	f2c2 0a00 	movt	sl, #8192	; 0x2000
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PLAYING...     ", CENTER_MODE);
 808f3ac:	f7f4 f944 	bl	8083638 <BSP_LCD_DisplayStringAt>
  sprintf((char*)FreqStr, "       VOL:    %3lu     ", uwVolume);
 808f3b0:	f245 71cc 	movw	r1, #22476	; 0x57cc
 808f3b4:	6822      	ldr	r2, [r4, #0]
 808f3b6:	a80e      	add	r0, sp, #56	; 0x38
 808f3b8:	f6c0 0109 	movt	r1, #2057	; 0x809
 808f3bc:	f002 fe8a 	bl	80920d4 <siprintf>
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 65, (uint8_t *)FreqStr, CENTER_MODE);
 808f3c0:	f7f3 ff50 	bl	8083264 <BSP_LCD_GetYSize>
 808f3c4:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 808f3c8:	2301      	movs	r3, #1
 808f3ca:	aa0e      	add	r2, sp, #56	; 0x38
 808f3cc:	b289      	uxth	r1, r1
 808f3ce:	2000      	movs	r0, #0
 808f3d0:	f7f4 f932 	bl	8083638 <BSP_LCD_DisplayStringAt>
  sprintf((char*)FreqStr, "      FREQ: %6lu     ", *AudioFreq_ptr);
 808f3d4:	f245 71e8 	movw	r1, #22504	; 0x57e8
 808f3d8:	f8d8 2018 	ldr.w	r2, [r8, #24]
 808f3dc:	a80e      	add	r0, sp, #56	; 0x38
 808f3de:	f6c0 0109 	movt	r1, #2057	; 0x809
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PLAYING...     ", CENTER_MODE);
 808f3e2:	f245 78b4 	movw	r8, #22452	; 0x57b4
  sprintf((char*)FreqStr, "      FREQ: %6lu     ", *AudioFreq_ptr);
 808f3e6:	f002 fe75 	bl	80920d4 <siprintf>
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 50, (uint8_t *)FreqStr, CENTER_MODE);
 808f3ea:	f7f3 ff3b 	bl	8083264 <BSP_LCD_GetYSize>
 808f3ee:	f1a0 0132 	sub.w	r1, r0, #50	; 0x32
 808f3f2:	2301      	movs	r3, #1
 808f3f4:	aa0e      	add	r2, sp, #56	; 0x38
 808f3f6:	b289      	uxth	r1, r1
 808f3f8:	2000      	movs	r0, #0
 808f3fa:	f7f4 f91d 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_AUDIO_OUT_SetVolume(70);
 808f3fe:	2046      	movs	r0, #70	; 0x46
 808f400:	f7f3 fa1e 	bl	8082840 <BSP_AUDIO_OUT_SetVolume>
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f404:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f408:	f7f3 ffb0 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f40c:	20ff      	movs	r0, #255	; 0xff
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PLAYING...     ", CENTER_MODE);
 808f40e:	f6c0 0809 	movt	r8, #2057	; 0x809
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f412:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f416:	f7f3 ff8d 	bl	8083334 <BSP_LCD_SetTextColor>
  switch(audio_state)
 808f41a:	7833      	ldrb	r3, [r6, #0]
 808f41c:	2b02      	cmp	r3, #2
 808f41e:	d02d      	beq.n	808f47c <AudioPlay_Demo+0x29c>
    BSP_TS_GetState(&TS_State);
 808f420:	a803      	add	r0, sp, #12
 808f422:	f7f6 f895 	bl	8085550 <BSP_TS_GetState>
    if(TS_State.touchDetected == 1)
 808f426:	f89d 300c 	ldrb.w	r3, [sp, #12]
 808f42a:	2b01      	cmp	r3, #1
 808f42c:	d02f      	beq.n	808f48e <AudioPlay_Demo+0x2ae>
    if (TS_State.touchDetected >= 2)
 808f42e:	d919      	bls.n	808f464 <AudioPlay_Demo+0x284>
      if (uwPauseEnabledStatus == 1)
 808f430:	682b      	ldr	r3, [r5, #0]
 808f432:	2b01      	cmp	r3, #1
 808f434:	d057      	beq.n	808f4e6 <AudioPlay_Demo+0x306>
        uwPauseEnabledStatus = 1;
 808f436:	f04f 0b01 	mov.w	fp, #1
        BSP_AUDIO_OUT_Pause();
 808f43a:	f7f3 f9b7 	bl	80827ac <BSP_AUDIO_OUT_Pause>
        uwPauseEnabledStatus = 1;
 808f43e:	f8c5 b000 	str.w	fp, [r5]
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PAUSE  ...     ", CENTER_MODE);
 808f442:	f7f3 ff0f 	bl	8083264 <BSP_LCD_GetYSize>
 808f446:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808f44a:	465b      	mov	r3, fp
 808f44c:	463a      	mov	r2, r7
 808f44e:	2000      	movs	r0, #0
 808f450:	b289      	uxth	r1, r1
 808f452:	f7f4 f8f1 	bl	8083638 <BSP_LCD_DisplayStringAt>
        BSP_TS_GetState(&TS_State);
 808f456:	a803      	add	r0, sp, #12
 808f458:	f7f6 f87a 	bl	8085550 <BSP_TS_GetState>
      }while(TS_State.touchDetected > 0);
 808f45c:	f89d 300c 	ldrb.w	r3, [sp, #12]
 808f460:	2b00      	cmp	r3, #0
 808f462:	d1f8      	bne.n	808f456 <AudioPlay_Demo+0x276>
    if (CheckForUserInput() > 0)
 808f464:	f001 ff80 	bl	8091368 <CheckForUserInput>
 808f468:	2800      	cmp	r0, #0
 808f46a:	d0d6      	beq.n	808f41a <AudioPlay_Demo+0x23a>
      BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 808f46c:	2002      	movs	r0, #2
 808f46e:	f7f3 f9c9 	bl	8082804 <BSP_AUDIO_OUT_Stop>
      BSP_AUDIO_OUT_DeInit();
 808f472:	f7f3 fafd 	bl	8082a70 <BSP_AUDIO_OUT_DeInit>
}
 808f476:	b04f      	add	sp, #316	; 0x13c
 808f478:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 808f47c:	f7ff fdc6 	bl	808f00c <Audio_Test_Process.part.0>
    BSP_TS_GetState(&TS_State);
 808f480:	a803      	add	r0, sp, #12
 808f482:	f7f6 f865 	bl	8085550 <BSP_TS_GetState>
    if(TS_State.touchDetected == 1)
 808f486:	f89d 300c 	ldrb.w	r3, [sp, #12]
 808f48a:	2b01      	cmp	r3, #1
 808f48c:	d1cf      	bne.n	808f42e <AudioPlay_Demo+0x24e>
      if (TS_State.touchY[0] < 30)
 808f48e:	f8bd b018 	ldrh.w	fp, [sp, #24]
 808f492:	f1bb 0f1d 	cmp.w	fp, #29
 808f496:	d860      	bhi.n	808f55a <AudioPlay_Demo+0x37a>
        if (uwVolume < 95)
 808f498:	6823      	ldr	r3, [r4, #0]
 808f49a:	2b5e      	cmp	r3, #94	; 0x5e
 808f49c:	d959      	bls.n	808f552 <AudioPlay_Demo+0x372>
          uwVolume = 100;
 808f49e:	2364      	movs	r3, #100	; 0x64
 808f4a0:	6023      	str	r3, [r4, #0]
        sprintf((char*)FreqStr, "       VOL:    %3lu     ", uwVolume);
 808f4a2:	f245 71cc 	movw	r1, #22476	; 0x57cc
 808f4a6:	6822      	ldr	r2, [r4, #0]
 808f4a8:	a80e      	add	r0, sp, #56	; 0x38
 808f4aa:	f6c0 0109 	movt	r1, #2057	; 0x809
 808f4ae:	f002 fe11 	bl	80920d4 <siprintf>
        BSP_AUDIO_OUT_SetVolume(uwVolume);
 808f4b2:	6820      	ldr	r0, [r4, #0]
 808f4b4:	b2c0      	uxtb	r0, r0
 808f4b6:	f7f3 f9c3 	bl	8082840 <BSP_AUDIO_OUT_SetVolume>
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 65, (uint8_t *)FreqStr, CENTER_MODE);
 808f4ba:	f7f3 fed3 	bl	8083264 <BSP_LCD_GetYSize>
 808f4be:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 50, (uint8_t *)FreqStr, CENTER_MODE);
 808f4c2:	2301      	movs	r3, #1
 808f4c4:	aa0e      	add	r2, sp, #56	; 0x38
 808f4c6:	b289      	uxth	r1, r1
 808f4c8:	2000      	movs	r0, #0
 808f4ca:	f7f4 f8b5 	bl	8083638 <BSP_LCD_DisplayStringAt>
        BSP_TS_GetState(&TS_State);
 808f4ce:	a803      	add	r0, sp, #12
 808f4d0:	f7f6 f83e 	bl	8085550 <BSP_TS_GetState>
      }while(TS_State.touchDetected > 0);
 808f4d4:	f89d 300c 	ldrb.w	r3, [sp, #12]
 808f4d8:	2b00      	cmp	r3, #0
 808f4da:	d1f8      	bne.n	808f4ce <AudioPlay_Demo+0x2ee>
    if (CheckForUserInput() > 0)
 808f4dc:	f001 ff44 	bl	8091368 <CheckForUserInput>
 808f4e0:	2800      	cmp	r0, #0
 808f4e2:	d09a      	beq.n	808f41a <AudioPlay_Demo+0x23a>
 808f4e4:	e7c2      	b.n	808f46c <AudioPlay_Demo+0x28c>
        uwPauseEnabledStatus = 0;
 808f4e6:	f04f 0b00 	mov.w	fp, #0
 808f4ea:	9301      	str	r3, [sp, #4]
        BSP_AUDIO_OUT_Resume();
 808f4ec:	f7f3 f974 	bl	80827d8 <BSP_AUDIO_OUT_Resume>
        uwPauseEnabledStatus = 0;
 808f4f0:	f8c5 b000 	str.w	fp, [r5]
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       PLAYING...     ", CENTER_MODE);
 808f4f4:	f7f3 feb6 	bl	8083264 <BSP_LCD_GetYSize>
 808f4f8:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808f4fc:	9b01      	ldr	r3, [sp, #4]
 808f4fe:	4658      	mov	r0, fp
 808f500:	4642      	mov	r2, r8
 808f502:	b289      	uxth	r1, r1
 808f504:	f7f4 f898 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808f508:	e7a5      	b.n	808f456 <AudioPlay_Demo+0x276>
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f50a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f50e:	f7f3 ff2d 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_RED);
 808f512:	2000      	movs	r0, #0
 808f514:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 808f518:	f7f3 ff0c 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 95, (uint8_t *)"  AUDIO CODEC  FAIL ", CENTER_MODE);
 808f51c:	f7f3 fea2 	bl	8083264 <BSP_LCD_GetYSize>
 808f520:	f245 7278 	movw	r2, #22392	; 0x5778
 808f524:	f1a0 015f 	sub.w	r1, r0, #95	; 0x5f
 808f528:	4633      	mov	r3, r6
 808f52a:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f52e:	2000      	movs	r0, #0
 808f530:	b289      	uxth	r1, r1
 808f532:	f7f4 f881 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)" Try to reset board ", CENTER_MODE);
 808f536:	f7f3 fe95 	bl	8083264 <BSP_LCD_GetYSize>
 808f53a:	f245 6288 	movw	r2, #22152	; 0x5688
 808f53e:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808f542:	4633      	mov	r3, r6
 808f544:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f548:	2000      	movs	r0, #0
 808f54a:	b289      	uxth	r1, r1
 808f54c:	f7f4 f874 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808f550:	e6f5      	b.n	808f33e <AudioPlay_Demo+0x15e>
          uwVolume += 5;
 808f552:	6823      	ldr	r3, [r4, #0]
 808f554:	3305      	adds	r3, #5
 808f556:	6023      	str	r3, [r4, #0]
 808f558:	e7a3      	b.n	808f4a2 <AudioPlay_Demo+0x2c2>
      else if (TS_State.touchY[0] > (BSP_LCD_GetYSize() - 30))
 808f55a:	f7f3 fe83 	bl	8083264 <BSP_LCD_GetYSize>
 808f55e:	381e      	subs	r0, #30
 808f560:	4583      	cmp	fp, r0
 808f562:	d92a      	bls.n	808f5ba <AudioPlay_Demo+0x3da>
        if (uwVolume > 5)
 808f564:	6823      	ldr	r3, [r4, #0]
 808f566:	2b05      	cmp	r3, #5
 808f568:	d94e      	bls.n	808f608 <AudioPlay_Demo+0x428>
          uwVolume -= 5;
 808f56a:	6823      	ldr	r3, [r4, #0]
 808f56c:	3b05      	subs	r3, #5
 808f56e:	6023      	str	r3, [r4, #0]
 808f570:	e797      	b.n	808f4a2 <AudioPlay_Demo+0x2c2>
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f572:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f576:	f7f3 fef9 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_RED);
 808f57a:	2000      	movs	r0, #0
 808f57c:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 808f580:	f7f3 fed8 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 65, (uint8_t *)"ERROR", CENTER_MODE);
 808f584:	f7f3 fe6e 	bl	8083264 <BSP_LCD_GetYSize>
 808f588:	f645 6264 	movw	r2, #24164	; 0x5e64
 808f58c:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 808f590:	2301      	movs	r3, #1
 808f592:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f596:	2000      	movs	r0, #0
 808f598:	b289      	uxth	r1, r1
 808f59a:	f7f4 f84d 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 50, (uint8_t *)"Touchscreen cannot be initialized", CENTER_MODE);
 808f59e:	f7f3 fe61 	bl	8083264 <BSP_LCD_GetYSize>
 808f5a2:	f245 7290 	movw	r2, #22416	; 0x5790
 808f5a6:	f1a0 0132 	sub.w	r1, r0, #50	; 0x32
 808f5aa:	2301      	movs	r3, #1
 808f5ac:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f5b0:	2000      	movs	r0, #0
 808f5b2:	b289      	uxth	r1, r1
 808f5b4:	f7f4 f840 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808f5b8:	e6cd      	b.n	808f356 <AudioPlay_Demo+0x176>
      else if (TS_State.touchX[0] < 30)
 808f5ba:	f8bd b00e 	ldrh.w	fp, [sp, #14]
 808f5be:	f1bb 0f1d 	cmp.w	fp, #29
 808f5c2:	d824      	bhi.n	808f60e <AudioPlay_Demo+0x42e>
        if (*AudioFreq_ptr != 8000)
 808f5c4:	f8da 3000 	ldr.w	r3, [sl]
 808f5c8:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
 808f5cc:	d017      	beq.n	808f5fe <AudioPlay_Demo+0x41e>
          sprintf((char*)FreqStr, "      FREQ: %6lu     ", *AudioFreq_ptr);
 808f5ce:	f245 71e8 	movw	r1, #22504	; 0x57e8
 808f5d2:	f85a 2c04 	ldr.w	r2, [sl, #-4]
 808f5d6:	a80e      	add	r0, sp, #56	; 0x38
          AudioFreq_ptr--;
 808f5d8:	f1aa 0b04 	sub.w	fp, sl, #4
          sprintf((char*)FreqStr, "      FREQ: %6lu     ", *AudioFreq_ptr);
 808f5dc:	f6c0 0109 	movt	r1, #2057	; 0x809
 808f5e0:	f002 fd78 	bl	80920d4 <siprintf>
          BSP_AUDIO_OUT_Pause();
 808f5e4:	f7f3 f8e2 	bl	80827ac <BSP_AUDIO_OUT_Pause>
          BSP_AUDIO_OUT_SetFrequency(*AudioFreq_ptr);
 808f5e8:	f85a 0c04 	ldr.w	r0, [sl, #-4]
          BSP_AUDIO_OUT_SetFrequency(*AudioFreq_ptr);
 808f5ec:	f7f3 fafe 	bl	8082bec <BSP_AUDIO_OUT_SetFrequency>
          AudioFreq_ptr++;
 808f5f0:	46da      	mov	sl, fp
          BSP_AUDIO_OUT_Resume();
 808f5f2:	f7f3 f8f1 	bl	80827d8 <BSP_AUDIO_OUT_Resume>
          BSP_AUDIO_OUT_SetVolume(uwVolume);
 808f5f6:	6820      	ldr	r0, [r4, #0]
 808f5f8:	b2c0      	uxtb	r0, r0
 808f5fa:	f7f3 f921 	bl	8082840 <BSP_AUDIO_OUT_SetVolume>
        BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 50, (uint8_t *)FreqStr, CENTER_MODE);
 808f5fe:	f7f3 fe31 	bl	8083264 <BSP_LCD_GetYSize>
 808f602:	f1a0 0132 	sub.w	r1, r0, #50	; 0x32
 808f606:	e75c      	b.n	808f4c2 <AudioPlay_Demo+0x2e2>
          uwVolume = 0;
 808f608:	2300      	movs	r3, #0
 808f60a:	6023      	str	r3, [r4, #0]
 808f60c:	e749      	b.n	808f4a2 <AudioPlay_Demo+0x2c2>
      else if (TS_State.touchX[0] > (BSP_LCD_GetXSize() - 30))
 808f60e:	f7f3 fe1b 	bl	8083248 <BSP_LCD_GetXSize>
 808f612:	381e      	subs	r0, #30
 808f614:	4583      	cmp	fp, r0
 808f616:	f67f af5a 	bls.w	808f4ce <AudioPlay_Demo+0x2ee>
        if (*AudioFreq_ptr != 96000)
 808f61a:	f8da 3000 	ldr.w	r3, [sl]
 808f61e:	454b      	cmp	r3, r9
 808f620:	d0ed      	beq.n	808f5fe <AudioPlay_Demo+0x41e>
          sprintf((char*)FreqStr, "      FREQ: %6lu     ", *AudioFreq_ptr);
 808f622:	f245 71e8 	movw	r1, #22504	; 0x57e8
 808f626:	f8da 2004 	ldr.w	r2, [sl, #4]
 808f62a:	a80e      	add	r0, sp, #56	; 0x38
          AudioFreq_ptr++;
 808f62c:	f10a 0b04 	add.w	fp, sl, #4
          sprintf((char*)FreqStr, "      FREQ: %6lu     ", *AudioFreq_ptr);
 808f630:	f6c0 0109 	movt	r1, #2057	; 0x809
 808f634:	f002 fd4e 	bl	80920d4 <siprintf>
          BSP_AUDIO_OUT_Pause();
 808f638:	f7f3 f8b8 	bl	80827ac <BSP_AUDIO_OUT_Pause>
          BSP_AUDIO_OUT_SetFrequency(*AudioFreq_ptr);
 808f63c:	f8da 0004 	ldr.w	r0, [sl, #4]
 808f640:	e7d4      	b.n	808f5ec <AudioPlay_Demo+0x40c>
 808f642:	bf00      	nop

0808f644 <Audio_Test_Process>:
  switch(audio_state)
 808f644:	f64b 53d4 	movw	r3, #48596	; 0xbdd4
 808f648:	f2c2 0300 	movt	r3, #8192	; 0x2000
 808f64c:	781b      	ldrb	r3, [r3, #0]
 808f64e:	2b02      	cmp	r3, #2
 808f650:	d101      	bne.n	808f656 <Audio_Test_Process+0x12>
 808f652:	f7ff bcdb 	b.w	808f00c <Audio_Test_Process.part.0>
}
 808f656:	2001      	movs	r0, #1
 808f658:	4770      	bx	lr
 808f65a:	bf00      	nop

0808f65c <BSP_AUDIO_OUT_Error_CallBack>:
  * @retval None
  */
void BSP_AUDIO_OUT_Error_CallBack(void)
{
  /* Display message on the LCD screen */
  BSP_LCD_SetBackColor(LCD_COLOR_RED);
 808f65c:	2000      	movs	r0, #0
{
 808f65e:	b508      	push	{r3, lr}
  BSP_LCD_SetBackColor(LCD_COLOR_RED);
 808f660:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 808f664:	f7f3 fe82 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_DisplayStringAtLine(14, (uint8_t *)"       DMA  ERROR     ");
 808f668:	f645 0118 	movw	r1, #22552	; 0x5818
 808f66c:	200e      	movs	r0, #14
 808f66e:	f6c0 0109 	movt	r1, #2057	; 0x809
 808f672:	f7f4 f841 	bl	80836f8 <BSP_LCD_DisplayStringAtLine>

  /* Stop the program with an infinite loop */
  while (BSP_PB_GetState(BUTTON_KEY) != RESET)
 808f676:	2002      	movs	r0, #2
    return;
  }

  /* could also generate a system reset to recover from the error */
  /* .... */
}
 808f678:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  while (BSP_PB_GetState(BUTTON_KEY) != RESET)
 808f67c:	f7f2 bd40 	b.w	8082100 <BSP_PB_GetState>

0808f680 <AudioRec_demo>:
  * @brief  Audio Play demo
  * @param  None
  * @retval None
  */
void AudioRec_demo (void)
{
 808f680:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  * @retval None
  */
static void AudioRec_SetHint(void)
{
  /* Clear the LCD */
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 808f684:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f688:	f7f3 fea0 	bl	80833cc <BSP_LCD_Clear>

  /* Set Audio Demo description */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f68c:	20ff      	movs	r0, #255	; 0xff
 808f68e:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f692:	f7f3 fe4f 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 90);
 808f696:	f7f3 fdd7 	bl	8083248 <BSP_LCD_GetXSize>
 808f69a:	2100      	movs	r1, #0
 808f69c:	b282      	uxth	r2, r0
 808f69e:	235a      	movs	r3, #90	; 0x5a
 808f6a0:	4608      	mov	r0, r1
 808f6a2:	f7f4 fb35 	bl	8083d10 <BSP_LCD_FillRect>
  BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808f6a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f6aa:	f7f3 fe43 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 808f6ae:	20ff      	movs	r0, #255	; 0xff
 808f6b0:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f6b4:	f7f3 fe5a 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetFont(&Font24);
 808f6b8:	f24b 3064 	movw	r0, #45924	; 0xb364
 808f6bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808f6c0:	f7f3 fe64 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"AUDIO RECORD EXAMPLE", CENTER_MODE);
 808f6c4:	2100      	movs	r1, #0
 808f6c6:	f645 0230 	movw	r2, #22576	; 0x5830
 808f6ca:	2301      	movs	r3, #1
 808f6cc:	4608      	mov	r0, r1
 808f6ce:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f6d2:	f7f3 ffb1 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetFont(&Font12);
 808f6d6:	f24b 304c 	movw	r0, #45900	; 0xb34c
 808f6da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808f6de:	f7f3 fe55 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"Press User button for next menu", CENTER_MODE);
 808f6e2:	f245 6230 	movw	r2, #22064	; 0x5630
 808f6e6:	2301      	movs	r3, #1
 808f6e8:	211e      	movs	r1, #30
 808f6ea:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f6ee:	2000      	movs	r0, #0
 808f6f0:	f7f3 ffa2 	bl	8083638 <BSP_LCD_DisplayStringAt>

  /* Set the LCD Text Color */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f6f4:	20ff      	movs	r0, #255	; 0xff
 808f6f6:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f6fa:	f7f3 fe1b 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DrawRect(10, 100, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 110);
 808f6fe:	f7f3 fda3 	bl	8083248 <BSP_LCD_GetXSize>
 808f702:	4604      	mov	r4, r0
 808f704:	f7f3 fdae 	bl	8083264 <BSP_LCD_GetYSize>
 808f708:	f1a0 036e 	sub.w	r3, r0, #110	; 0x6e
 808f70c:	f1a4 0214 	sub.w	r2, r4, #20
 808f710:	2164      	movs	r1, #100	; 0x64
 808f712:	b29b      	uxth	r3, r3
 808f714:	200a      	movs	r0, #10
 808f716:	b292      	uxth	r2, r2
 808f718:	f7f3 fee4 	bl	80834e4 <BSP_LCD_DrawRect>
  BSP_LCD_DrawRect(11, 101, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 112);
 808f71c:	f7f3 fd94 	bl	8083248 <BSP_LCD_GetXSize>
 808f720:	4604      	mov	r4, r0
 808f722:	f7f3 fd9f 	bl	8083264 <BSP_LCD_GetYSize>
 808f726:	f1a0 0370 	sub.w	r3, r0, #112	; 0x70
 808f72a:	f1a4 0216 	sub.w	r2, r4, #22
 808f72e:	2165      	movs	r1, #101	; 0x65
 808f730:	200b      	movs	r0, #11
 808f732:	b29b      	uxth	r3, r3
 808f734:	b292      	uxth	r2, r2
 808f736:	f7f3 fed5 	bl	80834e4 <BSP_LCD_DrawRect>
  if (BSP_AUDIO_IN_Init(DEFAULT_AUDIO_IN_FREQ, DEFAULT_AUDIO_IN_BIT_RESOLUTION, DEFAULT_AUDIO_IN_CHANNEL_NBR) == AUDIO_OK)
 808f73a:	2202      	movs	r2, #2
 808f73c:	2110      	movs	r1, #16
 808f73e:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
 808f742:	f7f3 fb9b 	bl	8082e7c <BSP_AUDIO_IN_Init>
 808f746:	2800      	cmp	r0, #0
 808f748:	f040 80ba 	bne.w	808f8c0 <AudioRec_demo+0x240>
 808f74c:	4604      	mov	r4, r0
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f74e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f752:	f7f3 fe0b 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 808f756:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
 808f75a:	f7f3 fdeb 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 95, (uint8_t *)"  AUDIO RECORD INIT OK  ", CENTER_MODE);
 808f75e:	f7f3 fd81 	bl	8083264 <BSP_LCD_GetYSize>
 808f762:	f245 6250 	movw	r2, #22096	; 0x5650
 808f766:	f1a0 015f 	sub.w	r1, r0, #95	; 0x5f
 808f76a:	2301      	movs	r3, #1
 808f76c:	4620      	mov	r0, r4
 808f76e:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f772:	b289      	uxth	r1, r1
 808f774:	f7f3 ff60 	bl	8083638 <BSP_LCD_DisplayStringAt>
  audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808f778:	f24f 04f0 	movw	r4, #61680	; 0xf0f0
 808f77c:	2500      	movs	r5, #0
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f77e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2) + (AUDIO_BLOCK_SIZE)),
 808f782:	f64f 0900 	movw	r9, #63488	; 0xf800
  audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808f786:	f2c2 0402 	movt	r4, #8194	; 0x2002
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2)),
 808f78a:	f24c 57ec 	movw	r7, #50668	; 0xc5ec
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2) + (AUDIO_BLOCK_SIZE)),
 808f78e:	f2cc 0907 	movt	r9, #49159	; 0xc007
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2)),
 808f792:	f64f 0600 	movw	r6, #63488	; 0xf800
  audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808f796:	6025      	str	r5, [r4, #0]
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f798:	f7f3 fde8 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f79c:	20ff      	movs	r0, #255	; 0xff
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2)),
 808f79e:	f2c2 0700 	movt	r7, #8192	; 0x2000
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2) + (AUDIO_BLOCK_SIZE)),
 808f7a2:	f509 497f 	add.w	r9, r9, #65280	; 0xff00
  BSP_AUDIO_IN_Record(internal_buffer, AUDIO_BLOCK_SIZE);
 808f7a6:	46a8      	mov	r8, r5
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f7a8:	f6cf 7000 	movt	r0, #65280	; 0xff00
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2)),
 808f7ac:	f2cc 0607 	movt	r6, #49159	; 0xc007
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f7b0:	f7f3 fdc0 	bl	8083334 <BSP_LCD_SetTextColor>
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2) + (AUDIO_BLOCK_SIZE)),
 808f7b4:	f109 09fe 	add.w	r9, r9, #254	; 0xfe
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"       RECORDING...     ", CENTER_MODE);
 808f7b8:	f7f3 fd54 	bl	8083264 <BSP_LCD_GetYSize>
 808f7bc:	f645 0248 	movw	r2, #22600	; 0x5848
 808f7c0:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808f7c4:	2301      	movs	r3, #1
 808f7c6:	4628      	mov	r0, r5
 808f7c8:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f7cc:	b289      	uxth	r1, r1
 808f7ce:	f7f3 ff33 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_AUDIO_IN_Record(internal_buffer, AUDIO_BLOCK_SIZE);
 808f7d2:	f64f 71fe 	movw	r1, #65534	; 0xfffe
 808f7d6:	4638      	mov	r0, r7
 808f7d8:	f7f3 fa22 	bl	8082c20 <BSP_AUDIO_IN_Record>
 808f7dc:	e003      	b.n	808f7e6 <AudioRec_demo+0x166>
      if (CheckForUserInput() > 0)
 808f7de:	f001 fdc3 	bl	8091368 <CheckForUserInput>
 808f7e2:	2800      	cmp	r0, #0
 808f7e4:	d167      	bne.n	808f8b6 <AudioRec_demo+0x236>
    while(audio_rec_buffer_state != BUFFER_OFFSET_HALF)
 808f7e6:	6823      	ldr	r3, [r4, #0]
 808f7e8:	2b01      	cmp	r3, #1
 808f7ea:	d1f8      	bne.n	808f7de <AudioRec_demo+0x15e>
    audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808f7ec:	2300      	movs	r3, #0
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2)),
 808f7ee:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 808f7f2:	4639      	mov	r1, r7
 808f7f4:	eb06 0008 	add.w	r0, r6, r8
    audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808f7f8:	6023      	str	r3, [r4, #0]
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2)),
 808f7fa:	f002 fc57 	bl	80920ac <memcpy>
    while(audio_rec_buffer_state != BUFFER_OFFSET_FULL)
 808f7fe:	e003      	b.n	808f808 <AudioRec_demo+0x188>
      if (CheckForUserInput() > 0)
 808f800:	f001 fdb2 	bl	8091368 <CheckForUserInput>
 808f804:	2800      	cmp	r0, #0
 808f806:	d156      	bne.n	808f8b6 <AudioRec_demo+0x236>
    while(audio_rec_buffer_state != BUFFER_OFFSET_FULL)
 808f808:	6825      	ldr	r5, [r4, #0]
 808f80a:	2d02      	cmp	r5, #2
 808f80c:	d1f8      	bne.n	808f800 <AudioRec_demo+0x180>
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2) + (AUDIO_BLOCK_SIZE)),
 808f80e:	f24c 51ec 	movw	r1, #50668	; 0xc5ec
    audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808f812:	f04f 0a00 	mov.w	sl, #0
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2) + (AUDIO_BLOCK_SIZE)),
 808f816:	eb09 0008 	add.w	r0, r9, r8
 808f81a:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 808f81e:	f2c2 0100 	movt	r1, #8192	; 0x2000
    audio_rec_buffer_state = BUFFER_OFFSET_NONE;
 808f822:	f8c4 a000 	str.w	sl, [r4]
 808f826:	f508 38ff 	add.w	r8, r8, #130560	; 0x1fe00
    memcpy((uint32_t *)(AUDIO_REC_START_ADDR + (block_number * AUDIO_BLOCK_SIZE * 2) + (AUDIO_BLOCK_SIZE)),
 808f82a:	f501 417f 	add.w	r1, r1, #65280	; 0xff00
 808f82e:	f508 78fe 	add.w	r8, r8, #508	; 0x1fc
 808f832:	31fe      	adds	r1, #254	; 0xfe
 808f834:	f002 fc3a 	bl	80920ac <memcpy>
  for (block_number = 0; block_number < AUDIO_NB_BLOCKS; block_number++)
 808f838:	f64f 73f0 	movw	r3, #65520	; 0xfff0
 808f83c:	f2c0 0307 	movt	r3, #7
 808f840:	4598      	cmp	r8, r3
 808f842:	d1d0      	bne.n	808f7e6 <AudioRec_demo+0x166>
  BSP_AUDIO_IN_Stop(CODEC_PDWN_SW);
 808f844:	4628      	mov	r0, r5
 808f846:	f7f3 f9f7 	bl	8082c38 <BSP_AUDIO_IN_Stop>
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f84a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f84e:	f7f3 fd8d 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f852:	20ff      	movs	r0, #255	; 0xff
 808f854:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f858:	f7f3 fd6c 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 65, (uint8_t *)"RECORDING DONE, START PLAYBACK...", CENTER_MODE);
 808f85c:	f7f3 fd02 	bl	8083264 <BSP_LCD_GetYSize>
 808f860:	f645 0264 	movw	r2, #22628	; 0x5864
 808f864:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 808f868:	2301      	movs	r3, #1
 808f86a:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f86e:	4650      	mov	r0, sl
 808f870:	b289      	uxth	r1, r1
 808f872:	f7f3 fee1 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_BOTH, 70, DEFAULT_AUDIO_IN_FREQ);
 808f876:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
 808f87a:	2146      	movs	r1, #70	; 0x46
 808f87c:	2003      	movs	r0, #3
 808f87e:	f7f3 f939 	bl	8082af4 <BSP_AUDIO_OUT_Init>
  BSP_AUDIO_OUT_SetAudioFrameSlot(CODEC_AUDIOFRAME_SLOT_02);
 808f882:	2005      	movs	r0, #5
 808f884:	f7f2 ffea 	bl	808285c <BSP_AUDIO_OUT_SetAudioFrameSlot>
  AUDIO_Start(AUDIO_REC_START_ADDR, AUDIO_BLOCK_SIZE * AUDIO_NB_BLOCKS * 2);  /* Use Audio play demo to playback sound */
 808f888:	4641      	mov	r1, r8
 808f88a:	4630      	mov	r0, r6
 808f88c:	f7fc ffcc 	bl	808c828 <AUDIO_Start>
  BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 40, (uint8_t *)"PLAYBACK DONE", CENTER_MODE);
 808f890:	f7f3 fce8 	bl	8083264 <BSP_LCD_GetYSize>
 808f894:	f645 0288 	movw	r2, #22664	; 0x5888
 808f898:	f1a0 0128 	sub.w	r1, r0, #40	; 0x28
 808f89c:	2301      	movs	r3, #1
 808f89e:	4650      	mov	r0, sl
 808f8a0:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f8a4:	b289      	uxth	r1, r1
 808f8a6:	f7f3 fec7 	bl	8083638 <BSP_LCD_DisplayStringAt>
    Audio_Test_Process();
 808f8aa:	f7ff fecb 	bl	808f644 <Audio_Test_Process>
    if (CheckForUserInput() > 0)
 808f8ae:	f001 fd5b 	bl	8091368 <CheckForUserInput>
 808f8b2:	2800      	cmp	r0, #0
 808f8b4:	d0f9      	beq.n	808f8aa <AudioRec_demo+0x22a>
        BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 808f8b6:	2002      	movs	r0, #2
}
 808f8b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        BSP_AUDIO_OUT_Stop(CODEC_PDWN_SW);
 808f8bc:	f7f2 bfa2 	b.w	8082804 <BSP_AUDIO_OUT_Stop>
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808f8c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f8c4:	f7f3 fd52 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_RED);
 808f8c8:	2000      	movs	r0, #0
 808f8ca:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 808f8ce:	f7f3 fd31 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 95, (uint8_t *)"  AUDIO RECORD INIT FAIL", CENTER_MODE);
 808f8d2:	f7f3 fcc7 	bl	8083264 <BSP_LCD_GetYSize>
 808f8d6:	f245 626c 	movw	r2, #22124	; 0x566c
 808f8da:	f1a0 015f 	sub.w	r1, r0, #95	; 0x5f
 808f8de:	2301      	movs	r3, #1
 808f8e0:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f8e4:	2000      	movs	r0, #0
 808f8e6:	b289      	uxth	r1, r1
 808f8e8:	f7f3 fea6 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)" Try to reset board ", CENTER_MODE);
 808f8ec:	f7f3 fcba 	bl	8083264 <BSP_LCD_GetYSize>
 808f8f0:	f245 6288 	movw	r2, #22152	; 0x5688
 808f8f4:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 808f8f8:	2301      	movs	r3, #1
 808f8fa:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f8fe:	2000      	movs	r0, #0
 808f900:	b289      	uxth	r1, r1
 808f902:	f7f3 fe99 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808f906:	e737      	b.n	808f778 <AudioRec_demo+0xf8>

0808f908 <BSP_AUDIO_IN_TransferComplete_CallBack>:
  * @param None
  * @retval None
  */
void BSP_AUDIO_IN_TransferComplete_CallBack(void)
{
  audio_rec_buffer_state = BUFFER_OFFSET_FULL;
 808f908:	f24f 03f0 	movw	r3, #61680	; 0xf0f0
 808f90c:	2202      	movs	r2, #2
 808f90e:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808f912:	601a      	str	r2, [r3, #0]
  return;
}
 808f914:	4770      	bx	lr
 808f916:	bf00      	nop

0808f918 <BSP_AUDIO_IN_HalfTransfer_CallBack>:
  * @param  None
  * @retval None
  */
void BSP_AUDIO_IN_HalfTransfer_CallBack(void)
{
  audio_rec_buffer_state = BUFFER_OFFSET_HALF;
 808f918:	f24f 03f0 	movw	r3, #61680	; 0xf0f0
 808f91c:	2201      	movs	r2, #1
 808f91e:	f2c2 0302 	movt	r3, #8194	; 0x2002
 808f922:	601a      	str	r2, [r3, #0]
  return;
}
 808f924:	4770      	bx	lr
 808f926:	bf00      	nop

0808f928 <BSP_AUDIO_IN_Error_CallBack>:
void BSP_AUDIO_IN_Error_CallBack(void)
{
  /* This function is called when an Interrupt due to transfer error on or peripheral
     error occurs. */
  /* Display message on the LCD screen */
  BSP_LCD_SetBackColor(LCD_COLOR_RED);
 808f928:	2000      	movs	r0, #0
{
 808f92a:	b508      	push	{r3, lr}
  BSP_LCD_SetBackColor(LCD_COLOR_RED);
 808f92c:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 808f930:	f7f3 fd1c 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_DisplayStringAt(0, LINE(14), (uint8_t *)"       DMA  ERROR     ", CENTER_MODE);
 808f934:	f7f3 fd3a 	bl	80833ac <BSP_LCD_GetFont>
 808f938:	88c1      	ldrh	r1, [r0, #6]
 808f93a:	2301      	movs	r3, #1
 808f93c:	f645 0218 	movw	r2, #22552	; 0x5818
 808f940:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 808f944:	2000      	movs	r0, #0
 808f946:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f94a:	4099      	lsls	r1, r3
 808f94c:	b289      	uxth	r1, r1
 808f94e:	f7f3 fe73 	bl	8083638 <BSP_LCD_DisplayStringAt>

  /* Stop the program with an infinite loop */
  while (BSP_PB_GetState(BUTTON_KEY) != RESET)
 808f952:	2002      	movs	r0, #2
  {
    return;
  }
  /* could also generate a system reset to recover from the error */
  /* .... */
}
 808f954:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  while (BSP_PB_GetState(BUTTON_KEY) != RESET)
 808f958:	f7f2 bbd2 	b.w	8082100 <BSP_PB_GetState>

0808f95c <FATFSSD_demo>:
 * @brief  SD Demo
 * @param  None
 * @retval None
 */
void FATFSSD_demo (void)
{
 808f95c:	b510      	push	{r4, lr}
 * @retval None
 */
static void SD_SetHint(void)
{
	/* Clear the LCD */
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 808f95e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
{
 808f962:	f5ad 6da5 	sub.w	sp, sp, #1320	; 0x528
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 808f966:	f7f3 fd31 	bl	80833cc <BSP_LCD_Clear>

	/* Set LCD Demo description */
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f96a:	20ff      	movs	r0, #255	; 0xff
 808f96c:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f970:	f7f3 fce0 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 808f974:	f7f3 fc68 	bl	8083248 <BSP_LCD_GetXSize>
 808f978:	2100      	movs	r1, #0
 808f97a:	b282      	uxth	r2, r0
 808f97c:	2350      	movs	r3, #80	; 0x50
 808f97e:	4608      	mov	r0, r1
 808f980:	f7f4 f9c6 	bl	8083d10 <BSP_LCD_FillRect>
	BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808f984:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808f988:	f7f3 fcd4 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 808f98c:	20ff      	movs	r0, #255	; 0xff
 808f98e:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f992:	f7f3 fceb 	bl	808336c <BSP_LCD_SetBackColor>
	BSP_LCD_SetFont(&Font24);
 808f996:	f24b 3064 	movw	r0, #45924	; 0xb364
 808f99a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808f99e:	f7f3 fcf5 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"FATFS", CENTER_MODE);
 808f9a2:	2100      	movs	r1, #0
 808f9a4:	f645 0298 	movw	r2, #22680	; 0x5898
 808f9a8:	2301      	movs	r3, #1
 808f9aa:	4608      	mov	r0, r1
 808f9ac:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f9b0:	f7f3 fe42 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_SetFont(&Font12);
 808f9b4:	f24b 304c 	movw	r0, #45900	; 0xb34c
 808f9b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808f9bc:	f7f3 fce6 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows how to write", CENTER_MODE);
 808f9c0:	f645 02a0 	movw	r2, #22688	; 0x58a0
 808f9c4:	2301      	movs	r3, #1
 808f9c6:	211e      	movs	r1, #30
 808f9c8:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f9cc:	2000      	movs	r0, #0
 808f9ce:	f7f3 fe33 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"and read data on the SD card ", CENTER_MODE);
 808f9d2:	f645 02c0 	movw	r2, #22720	; 0x58c0
 808f9d6:	2301      	movs	r3, #1
 808f9d8:	212d      	movs	r1, #45	; 0x2d
 808f9da:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f9de:	2000      	movs	r0, #0
 808f9e0:	f7f3 fe2a 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(0, 60, (uint8_t *)"using FATFS", CENTER_MODE);
 808f9e4:	f645 02e0 	movw	r2, #22752	; 0x58e0
 808f9e8:	2301      	movs	r3, #1
 808f9ea:	213c      	movs	r1, #60	; 0x3c
 808f9ec:	f6c0 0209 	movt	r2, #2057	; 0x809
 808f9f0:	2000      	movs	r0, #0
 808f9f2:	f7f3 fe21 	bl	8083638 <BSP_LCD_DisplayStringAt>

	/* Set the LCD Text Color */
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808f9f6:	20ff      	movs	r0, #255	; 0xff
 808f9f8:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808f9fc:	f7f3 fc9a 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 100);
 808fa00:	f7f3 fc22 	bl	8083248 <BSP_LCD_GetXSize>
 808fa04:	4604      	mov	r4, r0
 808fa06:	f7f3 fc2d 	bl	8083264 <BSP_LCD_GetYSize>
 808fa0a:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 808fa0e:	f1a4 0214 	sub.w	r2, r4, #20
 808fa12:	215a      	movs	r1, #90	; 0x5a
 808fa14:	b29b      	uxth	r3, r3
 808fa16:	200a      	movs	r0, #10
 808fa18:	b292      	uxth	r2, r2
 808fa1a:	f7f3 fd63 	bl	80834e4 <BSP_LCD_DrawRect>
	BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 102);
 808fa1e:	f7f3 fc13 	bl	8083248 <BSP_LCD_GetXSize>
 808fa22:	4604      	mov	r4, r0
 808fa24:	f7f3 fc1e 	bl	8083264 <BSP_LCD_GetYSize>
 808fa28:	f1a0 0366 	sub.w	r3, r0, #102	; 0x66
 808fa2c:	f1a4 0216 	sub.w	r2, r4, #22
 808fa30:	215b      	movs	r1, #91	; 0x5b
 808fa32:	b29b      	uxth	r3, r3
 808fa34:	200b      	movs	r0, #11
 808fa36:	b292      	uxth	r2, r2
 808fa38:	f7f3 fd54 	bl	80834e4 <BSP_LCD_DrawRect>

	BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fa3c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fa40:	f7f3 fc78 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fa44:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fa48:	f7f3 fc90 	bl	808336c <BSP_LCD_SetBackColor>
	SD_state = BSP_SD_Init();
 808fa4c:	f7f5 fa9e 	bl	8084f8c <BSP_SD_Init>
	if (SD_state != MSD_OK)
 808fa50:	2800      	cmp	r0, #0
 808fa52:	f000 80c9 	beq.w	808fbe8 <FATFSSD_demo+0x28c>
		if(SD_state == MSD_ERROR_SD_NOT_PRESENT)
 808fa56:	2802      	cmp	r0, #2
 808fa58:	f000 8099 	beq.w	808fb8e <FATFSSD_demo+0x232>
			BSP_LCD_DisplayStringAt(20, 100, (uint8_t *)"SD Initialization : FAIL.", LEFT_MODE);
 808fa5c:	f645 1218 	movw	r2, #22808	; 0x5918
 808fa60:	2303      	movs	r3, #3
 808fa62:	2164      	movs	r1, #100	; 0x64
 808fa64:	2014      	movs	r0, #20
 808fa66:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fa6a:	f7f3 fde5 	bl	8083638 <BSP_LCD_DisplayStringAt>
		BSP_LCD_DisplayStringAt(20, 115, (uint8_t *)"SD Test Aborted.", LEFT_MODE);
 808fa6e:	f645 1234 	movw	r2, #22836	; 0x5934
 808fa72:	2303      	movs	r3, #3
 808fa74:	2173      	movs	r1, #115	; 0x73
 808fa76:	2014      	movs	r0, #20
 808fa78:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fa7c:	f7f3 fddc 	bl	8083638 <BSP_LCD_DisplayStringAt>
	res = f_mount(&FATFS_Obj, "0:" ,0);
 808fa80:	f645 1160 	movw	r1, #22880	; 0x5960
 808fa84:	2200      	movs	r2, #0
 808fa86:	a8bc      	add	r0, sp, #752	; 0x2f0
 808fa88:	f6c0 0109 	movt	r1, #2057	; 0x809
 808fa8c:	f7fe fdc8 	bl	808e620 <f_mount>
	res = f_open(&fp, "/essai.txt", FA_READ|FA_WRITE);
 808fa90:	f645 1164 	movw	r1, #22884	; 0x5964
	res = f_mount(&FATFS_Obj, "0:" ,0);
 808fa94:	4603      	mov	r3, r0
	res = f_open(&fp, "/essai.txt", FA_READ|FA_WRITE);
 808fa96:	2203      	movs	r2, #3
 808fa98:	a832      	add	r0, sp, #200	; 0xc8
 808fa9a:	f6c0 0109 	movt	r1, #2057	; 0x809
	res = f_mount(&FATFS_Obj, "0:" ,0);
 808fa9e:	f88d 3007 	strb.w	r3, [sp, #7]
	res = f_open(&fp, "/essai.txt", FA_READ|FA_WRITE);
 808faa2:	f7fe fde7 	bl	808e674 <f_open>
 808faa6:	f88d 0007 	strb.w	r0, [sp, #7]
	if (res != FR_OK) BSP_LCD_DisplayStringAt(20, 120, (uint8_t *)"File opening : Failed.", LEFT_MODE);
 808faaa:	f89d 3007 	ldrb.w	r3, [sp, #7]
 808faae:	2b00      	cmp	r3, #0
 808fab0:	f000 8090 	beq.w	808fbd4 <FATFSSD_demo+0x278>
 808fab4:	f645 1270 	movw	r2, #22896	; 0x5970
 808fab8:	2303      	movs	r3, #3
 808faba:	2178      	movs	r1, #120	; 0x78
 808fabc:	2014      	movs	r0, #20
 808fabe:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fac2:	f7f3 fdb9 	bl	8083638 <BSP_LCD_DisplayStringAt>
	res=f_read(&fp, buffer,  20, &br);
 808fac6:	ac12      	add	r4, sp, #72	; 0x48
 808fac8:	ab02      	add	r3, sp, #8
 808faca:	2214      	movs	r2, #20
 808facc:	a832      	add	r0, sp, #200	; 0xc8
 808face:	4621      	mov	r1, r4
 808fad0:	f7fe ff04 	bl	808e8dc <f_read>
 808fad4:	f88d 0007 	strb.w	r0, [sp, #7]
	if (res != FR_OK) BSP_LCD_DisplayStringAt(20, 140, (uint8_t *)"File read : Failed.", LEFT_MODE);
 808fad8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 808fadc:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 808fae0:	2b00      	cmp	r3, #0
 808fae2:	f040 808b 	bne.w	808fbfc <FATFSSD_demo+0x2a0>
		buffer[br]='\0';
 808fae6:	9a02      	ldr	r2, [sp, #8]
		if (buffer[br-1] == '\n') buffer[br-1]='\0';
 808fae8:	1e53      	subs	r3, r2, #1
		buffer[br]='\0';
 808faea:	54a1      	strb	r1, [r4, r2]
		if (buffer[br-1] == '\n') buffer[br-1]='\0';
 808faec:	5ce0      	ldrb	r0, [r4, r3]
 808faee:	280a      	cmp	r0, #10
		sprintf((char*)&strbuff, "File read(%i): OK (%s).", br, (char*)buffer);
 808faf0:	a803      	add	r0, sp, #12
		if (buffer[br-1] == '\n') buffer[br-1]='\0';
 808faf2:	bf08      	it	eq
 808faf4:	54e1      	strbeq	r1, [r4, r3]
		sprintf((char*)&strbuff, "File read(%i): OK (%s).", br, (char*)buffer);
 808faf6:	f645 11b0 	movw	r1, #22960	; 0x59b0
 808fafa:	4623      	mov	r3, r4
 808fafc:	f6c0 0109 	movt	r1, #2057	; 0x809
 808fb00:	f002 fae8 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 140, (uint8_t *)strbuff, LEFT_MODE);
 808fb04:	aa03      	add	r2, sp, #12
 808fb06:	2303      	movs	r3, #3
 808fb08:	218c      	movs	r1, #140	; 0x8c
 808fb0a:	2014      	movs	r0, #20
 808fb0c:	f7f3 fd94 	bl	8083638 <BSP_LCD_DisplayStringAt>
	res=f_write(&fp, (char*)"/hello",  strlen("/hello"), &br);
 808fb10:	f645 11c8 	movw	r1, #22984	; 0x59c8
 808fb14:	ab02      	add	r3, sp, #8
 808fb16:	2206      	movs	r2, #6
 808fb18:	a832      	add	r0, sp, #200	; 0xc8
 808fb1a:	f6c0 0109 	movt	r1, #2057	; 0x809
 808fb1e:	f7fe ff89 	bl	808ea34 <f_write>
 808fb22:	f88d 0007 	strb.w	r0, [sp, #7]
	if (res != FR_OK) BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)"File write : Failed.", LEFT_MODE);
 808fb26:	f89d 3007 	ldrb.w	r3, [sp, #7]
 808fb2a:	2b00      	cmp	r3, #0
 808fb2c:	d043      	beq.n	808fbb6 <FATFSSD_demo+0x25a>
 808fb2e:	f645 12d0 	movw	r2, #22992	; 0x59d0
 808fb32:	2303      	movs	r3, #3
 808fb34:	21a0      	movs	r1, #160	; 0xa0
 808fb36:	2014      	movs	r0, #20
 808fb38:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fb3c:	f7f3 fd7c 	bl	8083638 <BSP_LCD_DisplayStringAt>
	res= f_sync(&fp);
 808fb40:	a832      	add	r0, sp, #200	; 0xc8
 808fb42:	f7ff f851 	bl	808ebe8 <f_sync>
 808fb46:	4603      	mov	r3, r0
	res =f_close(&fp);
 808fb48:	a832      	add	r0, sp, #200	; 0xc8
	res= f_sync(&fp);
 808fb4a:	f88d 3007 	strb.w	r3, [sp, #7]
	res =f_close(&fp);
 808fb4e:	f7ff f8a7 	bl	808eca0 <f_close>
 808fb52:	f88d 0007 	strb.w	r0, [sp, #7]
	if (res != FR_OK) BSP_LCD_DisplayStringAt(20, 180, (uint8_t *)"File close : Failed.", LEFT_MODE);
 808fb56:	f89d 3007 	ldrb.w	r3, [sp, #7]
 808fb5a:	b313      	cbz	r3, 808fba2 <FATFSSD_demo+0x246>
 808fb5c:	f645 12fc 	movw	r2, #23036	; 0x59fc
 808fb60:	2303      	movs	r3, #3
 808fb62:	21b4      	movs	r1, #180	; 0xb4
 808fb64:	2014      	movs	r0, #20
 808fb66:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fb6a:	f7f3 fd65 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(20, 200, (uint8_t *)"Test finished !", LEFT_MODE);
 808fb6e:	f645 2228 	movw	r2, #23080	; 0x5a28
 808fb72:	2303      	movs	r3, #3
 808fb74:	21c8      	movs	r1, #200	; 0xc8
 808fb76:	2014      	movs	r0, #20
 808fb78:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fb7c:	f7f3 fd5c 	bl	8083638 <BSP_LCD_DisplayStringAt>
		if (CheckForUserInput() > 0)
 808fb80:	f001 fbf2 	bl	8091368 <CheckForUserInput>
 808fb84:	2800      	cmp	r0, #0
 808fb86:	d0fb      	beq.n	808fb80 <FATFSSD_demo+0x224>
}
 808fb88:	f50d 6da5 	add.w	sp, sp, #1320	; 0x528
 808fb8c:	bd10      	pop	{r4, pc}
			BSP_LCD_DisplayStringAt(20, 100, (uint8_t *)"SD shall be inserted before running test", LEFT_MODE);
 808fb8e:	f645 02ec 	movw	r2, #22764	; 0x58ec
 808fb92:	2303      	movs	r3, #3
 808fb94:	2164      	movs	r1, #100	; 0x64
 808fb96:	2014      	movs	r0, #20
 808fb98:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fb9c:	f7f3 fd4c 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808fba0:	e765      	b.n	808fa6e <FATFSSD_demo+0x112>
	else BSP_LCD_DisplayStringAt(20, 180, (uint8_t *)"File close : OK.", LEFT_MODE);
 808fba2:	f645 2214 	movw	r2, #23060	; 0x5a14
 808fba6:	2303      	movs	r3, #3
 808fba8:	21b4      	movs	r1, #180	; 0xb4
 808fbaa:	2014      	movs	r0, #20
 808fbac:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fbb0:	f7f3 fd42 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808fbb4:	e7db      	b.n	808fb6e <FATFSSD_demo+0x212>
		sprintf((char*)&strbuff, "File write(%i): OK.", br);
 808fbb6:	f645 11e8 	movw	r1, #23016	; 0x59e8
 808fbba:	9a02      	ldr	r2, [sp, #8]
 808fbbc:	a803      	add	r0, sp, #12
 808fbbe:	f6c0 0109 	movt	r1, #2057	; 0x809
 808fbc2:	f002 fa87 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)strbuff, LEFT_MODE);
 808fbc6:	aa03      	add	r2, sp, #12
 808fbc8:	2303      	movs	r3, #3
 808fbca:	21a0      	movs	r1, #160	; 0xa0
 808fbcc:	2014      	movs	r0, #20
 808fbce:	f7f3 fd33 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808fbd2:	e7b5      	b.n	808fb40 <FATFSSD_demo+0x1e4>
	else BSP_LCD_DisplayStringAt(20, 120, (uint8_t *)"File opening : OK.", LEFT_MODE);
 808fbd4:	f645 1288 	movw	r2, #22920	; 0x5988
 808fbd8:	2303      	movs	r3, #3
 808fbda:	2178      	movs	r1, #120	; 0x78
 808fbdc:	2014      	movs	r0, #20
 808fbde:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fbe2:	f7f3 fd29 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808fbe6:	e76e      	b.n	808fac6 <FATFSSD_demo+0x16a>
		BSP_LCD_DisplayStringAt(20, 100, (uint8_t *)"SD Initialization : OK.", LEFT_MODE);
 808fbe8:	f645 1248 	movw	r2, #22856	; 0x5948
 808fbec:	2303      	movs	r3, #3
 808fbee:	2164      	movs	r1, #100	; 0x64
 808fbf0:	2014      	movs	r0, #20
 808fbf2:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fbf6:	f7f3 fd1f 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808fbfa:	e741      	b.n	808fa80 <FATFSSD_demo+0x124>
	if (res != FR_OK) BSP_LCD_DisplayStringAt(20, 140, (uint8_t *)"File read : Failed.", LEFT_MODE);
 808fbfc:	f645 129c 	movw	r2, #22940	; 0x599c
 808fc00:	2303      	movs	r3, #3
 808fc02:	218c      	movs	r1, #140	; 0x8c
 808fc04:	2014      	movs	r0, #20
 808fc06:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fc0a:	f7f3 fd15 	bl	8083638 <BSP_LCD_DisplayStringAt>
 808fc0e:	e77f      	b.n	808fb10 <FATFSSD_demo+0x1b4>

0808fc10 <Keys_demo>:
 * @brief  Keys Demo
 * @param  None
 * @retval None
 */
void Keys_demo (void)
{
 808fc10:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @retval None
 */
static void KEYS_SetHint(void)
{
	/* Clear the LCD */
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 808fc12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
{
 808fc16:	b089      	sub	sp, #36	; 0x24
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 808fc18:	f7f3 fbd8 	bl	80833cc <BSP_LCD_Clear>

	/* Set LCD Demo description */
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808fc1c:	20ff      	movs	r0, #255	; 0xff
			sprintf((char*)&strbuff, "Up");
 808fc1e:	f645 278c 	movw	r7, #23180	; 0x5a8c
			sprintf((char*)&strbuff, "Down");
 808fc22:	f645 2690 	movw	r6, #23184	; 0x5a90
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808fc26:	f6cf 7000 	movt	r0, #65280	; 0xff00
			sprintf((char*)&strbuff, "Left");
 808fc2a:	f645 2598 	movw	r5, #23192	; 0x5a98
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808fc2e:	f7f3 fb81 	bl	8083334 <BSP_LCD_SetTextColor>
			sprintf((char*)&strbuff, "Up");
 808fc32:	f6c0 0709 	movt	r7, #2057	; 0x809
	BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 808fc36:	f7f3 fb07 	bl	8083248 <BSP_LCD_GetXSize>
 808fc3a:	2100      	movs	r1, #0
 808fc3c:	b282      	uxth	r2, r0
 808fc3e:	2350      	movs	r3, #80	; 0x50
 808fc40:	4608      	mov	r0, r1
			sprintf((char*)&strbuff, "Down");
 808fc42:	f6c0 0609 	movt	r6, #2057	; 0x809
	BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 808fc46:	f7f4 f863 	bl	8083d10 <BSP_LCD_FillRect>
	BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fc4a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fc4e:	f7f3 fb71 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 808fc52:	20ff      	movs	r0, #255	; 0xff
			sprintf((char*)&strbuff, "Left");
 808fc54:	f6c0 0509 	movt	r5, #2057	; 0x809
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 808fc58:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808fc5c:	f7f3 fb86 	bl	808336c <BSP_LCD_SetBackColor>
	BSP_LCD_SetFont(&Font24);
 808fc60:	f24b 3064 	movw	r0, #45924	; 0xb364
 808fc64:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808fc68:	f7f3 fb90 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"KEYS", CENTER_MODE);
 808fc6c:	2100      	movs	r1, #0
 808fc6e:	f645 2238 	movw	r2, #23096	; 0x5a38
 808fc72:	2301      	movs	r3, #1
 808fc74:	4608      	mov	r0, r1
 808fc76:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fc7a:	f7f3 fcdd 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_SetFont(&Font12);
 808fc7e:	f24b 304c 	movw	r0, #45900	; 0xb34c
 808fc82:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808fc86:	f7f3 fb81 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows keys input", CENTER_MODE);
 808fc8a:	f645 2240 	movw	r2, #23104	; 0x5a40
 808fc8e:	2301      	movs	r3, #1
 808fc90:	211e      	movs	r1, #30
 808fc92:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fc96:	2000      	movs	r0, #0
 808fc98:	f7f3 fcce 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"Press A + Down to leave ", CENTER_MODE);
 808fc9c:	f645 2260 	movw	r2, #23136	; 0x5a60
 808fca0:	2301      	movs	r3, #1
 808fca2:	212d      	movs	r1, #45	; 0x2d
 808fca4:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fca8:	2000      	movs	r0, #0
 808fcaa:	f7f3 fcc5 	bl	8083638 <BSP_LCD_DisplayStringAt>

	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 808fcae:	20ff      	movs	r0, #255	; 0xff
 808fcb0:	f6cf 7000 	movt	r0, #65280	; 0xff00
 808fcb4:	f7f3 fb3e 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 100);
 808fcb8:	f7f3 fac6 	bl	8083248 <BSP_LCD_GetXSize>
 808fcbc:	4604      	mov	r4, r0
 808fcbe:	f7f3 fad1 	bl	8083264 <BSP_LCD_GetYSize>
 808fcc2:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 808fcc6:	f1a4 0214 	sub.w	r2, r4, #20
 808fcca:	215a      	movs	r1, #90	; 0x5a
 808fccc:	b29b      	uxth	r3, r3
 808fcce:	200a      	movs	r0, #10
 808fcd0:	b292      	uxth	r2, r2
 808fcd2:	f7f3 fc07 	bl	80834e4 <BSP_LCD_DrawRect>
	BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 102);
 808fcd6:	f7f3 fab7 	bl	8083248 <BSP_LCD_GetXSize>
 808fcda:	4604      	mov	r4, r0
 808fcdc:	f7f3 fac2 	bl	8083264 <BSP_LCD_GetYSize>
 808fce0:	f1a0 0366 	sub.w	r3, r0, #102	; 0x66
 808fce4:	f1a4 0216 	sub.w	r2, r4, #22
 808fce8:	215b      	movs	r1, #91	; 0x5b
 808fcea:	b29b      	uxth	r3, r3
 808fcec:	200b      	movs	r0, #11
 808fcee:	b292      	uxth	r2, r2
 808fcf0:	f7f3 fbf8 	bl	80834e4 <BSP_LCD_DrawRect>

	BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fcf4:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fcf8:	f7f3 fb1c 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fcfc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fd00:	f7f3 fb34 	bl	808336c <BSP_LCD_SetBackColor>
		BSP_LCD_DisplayStringAt(20, 100, (uint8_t *)"Keys init : OK.", LEFT_MODE);
 808fd04:	f645 227c 	movw	r2, #23164	; 0x5a7c
 808fd08:	2303      	movs	r3, #3
 808fd0a:	2164      	movs	r1, #100	; 0x64
 808fd0c:	f6c0 0209 	movt	r2, #2057	; 0x809
 808fd10:	2014      	movs	r0, #20
 808fd12:	f7f3 fc91 	bl	8083638 <BSP_LCD_DisplayStringAt>
		BSP_LCD_SetFont(&Font20);
 808fd16:	f24b 305c 	movw	r0, #45916	; 0xb35c
 808fd1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808fd1e:	f7f3 fb35 	bl	808338c <BSP_LCD_SetFont>
		while (BSP_KEYS_GetKeys() != (KEYS_A | KEYS_DOWN))
 808fd22:	e0a8      	b.n	808fe76 <Keys_demo+0x266>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fd24:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fd28:	f7f3 fb04 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808fd2c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fd30:	f7f3 fb1c 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(320, 180, (uint8_t *)strbuff, LEFT_MODE);
 808fd34:	2303      	movs	r3, #3
 808fd36:	21b4      	movs	r1, #180	; 0xb4
 808fd38:	466a      	mov	r2, sp
 808fd3a:	f44f 70a0 	mov.w	r0, #320	; 0x140
 808fd3e:	f7f3 fc7b 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "B");
 808fd42:	2342      	movs	r3, #66	; 0x42
			if (keys & KEYS_B)
 808fd44:	0761      	lsls	r1, r4, #29
			sprintf((char*)&strbuff, "B");
 808fd46:	f8ad 3000 	strh.w	r3, [sp]
			if (keys & KEYS_B)
 808fd4a:	f140 80da 	bpl.w	808ff02 <Keys_demo+0x2f2>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fd4e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fd52:	f7f3 faef 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808fd56:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fd5a:	f7f3 fb07 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(390, 190, (uint8_t *)strbuff, LEFT_MODE);
 808fd5e:	2303      	movs	r3, #3
 808fd60:	466a      	mov	r2, sp
 808fd62:	21be      	movs	r1, #190	; 0xbe
 808fd64:	f44f 70c3 	mov.w	r0, #390	; 0x186
 808fd68:	f7f3 fc66 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "X");
 808fd6c:	2358      	movs	r3, #88	; 0x58
			if (keys & KEYS_X)
 808fd6e:	07a2      	lsls	r2, r4, #30
			sprintf((char*)&strbuff, "X");
 808fd70:	f8ad 3000 	strh.w	r3, [sp]
			if (keys & KEYS_X)
 808fd74:	f140 80bc 	bpl.w	808fef0 <Keys_demo+0x2e0>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fd78:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fd7c:	f7f3 fada 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808fd80:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fd84:	f7f3 faf2 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(320, 140, (uint8_t *)strbuff, LEFT_MODE);
 808fd88:	2303      	movs	r3, #3
 808fd8a:	466a      	mov	r2, sp
 808fd8c:	218c      	movs	r1, #140	; 0x8c
 808fd8e:	f44f 70a0 	mov.w	r0, #320	; 0x140
 808fd92:	f7f3 fc51 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "Y");
 808fd96:	2359      	movs	r3, #89	; 0x59
 808fd98:	f8ad 3000 	strh.w	r3, [sp]
			if (keys & KEYS_Y)
 808fd9c:	07e3      	lsls	r3, r4, #31
 808fd9e:	f140 809e 	bpl.w	808fede <Keys_demo+0x2ce>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fda2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fda6:	f7f3 fac5 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808fdaa:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fdae:	f7f3 fadd 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(390, 150, (uint8_t *)strbuff, LEFT_MODE);
 808fdb2:	2303      	movs	r3, #3
 808fdb4:	466a      	mov	r2, sp
 808fdb6:	f44f 70c3 	mov.w	r0, #390	; 0x186
 808fdba:	2196      	movs	r1, #150	; 0x96
 808fdbc:	f7f3 fc3c 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "Up");
 808fdc0:	683b      	ldr	r3, [r7, #0]
			if (keys & KEYS_UP)
 808fdc2:	0620      	lsls	r0, r4, #24
			sprintf((char*)&strbuff, "Up");
 808fdc4:	ea4f 4213 	mov.w	r2, r3, lsr #16
 808fdc8:	f8ad 3000 	strh.w	r3, [sp]
 808fdcc:	f88d 2002 	strb.w	r2, [sp, #2]
			if (keys & KEYS_UP)
 808fdd0:	f100 80a0 	bmi.w	808ff14 <Keys_demo+0x304>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fdd4:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fdd8:	f7f3 faac 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fddc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fde0:	f7f3 fac4 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(100, 130, (uint8_t *)strbuff, LEFT_MODE);
 808fde4:	2182      	movs	r1, #130	; 0x82
 808fde6:	2064      	movs	r0, #100	; 0x64
 808fde8:	2303      	movs	r3, #3
 808fdea:	466a      	mov	r2, sp
 808fdec:	f7f3 fc24 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "Down");
 808fdf0:	e896 0003 	ldmia.w	r6, {r0, r1}
 808fdf4:	f88d 1004 	strb.w	r1, [sp, #4]
			if (keys & KEYS_DOWN)
 808fdf8:	0661      	lsls	r1, r4, #25
			sprintf((char*)&strbuff, "Down");
 808fdfa:	9000      	str	r0, [sp, #0]
			if (keys & KEYS_DOWN)
 808fdfc:	d566      	bpl.n	808fecc <Keys_demo+0x2bc>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fdfe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fe02:	f7f3 fa97 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808fe06:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fe0a:	f7f3 faaf 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(80, 190, (uint8_t *)strbuff, LEFT_MODE);
 808fe0e:	466a      	mov	r2, sp
 808fe10:	21be      	movs	r1, #190	; 0xbe
 808fe12:	2050      	movs	r0, #80	; 0x50
 808fe14:	2303      	movs	r3, #3
 808fe16:	f7f3 fc0f 	bl	8083638 <BSP_LCD_DisplayStringAt>
			if (keys & KEYS_LEFT)
 808fe1a:	06a2      	lsls	r2, r4, #26
			sprintf((char*)&strbuff, "Left");
 808fe1c:	e895 0003 	ldmia.w	r5, {r0, r1}
 808fe20:	9000      	str	r0, [sp, #0]
 808fe22:	f88d 1004 	strb.w	r1, [sp, #4]
			if (keys & KEYS_LEFT)
 808fe26:	d548      	bpl.n	808feba <Keys_demo+0x2aa>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fe28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fe2c:	f7f3 fa82 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808fe30:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fe34:	f7f3 fa9a 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(40, 160, (uint8_t *)strbuff, LEFT_MODE);
 808fe38:	2303      	movs	r3, #3
 808fe3a:	21a0      	movs	r1, #160	; 0xa0
 808fe3c:	2028      	movs	r0, #40	; 0x28
 808fe3e:	466a      	mov	r2, sp
 808fe40:	f7f3 fbfa 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "Right");
 808fe44:	f645 23a0 	movw	r3, #23200	; 0x5aa0
 808fe48:	f6c0 0309 	movt	r3, #2057	; 0x809
 808fe4c:	e893 0003 	ldmia.w	r3, {r0, r1}
			if (keys & KEYS_RIGHT)
 808fe50:	06e3      	lsls	r3, r4, #27
			sprintf((char*)&strbuff, "Right");
 808fe52:	9000      	str	r0, [sp, #0]
 808fe54:	f8ad 1004 	strh.w	r1, [sp, #4]
			if (keys & KEYS_RIGHT)
 808fe58:	d526      	bpl.n	808fea8 <Keys_demo+0x298>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808fe5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fe5e:	f7f3 fa69 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808fe62:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fe66:	f7f3 fa81 	bl	808336c <BSP_LCD_SetBackColor>
			BSP_LCD_DisplayStringAt(120, 160, (uint8_t *)strbuff, LEFT_MODE);
 808fe6a:	466a      	mov	r2, sp
 808fe6c:	2303      	movs	r3, #3
 808fe6e:	21a0      	movs	r1, #160	; 0xa0
 808fe70:	2078      	movs	r0, #120	; 0x78
 808fe72:	f7f3 fbe1 	bl	8083638 <BSP_LCD_DisplayStringAt>
		while (BSP_KEYS_GetKeys() != (KEYS_A | KEYS_DOWN))
 808fe76:	f7f3 f8cf 	bl	8083018 <BSP_KEYS_GetKeys>
 808fe7a:	2848      	cmp	r0, #72	; 0x48
 808fe7c:	d053      	beq.n	808ff26 <Keys_demo+0x316>
			HAL_Delay(100);
 808fe7e:	2064      	movs	r0, #100	; 0x64
 808fe80:	f7f5 fc9c 	bl	80857bc <HAL_Delay>
			keys=BSP_KEYS_GetKeys();
 808fe84:	f7f3 f8c8 	bl	8083018 <BSP_KEYS_GetKeys>
 808fe88:	4604      	mov	r4, r0
			sprintf((char*)&strbuff, "A");
 808fe8a:	2341      	movs	r3, #65	; 0x41
			if (keys & KEYS_A)
 808fe8c:	0720      	lsls	r0, r4, #28
			sprintf((char*)&strbuff, "A");
 808fe8e:	f8ad 3000 	strh.w	r3, [sp]
			if (keys & KEYS_A)
 808fe92:	f53f af47 	bmi.w	808fd24 <Keys_demo+0x114>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fe96:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fe9a:	f7f3 fa4b 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fe9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fea2:	f7f3 fa63 	bl	808336c <BSP_LCD_SetBackColor>
 808fea6:	e745      	b.n	808fd34 <Keys_demo+0x124>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fea8:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808feac:	f7f3 fa42 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808feb0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808feb4:	f7f3 fa5a 	bl	808336c <BSP_LCD_SetBackColor>
 808feb8:	e7d7      	b.n	808fe6a <Keys_demo+0x25a>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808feba:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808febe:	f7f3 fa39 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fec2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fec6:	f7f3 fa51 	bl	808336c <BSP_LCD_SetBackColor>
 808feca:	e7b5      	b.n	808fe38 <Keys_demo+0x228>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fecc:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fed0:	f7f3 fa30 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fed4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fed8:	f7f3 fa48 	bl	808336c <BSP_LCD_SetBackColor>
 808fedc:	e797      	b.n	808fe0e <Keys_demo+0x1fe>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fede:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fee2:	f7f3 fa27 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fee6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808feea:	f7f3 fa3f 	bl	808336c <BSP_LCD_SetBackColor>
 808feee:	e760      	b.n	808fdb2 <Keys_demo+0x1a2>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808fef0:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808fef4:	f7f3 fa1e 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808fef8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808fefc:	f7f3 fa36 	bl	808336c <BSP_LCD_SetBackColor>
 808ff00:	e742      	b.n	808fd88 <Keys_demo+0x178>
				BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808ff02:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808ff06:	f7f3 fa15 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808ff0a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808ff0e:	f7f3 fa2d 	bl	808336c <BSP_LCD_SetBackColor>
 808ff12:	e724      	b.n	808fd5e <Keys_demo+0x14e>
				BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808ff14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808ff18:	f7f3 fa0c 	bl	8083334 <BSP_LCD_SetTextColor>
				BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 808ff1c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808ff20:	f7f3 fa24 	bl	808336c <BSP_LCD_SetBackColor>
 808ff24:	e75e      	b.n	808fde4 <Keys_demo+0x1d4>
	BSP_LCD_SetFont(&Font12);
 808ff26:	f24b 304c 	movw	r0, #45900	; 0xb34c
 808ff2a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 808ff2e:	f7f3 fa2d 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808ff32:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808ff36:	f7f3 f9fd 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808ff3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808ff3e:	f7f3 fa15 	bl	808336c <BSP_LCD_SetBackColor>
}
 808ff42:	b009      	add	sp, #36	; 0x24
 808ff44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 808ff46:	bf00      	nop

0808ff48 <LCD_Show_Feature>:
 * @param  feature : feature index
 * @retval None
 */
static void LCD_Show_Feature(uint8_t feature)
{
	Point Points[] = {{20, 150}, {80, 150}, {80, 200}};
 808ff48:	f642 1300 	movw	r3, #10496	; 0x2900
{
 808ff4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	Point Points[] = {{20, 150}, {80, 150}, {80, 200}};
 808ff50:	f6c0 0309 	movt	r3, #2057	; 0x809
{
 808ff54:	b095      	sub	sp, #84	; 0x54
 808ff56:	4607      	mov	r7, r0
	Point Points[] = {{20, 150}, {80, 150}, {80, 200}};
 808ff58:	ad06      	add	r5, sp, #24
	Point Points2[] = {{100, 150}, {160, 150}, {160, 200}};
 808ff5a:	ac09      	add	r4, sp, #36	; 0x24
	Point Points[] = {{20, 150}, {80, 150}, {80, 200}};
 808ff5c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
	Point Points2[] = {{100, 150}, {160, 150}, {160, 200}};
 808ff60:	330c      	adds	r3, #12
	Point Points[] = {{20, 150}, {80, 150}, {80, 200}};
 808ff62:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	Point Points2[] = {{100, 150}, {160, 150}, {160, 200}};
 808ff66:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 808ff6a:	e884 0007 	stmia.w	r4, {r0, r1, r2}

	uint16_t screenWidth, screenHeight;

	char StrBuffer[30];

	BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 808ff6e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808ff72:	f7f3 f9fb 	bl	808336c <BSP_LCD_SetBackColor>
	BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 808ff76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 808ff7a:	f7f3 f9db 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_FillRect(12, 92, BSP_LCD_GetXSize() - 24, BSP_LCD_GetYSize() - 104);
 808ff7e:	f7f3 f963 	bl	8083248 <BSP_LCD_GetXSize>
 808ff82:	4606      	mov	r6, r0
 808ff84:	f7f3 f96e 	bl	8083264 <BSP_LCD_GetYSize>
 808ff88:	f1a0 0368 	sub.w	r3, r0, #104	; 0x68
 808ff8c:	f1a6 0218 	sub.w	r2, r6, #24
 808ff90:	200c      	movs	r0, #12
 808ff92:	b29b      	uxth	r3, r3
 808ff94:	215c      	movs	r1, #92	; 0x5c
 808ff96:	b292      	uxth	r2, r2
 808ff98:	f7f3 feba 	bl	8083d10 <BSP_LCD_FillRect>
	BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 808ff9c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 808ffa0:	f7f3 f9c8 	bl	8083334 <BSP_LCD_SetTextColor>

	switch (feature)
 808ffa4:	2f05      	cmp	r7, #5
 808ffa6:	f200 8086 	bhi.w	80900b6 <LCD_Show_Feature+0x16e>
 808ffaa:	e8df f017 	tbh	[pc, r7, lsl #1]
 808ffae:	00e9      	.short	0x00e9
 808ffb0:	01d5013f 	.word	0x01d5013f
 808ffb4:	02560006 	.word	0x02560006
 808ffb8:	0087      	.short	0x0087
			BSP_LCD_FillRect(x1, y1, x2 , y2);
		}

		break;
	case 3:
		screenWidth = BSP_LCD_GetXSize();
 808ffba:	f7f3 f945 	bl	8083248 <BSP_LCD_GetXSize>
 808ffbe:	4604      	mov	r4, r0
		screenHeight = BSP_LCD_GetYSize();
 808ffc0:	f7f3 f950 	bl	8083264 <BSP_LCD_GetYSize>
		/* Random drawFillRect */
		while (CheckForUserInput() == 0)
		{
			color = BSP_RNG_GetNumber();
			rng_val = (uint16_t)BSP_RNG_GetNumber();
			x1 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 808ffc4:	f248 0901 	movw	r9, #32769	; 0x8001
 808ffc8:	b2a3      	uxth	r3, r4
		screenHeight = BSP_LCD_GetYSize();
 808ffca:	9002      	str	r0, [sp, #8]
			x1 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 808ffcc:	f2c8 0900 	movt	r9, #32768	; 0x8000
 808ffd0:	9305      	str	r3, [sp, #20]
 808ffd2:	f1a3 0a28 	sub.w	sl, r3, #40	; 0x28
		screenWidth = BSP_LCD_GetXSize();
 808ffd6:	9303      	str	r3, [sp, #12]
		screenHeight = BSP_LCD_GetYSize();
 808ffd8:	b283      	uxth	r3, r0
 808ffda:	9304      	str	r3, [sp, #16]
		while (CheckForUserInput() == 0)
 808ffdc:	e063      	b.n	80900a6 <LCD_Show_Feature+0x15e>
			color = BSP_RNG_GetNumber();
 808ffde:	f7f4 fe5f 	bl	8084ca0 <BSP_RNG_GetNumber>
 808ffe2:	4683      	mov	fp, r0
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 808ffe4:	f7f4 fe5c 	bl	8084ca0 <BSP_RNG_GetNumber>
			x1 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 808ffe8:	b280      	uxth	r0, r0
 808ffea:	fb0a f000 	mul.w	r0, sl, r0
 808ffee:	fb89 2300 	smull	r2, r3, r9, r0
 808fff2:	17c5      	asrs	r5, r0, #31
 808fff4:	4418      	add	r0, r3
 808fff6:	ebc5 35e0 	rsb	r5, r5, r0, asr #15
			x1 += 20;

			rng_val = (uint16_t)BSP_RNG_GetNumber();
 808fffa:	f7f4 fe51 	bl	8084ca0 <BSP_RNG_GetNumber>
			x2 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 808fffe:	b280      	uxth	r0, r0
			x1 += 20;
 8090000:	3514      	adds	r5, #20
			x2 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 8090002:	fb0a f000 	mul.w	r0, sl, r0
			x1 += 20;
 8090006:	b2ad      	uxth	r5, r5
			x2 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 8090008:	fb89 3200 	smull	r3, r2, r9, r0
 809000c:	17c7      	asrs	r7, r0, #31
 809000e:	4410      	add	r0, r2
 8090010:	ebc7 37e0 	rsb	r7, r7, r0, asr #15
			x2 += 20;

			rng_val = (uint16_t)BSP_RNG_GetNumber();
 8090014:	f7f4 fe44 	bl	8084ca0 <BSP_RNG_GetNumber>
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090018:	b280      	uxth	r0, r0
			x2 += 20;
 809001a:	3714      	adds	r7, #20
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 809001c:	fb08 f000 	mul.w	r0, r8, r0
			x2 += 20;
 8090020:	b2bf      	uxth	r7, r7
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090022:	fb89 3100 	smull	r3, r1, r9, r0
 8090026:	17c6      	asrs	r6, r0, #31
 8090028:	4408      	add	r0, r1
 809002a:	ebc6 36e0 	rsb	r6, r6, r0, asr #15
			y1 +=100;

			rng_val = (uint16_t)BSP_RNG_GetNumber();
 809002e:	f7f4 fe37 	bl	8084ca0 <BSP_RNG_GetNumber>
				tmp= y1;
				y1=y2;
				y2=tmp;
			}

			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 8090032:	9b03      	ldr	r3, [sp, #12]
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090034:	b280      	uxth	r0, r0
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 8090036:	f1a4 0c14 	sub.w	ip, r4, #20
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 809003a:	f1a3 0114 	sub.w	r1, r3, #20
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 809003e:	9b04      	ldr	r3, [sp, #16]
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090040:	fb08 f400 	mul.w	r4, r8, r0

			BSP_LCD_SetTextColor(color);
 8090044:	4658      	mov	r0, fp
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 8090046:	f1a3 0214 	sub.w	r2, r3, #20
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 809004a:	9b05      	ldr	r3, [sp, #20]
			y1 +=100;
 809004c:	3664      	adds	r6, #100	; 0x64
			if (x1>x2)
 809004e:	42bd      	cmp	r5, r7
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 8090050:	f1a3 0e14 	sub.w	lr, r3, #20
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090054:	fb89 3b04 	smull	r3, fp, r9, r4
			y1 +=100;
 8090058:	b2b6      	uxth	r6, r6
			if (x1>x2)
 809005a:	46a8      	mov	r8, r5
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 809005c:	44a3      	add	fp, r4
 809005e:	ea4f 74e4 	mov.w	r4, r4, asr #31
			if (y1>y2)
 8090062:	9601      	str	r6, [sp, #4]
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090064:	ebc4 34eb 	rsb	r4, r4, fp, asr #15
			y2 +=100;
 8090068:	f104 0464 	add.w	r4, r4, #100	; 0x64
 809006c:	b2a4      	uxth	r4, r4
			if (x1>x2)
 809006e:	d901      	bls.n	8090074 <LCD_Show_Feature+0x12c>
 8090070:	463d      	mov	r5, r7
 8090072:	4647      	mov	r7, r8
			if (y1>y2)
 8090074:	42a6      	cmp	r6, r4
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 8090076:	eb05 0807 	add.w	r8, r5, r7
 809007a:	eba1 0105 	sub.w	r1, r1, r5
			if (y1>y2)
 809007e:	d901      	bls.n	8090084 <LCD_Show_Feature+0x13c>
 8090080:	4626      	mov	r6, r4
 8090082:	9c01      	ldr	r4, [sp, #4]
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 8090084:	1933      	adds	r3, r6, r4
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 8090086:	45f0      	cmp	r8, lr
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 8090088:	eba2 0206 	sub.w	r2, r2, r6
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 809008c:	bfa8      	it	ge
 809008e:	b28f      	uxthge	r7, r1
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 8090090:	4563      	cmp	r3, ip
 8090092:	bfa8      	it	ge
 8090094:	b294      	uxthge	r4, r2
			BSP_LCD_SetTextColor(color);
 8090096:	f7f3 f94d 	bl	8083334 <BSP_LCD_SetTextColor>
			BSP_LCD_DrawRect(x1, y1, x2 , y2);
 809009a:	463a      	mov	r2, r7
 809009c:	4623      	mov	r3, r4
 809009e:	4631      	mov	r1, r6
 80900a0:	4628      	mov	r0, r5
 80900a2:	f7f3 fa1f 	bl	80834e4 <BSP_LCD_DrawRect>
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80900a6:	f8bd 4008 	ldrh.w	r4, [sp, #8]
		while (CheckForUserInput() == 0)
 80900aa:	f001 f95d 	bl	8091368 <CheckForUserInput>
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80900ae:	f1a4 0878 	sub.w	r8, r4, #120	; 0x78
		while (CheckForUserInput() == 0)
 80900b2:	2800      	cmp	r0, #0
 80900b4:	d093      	beq.n	808ffde <LCD_Show_Feature+0x96>
		break;

	default :
		break;
	}
}
 80900b6:	b015      	add	sp, #84	; 0x54
 80900b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		OrgTick = HAL_GetTick();
 80900bc:	f7f5 fb78 	bl	80857b0 <HAL_GetTick>
 80900c0:	4681      	mov	r9, r0
		screenWidth = BSP_LCD_GetXSize();
 80900c2:	f7f3 f8c1 	bl	8083248 <BSP_LCD_GetXSize>
 80900c6:	4604      	mov	r4, r0
			x1 = (uint16_t)((rng_val*(screenWidth-20))/0xFFFF);
 80900c8:	f248 0501 	movw	r5, #32769	; 0x8001
		screenHeight = BSP_LCD_GetYSize();
 80900cc:	f7f3 f8ca 	bl	8083264 <BSP_LCD_GetYSize>
			x1 = (uint16_t)((rng_val*(screenWidth-20))/0xFFFF);
 80900d0:	fa1f f884 	uxth.w	r8, r4
			BSP_LCD_DrawBitmap(x1, y1, (uint8_t *)stlogo);
 80900d4:	f243 2640 	movw	r6, #12864	; 0x3240
		screenHeight = BSP_LCD_GetYSize();
 80900d8:	4607      	mov	r7, r0
			x1 = (uint16_t)((rng_val*(screenWidth-20))/0xFFFF);
 80900da:	f2c8 0500 	movt	r5, #32768	; 0x8000
 80900de:	f1a8 0314 	sub.w	r3, r8, #20
			BSP_LCD_DrawBitmap(x1, y1, (uint8_t *)stlogo);
 80900e2:	f6c0 0609 	movt	r6, #2057	; 0x809
		screenWidth = BSP_LCD_GetXSize();
 80900e6:	f8cd 8004 	str.w	r8, [sp, #4]
			x1 = (uint16_t)((rng_val*(screenWidth-20))/0xFFFF);
 80900ea:	9303      	str	r3, [sp, #12]
		screenHeight = BSP_LCD_GetYSize();
 80900ec:	b283      	uxth	r3, r0
 80900ee:	9302      	str	r3, [sp, #8]
			CurrentTick= HAL_GetTick();
 80900f0:	2400      	movs	r4, #0
 80900f2:	e03f      	b.n	8090174 <LCD_Show_Feature+0x22c>
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 80900f4:	f7f4 fdd4 	bl	8084ca0 <BSP_RNG_GetNumber>
			x1 = (uint16_t)((rng_val*(screenWidth-20))/0xFFFF);
 80900f8:	9b03      	ldr	r3, [sp, #12]
 80900fa:	b280      	uxth	r0, r0
 80900fc:	fb03 f000 	mul.w	r0, r3, r0
 8090100:	fb85 2300 	smull	r2, r3, r5, r0
 8090104:	ea4f 7ae0 	mov.w	sl, r0, asr #31
 8090108:	4418      	add	r0, r3
 809010a:	ebca 3ae0 	rsb	sl, sl, r0, asr #15
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 809010e:	f7f4 fdc7 	bl	8084ca0 <BSP_RNG_GetNumber>
			if (x1>screenWidth-80-20) x1 = screenWidth-80-20;
 8090112:	9b01      	ldr	r3, [sp, #4]
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090114:	fa1f fc87 	uxth.w	ip, r7
			x1 += 20;
 8090118:	f10a 0a14 	add.w	sl, sl, #20
			if (x1>screenWidth-80-20) x1 = screenWidth-80-20;
 809011c:	f1a3 0b64 	sub.w	fp, r3, #100	; 0x64
			if (y1>screenHeight-54-20) y1 = screenHeight-54-20;
 8090120:	9b02      	ldr	r3, [sp, #8]
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090122:	b280      	uxth	r0, r0
			BSP_LCD_DrawBitmap(x1, y1, (uint8_t *)stlogo);
 8090124:	4632      	mov	r2, r6
			if (y1>screenHeight-54-20) y1 = screenHeight-54-20;
 8090126:	f1a3 0e4a 	sub.w	lr, r3, #74	; 0x4a
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 809012a:	f1ac 0378 	sub.w	r3, ip, #120	; 0x78
			x1 += 20;
 809012e:	fa1f fa8a 	uxth.w	sl, sl
			if (y1>screenHeight-54-20) y1 = screenHeight-54-20;
 8090132:	f1ac 0c49 	sub.w	ip, ip, #73	; 0x49
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090136:	fb03 f000 	mul.w	r0, r3, r0
 809013a:	fb85 1300 	smull	r1, r3, r5, r0
 809013e:	17c1      	asrs	r1, r0, #31
 8090140:	4418      	add	r0, r3
 8090142:	ebc1 31e0 	rsb	r1, r1, r0, asr #15
			if (x1>screenWidth-80-20) x1 = screenWidth-80-20;
 8090146:	f1a8 0063 	sub.w	r0, r8, #99	; 0x63
			y1 +=100;
 809014a:	3164      	adds	r1, #100	; 0x64
			if (x1>screenWidth-80-20) x1 = screenWidth-80-20;
 809014c:	4550      	cmp	r0, sl
			y1 +=100;
 809014e:	b289      	uxth	r1, r1
			if (x1>screenWidth-80-20) x1 = screenWidth-80-20;
 8090150:	bfd8      	it	le
 8090152:	fa1f fa8b 	uxthle.w	sl, fp
			if (y1>screenHeight-54-20) y1 = screenHeight-54-20;
 8090156:	458c      	cmp	ip, r1
			BSP_LCD_DrawBitmap(x1, y1, (uint8_t *)stlogo);
 8090158:	4650      	mov	r0, sl
			if (y1>screenHeight-54-20) y1 = screenHeight-54-20;
 809015a:	bfd8      	it	le
 809015c:	fa1f f18e 	uxthle.w	r1, lr
			BSP_LCD_DrawBitmap(x1, y1, (uint8_t *)stlogo);
 8090160:	f7f3 fce4 	bl	8083b2c <BSP_LCD_DrawBitmap>
			CurrentTick= HAL_GetTick();
 8090164:	f7f5 fb24 	bl	80857b0 <HAL_GetTick>
			if(CurrentTick - OrgTick >=1000) {
 8090168:	eba0 0309 	sub.w	r3, r0, r9
 809016c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8090170:	f080 81b2 	bcs.w	80904d8 <LCD_Show_Feature+0x590>
			FPS++;
 8090174:	3401      	adds	r4, #1
		while (CheckForUserInput() == 0)
 8090176:	f001 f8f7 	bl	8091368 <CheckForUserInput>
 809017a:	2800      	cmp	r0, #0
 809017c:	d0ba      	beq.n	80900f4 <LCD_Show_Feature+0x1ac>
 809017e:	e79a      	b.n	80900b6 <LCD_Show_Feature+0x16e>
		BSP_LCD_DisplayStringAt(14, 100, (uint8_t *)"Left aligned Text", LEFT_MODE);
 8090180:	f645 22a8 	movw	r2, #23208	; 0x5aa8
 8090184:	2303      	movs	r3, #3
 8090186:	2164      	movs	r1, #100	; 0x64
 8090188:	200e      	movs	r0, #14
 809018a:	f6c0 0209 	movt	r2, #2057	; 0x809
 809018e:	f7f3 fa53 	bl	8083638 <BSP_LCD_DisplayStringAt>
		BSP_LCD_DisplayStringAt(0, 115, (uint8_t *)"Center aligned Text", CENTER_MODE);
 8090192:	f645 22bc 	movw	r2, #23228	; 0x5abc
 8090196:	2301      	movs	r3, #1
 8090198:	2173      	movs	r1, #115	; 0x73
 809019a:	f6c0 0209 	movt	r2, #2057	; 0x809
 809019e:	2000      	movs	r0, #0
 80901a0:	f7f3 fa4a 	bl	8083638 <BSP_LCD_DisplayStringAt>
		BSP_LCD_DisplayStringAt(14, 130, (uint8_t *)"Right aligned Text", RIGHT_MODE);
 80901a4:	f645 22d0 	movw	r2, #23248	; 0x5ad0
 80901a8:	2302      	movs	r3, #2
 80901aa:	2182      	movs	r1, #130	; 0x82
 80901ac:	f6c0 0209 	movt	r2, #2057	; 0x809
 80901b0:	200e      	movs	r0, #14
 80901b2:	f7f3 fa41 	bl	8083638 <BSP_LCD_DisplayStringAt>
		BSP_LCD_SetFont(&Font24);
 80901b6:	f24b 3064 	movw	r0, #45924	; 0xb364
 80901ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80901be:	f7f3 f8e5 	bl	808338c <BSP_LCD_SetFont>
		BSP_LCD_DisplayStringAt(14, 180, (uint8_t *)"Font24", LEFT_MODE);
 80901c2:	f645 22e4 	movw	r2, #23268	; 0x5ae4
 80901c6:	2303      	movs	r3, #3
 80901c8:	21b4      	movs	r1, #180	; 0xb4
 80901ca:	f6c0 0209 	movt	r2, #2057	; 0x809
 80901ce:	200e      	movs	r0, #14
 80901d0:	f7f3 fa32 	bl	8083638 <BSP_LCD_DisplayStringAt>
		BSP_LCD_SetFont(&Font20);
 80901d4:	f24b 305c 	movw	r0, #45916	; 0xb35c
 80901d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80901dc:	f7f3 f8d6 	bl	808338c <BSP_LCD_SetFont>
		BSP_LCD_DisplayStringAt(BSP_LCD_GetXSize() / 2 - 20, 180, (uint8_t *)"Font20", LEFT_MODE);
 80901e0:	f7f3 f832 	bl	8083248 <BSP_LCD_GetXSize>
 80901e4:	f645 22ec 	movw	r2, #23276	; 0x5aec
 80901e8:	0840      	lsrs	r0, r0, #1
 80901ea:	2303      	movs	r3, #3
 80901ec:	f6c0 0209 	movt	r2, #2057	; 0x809
 80901f0:	21b4      	movs	r1, #180	; 0xb4
 80901f2:	3814      	subs	r0, #20
 80901f4:	b280      	uxth	r0, r0
 80901f6:	f7f3 fa1f 	bl	8083638 <BSP_LCD_DisplayStringAt>
		BSP_LCD_SetFont(&Font16);
 80901fa:	f24b 3054 	movw	r0, #45908	; 0xb354
 80901fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8090202:	f7f3 f8c3 	bl	808338c <BSP_LCD_SetFont>
		BSP_LCD_DisplayStringAt(BSP_LCD_GetXSize() - 80, 184, (uint8_t *)"Font16", LEFT_MODE);
 8090206:	f7f3 f81f 	bl	8083248 <BSP_LCD_GetXSize>
 809020a:	f645 22f4 	movw	r2, #23284	; 0x5af4
 809020e:	3850      	subs	r0, #80	; 0x50
 8090210:	2303      	movs	r3, #3
 8090212:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090216:	21b8      	movs	r1, #184	; 0xb8
 8090218:	b280      	uxth	r0, r0
 809021a:	f7f3 fa0d 	bl	8083638 <BSP_LCD_DisplayStringAt>
		while (CheckForUserInput() == 0);
 809021e:	f001 f8a3 	bl	8091368 <CheckForUserInput>
 8090222:	2800      	cmp	r0, #0
 8090224:	d0fb      	beq.n	809021e <LCD_Show_Feature+0x2d6>
}
 8090226:	b015      	add	sp, #84	; 0x54
 8090228:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 809022c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8090230:	f7f3 f880 	bl	8083334 <BSP_LCD_SetTextColor>
		BSP_LCD_DrawRect(20, 100, 60 , 40);
 8090234:	2328      	movs	r3, #40	; 0x28
 8090236:	223c      	movs	r2, #60	; 0x3c
 8090238:	2164      	movs	r1, #100	; 0x64
 809023a:	2014      	movs	r0, #20
 809023c:	f7f3 f952 	bl	80834e4 <BSP_LCD_DrawRect>
		BSP_LCD_FillRect(100, 100, 60 , 40);
 8090240:	2164      	movs	r1, #100	; 0x64
 8090242:	2328      	movs	r3, #40	; 0x28
 8090244:	223c      	movs	r2, #60	; 0x3c
 8090246:	4608      	mov	r0, r1
 8090248:	f7f3 fd62 	bl	8083d10 <BSP_LCD_FillRect>
		BSP_LCD_SetTextColor(LCD_COLOR_GRAY);
 809024c:	f248 0080 	movw	r0, #32896	; 0x8080
 8090250:	f6cf 7080 	movt	r0, #65408	; 0xff80
 8090254:	f7f3 f86e 	bl	8083334 <BSP_LCD_SetTextColor>
		BSP_LCD_DrawCircle(BSP_LCD_GetXSize() - 120, 120, 20);
 8090258:	f7f2 fff6 	bl	8083248 <BSP_LCD_GetXSize>
 809025c:	3878      	subs	r0, #120	; 0x78
 809025e:	2214      	movs	r2, #20
 8090260:	2178      	movs	r1, #120	; 0x78
 8090262:	b280      	uxth	r0, r0
 8090264:	f7f3 fb6c 	bl	8083940 <BSP_LCD_DrawCircle>
		BSP_LCD_FillCircle(BSP_LCD_GetXSize() - 40, 120, 20);
 8090268:	f7f2 ffee 	bl	8083248 <BSP_LCD_GetXSize>
 809026c:	3828      	subs	r0, #40	; 0x28
 809026e:	2214      	movs	r2, #20
 8090270:	2178      	movs	r1, #120	; 0x78
 8090272:	b280      	uxth	r0, r0
 8090274:	f7f3 fd7e 	bl	8083d74 <BSP_LCD_FillCircle>
		BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 8090278:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
 809027c:	f7f3 f85a 	bl	8083334 <BSP_LCD_SetTextColor>
		BSP_LCD_DrawPolygon(Points, 3);
 8090280:	4628      	mov	r0, r5
 8090282:	2103      	movs	r1, #3
 8090284:	f7f3 faca 	bl	808381c <BSP_LCD_DrawPolygon>
		BSP_LCD_FillPolygon(Points2, 3);
 8090288:	2103      	movs	r1, #3
 809028a:	4620      	mov	r0, r4
 809028c:	f7f3 fdc6 	bl	8083e1c <BSP_LCD_FillPolygon>
		BSP_LCD_SetTextColor(LCD_COLOR_RED);
 8090290:	2000      	movs	r0, #0
 8090292:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 8090296:	f7f3 f84d 	bl	8083334 <BSP_LCD_SetTextColor>
		BSP_LCD_DrawEllipse(BSP_LCD_GetXSize() - 120, 170, 30, 20);
 809029a:	f7f2 ffd5 	bl	8083248 <BSP_LCD_GetXSize>
 809029e:	2314      	movs	r3, #20
 80902a0:	221e      	movs	r2, #30
 80902a2:	21aa      	movs	r1, #170	; 0xaa
 80902a4:	3878      	subs	r0, #120	; 0x78
 80902a6:	f7f3 fbcd 	bl	8083a44 <BSP_LCD_DrawEllipse>
		BSP_LCD_FillEllipse(BSP_LCD_GetXSize() - 50, 170, 30, 20);
 80902aa:	f7f2 ffcd 	bl	8083248 <BSP_LCD_GetXSize>
 80902ae:	2314      	movs	r3, #20
 80902b0:	221e      	movs	r2, #30
 80902b2:	21aa      	movs	r1, #170	; 0xaa
 80902b4:	3832      	subs	r0, #50	; 0x32
 80902b6:	f7f3 fe31 	bl	8083f1c <BSP_LCD_FillEllipse>
		BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 80902ba:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 80902be:	f7f3 f839 	bl	8083334 <BSP_LCD_SetTextColor>
		BSP_LCD_DrawHLine(20, BSP_LCD_GetYSize() - 30, BSP_LCD_GetXSize() / 5);
 80902c2:	f7f2 ffcf 	bl	8083264 <BSP_LCD_GetYSize>
 80902c6:	4604      	mov	r4, r0
 80902c8:	f7f2 ffbe 	bl	8083248 <BSP_LCD_GetXSize>
 80902cc:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 80902d0:	4602      	mov	r2, r0
 80902d2:	f1a4 011e 	sub.w	r1, r4, #30
 80902d6:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 80902da:	2014      	movs	r0, #20
 80902dc:	b289      	uxth	r1, r1
 80902de:	fba3 3202 	umull	r3, r2, r3, r2
 80902e2:	f3c2 028f 	ubfx	r2, r2, #2, #16
 80902e6:	f7f3 f89d 	bl	8083424 <BSP_LCD_DrawHLine>
		BSP_LCD_DrawLine (BSP_LCD_GetXSize() - 150, BSP_LCD_GetYSize() - 20, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 50);
 80902ea:	f7f2 ffad 	bl	8083248 <BSP_LCD_GetXSize>
 80902ee:	4604      	mov	r4, r0
 80902f0:	f7f2 ffb8 	bl	8083264 <BSP_LCD_GetYSize>
 80902f4:	4606      	mov	r6, r0
 80902f6:	f7f2 ffa7 	bl	8083248 <BSP_LCD_GetXSize>
 80902fa:	4605      	mov	r5, r0
 80902fc:	3c96      	subs	r4, #150	; 0x96
 80902fe:	f7f2 ffb1 	bl	8083264 <BSP_LCD_GetYSize>
 8090302:	f1a6 0114 	sub.w	r1, r6, #20
 8090306:	f1a5 0214 	sub.w	r2, r5, #20
 809030a:	f1a0 0332 	sub.w	r3, r0, #50	; 0x32
 809030e:	b2a0      	uxth	r0, r4
 8090310:	b289      	uxth	r1, r1
 8090312:	b292      	uxth	r2, r2
 8090314:	b29b      	uxth	r3, r3
 8090316:	f7f3 fa09 	bl	808372c <BSP_LCD_DrawLine>
		BSP_LCD_DrawLine (BSP_LCD_GetXSize() - 150, BSP_LCD_GetYSize() - 50, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 20);
 809031a:	f7f2 ff95 	bl	8083248 <BSP_LCD_GetXSize>
 809031e:	4604      	mov	r4, r0
 8090320:	f7f2 ffa0 	bl	8083264 <BSP_LCD_GetYSize>
 8090324:	4606      	mov	r6, r0
 8090326:	f7f2 ff8f 	bl	8083248 <BSP_LCD_GetXSize>
 809032a:	4605      	mov	r5, r0
 809032c:	3c96      	subs	r4, #150	; 0x96
 809032e:	f7f2 ff99 	bl	8083264 <BSP_LCD_GetYSize>
 8090332:	f1a6 0132 	sub.w	r1, r6, #50	; 0x32
 8090336:	f1a0 0314 	sub.w	r3, r0, #20
 809033a:	f1a5 0214 	sub.w	r2, r5, #20
 809033e:	b2a0      	uxth	r0, r4
 8090340:	b289      	uxth	r1, r1
 8090342:	b292      	uxth	r2, r2
 8090344:	b29b      	uxth	r3, r3
 8090346:	f7f3 f9f1 	bl	808372c <BSP_LCD_DrawLine>
		while (CheckForUserInput() == 0);
 809034a:	f001 f80d 	bl	8091368 <CheckForUserInput>
 809034e:	2800      	cmp	r0, #0
 8090350:	d0fb      	beq.n	809034a <LCD_Show_Feature+0x402>
}
 8090352:	b015      	add	sp, #84	; 0x54
 8090354:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		screenWidth = BSP_LCD_GetXSize();
 8090358:	f7f2 ff76 	bl	8083248 <BSP_LCD_GetXSize>
 809035c:	4604      	mov	r4, r0
		screenHeight = BSP_LCD_GetYSize();
 809035e:	f7f2 ff81 	bl	8083264 <BSP_LCD_GetYSize>
			x1 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 8090362:	f248 0901 	movw	r9, #32769	; 0x8001
 8090366:	b2a3      	uxth	r3, r4
		screenHeight = BSP_LCD_GetYSize();
 8090368:	9002      	str	r0, [sp, #8]
			x1 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 809036a:	f2c8 0900 	movt	r9, #32768	; 0x8000
 809036e:	9305      	str	r3, [sp, #20]
 8090370:	f1a3 0a28 	sub.w	sl, r3, #40	; 0x28
		screenWidth = BSP_LCD_GetXSize();
 8090374:	9303      	str	r3, [sp, #12]
		screenHeight = BSP_LCD_GetYSize();
 8090376:	b283      	uxth	r3, r0
 8090378:	9304      	str	r3, [sp, #16]
		while (CheckForUserInput() == 0)
 809037a:	e063      	b.n	8090444 <LCD_Show_Feature+0x4fc>
			color = BSP_RNG_GetNumber();
 809037c:	f7f4 fc90 	bl	8084ca0 <BSP_RNG_GetNumber>
 8090380:	4683      	mov	fp, r0
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 8090382:	f7f4 fc8d 	bl	8084ca0 <BSP_RNG_GetNumber>
			x1 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 8090386:	b280      	uxth	r0, r0
 8090388:	fb0a f000 	mul.w	r0, sl, r0
 809038c:	fb89 2300 	smull	r2, r3, r9, r0
 8090390:	17c5      	asrs	r5, r0, #31
 8090392:	4418      	add	r0, r3
 8090394:	ebc5 35e0 	rsb	r5, r5, r0, asr #15
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 8090398:	f7f4 fc82 	bl	8084ca0 <BSP_RNG_GetNumber>
			x2 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 809039c:	b280      	uxth	r0, r0
			x1 += 20;
 809039e:	3514      	adds	r5, #20
			x2 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 80903a0:	fb0a f000 	mul.w	r0, sl, r0
			x1 += 20;
 80903a4:	b2ad      	uxth	r5, r5
			x2 = (uint16_t)((rng_val*(screenWidth-40))/0xFFFF);
 80903a6:	fb89 3200 	smull	r3, r2, r9, r0
 80903aa:	17c7      	asrs	r7, r0, #31
 80903ac:	4410      	add	r0, r2
 80903ae:	ebc7 37e0 	rsb	r7, r7, r0, asr #15
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 80903b2:	f7f4 fc75 	bl	8084ca0 <BSP_RNG_GetNumber>
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80903b6:	b280      	uxth	r0, r0
			x2 += 20;
 80903b8:	3714      	adds	r7, #20
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80903ba:	fb08 f000 	mul.w	r0, r8, r0
			x2 += 20;
 80903be:	b2bf      	uxth	r7, r7
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80903c0:	fb89 3100 	smull	r3, r1, r9, r0
 80903c4:	17c6      	asrs	r6, r0, #31
 80903c6:	4408      	add	r0, r1
 80903c8:	ebc6 36e0 	rsb	r6, r6, r0, asr #15
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 80903cc:	f7f4 fc68 	bl	8084ca0 <BSP_RNG_GetNumber>
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 80903d0:	9b03      	ldr	r3, [sp, #12]
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80903d2:	b280      	uxth	r0, r0
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 80903d4:	f1a4 0c14 	sub.w	ip, r4, #20
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 80903d8:	f1a3 0114 	sub.w	r1, r3, #20
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 80903dc:	9b04      	ldr	r3, [sp, #16]
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80903de:	fb08 f400 	mul.w	r4, r8, r0
			BSP_LCD_SetTextColor(color);
 80903e2:	4658      	mov	r0, fp
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 80903e4:	f1a3 0214 	sub.w	r2, r3, #20
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 80903e8:	9b05      	ldr	r3, [sp, #20]
			y1 +=100;
 80903ea:	3664      	adds	r6, #100	; 0x64
			if (x1>x2)
 80903ec:	42bd      	cmp	r5, r7
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 80903ee:	f1a3 0e14 	sub.w	lr, r3, #20
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80903f2:	fb89 3b04 	smull	r3, fp, r9, r4
			y1 +=100;
 80903f6:	b2b6      	uxth	r6, r6
			if (x1>x2)
 80903f8:	46a8      	mov	r8, r5
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 80903fa:	44a3      	add	fp, r4
 80903fc:	ea4f 74e4 	mov.w	r4, r4, asr #31
			if (y1>y2)
 8090400:	9601      	str	r6, [sp, #4]
			y2 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090402:	ebc4 34eb 	rsb	r4, r4, fp, asr #15
			y2 +=100;
 8090406:	f104 0464 	add.w	r4, r4, #100	; 0x64
 809040a:	b2a4      	uxth	r4, r4
			if (x1>x2)
 809040c:	d901      	bls.n	8090412 <LCD_Show_Feature+0x4ca>
 809040e:	463d      	mov	r5, r7
 8090410:	4647      	mov	r7, r8
			if (y1>y2)
 8090412:	42a6      	cmp	r6, r4
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 8090414:	eb05 0807 	add.w	r8, r5, r7
 8090418:	eba1 0105 	sub.w	r1, r1, r5
			if (y1>y2)
 809041c:	d901      	bls.n	8090422 <LCD_Show_Feature+0x4da>
 809041e:	4626      	mov	r6, r4
 8090420:	9c01      	ldr	r4, [sp, #4]
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 8090422:	1933      	adds	r3, r6, r4
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 8090424:	45f0      	cmp	r8, lr
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 8090426:	eba2 0206 	sub.w	r2, r2, r6
			if (x1+x2 >=screenWidth-20 ) x2 = screenWidth- x1-20;
 809042a:	bfa8      	it	ge
 809042c:	b28f      	uxthge	r7, r1
			if (y1+y2 >=screenHeight-20 ) y2 = screenHeight- y1-20;
 809042e:	4563      	cmp	r3, ip
 8090430:	bfa8      	it	ge
 8090432:	b294      	uxthge	r4, r2
			BSP_LCD_SetTextColor(color);
 8090434:	f7f2 ff7e 	bl	8083334 <BSP_LCD_SetTextColor>
			BSP_LCD_FillRect(x1, y1, x2 , y2);
 8090438:	463a      	mov	r2, r7
 809043a:	4623      	mov	r3, r4
 809043c:	4631      	mov	r1, r6
 809043e:	4628      	mov	r0, r5
 8090440:	f7f3 fc66 	bl	8083d10 <BSP_LCD_FillRect>
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 8090444:	f8bd 4008 	ldrh.w	r4, [sp, #8]
		while (CheckForUserInput() == 0)
 8090448:	f000 ff8e 	bl	8091368 <CheckForUserInput>
			y1 = (uint16_t)((rng_val*(screenHeight-120))/0xFFFF);
 809044c:	f1a4 0878 	sub.w	r8, r4, #120	; 0x78
		while (CheckForUserInput() == 0)
 8090450:	2800      	cmp	r0, #0
 8090452:	d093      	beq.n	809037c <LCD_Show_Feature+0x434>
}
 8090454:	b015      	add	sp, #84	; 0x54
 8090456:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		screenWidth = BSP_LCD_GetXSize();
 809045a:	f7f2 fef5 	bl	8083248 <BSP_LCD_GetXSize>
 809045e:	4606      	mov	r6, r0
			x1 = (uint16_t)((rng_val*(screenWidth-80))/0xFFFF);
 8090460:	f248 0501 	movw	r5, #32769	; 0x8001
		screenHeight = BSP_LCD_GetYSize();
 8090464:	f7f2 fefe 	bl	8083264 <BSP_LCD_GetYSize>
			x1 = (uint16_t)((rng_val*(screenWidth-80))/0xFFFF);
 8090468:	b2b6      	uxth	r6, r6
		screenHeight = BSP_LCD_GetYSize();
 809046a:	4607      	mov	r7, r0
			x1 = (uint16_t)((rng_val*(screenWidth-80))/0xFFFF);
 809046c:	f2c8 0500 	movt	r5, #32768	; 0x8000
 8090470:	3e50      	subs	r6, #80	; 0x50
		while (CheckForUserInput() == 0)
 8090472:	e02a      	b.n	80904ca <LCD_Show_Feature+0x582>
			color = BSP_RNG_GetNumber();
 8090474:	f7f4 fc14 	bl	8084ca0 <BSP_RNG_GetNumber>
 8090478:	4681      	mov	r9, r0
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 809047a:	f7f4 fc11 	bl	8084ca0 <BSP_RNG_GetNumber>
			x1 = (uint16_t)((rng_val*(screenWidth-80))/0xFFFF);
 809047e:	b280      	uxth	r0, r0
 8090480:	fb00 f006 	mul.w	r0, r0, r6
 8090484:	fb85 2300 	smull	r2, r3, r5, r0
 8090488:	ea4f 78e0 	mov.w	r8, r0, asr #31
 809048c:	4418      	add	r0, r3
 809048e:	ebc8 38e0 	rsb	r8, r8, r0, asr #15
			rng_val = (uint16_t)BSP_RNG_GetNumber();
 8090492:	f7f4 fc05 	bl	8084ca0 <BSP_RNG_GetNumber>
			y1 = (uint16_t)((rng_val*(screenHeight-160))/0xFFFF);
 8090496:	b2bb      	uxth	r3, r7
 8090498:	b284      	uxth	r4, r0
			BSP_LCD_SetTextColor(color);
 809049a:	4648      	mov	r0, r9
			y1 = (uint16_t)((rng_val*(screenHeight-160))/0xFFFF);
 809049c:	3ba0      	subs	r3, #160	; 0xa0
			x1 = (uint16_t)((rng_val*(screenWidth-80))/0xFFFF);
 809049e:	fa1f f888 	uxth.w	r8, r8
			y1 = (uint16_t)((rng_val*(screenHeight-160))/0xFFFF);
 80904a2:	fb04 f303 	mul.w	r3, r4, r3
 80904a6:	fb85 2103 	smull	r2, r1, r5, r3
 80904aa:	17dc      	asrs	r4, r3, #31
 80904ac:	440b      	add	r3, r1
 80904ae:	ebc4 34e3 	rsb	r4, r4, r3, asr #15
			BSP_LCD_SetTextColor(color);
 80904b2:	f7f2 ff3f 	bl	8083334 <BSP_LCD_SetTextColor>
			x1 += 40;
 80904b6:	f108 0028 	add.w	r0, r8, #40	; 0x28
			y1 = (uint16_t)((rng_val*(screenHeight-160))/0xFFFF);
 80904ba:	b2a4      	uxth	r4, r4
			BSP_LCD_FillCircle(x1,y1, 20);
 80904bc:	2214      	movs	r2, #20
 80904be:	b280      	uxth	r0, r0
			y1 +=120;
 80904c0:	f104 0178 	add.w	r1, r4, #120	; 0x78
			BSP_LCD_FillCircle(x1,y1, 20);
 80904c4:	b289      	uxth	r1, r1
 80904c6:	f7f3 fc55 	bl	8083d74 <BSP_LCD_FillCircle>
		while (CheckForUserInput() == 0)
 80904ca:	f000 ff4d 	bl	8091368 <CheckForUserInput>
 80904ce:	2800      	cmp	r0, #0
 80904d0:	d0d0      	beq.n	8090474 <LCD_Show_Feature+0x52c>
}
 80904d2:	b015      	add	sp, #84	; 0x54
 80904d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				sprintf (StrBuffer,"FPS = %lu     ", FPS);
 80904d8:	f645 21fc 	movw	r1, #23292	; 0x5afc
 80904dc:	4622      	mov	r2, r4
			CurrentTick= HAL_GetTick();
 80904de:	4681      	mov	r9, r0
				sprintf (StrBuffer,"FPS = %lu     ", FPS);
 80904e0:	a80c      	add	r0, sp, #48	; 0x30
 80904e2:	f6c0 0109 	movt	r1, #2057	; 0x809
 80904e6:	f001 fdf5 	bl	80920d4 <siprintf>
				BSP_LCD_DisplayStringAt(20, 20, (uint8_t *)StrBuffer, LEFT_MODE);
 80904ea:	2114      	movs	r1, #20
 80904ec:	aa0c      	add	r2, sp, #48	; 0x30
 80904ee:	2303      	movs	r3, #3
 80904f0:	4608      	mov	r0, r1
 80904f2:	f7f3 f8a1 	bl	8083638 <BSP_LCD_DisplayStringAt>
 80904f6:	e5fb      	b.n	80900f0 <LCD_Show_Feature+0x1a8>

080904f8 <LCD_demo>:
{
 80904f8:	b538      	push	{r3, r4, r5, lr}
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 80904fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	LCD_Feature = 0;
 80904fe:	f24c 54e8 	movw	r4, #50664	; 0xc5e8
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 8090502:	f7f2 ff63 	bl	80833cc <BSP_LCD_Clear>
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090506:	20ff      	movs	r0, #255	; 0xff
	LCD_Feature = 0;
 8090508:	f2c2 0402 	movt	r4, #8194	; 0x2002
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 809050c:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090510:	f7f2 ff10 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 8090514:	f7f2 fe98 	bl	8083248 <BSP_LCD_GetXSize>
 8090518:	2100      	movs	r1, #0
 809051a:	b282      	uxth	r2, r0
 809051c:	2350      	movs	r3, #80	; 0x50
 809051e:	4608      	mov	r0, r1
 8090520:	f7f3 fbf6 	bl	8083d10 <BSP_LCD_FillRect>
	BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 8090524:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090528:	f7f2 ff04 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 809052c:	20ff      	movs	r0, #255	; 0xff
 809052e:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090532:	f7f2 ff1b 	bl	808336c <BSP_LCD_SetBackColor>
	BSP_LCD_SetFont(&Font24);
 8090536:	f24b 3064 	movw	r0, #45924	; 0xb364
 809053a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 809053e:	f7f2 ff25 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"LCD", CENTER_MODE);
 8090542:	2100      	movs	r1, #0
 8090544:	f645 320c 	movw	r2, #23308	; 0x5b0c
 8090548:	2301      	movs	r3, #1
 809054a:	4608      	mov	r0, r1
 809054c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090550:	f7f3 f872 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_SetFont(&Font12);
 8090554:	f24b 304c 	movw	r0, #45900	; 0xb34c
 8090558:	f2c2 0000 	movt	r0, #8192	; 0x2000
 809055c:	f7f2 ff16 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows the different", CENTER_MODE);
 8090560:	f645 3210 	movw	r2, #23312	; 0x5b10
 8090564:	2301      	movs	r3, #1
 8090566:	211e      	movs	r1, #30
 8090568:	f6c0 0209 	movt	r2, #2057	; 0x809
 809056c:	2000      	movs	r0, #0
 809056e:	f7f3 f863 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"LCD Features, press A to display", CENTER_MODE);
 8090572:	f645 3234 	movw	r2, #23348	; 0x5b34
 8090576:	2301      	movs	r3, #1
 8090578:	212d      	movs	r1, #45	; 0x2d
 809057a:	f6c0 0209 	movt	r2, #2057	; 0x809
 809057e:	2000      	movs	r0, #0
 8090580:	f7f3 f85a 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(0, 60, (uint8_t *)"next page", CENTER_MODE);
 8090584:	f645 3258 	movw	r2, #23384	; 0x5b58
 8090588:	2301      	movs	r3, #1
 809058a:	213c      	movs	r1, #60	; 0x3c
 809058c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090590:	2000      	movs	r0, #0
 8090592:	f7f3 f851 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090596:	20ff      	movs	r0, #255	; 0xff
 8090598:	f6cf 7000 	movt	r0, #65280	; 0xff00
 809059c:	f7f2 feca 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 100);
 80905a0:	f7f2 fe52 	bl	8083248 <BSP_LCD_GetXSize>
 80905a4:	4605      	mov	r5, r0
 80905a6:	f7f2 fe5d 	bl	8083264 <BSP_LCD_GetYSize>
 80905aa:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 80905ae:	f1a5 0214 	sub.w	r2, r5, #20
 80905b2:	215a      	movs	r1, #90	; 0x5a
 80905b4:	b29b      	uxth	r3, r3
 80905b6:	200a      	movs	r0, #10
 80905b8:	b292      	uxth	r2, r2
 80905ba:	f7f2 ff93 	bl	80834e4 <BSP_LCD_DrawRect>
	BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 102);
 80905be:	f7f2 fe43 	bl	8083248 <BSP_LCD_GetXSize>
 80905c2:	4605      	mov	r5, r0
 80905c4:	f7f2 fe4e 	bl	8083264 <BSP_LCD_GetYSize>
 80905c8:	f1a0 0366 	sub.w	r3, r0, #102	; 0x66
 80905cc:	f1a5 0216 	sub.w	r2, r5, #22
 80905d0:	200b      	movs	r0, #11
 80905d2:	b29b      	uxth	r3, r3
 80905d4:	215b      	movs	r1, #91	; 0x5b
 80905d6:	b292      	uxth	r2, r2
 80905d8:	f7f2 ff84 	bl	80834e4 <BSP_LCD_DrawRect>
	LCD_Feature = 0;
 80905dc:	2300      	movs	r3, #0
	LCD_Show_Feature (LCD_Feature);
 80905de:	4618      	mov	r0, r3
	LCD_Feature = 0;
 80905e0:	7023      	strb	r3, [r4, #0]
	LCD_Show_Feature (LCD_Feature);
 80905e2:	f7ff fcb1 	bl	808ff48 <LCD_Show_Feature>
	while (CheckForUserInput() == 0);
 80905e6:	f000 febf 	bl	8091368 <CheckForUserInput>
 80905ea:	2800      	cmp	r0, #0
 80905ec:	d0fb      	beq.n	80905e6 <LCD_demo+0xee>
		if (++LCD_Feature < LCD_FEATURES_NUM)
 80905ee:	7820      	ldrb	r0, [r4, #0]
 80905f0:	3001      	adds	r0, #1
 80905f2:	b2c0      	uxtb	r0, r0
 80905f4:	2805      	cmp	r0, #5
 80905f6:	7020      	strb	r0, [r4, #0]
 80905f8:	d809      	bhi.n	809060e <LCD_demo+0x116>
			LCD_Show_Feature (LCD_Feature);
 80905fa:	f7ff fca5 	bl	808ff48 <LCD_Show_Feature>
		HAL_Delay(100);
 80905fe:	2064      	movs	r0, #100	; 0x64
 8090600:	f7f5 f8dc 	bl	80857bc <HAL_Delay>
		while (CheckForUserInput() != 0);
 8090604:	f000 feb0 	bl	8091368 <CheckForUserInput>
 8090608:	2800      	cmp	r0, #0
 809060a:	d1fb      	bne.n	8090604 <LCD_demo+0x10c>
 809060c:	e7ef      	b.n	80905ee <LCD_demo+0xf6>
}
 809060e:	bd38      	pop	{r3, r4, r5, pc}

08090610 <QSPI_demo>:
* @brief  QSPI Demo
* @param  None
* @retval None
*/
void QSPI_demo (void)
{ 
 8090610:	b570      	push	{r4, r5, r6, lr}
* @retval None
*/
static void QSPI_SetHint(void)
{
  /* Clear the LCD */ 
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 8090612:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090616:	f7f2 fed9 	bl	80833cc <BSP_LCD_Clear>
  
  /* Set LCD Demo description */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 809061a:	20ff      	movs	r0, #255	; 0xff
 809061c:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090620:	f7f2 fe88 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 8090624:	f7f2 fe10 	bl	8083248 <BSP_LCD_GetXSize>
 8090628:	2100      	movs	r1, #0
 809062a:	b282      	uxth	r2, r0
 809062c:	2350      	movs	r3, #80	; 0x50
 809062e:	4608      	mov	r0, r1
 8090630:	f7f3 fb6e 	bl	8083d10 <BSP_LCD_FillRect>
  BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 8090634:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090638:	f7f2 fe7c 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_BLUE); 
 809063c:	20ff      	movs	r0, #255	; 0xff
 809063e:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090642:	f7f2 fe93 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetFont(&Font24);
 8090646:	f24b 3064 	movw	r0, #45924	; 0xb364
 809064a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 809064e:	f7f2 fe9d 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 0, (uint8_t*)"QSPI", CENTER_MODE);
 8090652:	2100      	movs	r1, #0
 8090654:	f645 3264 	movw	r2, #23396	; 0x5b64
 8090658:	2301      	movs	r3, #1
 809065a:	4608      	mov	r0, r1
 809065c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090660:	f7f2 ffea 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetFont(&Font12);
 8090664:	f24b 304c 	movw	r0, #45900	; 0xb34c
 8090668:	f2c2 0000 	movt	r0, #8192	; 0x2000
 809066c:	f7f2 fe8e 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 30, (uint8_t*)"This example shows how to write", CENTER_MODE);
 8090670:	f645 02a0 	movw	r2, #22688	; 0x58a0
 8090674:	2301      	movs	r3, #1
 8090676:	211e      	movs	r1, #30
 8090678:	f6c0 0209 	movt	r2, #2057	; 0x809
 809067c:	2000      	movs	r0, #0
 809067e:	f7f2 ffdb 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 45, (uint8_t*)"and read data on QSPI memory", CENTER_MODE); 
 8090682:	f645 326c 	movw	r2, #23404	; 0x5b6c
 8090686:	2301      	movs	r3, #1
 8090688:	212d      	movs	r1, #45	; 0x2d
 809068a:	f6c0 0209 	movt	r2, #2057	; 0x809
 809068e:	2000      	movs	r0, #0
 8090690:	f7f2 ffd2 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 60, (uint8_t*)"(Hardware modifications needed)", CENTER_MODE); 
 8090694:	f645 328c 	movw	r2, #23436	; 0x5b8c
 8090698:	2301      	movs	r3, #1
 809069a:	213c      	movs	r1, #60	; 0x3c
 809069c:	f6c0 0209 	movt	r2, #2057	; 0x809
 80906a0:	2000      	movs	r0, #0
 80906a2:	f7f2 ffc9 	bl	8083638 <BSP_LCD_DisplayStringAt>
  
  /* Set the LCD Text Color */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);  
 80906a6:	20ff      	movs	r0, #255	; 0xff
 80906a8:	f6cf 7000 	movt	r0, #65280	; 0xff00
 80906ac:	f7f2 fe42 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize()- 100);
 80906b0:	f7f2 fdca 	bl	8083248 <BSP_LCD_GetXSize>
 80906b4:	4604      	mov	r4, r0
 80906b6:	f7f2 fdd5 	bl	8083264 <BSP_LCD_GetYSize>
 80906ba:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 80906be:	f1a4 0214 	sub.w	r2, r4, #20
 80906c2:	215a      	movs	r1, #90	; 0x5a
 80906c4:	b29b      	uxth	r3, r3
 80906c6:	200a      	movs	r0, #10
 80906c8:	b292      	uxth	r2, r2
 80906ca:	f7f2 ff0b 	bl	80834e4 <BSP_LCD_DrawRect>
  BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize()- 102);
 80906ce:	f7f2 fdbb 	bl	8083248 <BSP_LCD_GetXSize>
 80906d2:	4604      	mov	r4, r0
 80906d4:	f7f2 fdc6 	bl	8083264 <BSP_LCD_GetYSize>
 80906d8:	f1a0 0366 	sub.w	r3, r0, #102	; 0x66
 80906dc:	f1a4 0216 	sub.w	r2, r4, #22
 80906e0:	215b      	movs	r1, #91	; 0x5b
 80906e2:	b29b      	uxth	r3, r3
 80906e4:	200b      	movs	r0, #11
 80906e6:	b292      	uxth	r2, r2
 80906e8:	f7f2 fefc 	bl	80834e4 <BSP_LCD_DrawRect>
  
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 80906ec:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 80906f0:	f7f2 fe20 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE); 
 80906f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80906f8:	f7f2 fe38 	bl	808336c <BSP_LCD_SetBackColor>
  status = BSP_QSPI_Init();
 80906fc:	f7f4 fa24 	bl	8084b48 <BSP_QSPI_Init>
  if (status == QSPI_NOT_SUPPORTED)
 8090700:	2804      	cmp	r0, #4
 8090702:	d049      	beq.n	8090798 <QSPI_demo+0x188>
  else if (status == QSPI_ERROR)
 8090704:	2801      	cmp	r0, #1
 8090706:	d034      	beq.n	8090772 <QSPI_demo+0x162>
    BSP_LCD_DisplayStringAt(20, 100, (uint8_t*)"QSPI Initialization : OK.", LEFT_MODE);
 8090708:	f645 4268 	movw	r2, #23656	; 0x5c68
    pQSPI_Info.FlashSize        = (uint32_t)0x00;
 809070c:	f24c 54ec 	movw	r4, #50668	; 0xc5ec
    BSP_LCD_DisplayStringAt(20, 100, (uint8_t*)"QSPI Initialization : OK.", LEFT_MODE);
 8090710:	2303      	movs	r3, #3
 8090712:	2164      	movs	r1, #100	; 0x64
    pQSPI_Info.FlashSize        = (uint32_t)0x00;
 8090714:	f2c2 0402 	movt	r4, #8194	; 0x2002
    BSP_LCD_DisplayStringAt(20, 100, (uint8_t*)"QSPI Initialization : OK.", LEFT_MODE);
 8090718:	f6c0 0209 	movt	r2, #2057	; 0x809
 809071c:	2014      	movs	r0, #20
 809071e:	f7f2 ff8b 	bl	8083638 <BSP_LCD_DisplayStringAt>
    pQSPI_Info.FlashSize        = (uint32_t)0x00;
 8090722:	2300      	movs	r3, #0
    BSP_QSPI_GetInfo(&pQSPI_Info);
 8090724:	4620      	mov	r0, r4
    pQSPI_Info.ProgPagesNumber    = (uint32_t)0x00;
 8090726:	6123      	str	r3, [r4, #16]
    pQSPI_Info.EraseSectorSize    = (uint32_t)0x00;
 8090728:	e9c4 3300 	strd	r3, r3, [r4]
    pQSPI_Info.ProgPageSize       = (uint32_t)0x00;
 809072c:	e9c4 3302 	strd	r3, r3, [r4, #8]
    BSP_QSPI_GetInfo(&pQSPI_Info);
 8090730:	f7f4 f932 	bl	8084998 <BSP_QSPI_GetInfo>
    if((pQSPI_Info.FlashSize != 0x1000000) || (pQSPI_Info.EraseSectorSize != 0x1000)  ||
 8090734:	6823      	ldr	r3, [r4, #0]
 8090736:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 809073a:	d103      	bne.n	8090744 <QSPI_demo+0x134>
 809073c:	6863      	ldr	r3, [r4, #4]
 809073e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8090742:	d060      	beq.n	8090806 <QSPI_demo+0x1f6>
      BSP_LCD_DisplayStringAt(20, 115, (uint8_t*)"QSPI GET INFO : FAILED.", LEFT_MODE);
 8090744:	f645 4284 	movw	r2, #23684	; 0x5c84
 8090748:	2303      	movs	r3, #3
 809074a:	2173      	movs	r1, #115	; 0x73
 809074c:	2014      	movs	r0, #20
 809074e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090752:	f7f2 ff71 	bl	8083638 <BSP_LCD_DisplayStringAt>
      BSP_LCD_DisplayStringAt(20, 130, (uint8_t*)"QSPI Test Aborted.", LEFT_MODE);
 8090756:	f645 32cc 	movw	r2, #23500	; 0x5bcc
 809075a:	2303      	movs	r3, #3
 809075c:	2182      	movs	r1, #130	; 0x82
 809075e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090762:	2014      	movs	r0, #20
 8090764:	f7f2 ff68 	bl	8083638 <BSP_LCD_DisplayStringAt>
    if(CheckForUserInput() > 0)
 8090768:	f000 fdfe 	bl	8091368 <CheckForUserInput>
 809076c:	2800      	cmp	r0, #0
 809076e:	d0fb      	beq.n	8090768 <QSPI_demo+0x158>
}
 8090770:	bd70      	pop	{r4, r5, r6, pc}
    BSP_LCD_DisplayStringAt(20, 100, (uint8_t*)"QSPI Initialization : FAILED.", LEFT_MODE);
 8090772:	f645 32ac 	movw	r2, #23468	; 0x5bac
 8090776:	2303      	movs	r3, #3
 8090778:	2164      	movs	r1, #100	; 0x64
 809077a:	2014      	movs	r0, #20
 809077c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090780:	f7f2 ff5a 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t*)"QSPI Test Aborted.", LEFT_MODE);
 8090784:	f645 32cc 	movw	r2, #23500	; 0x5bcc
 8090788:	2303      	movs	r3, #3
 809078a:	2173      	movs	r1, #115	; 0x73
 809078c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090790:	2014      	movs	r0, #20
 8090792:	f7f2 ff51 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090796:	e7e7      	b.n	8090768 <QSPI_demo+0x158>
    BSP_LCD_DisplayStringAt(20, 100, (uint8_t*)"QSPI Initialization : FAILED.", LEFT_MODE);
 8090798:	f645 32ac 	movw	r2, #23468	; 0x5bac
 809079c:	2303      	movs	r3, #3
 809079e:	2164      	movs	r1, #100	; 0x64
 80907a0:	2014      	movs	r0, #20
 80907a2:	f6c0 0209 	movt	r2, #2057	; 0x809
 80907a6:	f7f2 ff47 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t*)"QSPI Test Aborted.", LEFT_MODE);
 80907aa:	f645 32cc 	movw	r2, #23500	; 0x5bcc
 80907ae:	2303      	movs	r3, #3
 80907b0:	2173      	movs	r1, #115	; 0x73
 80907b2:	f6c0 0209 	movt	r2, #2057	; 0x809
 80907b6:	2014      	movs	r0, #20
 80907b8:	f7f2 ff3e 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 145, (uint8_t*)"Check the hardware configuration :", LEFT_MODE);
 80907bc:	f645 32e0 	movw	r2, #23520	; 0x5be0
 80907c0:	2303      	movs	r3, #3
 80907c2:	2191      	movs	r1, #145	; 0x91
 80907c4:	f6c0 0209 	movt	r2, #2057	; 0x809
 80907c8:	2014      	movs	r0, #20
 80907ca:	f7f2 ff35 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 160, (uint8_t*)"  refer to the UM of the board", LEFT_MODE);
 80907ce:	f645 4204 	movw	r2, #23556	; 0x5c04
 80907d2:	2303      	movs	r3, #3
 80907d4:	21a0      	movs	r1, #160	; 0xa0
 80907d6:	f6c0 0209 	movt	r2, #2057	; 0x809
 80907da:	2014      	movs	r0, #20
 80907dc:	f7f2 ff2c 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 175, (uint8_t*)"  for the hardware modifications", LEFT_MODE);
 80907e0:	f645 4224 	movw	r2, #23588	; 0x5c24
 80907e4:	2303      	movs	r3, #3
 80907e6:	21af      	movs	r1, #175	; 0xaf
 80907e8:	f6c0 0209 	movt	r2, #2057	; 0x809
 80907ec:	2014      	movs	r0, #20
 80907ee:	f7f2 ff23 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 190, (uint8_t*)"  to connect the QSPI memory", LEFT_MODE);
 80907f2:	f645 4248 	movw	r2, #23624	; 0x5c48
 80907f6:	2303      	movs	r3, #3
 80907f8:	21be      	movs	r1, #190	; 0xbe
 80907fa:	f6c0 0209 	movt	r2, #2057	; 0x809
 80907fe:	2014      	movs	r0, #20
 8090800:	f7f2 ff1a 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090804:	e7b0      	b.n	8090768 <QSPI_demo+0x158>
    if((pQSPI_Info.FlashSize != 0x1000000) || (pQSPI_Info.EraseSectorSize != 0x1000)  ||
 8090806:	68e3      	ldr	r3, [r4, #12]
 8090808:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 809080c:	d19a      	bne.n	8090744 <QSPI_demo+0x134>
       (pQSPI_Info.ProgPageSize != 0x100)  || (pQSPI_Info.EraseSectorsNumber != 4096) ||
 809080e:	68a3      	ldr	r3, [r4, #8]
 8090810:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8090814:	d196      	bne.n	8090744 <QSPI_demo+0x134>
 8090816:	6923      	ldr	r3, [r4, #16]
 8090818:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 809081c:	d192      	bne.n	8090744 <QSPI_demo+0x134>
      BSP_LCD_DisplayStringAt(20, 115, (uint8_t*)"QSPI GET INFO : OK.   ", LEFT_MODE);
 809081e:	f645 429c 	movw	r2, #23708	; 0x5c9c
 8090822:	2014      	movs	r0, #20
 8090824:	2303      	movs	r3, #3
 8090826:	2173      	movs	r1, #115	; 0x73
 8090828:	f6c0 0209 	movt	r2, #2057	; 0x809
 809082c:	f7f2 ff04 	bl	8083638 <BSP_LCD_DisplayStringAt>
      if(BSP_QSPI_Erase_Block(WRITE_READ_ADDR) != QSPI_OK)
 8090830:	2050      	movs	r0, #80	; 0x50
 8090832:	f7f4 f881 	bl	8084938 <BSP_QSPI_Erase_Block>
 8090836:	b190      	cbz	r0, 809085e <QSPI_demo+0x24e>
        BSP_LCD_DisplayStringAt(20, 130, (uint8_t*)"QSPI ERASE : FAILED.", LEFT_MODE);
 8090838:	f645 42b4 	movw	r2, #23732	; 0x5cb4
 809083c:	2303      	movs	r3, #3
 809083e:	2182      	movs	r1, #130	; 0x82
 8090840:	2014      	movs	r0, #20
 8090842:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090846:	f7f2 fef7 	bl	8083638 <BSP_LCD_DisplayStringAt>
        BSP_LCD_DisplayStringAt(20, 145, (uint8_t*)"QSPI Test Aborted.", LEFT_MODE);
 809084a:	f645 32cc 	movw	r2, #23500	; 0x5bcc
 809084e:	2303      	movs	r3, #3
 8090850:	2191      	movs	r1, #145	; 0x91
 8090852:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090856:	2014      	movs	r0, #20
 8090858:	f7f2 feee 	bl	8083638 <BSP_LCD_DisplayStringAt>
 809085c:	e784      	b.n	8090768 <QSPI_demo+0x158>
        BSP_LCD_DisplayStringAt(20, 130, (uint8_t*)"QSPI ERASE : OK.   ", LEFT_MODE);
 809085e:	f645 42cc 	movw	r2, #23756	; 0x5ccc
 8090862:	2303      	movs	r3, #3
 8090864:	2014      	movs	r0, #20
 8090866:	2182      	movs	r1, #130	; 0x82
 8090868:	f6c0 0209 	movt	r2, #2057	; 0x809
 809086c:	f7f2 fee4 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090870:	f24f 23f3 	movw	r3, #62195	; 0xf2f3
 8090874:	220f      	movs	r2, #15
 8090876:	f2c2 0302 	movt	r3, #8194	; 0x2002
 809087a:	1c5d      	adds	r5, r3, #1
 809087c:	462e      	mov	r6, r5
 809087e:	f205 10ff 	addw	r0, r5, #511	; 0x1ff
  uint32_t tmpIndex = 0;
  
  /* Put in global buffer different values */
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
  {
    pBuffer[tmpIndex] = tmpIndex + uwOffset;
 8090882:	f803 2f01 	strb.w	r2, [r3, #1]!
 8090886:	1c51      	adds	r1, r2, #1
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
 8090888:	4283      	cmp	r3, r0
 809088a:	b2ca      	uxtb	r2, r1
 809088c:	d1f9      	bne.n	8090882 <QSPI_demo+0x272>
        if(BSP_QSPI_Write(qspi_aTxBuffer, WRITE_READ_ADDR, BUFFER_SIZE) != QSPI_OK)
 809088e:	f24f 20f4 	movw	r0, #62196	; 0xf2f4
 8090892:	f44f 7200 	mov.w	r2, #512	; 0x200
 8090896:	2150      	movs	r1, #80	; 0x50
 8090898:	f2c2 0002 	movt	r0, #8194	; 0x2002
 809089c:	f7f3 fffc 	bl	8084898 <BSP_QSPI_Write>
 80908a0:	b190      	cbz	r0, 80908c8 <QSPI_demo+0x2b8>
          BSP_LCD_DisplayStringAt(20, 145, (uint8_t*)"QSPI WRITE : FAILED.", LEFT_MODE);
 80908a2:	f645 42e0 	movw	r2, #23776	; 0x5ce0
 80908a6:	2303      	movs	r3, #3
 80908a8:	2191      	movs	r1, #145	; 0x91
 80908aa:	2014      	movs	r0, #20
 80908ac:	f6c0 0209 	movt	r2, #2057	; 0x809
 80908b0:	f7f2 fec2 	bl	8083638 <BSP_LCD_DisplayStringAt>
          BSP_LCD_DisplayStringAt(20, 160, (uint8_t*)"QSPI Test Aborted.", LEFT_MODE);
 80908b4:	f645 32cc 	movw	r2, #23500	; 0x5bcc
 80908b8:	2303      	movs	r3, #3
 80908ba:	21a0      	movs	r1, #160	; 0xa0
 80908bc:	f6c0 0209 	movt	r2, #2057	; 0x809
 80908c0:	2014      	movs	r0, #20
 80908c2:	f7f2 feb9 	bl	8083638 <BSP_LCD_DisplayStringAt>
 80908c6:	e74f      	b.n	8090768 <QSPI_demo+0x158>
          if(BSP_QSPI_Read(qspi_aRxBuffer, WRITE_READ_ADDR, BUFFER_SIZE) != QSPI_OK)
 80908c8:	f24f 04f4 	movw	r4, #61684	; 0xf0f4
          BSP_LCD_DisplayStringAt(20, 145, (uint8_t*)"QSPI WRITE : OK.     ", LEFT_MODE);
 80908cc:	f645 42f8 	movw	r2, #23800	; 0x5cf8
 80908d0:	2191      	movs	r1, #145	; 0x91
 80908d2:	2014      	movs	r0, #20
          if(BSP_QSPI_Read(qspi_aRxBuffer, WRITE_READ_ADDR, BUFFER_SIZE) != QSPI_OK)
 80908d4:	f2c2 0402 	movt	r4, #8194	; 0x2002
          BSP_LCD_DisplayStringAt(20, 145, (uint8_t*)"QSPI WRITE : OK.     ", LEFT_MODE);
 80908d8:	f6c0 0209 	movt	r2, #2057	; 0x809
 80908dc:	2303      	movs	r3, #3
 80908de:	f7f2 feab 	bl	8083638 <BSP_LCD_DisplayStringAt>
          if(BSP_QSPI_Read(qspi_aRxBuffer, WRITE_READ_ADDR, BUFFER_SIZE) != QSPI_OK)
 80908e2:	4620      	mov	r0, r4
 80908e4:	f44f 7200 	mov.w	r2, #512	; 0x200
 80908e8:	2150      	movs	r1, #80	; 0x50
 80908ea:	f7f3 ff95 	bl	8084818 <BSP_QSPI_Read>
 80908ee:	b190      	cbz	r0, 8090916 <QSPI_demo+0x306>
            BSP_LCD_DisplayStringAt(20, 160, (uint8_t*)"QSPI READ : FAILED.", LEFT_MODE);
 80908f0:	f645 5210 	movw	r2, #23824	; 0x5d10
 80908f4:	2303      	movs	r3, #3
 80908f6:	21a0      	movs	r1, #160	; 0xa0
 80908f8:	2014      	movs	r0, #20
 80908fa:	f6c0 0209 	movt	r2, #2057	; 0x809
 80908fe:	f7f2 fe9b 	bl	8083638 <BSP_LCD_DisplayStringAt>
            BSP_LCD_DisplayStringAt(20, 175, (uint8_t*)"QSPI Test Aborted.", LEFT_MODE);
 8090902:	f645 32cc 	movw	r2, #23500	; 0x5bcc
 8090906:	2303      	movs	r3, #3
 8090908:	21af      	movs	r1, #175	; 0xaf
 809090a:	f6c0 0209 	movt	r2, #2057	; 0x809
 809090e:	2014      	movs	r0, #20
 8090910:	f7f2 fe92 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090914:	e728      	b.n	8090768 <QSPI_demo+0x158>
            BSP_LCD_DisplayStringAt(20, 160, (uint8_t*)"QSPI READ :  OK.    ", LEFT_MODE);
 8090916:	f645 5224 	movw	r2, #23844	; 0x5d24
 809091a:	2303      	movs	r3, #3
 809091c:	21a0      	movs	r1, #160	; 0xa0
 809091e:	2014      	movs	r0, #20
 8090920:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090924:	f7f2 fe88 	bl	8083638 <BSP_LCD_DisplayStringAt>
*/
static uint8_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint32_t BufferLength)
{
  while (BufferLength--)
  {
    if (*pBuffer1 != *pBuffer2)
 8090928:	782a      	ldrb	r2, [r5, #0]
 809092a:	7823      	ldrb	r3, [r4, #0]
 809092c:	429a      	cmp	r2, r3
 809092e:	d10a      	bne.n	8090946 <QSPI_demo+0x336>
 8090930:	f204 13ff 	addw	r3, r4, #511	; 0x1ff
 8090934:	e001      	b.n	809093a <QSPI_demo+0x32a>
  while (BufferLength--)
 8090936:	429c      	cmp	r4, r3
 8090938:	d018      	beq.n	809096c <QSPI_demo+0x35c>
    if (*pBuffer1 != *pBuffer2)
 809093a:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 809093e:	f816 2f01 	ldrb.w	r2, [r6, #1]!
 8090942:	4291      	cmp	r1, r2
 8090944:	d0f7      	beq.n	8090936 <QSPI_demo+0x326>
              BSP_LCD_DisplayStringAt(20, 175, (uint8_t*)"QSPI COMPARE : FAILED.", LEFT_MODE);
 8090946:	f645 523c 	movw	r2, #23868	; 0x5d3c
 809094a:	2303      	movs	r3, #3
 809094c:	21af      	movs	r1, #175	; 0xaf
 809094e:	2014      	movs	r0, #20
 8090950:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090954:	f7f2 fe70 	bl	8083638 <BSP_LCD_DisplayStringAt>
              BSP_LCD_DisplayStringAt(20, 190, (uint8_t*)"QSPI Test Aborted.", LEFT_MODE);
 8090958:	f645 32cc 	movw	r2, #23500	; 0x5bcc
 809095c:	2303      	movs	r3, #3
 809095e:	21be      	movs	r1, #190	; 0xbe
 8090960:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090964:	2014      	movs	r0, #20
 8090966:	f7f2 fe67 	bl	8083638 <BSP_LCD_DisplayStringAt>
 809096a:	e6fd      	b.n	8090768 <QSPI_demo+0x158>
              BSP_LCD_DisplayStringAt(20, 175, (uint8_t*)"QSPI Test : OK.     ", LEFT_MODE);
 809096c:	f645 5254 	movw	r2, #23892	; 0x5d54
 8090970:	2303      	movs	r3, #3
 8090972:	21af      	movs	r1, #175	; 0xaf
 8090974:	2014      	movs	r0, #20
 8090976:	f6c0 0209 	movt	r2, #2057	; 0x809
 809097a:	f7f2 fe5d 	bl	8083638 <BSP_LCD_DisplayStringAt>
 809097e:	e6f3      	b.n	8090768 <QSPI_demo+0x158>

08090980 <SDRAM_demo>:
  * @brief  SDRAM Demo
  * @param  None
  * @retval None
  */
void SDRAM_demo (void)
{
 8090980:	b510      	push	{r4, lr}
  * @retval None
  */
static void SDRAM_SetHint(void)
{
  /* Clear the LCD */
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 8090982:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090986:	f7f2 fd21 	bl	80833cc <BSP_LCD_Clear>

  /* Set LCD Demo description */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 809098a:	20ff      	movs	r0, #255	; 0xff
 809098c:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090990:	f7f2 fcd0 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 8090994:	f7f2 fc58 	bl	8083248 <BSP_LCD_GetXSize>
 8090998:	2100      	movs	r1, #0
 809099a:	b282      	uxth	r2, r0
 809099c:	2350      	movs	r3, #80	; 0x50
 809099e:	4608      	mov	r0, r1
 80909a0:	f7f3 f9b6 	bl	8083d10 <BSP_LCD_FillRect>
  BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 80909a4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80909a8:	f7f2 fcc4 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 80909ac:	20ff      	movs	r0, #255	; 0xff
 80909ae:	f6cf 7000 	movt	r0, #65280	; 0xff00
 80909b2:	f7f2 fcdb 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetFont(&Font24);
 80909b6:	f24b 3064 	movw	r0, #45924	; 0xb364
 80909ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80909be:	f7f2 fce5 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"SDRAM", CENTER_MODE);
 80909c2:	2100      	movs	r1, #0
 80909c4:	f645 526c 	movw	r2, #23916	; 0x5d6c
 80909c8:	2301      	movs	r3, #1
 80909ca:	4608      	mov	r0, r1
 80909cc:	f6c0 0209 	movt	r2, #2057	; 0x809
 80909d0:	f7f2 fe32 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetFont(&Font12);
 80909d4:	f24b 304c 	movw	r0, #45900	; 0xb34c
 80909d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80909dc:	f7f2 fcd6 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows how to write", CENTER_MODE);
 80909e0:	f645 02a0 	movw	r2, #22688	; 0x58a0
 80909e4:	2301      	movs	r3, #1
 80909e6:	211e      	movs	r1, #30
 80909e8:	f6c0 0209 	movt	r2, #2057	; 0x809
 80909ec:	2000      	movs	r0, #0
 80909ee:	f7f2 fe23 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"and read data on SDRAM", CENTER_MODE);
 80909f2:	f645 5274 	movw	r2, #23924	; 0x5d74
 80909f6:	2301      	movs	r3, #1
 80909f8:	212d      	movs	r1, #45	; 0x2d
 80909fa:	f6c0 0209 	movt	r2, #2057	; 0x809
 80909fe:	2000      	movs	r0, #0
 8090a00:	f7f2 fe1a 	bl	8083638 <BSP_LCD_DisplayStringAt>

  /* Set the LCD Text Color */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090a04:	20ff      	movs	r0, #255	; 0xff
 8090a06:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090a0a:	f7f2 fc93 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 100);
 8090a0e:	f7f2 fc1b 	bl	8083248 <BSP_LCD_GetXSize>
 8090a12:	4604      	mov	r4, r0
 8090a14:	f7f2 fc26 	bl	8083264 <BSP_LCD_GetYSize>
 8090a18:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 8090a1c:	f1a4 0214 	sub.w	r2, r4, #20
 8090a20:	215a      	movs	r1, #90	; 0x5a
 8090a22:	b29b      	uxth	r3, r3
 8090a24:	200a      	movs	r0, #10
 8090a26:	b292      	uxth	r2, r2
 8090a28:	f7f2 fd5c 	bl	80834e4 <BSP_LCD_DrawRect>
  BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 102);
 8090a2c:	f7f2 fc0c 	bl	8083248 <BSP_LCD_GetXSize>
 8090a30:	4604      	mov	r4, r0
 8090a32:	f7f2 fc17 	bl	8083264 <BSP_LCD_GetYSize>
 8090a36:	f1a0 0366 	sub.w	r3, r0, #102	; 0x66
 8090a3a:	f1a4 0216 	sub.w	r2, r4, #22
 8090a3e:	215b      	movs	r1, #91	; 0x5b
 8090a40:	b29b      	uxth	r3, r3
 8090a42:	200b      	movs	r0, #11
 8090a44:	b292      	uxth	r2, r2
 8090a46:	f7f2 fd4d 	bl	80834e4 <BSP_LCD_DrawRect>

  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 8090a4a:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8090a4e:	f7f2 fc71 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 8090a52:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090a56:	f7f2 fc89 	bl	808336c <BSP_LCD_SetBackColor>
  if (BSP_SDRAM_Init() != SDRAM_OK)
 8090a5a:	f7f4 fc3b 	bl	80852d4 <BSP_SDRAM_Init>
 8090a5e:	2800      	cmp	r0, #0
 8090a60:	f000 80a3 	beq.w	8090baa <SDRAM_demo+0x22a>
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM Initialization : FAILED.", LEFT_MODE);
 8090a64:	f645 528c 	movw	r2, #23948	; 0x5d8c
 8090a68:	2303      	movs	r3, #3
 8090a6a:	2173      	movs	r1, #115	; 0x73
 8090a6c:	2014      	movs	r0, #20
 8090a6e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090a72:	f7f2 fde1 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
 8090a76:	f645 52ac 	movw	r2, #23980	; 0x5dac
 8090a7a:	2303      	movs	r3, #3
 8090a7c:	2182      	movs	r1, #130	; 0x82
 8090a7e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090a82:	2014      	movs	r0, #20
 8090a84:	f7f2 fdd8 	bl	8083638 <BSP_LCD_DisplayStringAt>
{
 8090a88:	f242 530f 	movw	r3, #9487	; 0x250f
static void Fill_Buffer(uint32_t *pBuffer, uint32_t uwBufferLenght, uint32_t uwOffset)
{
  uint32_t tmpIndex = 0;

  /* Put in global buffer different values */
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
 8090a8c:	f242 610f 	movw	r1, #9743	; 0x260f
 8090a90:	f64c 12fc 	movw	r2, #51708	; 0xc9fc
{
 8090a94:	f2ca 2344 	movt	r3, #41540	; 0xa244
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
 8090a98:	f2ca 2144 	movt	r1, #41540	; 0xa244
 8090a9c:	f2c2 0202 	movt	r2, #8194	; 0x2002
  {
    pBuffer[tmpIndex] = tmpIndex + uwOffset;
 8090aa0:	f842 3f04 	str.w	r3, [r2, #4]!
 8090aa4:	3301      	adds	r3, #1
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
 8090aa6:	428b      	cmp	r3, r1
 8090aa8:	d1fa      	bne.n	8090aa0 <SDRAM_demo+0x120>
  if (BSP_SDRAM_WriteData((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aTxBuffer, SDRAM_BUFFER_SIZE) != SDRAM_OK)
 8090aaa:	f240 0400 	movw	r4, #0
 8090aae:	f64c 2100 	movw	r1, #51712	; 0xca00
 8090ab2:	f44f 7280 	mov.w	r2, #256	; 0x100
 8090ab6:	f2cc 0408 	movt	r4, #49160	; 0xc008
 8090aba:	f2c2 0102 	movt	r1, #8194	; 0x2002
 8090abe:	4620      	mov	r0, r4
 8090ac0:	f7f4 fb28 	bl	8085114 <BSP_SDRAM_WriteData>
 8090ac4:	2800      	cmp	r0, #0
 8090ac6:	d066      	beq.n	8090b96 <SDRAM_demo+0x216>
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE : FAILED.", LEFT_MODE);
 8090ac8:	f645 52dc 	movw	r2, #24028	; 0x5ddc
 8090acc:	2303      	movs	r3, #3
 8090ace:	2173      	movs	r1, #115	; 0x73
 8090ad0:	2014      	movs	r0, #20
 8090ad2:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090ad6:	f7f2 fdaf 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
 8090ada:	f645 52ac 	movw	r2, #23980	; 0x5dac
 8090ade:	2303      	movs	r3, #3
 8090ae0:	2182      	movs	r1, #130	; 0x82
 8090ae2:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090ae6:	2014      	movs	r0, #20
 8090ae8:	f7f2 fda6 	bl	8083638 <BSP_LCD_DisplayStringAt>
  if (BSP_SDRAM_ReadData(SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET, sdram_aRxBuffer, SDRAM_BUFFER_SIZE) != SDRAM_OK)
 8090aec:	f24c 6100 	movw	r1, #50688	; 0xc600
 8090af0:	4620      	mov	r0, r4
 8090af2:	f44f 7280 	mov.w	r2, #256	; 0x100
 8090af6:	f2c2 0102 	movt	r1, #8194	; 0x2002
 8090afa:	f7f4 faef 	bl	80850dc <BSP_SDRAM_ReadData>
 8090afe:	2800      	cmp	r0, #0
 8090b00:	d03f      	beq.n	8090b82 <SDRAM_demo+0x202>
    BSP_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM READ : FAILED.", LEFT_MODE);
 8090b02:	f645 6208 	movw	r2, #24072	; 0x5e08
 8090b06:	2303      	movs	r3, #3
 8090b08:	2182      	movs	r1, #130	; 0x82
 8090b0a:	2014      	movs	r0, #20
 8090b0c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090b10:	f7f2 fd92 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
 8090b14:	f645 52ac 	movw	r2, #23980	; 0x5dac
 8090b18:	2303      	movs	r3, #3
 8090b1a:	2191      	movs	r1, #145	; 0x91
 8090b1c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090b20:	2014      	movs	r0, #20
 8090b22:	f7f2 fd89 	bl	8083638 <BSP_LCD_DisplayStringAt>
  */
static uint8_t Buffercmp(uint32_t* pBuffer1, uint32_t* pBuffer2, uint16_t BufferLength)
{
  while (BufferLength--)
  {
    if (*pBuffer1 != *pBuffer2)
 8090b26:	f24c 6200 	movw	r2, #50688	; 0xc600
 8090b2a:	f64c 2300 	movw	r3, #51712	; 0xca00
 8090b2e:	f2c2 0202 	movt	r2, #8194	; 0x2002
 8090b32:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8090b36:	6810      	ldr	r0, [r2, #0]
 8090b38:	6819      	ldr	r1, [r3, #0]
 8090b3a:	4288      	cmp	r0, r1
 8090b3c:	d10a      	bne.n	8090b54 <SDRAM_demo+0x1d4>
 8090b3e:	f503 747f 	add.w	r4, r3, #1020	; 0x3fc
 8090b42:	e001      	b.n	8090b48 <SDRAM_demo+0x1c8>
  while (BufferLength--)
 8090b44:	42a3      	cmp	r3, r4
 8090b46:	d03a      	beq.n	8090bbe <SDRAM_demo+0x23e>
    if (*pBuffer1 != *pBuffer2)
 8090b48:	f853 0f04 	ldr.w	r0, [r3, #4]!
 8090b4c:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8090b50:	4288      	cmp	r0, r1
 8090b52:	d0f7      	beq.n	8090b44 <SDRAM_demo+0x1c4>
    BSP_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM COMPARE : FAILED.", LEFT_MODE);
 8090b54:	f645 6234 	movw	r2, #24116	; 0x5e34
 8090b58:	2303      	movs	r3, #3
 8090b5a:	2191      	movs	r1, #145	; 0x91
 8090b5c:	2014      	movs	r0, #20
 8090b5e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090b62:	f7f2 fd69 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
 8090b66:	f645 52ac 	movw	r2, #23980	; 0x5dac
 8090b6a:	2303      	movs	r3, #3
 8090b6c:	21a0      	movs	r1, #160	; 0xa0
 8090b6e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090b72:	2014      	movs	r0, #20
 8090b74:	f7f2 fd60 	bl	8083638 <BSP_LCD_DisplayStringAt>
    if (CheckForUserInput() > 0)
 8090b78:	f000 fbf6 	bl	8091368 <CheckForUserInput>
 8090b7c:	2800      	cmp	r0, #0
 8090b7e:	d0fb      	beq.n	8090b78 <SDRAM_demo+0x1f8>
}
 8090b80:	bd10      	pop	{r4, pc}
    BSP_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM READ : OK.", LEFT_MODE);
 8090b82:	f645 6220 	movw	r2, #24096	; 0x5e20
 8090b86:	2303      	movs	r3, #3
 8090b88:	2182      	movs	r1, #130	; 0x82
 8090b8a:	2014      	movs	r0, #20
 8090b8c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090b90:	f7f2 fd52 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090b94:	e7c7      	b.n	8090b26 <SDRAM_demo+0x1a6>
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE : OK.", LEFT_MODE);
 8090b96:	f645 52f4 	movw	r2, #24052	; 0x5df4
 8090b9a:	2303      	movs	r3, #3
 8090b9c:	2173      	movs	r1, #115	; 0x73
 8090b9e:	2014      	movs	r0, #20
 8090ba0:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090ba4:	f7f2 fd48 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090ba8:	e7a0      	b.n	8090aec <SDRAM_demo+0x16c>
    BSP_LCD_DisplayStringAt(20, 100, (uint8_t *)"SDRAM Initialization : OK.", LEFT_MODE);
 8090baa:	f645 52c0 	movw	r2, #24000	; 0x5dc0
 8090bae:	2303      	movs	r3, #3
 8090bb0:	2164      	movs	r1, #100	; 0x64
 8090bb2:	2014      	movs	r0, #20
 8090bb4:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090bb8:	f7f2 fd3e 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090bbc:	e764      	b.n	8090a88 <SDRAM_demo+0x108>
    BSP_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM Test : OK.", LEFT_MODE);
 8090bbe:	f645 624c 	movw	r2, #24140	; 0x5e4c
 8090bc2:	2303      	movs	r3, #3
 8090bc4:	2191      	movs	r1, #145	; 0x91
 8090bc6:	2014      	movs	r0, #20
 8090bc8:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090bcc:	f7f2 fd34 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090bd0:	e7d2      	b.n	8090b78 <SDRAM_demo+0x1f8>
 8090bd2:	bf00      	nop

08090bd4 <SDRAM_DMA_demo>:
  * @brief  SDRAM Demo
  * @param  None
  * @retval None
  */
void SDRAM_DMA_demo (void)
{
 8090bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  * @retval None
  */
static void SDRAM_DMA_SetHint(void)
{
  /* Clear the LCD */
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 8090bd6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090bda:	f7f2 fbf7 	bl	80833cc <BSP_LCD_Clear>

  /* Set LCD Demo description */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090bde:	20ff      	movs	r0, #255	; 0xff
 8090be0:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090be4:	f7f2 fba6 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 8090be8:	f7f2 fb2e 	bl	8083248 <BSP_LCD_GetXSize>
 8090bec:	2100      	movs	r1, #0
 8090bee:	b282      	uxth	r2, r0
 8090bf0:	2350      	movs	r3, #80	; 0x50
 8090bf2:	4608      	mov	r0, r1
 8090bf4:	f7f3 f88c 	bl	8083d10 <BSP_LCD_FillRect>
  BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 8090bf8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090bfc:	f7f2 fb9a 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 8090c00:	20ff      	movs	r0, #255	; 0xff
 8090c02:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090c06:	f7f2 fbb1 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetFont(&Font24);
 8090c0a:	f24b 3064 	movw	r0, #45924	; 0xb364
 8090c0e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8090c12:	f7f2 fbbb 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"SDRAM DMA", CENTER_MODE);
 8090c16:	2100      	movs	r1, #0
 8090c18:	f645 626c 	movw	r2, #24172	; 0x5e6c
 8090c1c:	2301      	movs	r3, #1
 8090c1e:	4608      	mov	r0, r1
 8090c20:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090c24:	f7f2 fd08 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetFont(&Font12);
 8090c28:	f24b 304c 	movw	r0, #45900	; 0xb34c
 8090c2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8090c30:	f7f2 fbac 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows how to write", CENTER_MODE);
 8090c34:	f645 02a0 	movw	r2, #22688	; 0x58a0
 8090c38:	2301      	movs	r3, #1
 8090c3a:	211e      	movs	r1, #30
 8090c3c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090c40:	2000      	movs	r0, #0
 8090c42:	f7f2 fcf9 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"and read data on SDRAM", CENTER_MODE);
 8090c46:	f645 5274 	movw	r2, #23924	; 0x5d74
 8090c4a:	2301      	movs	r3, #1
 8090c4c:	212d      	movs	r1, #45	; 0x2d
 8090c4e:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090c52:	2000      	movs	r0, #0
 8090c54:	f7f2 fcf0 	bl	8083638 <BSP_LCD_DisplayStringAt>

  /* Set the LCD Text Color */
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090c58:	20ff      	movs	r0, #255	; 0xff
 8090c5a:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090c5e:	f7f2 fb69 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 100);
 8090c62:	f7f2 faf1 	bl	8083248 <BSP_LCD_GetXSize>
 8090c66:	4604      	mov	r4, r0
 8090c68:	f7f2 fafc 	bl	8083264 <BSP_LCD_GetYSize>
 8090c6c:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 8090c70:	f1a4 0214 	sub.w	r2, r4, #20
 8090c74:	215a      	movs	r1, #90	; 0x5a
 8090c76:	b29b      	uxth	r3, r3
 8090c78:	200a      	movs	r0, #10
 8090c7a:	b292      	uxth	r2, r2
 8090c7c:	f7f2 fc32 	bl	80834e4 <BSP_LCD_DrawRect>
  BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 102);
 8090c80:	f7f2 fae2 	bl	8083248 <BSP_LCD_GetXSize>
 8090c84:	4604      	mov	r4, r0
 8090c86:	f7f2 faed 	bl	8083264 <BSP_LCD_GetYSize>
 8090c8a:	f1a0 0366 	sub.w	r3, r0, #102	; 0x66
 8090c8e:	f1a4 0216 	sub.w	r2, r4, #22
 8090c92:	215b      	movs	r1, #91	; 0x5b
 8090c94:	b29b      	uxth	r3, r3
 8090c96:	200b      	movs	r0, #11
 8090c98:	b292      	uxth	r2, r2
 8090c9a:	f7f2 fc23 	bl	80834e4 <BSP_LCD_DrawRect>

  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 8090c9e:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8090ca2:	f7f2 fb47 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 8090ca6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090caa:	f7f2 fb5f 	bl	808336c <BSP_LCD_SetBackColor>
  if (BSP_SDRAM_Init() != SDRAM_OK)
 8090cae:	f7f4 fb11 	bl	80852d4 <BSP_SDRAM_Init>
 8090cb2:	2800      	cmp	r0, #0
 8090cb4:	f000 80e2 	beq.w	8090e7c <SDRAM_DMA_demo+0x2a8>
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM Initialization : FAILED.", LEFT_MODE);
 8090cb8:	f645 528c 	movw	r2, #23948	; 0x5d8c
 8090cbc:	2303      	movs	r3, #3
 8090cbe:	2173      	movs	r1, #115	; 0x73
 8090cc0:	2014      	movs	r0, #20
 8090cc2:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090cc6:	f7f2 fcb7 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
 8090cca:	f645 52ac 	movw	r2, #23980	; 0x5dac
 8090cce:	2303      	movs	r3, #3
 8090cd0:	2182      	movs	r1, #130	; 0x82
 8090cd2:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090cd6:	2014      	movs	r0, #20
 8090cd8:	f7f2 fcae 	bl	8083638 <BSP_LCD_DisplayStringAt>
{
 8090cdc:	f242 530f 	movw	r3, #9487	; 0x250f
static void Fill_Buffer(uint32_t *pBuffer, uint32_t uwBufferLength, uint32_t uwOffset)
{
  uint32_t tmpIndex = 0;

  /* Put in global buffer different values */
  for (tmpIndex = 0; tmpIndex < uwBufferLength; tmpIndex++ )
 8090ce0:	f242 610f 	movw	r1, #9743	; 0x260f
 8090ce4:	f24d 12fc 	movw	r2, #53756	; 0xd1fc
{
 8090ce8:	f2ca 2344 	movt	r3, #41540	; 0xa244
  for (tmpIndex = 0; tmpIndex < uwBufferLength; tmpIndex++ )
 8090cec:	f2ca 2144 	movt	r1, #41540	; 0xa244
 8090cf0:	f2c2 0202 	movt	r2, #8194	; 0x2002
  {
    pBuffer[tmpIndex] = tmpIndex + uwOffset;
 8090cf4:	f842 3f04 	str.w	r3, [r2, #4]!
 8090cf8:	3301      	adds	r3, #1
  for (tmpIndex = 0; tmpIndex < uwBufferLength; tmpIndex++ )
 8090cfa:	428b      	cmp	r3, r1
 8090cfc:	d1fa      	bne.n	8090cf4 <SDRAM_DMA_demo+0x120>
    uint32_t op_addr = (uint32_t) addr;
 8090cfe:	f24d 2400 	movw	r4, #53760	; 0xd200
 8090d02:	f2c2 0402 	movt	r4, #8194	; 0x2002
  __ASM volatile ("dsb 0xF":::"memory");
 8090d06:	f3bf 8f4f 	dsb	sy
      SCB->DCCMVAC = op_addr;
 8090d0a:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8090d0e:	f504 6180 	add.w	r1, r4, #1024	; 0x400
    uint32_t op_addr = (uint32_t) addr;
 8090d12:	4625      	mov	r5, r4
 8090d14:	4623      	mov	r3, r4
      SCB->DCCMVAC = op_addr;
 8090d16:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8090d1a:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += linesize;
 8090d1e:	3320      	adds	r3, #32
    while (op_size > 0) {
 8090d20:	4299      	cmp	r1, r3
 8090d22:	d1fa      	bne.n	8090d1a <SDRAM_DMA_demo+0x146>
 8090d24:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8090d28:	f3bf 8f6f 	isb	sy
  if (BSP_SDRAM_WriteData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aTxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090d2c:	f240 0700 	movw	r7, #0
  uwDMA_Transfer_Complete = 0;
 8090d30:	f24d 6600 	movw	r6, #54784	; 0xd600
  if (BSP_SDRAM_WriteData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aTxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090d34:	f24d 2100 	movw	r1, #53760	; 0xd200
  uwDMA_Transfer_Complete = 0;
 8090d38:	2300      	movs	r3, #0
  if (BSP_SDRAM_WriteData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aTxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090d3a:	f2cc 0708 	movt	r7, #49160	; 0xc008
  uwDMA_Transfer_Complete = 0;
 8090d3e:	f2c2 0602 	movt	r6, #8194	; 0x2002
  if (BSP_SDRAM_WriteData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aTxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090d42:	f2c2 0102 	movt	r1, #8194	; 0x2002
 8090d46:	f44f 7280 	mov.w	r2, #256	; 0x100
 8090d4a:	4638      	mov	r0, r7
  uwDMA_Transfer_Complete = 0;
 8090d4c:	6033      	str	r3, [r6, #0]
  if (BSP_SDRAM_WriteData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aTxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090d4e:	f7f4 f9ef 	bl	8085130 <BSP_SDRAM_WriteData_DMA>
 8090d52:	2800      	cmp	r0, #0
 8090d54:	f000 8088 	beq.w	8090e68 <SDRAM_DMA_demo+0x294>
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE dma : FAILED.", LEFT_MODE);
 8090d58:	f645 6278 	movw	r2, #24184	; 0x5e78
 8090d5c:	2303      	movs	r3, #3
 8090d5e:	2173      	movs	r1, #115	; 0x73
 8090d60:	2014      	movs	r0, #20
 8090d62:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090d66:	f7f2 fc67 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
 8090d6a:	f645 52ac 	movw	r2, #23980	; 0x5dac
 8090d6e:	2303      	movs	r3, #3
 8090d70:	2182      	movs	r1, #130	; 0x82
 8090d72:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090d76:	2014      	movs	r0, #20
 8090d78:	f7f2 fc5e 	bl	8083638 <BSP_LCD_DisplayStringAt>
  while (!uwDMA_Transfer_Complete)
 8090d7c:	6833      	ldr	r3, [r6, #0]
 8090d7e:	2b00      	cmp	r3, #0
 8090d80:	d0fc      	beq.n	8090d7c <SDRAM_DMA_demo+0x1a8>
  BSP_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM WRITE DMA : COMPLETED", LEFT_MODE);
 8090d82:	f645 62b0 	movw	r2, #24240	; 0x5eb0
 8090d86:	2303      	movs	r3, #3
 8090d88:	2182      	movs	r1, #130	; 0x82
 8090d8a:	2014      	movs	r0, #20
 8090d8c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090d90:	f7f2 fc52 	bl	8083638 <BSP_LCD_DisplayStringAt>
  if (BSP_SDRAM_ReadData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aRxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090d94:	f64c 6100 	movw	r1, #52736	; 0xce00
  uwDMA_Transfer_Complete = 0;
 8090d98:	2300      	movs	r3, #0
  if (BSP_SDRAM_ReadData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aRxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090d9a:	4638      	mov	r0, r7
 8090d9c:	f2c2 0102 	movt	r1, #8194	; 0x2002
 8090da0:	f44f 7280 	mov.w	r2, #256	; 0x100
  uwDMA_Transfer_Complete = 0;
 8090da4:	6033      	str	r3, [r6, #0]
  if (BSP_SDRAM_ReadData_DMA((SDRAM_WRITE_READ_ADDR + SDRAM_WRITE_READ_ADDR_OFFSET), sdram_aRxBuffer, SDRAM_DMA_BUFFER_SIZE) != SDRAM_OK)
 8090da6:	f7f4 f9a7 	bl	80850f8 <BSP_SDRAM_ReadData_DMA>
 8090daa:	2800      	cmp	r0, #0
 8090dac:	d070      	beq.n	8090e90 <SDRAM_DMA_demo+0x2bc>
    BSP_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM  READ DMA : FAILED", LEFT_MODE);
 8090dae:	f645 62cc 	movw	r2, #24268	; 0x5ecc
 8090db2:	2303      	movs	r3, #3
 8090db4:	2191      	movs	r1, #145	; 0x91
 8090db6:	2014      	movs	r0, #20
 8090db8:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090dbc:	f7f2 fc3c 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)"SDRAM  Test Aborted", LEFT_MODE);
 8090dc0:	f645 62e8 	movw	r2, #24296	; 0x5ee8
 8090dc4:	2303      	movs	r3, #3
 8090dc6:	21a0      	movs	r1, #160	; 0xa0
 8090dc8:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090dcc:	2014      	movs	r0, #20
 8090dce:	f7f2 fc33 	bl	8083638 <BSP_LCD_DisplayStringAt>
  while (!uwDMA_Transfer_Complete)
 8090dd2:	6833      	ldr	r3, [r6, #0]
 8090dd4:	2b00      	cmp	r3, #0
 8090dd6:	d0fc      	beq.n	8090dd2 <SDRAM_DMA_demo+0x1fe>
  BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)"SDRAM READ  DMA : COMPLETED", LEFT_MODE);
 8090dd8:	f645 7218 	movw	r2, #24344	; 0x5f18
 8090ddc:	2303      	movs	r3, #3
 8090dde:	21a0      	movs	r1, #160	; 0xa0
 8090de0:	2014      	movs	r0, #20
 8090de2:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090de6:	f7f2 fc27 	bl	8083638 <BSP_LCD_DisplayStringAt>
    uint32_t op_addr = (uint32_t)addr;
 8090dea:	f64c 6000 	movw	r0, #52736	; 0xce00
 8090dee:	f2c2 0002 	movt	r0, #8194	; 0x2002
  __ASM volatile ("dsb 0xF":::"memory");
 8090df2:	f3bf 8f4f 	dsb	sy
      SCB->DCIMVAC = op_addr;
 8090df6:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8090dfa:	f500 6180 	add.w	r1, r0, #1024	; 0x400
    uint32_t op_addr = (uint32_t)addr;
 8090dfe:	4606      	mov	r6, r0
 8090e00:	4603      	mov	r3, r0
      SCB->DCIMVAC = op_addr;
 8090e02:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8090e06:	f8c2 325c 	str.w	r3, [r2, #604]	; 0x25c
      op_addr += linesize;
 8090e0a:	3320      	adds	r3, #32
    while (op_size > 0) {
 8090e0c:	428b      	cmp	r3, r1
 8090e0e:	d1fa      	bne.n	8090e06 <SDRAM_DMA_demo+0x232>
 8090e10:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8090e14:	f3bf 8f6f 	isb	sy
  /* Invalidate Data Cache to get the updated content of the SRAM */
  SCB_InvalidateDCache_by_Addr((uint32_t *)pBuffer2, BufferLength*4);

  while (BufferLength--)
  {
    if (*pBuffer1 != *pBuffer2)
 8090e18:	682a      	ldr	r2, [r5, #0]
 8090e1a:	6833      	ldr	r3, [r6, #0]
 8090e1c:	429a      	cmp	r2, r3
 8090e1e:	d10c      	bne.n	8090e3a <SDRAM_DMA_demo+0x266>
 8090e20:	f24d 51fc 	movw	r1, #54780	; 0xd5fc
 8090e24:	f2c2 0102 	movt	r1, #8194	; 0x2002
 8090e28:	e001      	b.n	8090e2e <SDRAM_DMA_demo+0x25a>
  while (BufferLength--)
 8090e2a:	428c      	cmp	r4, r1
 8090e2c:	d03a      	beq.n	8090ea4 <SDRAM_DMA_demo+0x2d0>
    if (*pBuffer1 != *pBuffer2)
 8090e2e:	f854 2f04 	ldr.w	r2, [r4, #4]!
 8090e32:	f850 3f04 	ldr.w	r3, [r0, #4]!
 8090e36:	429a      	cmp	r2, r3
 8090e38:	d0f7      	beq.n	8090e2a <SDRAM_DMA_demo+0x256>
    BSP_LCD_DisplayStringAt(20, 175, (uint8_t *)"SDRAM COMPARE : FAILED.", LEFT_MODE);
 8090e3a:	f645 6234 	movw	r2, #24116	; 0x5e34
 8090e3e:	2303      	movs	r3, #3
 8090e40:	21af      	movs	r1, #175	; 0xaf
 8090e42:	2014      	movs	r0, #20
 8090e44:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090e48:	f7f2 fbf6 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(20, 190, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
 8090e4c:	f645 52ac 	movw	r2, #23980	; 0x5dac
 8090e50:	2303      	movs	r3, #3
 8090e52:	21be      	movs	r1, #190	; 0xbe
 8090e54:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090e58:	2014      	movs	r0, #20
 8090e5a:	f7f2 fbed 	bl	8083638 <BSP_LCD_DisplayStringAt>
    if (CheckForUserInput() > 0)
 8090e5e:	f000 fa83 	bl	8091368 <CheckForUserInput>
 8090e62:	2800      	cmp	r0, #0
 8090e64:	d0fb      	beq.n	8090e5e <SDRAM_DMA_demo+0x28a>
}
 8090e66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    BSP_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE DMA : REQUESTED", LEFT_MODE);
 8090e68:	f645 6294 	movw	r2, #24212	; 0x5e94
 8090e6c:	2303      	movs	r3, #3
 8090e6e:	2173      	movs	r1, #115	; 0x73
 8090e70:	2014      	movs	r0, #20
 8090e72:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090e76:	f7f2 fbdf 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090e7a:	e77f      	b.n	8090d7c <SDRAM_DMA_demo+0x1a8>
    BSP_LCD_DisplayStringAt(20, 100, (uint8_t *)"SDRAM Initialization : OK.", LEFT_MODE);
 8090e7c:	f645 52c0 	movw	r2, #24000	; 0x5dc0
 8090e80:	2303      	movs	r3, #3
 8090e82:	2164      	movs	r1, #100	; 0x64
 8090e84:	2014      	movs	r0, #20
 8090e86:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090e8a:	f7f2 fbd5 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090e8e:	e725      	b.n	8090cdc <SDRAM_DMA_demo+0x108>
    BSP_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM READ  DMA : REQUESTED", LEFT_MODE);
 8090e90:	f645 62fc 	movw	r2, #24316	; 0x5efc
 8090e94:	2303      	movs	r3, #3
 8090e96:	2191      	movs	r1, #145	; 0x91
 8090e98:	2014      	movs	r0, #20
 8090e9a:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090e9e:	f7f2 fbcb 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090ea2:	e796      	b.n	8090dd2 <SDRAM_DMA_demo+0x1fe>
    BSP_LCD_DisplayStringAt(20, 175, (uint8_t *)"SDRAM TEST      : SUCCESSFULL", LEFT_MODE);
 8090ea4:	f645 7234 	movw	r2, #24372	; 0x5f34
 8090ea8:	2303      	movs	r3, #3
 8090eaa:	21af      	movs	r1, #175	; 0xaf
 8090eac:	2014      	movs	r0, #20
 8090eae:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090eb2:	f7f2 fbc1 	bl	8083638 <BSP_LCD_DisplayStringAt>
 8090eb6:	e7d2      	b.n	8090e5e <SDRAM_DMA_demo+0x28a>

08090eb8 <HAL_SDRAM_DMA_XferCpltCallback>:
  uwDMA_Transfer_Complete = 1;
 8090eb8:	f24d 6300 	movw	r3, #54784	; 0xd600
 8090ebc:	2201      	movs	r2, #1
 8090ebe:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8090ec2:	601a      	str	r2, [r3, #0]
}
 8090ec4:	4770      	bx	lr
 8090ec6:	bf00      	nop

08090ec8 <HAL_SDRAM_DMA_XferErrorCallback>:
  BSP_LCD_SetTextColor(LCD_COLOR_RED);
 8090ec8:	2000      	movs	r0, #0
{
 8090eca:	b510      	push	{r4, lr}
  BSP_LCD_SetTextColor(LCD_COLOR_RED);
 8090ecc:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 8090ed0:	f7f2 fa30 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DisplayStringAt(20, 215, (uint8_t *)"DMA ERROR", LEFT_MODE);
 8090ed4:	f645 6260 	movw	r2, #24160	; 0x5e60
 8090ed8:	2303      	movs	r3, #3
 8090eda:	21d7      	movs	r1, #215	; 0xd7
 8090edc:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090ee0:	2014      	movs	r0, #20
}
 8090ee2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  BSP_LCD_DisplayStringAt(20, 215, (uint8_t *)"DMA ERROR", LEFT_MODE);
 8090ee6:	f7f2 bba7 	b.w	8083638 <BSP_LCD_DisplayStringAt>
 8090eea:	bf00      	nop

08090eec <SENSORS_Demo>:
 * @brief  Keys Demo
 * @param  None
 * @retval None
 */
void SENSORS_Demo (void)
{
 8090eec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 * @retval None
 */
static void SENSORS_SetHint(void)
{
	/* Clear the LCD */
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 8090ef0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
{
 8090ef4:	b0a3      	sub	sp, #140	; 0x8c
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 8090ef6:	f7f2 fa69 	bl	80833cc <BSP_LCD_Clear>

	/* Set LCD Demo description */
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090efa:	20ff      	movs	r0, #255	; 0xff
			sprintf((char*)&strbuff, "Mag (OK): X= %i, Y=%i, Z=%i     ", (int)mag.x, (int)mag.y, (int)mag.z);
 8090efc:	f645 7984 	movw	r9, #24452	; 0x5f84
			sprintf((char*)&strbuff, "Acc (OK): X= %i, Y=%i, Z=%i     ", (int)acc.x, (int)acc.y, (int)acc.z);
 8090f00:	f645 78e0 	movw	r8, #24544	; 0x5fe0
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090f04:	f6cf 7000 	movt	r0, #65280	; 0xff00
			sprintf((char*)&strbuff, "Gyro (OK): X= %i, Y=%i, Z=%i     ", (int)angularRate.x, (int)angularRate.y, (int)angularRate.z);
 8090f08:	f246 073c 	movw	r7, #24636	; 0x603c
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8090f0c:	f7f2 fa12 	bl	8083334 <BSP_LCD_SetTextColor>
			sprintf((char*)&strbuff, "Mag (OK): X= %i, Y=%i, Z=%i     ", (int)mag.x, (int)mag.y, (int)mag.z);
 8090f10:	f6c0 0909 	movt	r9, #2057	; 0x809
	BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 8090f14:	f7f2 f998 	bl	8083248 <BSP_LCD_GetXSize>
 8090f18:	2100      	movs	r1, #0
 8090f1a:	b282      	uxth	r2, r0
 8090f1c:	2350      	movs	r3, #80	; 0x50
 8090f1e:	4608      	mov	r0, r1
			sprintf((char*)&strbuff, "Acc (OK): X= %i, Y=%i, Z=%i     ", (int)acc.x, (int)acc.y, (int)acc.z);
 8090f20:	f6c0 0809 	movt	r8, #2057	; 0x809
	BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 8090f24:	f7f2 fef4 	bl	8083d10 <BSP_LCD_FillRect>
	BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 8090f28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090f2c:	f7f2 fa02 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 8090f30:	20ff      	movs	r0, #255	; 0xff
			sprintf((char*)&strbuff, "Gyro (OK): X= %i, Y=%i, Z=%i     ", (int)angularRate.x, (int)angularRate.y, (int)angularRate.z);
 8090f32:	f6c0 0709 	movt	r7, #2057	; 0x809
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 8090f36:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8090f3a:	f7f2 fa17 	bl	808336c <BSP_LCD_SetBackColor>
	BSP_LCD_SetFont(&Font24);
 8090f3e:	f24b 3064 	movw	r0, #45924	; 0xb364
 8090f42:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8090f46:	f7f2 fa21 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"SENSORS", CENTER_MODE);
 8090f4a:	2100      	movs	r1, #0
 8090f4c:	f645 7254 	movw	r2, #24404	; 0x5f54
 8090f50:	2301      	movs	r3, #1
 8090f52:	4608      	mov	r0, r1
 8090f54:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090f58:	f7f2 fb6e 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_SetFont(&Font12);
 8090f5c:	f24b 304c 	movw	r0, #45900	; 0xb34c
 8090f60:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8090f64:	f7f2 fa12 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows sensors", CENTER_MODE);
 8090f68:	f645 725c 	movw	r2, #24412	; 0x5f5c
 8090f6c:	2301      	movs	r3, #1
 8090f6e:	211e      	movs	r1, #30
 8090f70:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090f74:	2000      	movs	r0, #0
 8090f76:	f7f2 fb5f 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"values  ", CENTER_MODE);
 8090f7a:	f645 7278 	movw	r2, #24440	; 0x5f78
 8090f7e:	2301      	movs	r3, #1
 8090f80:	212d      	movs	r1, #45	; 0x2d
 8090f82:	f6c0 0209 	movt	r2, #2057	; 0x809
 8090f86:	2000      	movs	r0, #0
 8090f88:	f7f2 fb56 	bl	8083638 <BSP_LCD_DisplayStringAt>
	/* Set the LCD Text Color */
	/*BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
	BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 100);
	BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 102);*/

	BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 8090f8c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8090f90:	f7f2 f9d0 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 8090f94:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8090f98:	f7f2 f9e8 	bl	808336c <BSP_LCD_SetBackColor>
 8090f9c:	e0bc      	b.n	8091118 <SENSORS_Demo+0x22c>
			sprintf((char*)&strbuff, "Mag (OK): X= %i, Y=%i, Z=%i     ", (int)mag.x, (int)mag.y, (int)mag.z);
 8090f9e:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
 8090fa2:	ac0e      	add	r4, sp, #56	; 0x38
 8090fa4:	eddd 6a0c 	vldr	s13, [sp, #48]	; 0x30
 8090fa8:	4649      	mov	r1, r9
 8090faa:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
 8090fae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8090fb2:	eefd 6ae6 	vcvt.s32.f32	s13, s13
 8090fb6:	4620      	mov	r0, r4
 8090fb8:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8090fbc:	edcd 7a00 	vstr	s15, [sp]
 8090fc0:	ee16 3a90 	vmov	r3, s13
 8090fc4:	ee17 2a10 	vmov	r2, s14
 8090fc8:	f001 f884 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 100, (uint8_t *)strbuff, LEFT_MODE);
 8090fcc:	2014      	movs	r0, #20
 8090fce:	2303      	movs	r3, #3
 8090fd0:	4622      	mov	r2, r4
 8090fd2:	2164      	movs	r1, #100	; 0x64
 8090fd4:	f7f2 fb30 	bl	8083638 <BSP_LCD_DisplayStringAt>
		status = BSP_ACC_ReadValues(&acc);
 8090fd8:	a805      	add	r0, sp, #20
 8090fda:	f7f1 fa01 	bl	80823e0 <BSP_ACC_ReadValues>
		if (status == ACC_OK) {
 8090fde:	2800      	cmp	r0, #0
 8090fe0:	f040 8103 	bne.w	80911ea <SENSORS_Demo+0x2fe>
			sprintf((char*)&strbuff, "Acc (OK): X= %i, Y=%i, Z=%i     ", (int)acc.x, (int)acc.y, (int)acc.z);
 8090fe4:	eddd 7a07 	vldr	s15, [sp, #28]
 8090fe8:	4641      	mov	r1, r8
 8090fea:	eddd 6a06 	vldr	s13, [sp, #24]
 8090fee:	4620      	mov	r0, r4
 8090ff0:	ed9d 7a05 	vldr	s14, [sp, #20]
 8090ff4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8090ff8:	eefd 6ae6 	vcvt.s32.f32	s13, s13
 8090ffc:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8091000:	edcd 7a00 	vstr	s15, [sp]
 8091004:	ee16 3a90 	vmov	r3, s13
 8091008:	ee17 2a10 	vmov	r2, s14
 809100c:	f001 f862 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 120, (uint8_t *)strbuff, LEFT_MODE);
 8091010:	2014      	movs	r0, #20
 8091012:	2303      	movs	r3, #3
 8091014:	4622      	mov	r2, r4
 8091016:	2178      	movs	r1, #120	; 0x78
 8091018:	f7f2 fb0e 	bl	8083638 <BSP_LCD_DisplayStringAt>
		status = BSP_GYRO_ReadValues(&angularRate);
 809101c:	a808      	add	r0, sp, #32
 809101e:	f7f1 fa0d 	bl	808243c <BSP_GYRO_ReadValues>
		if (status == ACC_OK) {
 8091022:	2800      	cmp	r0, #0
 8091024:	f040 80d0 	bne.w	80911c8 <SENSORS_Demo+0x2dc>
			sprintf((char*)&strbuff, "Gyro (OK): X= %i, Y=%i, Z=%i     ", (int)angularRate.x, (int)angularRate.y, (int)angularRate.z);
 8091028:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
 809102c:	4639      	mov	r1, r7
 809102e:	eddd 6a09 	vldr	s13, [sp, #36]	; 0x24
 8091032:	4620      	mov	r0, r4
 8091034:	ed9d 7a08 	vldr	s14, [sp, #32]
 8091038:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 809103c:	eefd 6ae6 	vcvt.s32.f32	s13, s13
 8091040:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8091044:	edcd 7a00 	vstr	s15, [sp]
 8091048:	ee16 3a90 	vmov	r3, s13
 809104c:	ee17 2a10 	vmov	r2, s14
 8091050:	f001 f840 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 140, (uint8_t *)strbuff, LEFT_MODE);
 8091054:	218c      	movs	r1, #140	; 0x8c
 8091056:	2014      	movs	r0, #20
 8091058:	2303      	movs	r3, #3
 809105a:	4622      	mov	r2, r4
 809105c:	f7f2 faec 	bl	8083638 <BSP_LCD_DisplayStringAt>
		statusPressure = BSP_PRESSURE_ReadCompensatedValues(&pressure, &temperature);
 8091060:	a903      	add	r1, sp, #12
 8091062:	a804      	add	r0, sp, #16
 8091064:	f7f3 fa72 	bl	808454c <BSP_PRESSURE_ReadCompensatedValues>
		if (statusPressure == PRESSURE_OK) {
 8091068:	2800      	cmp	r0, #0
 809106a:	f040 808c 	bne.w	8091186 <SENSORS_Demo+0x29a>
			sprintf((char*)&strbuff, "Pressure (OK): %i     ", (int)pressure);
 809106e:	eddd 7a04 	vldr	s15, [sp, #16]
 8091072:	f246 0198 	movw	r1, #24728	; 0x6098
 8091076:	4620      	mov	r0, r4
 8091078:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 809107c:	f6c0 0109 	movt	r1, #2057	; 0x809
 8091080:	ee17 2a90 	vmov	r2, s15
 8091084:	f001 f826 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)strbuff, LEFT_MODE);
 8091088:	4622      	mov	r2, r4
 809108a:	21a0      	movs	r1, #160	; 0xa0
 809108c:	2014      	movs	r0, #20
 809108e:	2303      	movs	r3, #3
 8091090:	f7f2 fad2 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "Temperature (PRESSURE) ( OK): %i C     ", (int)temperature);
 8091094:	eddd 7a03 	vldr	s15, [sp, #12]
 8091098:	f246 01b0 	movw	r1, #24752	; 0x60b0
 809109c:	4620      	mov	r0, r4
 809109e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80910a2:	f6c0 0109 	movt	r1, #2057	; 0x809
 80910a6:	ee17 2a90 	vmov	r2, s15
 80910aa:	f001 f813 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 240, (uint8_t *)strbuff, LEFT_MODE);
 80910ae:	2014      	movs	r0, #20
 80910b0:	2303      	movs	r3, #3
 80910b2:	4622      	mov	r2, r4
 80910b4:	21f0      	movs	r1, #240	; 0xf0
 80910b6:	f7f2 fabf 	bl	8083638 <BSP_LCD_DisplayStringAt>
		status = BSP_MAG_ReadTemperature(&temperature);
 80910ba:	a803      	add	r0, sp, #12
 80910bc:	f7f3 f92a 	bl	8084314 <BSP_MAG_ReadTemperature>
		if (status == ACC_OK) {
 80910c0:	2800      	cmp	r0, #0
 80910c2:	d154      	bne.n	809116e <SENSORS_Demo+0x282>
			sprintf((char*)&strbuff, "Temperature (MAG) ( OK): %i C     ", (int)temperature);
 80910c4:	eddd 7a03 	vldr	s15, [sp, #12]
 80910c8:	f246 1134 	movw	r1, #24884	; 0x6134
 80910cc:	4620      	mov	r0, r4
 80910ce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80910d2:	f6c0 0109 	movt	r1, #2057	; 0x809
 80910d6:	ee17 2a90 	vmov	r2, s15
 80910da:	f000 fffb 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 200, (uint8_t *)strbuff, LEFT_MODE);
 80910de:	2014      	movs	r0, #20
 80910e0:	2303      	movs	r3, #3
 80910e2:	4622      	mov	r2, r4
 80910e4:	21c8      	movs	r1, #200	; 0xc8
 80910e6:	f7f2 faa7 	bl	8083638 <BSP_LCD_DisplayStringAt>
		status = BSP_ACC_ReadTemperature(&temperature);
 80910ea:	a803      	add	r0, sp, #12
 80910ec:	f7f1 f9d4 	bl	8082498 <BSP_ACC_ReadTemperature>
		if (status == ACC_OK) {
 80910f0:	bb88      	cbnz	r0, 8091156 <SENSORS_Demo+0x26a>
			sprintf((char*)&strbuff, "Temperature (ACC) ( OK): %i C     ", (int)temperature);
 80910f2:	eddd 7a03 	vldr	s15, [sp, #12]
 80910f6:	f246 1174 	movw	r1, #24948	; 0x6174
 80910fa:	4620      	mov	r0, r4
 80910fc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8091100:	f6c0 0109 	movt	r1, #2057	; 0x809
 8091104:	ee17 2a90 	vmov	r2, s15
 8091108:	f000 ffe4 	bl	80920d4 <siprintf>
		BSP_LCD_DisplayStringAt(20, 220, (uint8_t *)strbuff, LEFT_MODE);
 809110c:	4622      	mov	r2, r4
 809110e:	2303      	movs	r3, #3
 8091110:	21dc      	movs	r1, #220	; 0xdc
 8091112:	2014      	movs	r0, #20
 8091114:	f7f2 fa90 	bl	8083638 <BSP_LCD_DisplayStringAt>
	while (CheckForUserInput() == 0)
 8091118:	f000 f926 	bl	8091368 <CheckForUserInput>
 809111c:	2800      	cmp	r0, #0
 809111e:	d175      	bne.n	809120c <SENSORS_Demo+0x320>
		HAL_Delay(100);
 8091120:	2064      	movs	r0, #100	; 0x64
 8091122:	f7f4 fb4b 	bl	80857bc <HAL_Delay>
		status = BSP_MAG_ReadValues(&mag);
 8091126:	a80b      	add	r0, sp, #44	; 0x2c
 8091128:	f7f3 f8b8 	bl	808429c <BSP_MAG_ReadValues>
		if (status == MAG_OK) {
 809112c:	2800      	cmp	r0, #0
 809112e:	f43f af36 	beq.w	8090f9e <SENSORS_Demo+0xb2>
			sprintf((char*)&strbuff, "Mag (Failed):                                       ");
 8091132:	f645 75a8 	movw	r5, #24488	; 0x5fa8
 8091136:	ac0e      	add	r4, sp, #56	; 0x38
 8091138:	f6c0 0509 	movt	r5, #2057	; 0x809
 809113c:	4626      	mov	r6, r4
 809113e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8091140:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8091142:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8091144:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8091146:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8091148:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 809114a:	e895 0003 	ldmia.w	r5, {r0, r1}
 809114e:	f846 0b04 	str.w	r0, [r6], #4
 8091152:	7031      	strb	r1, [r6, #0]
 8091154:	e73a      	b.n	8090fcc <SENSORS_Demo+0xe0>
			sprintf((char*)&strbuff, "Temperature (ACC) (NOK):");
 8091156:	f246 1698 	movw	r6, #24984	; 0x6198
 809115a:	4625      	mov	r5, r4
 809115c:	f6c0 0609 	movt	r6, #2057	; 0x809
 8091160:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8091162:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8091164:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8091168:	c503      	stmia	r5!, {r0, r1}
 809116a:	702a      	strb	r2, [r5, #0]
 809116c:	e7ce      	b.n	809110c <SENSORS_Demo+0x220>
			sprintf((char*)&strbuff, "Temperature (MAG) (NOK):");
 809116e:	f246 1658 	movw	r6, #24920	; 0x6158
 8091172:	4625      	mov	r5, r4
 8091174:	f6c0 0609 	movt	r6, #2057	; 0x809
 8091178:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 809117a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 809117c:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8091180:	c503      	stmia	r5!, {r0, r1}
 8091182:	702a      	strb	r2, [r5, #0]
 8091184:	e7ab      	b.n	80910de <SENSORS_Demo+0x1f2>
			sprintf((char*)&strbuff, "Pressure (Failed):                                      ");
 8091186:	f246 06d8 	movw	r6, #24792	; 0x60d8
 809118a:	4625      	mov	r5, r4
 809118c:	f6c0 0609 	movt	r6, #2057	; 0x809
 8091190:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8091192:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8091194:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8091196:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8091198:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 809119a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 809119c:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
			sprintf((char*)&strbuff, "Temperature (PRESSURE) (NOK):");
 80911a0:	f246 1614 	movw	r6, #24852	; 0x6114
		BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)strbuff, LEFT_MODE);
 80911a4:	2303      	movs	r3, #3
			sprintf((char*)&strbuff, "Temperature (PRESSURE) (NOK):");
 80911a6:	f6c0 0609 	movt	r6, #2057	; 0x809
			sprintf((char*)&strbuff, "Pressure (Failed):                                      ");
 80911aa:	c503      	stmia	r5!, {r0, r1}
		BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)strbuff, LEFT_MODE);
 80911ac:	21a0      	movs	r1, #160	; 0xa0
			sprintf((char*)&strbuff, "Pressure (Failed):                                      ");
 80911ae:	702a      	strb	r2, [r5, #0]
		BSP_LCD_DisplayStringAt(20, 160, (uint8_t *)strbuff, LEFT_MODE);
 80911b0:	2014      	movs	r0, #20
 80911b2:	4622      	mov	r2, r4
 80911b4:	f7f2 fa40 	bl	8083638 <BSP_LCD_DisplayStringAt>
			sprintf((char*)&strbuff, "Temperature (PRESSURE) (NOK):");
 80911b8:	4625      	mov	r5, r4
 80911ba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80911bc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80911be:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 80911c2:	c507      	stmia	r5!, {r0, r1, r2}
 80911c4:	802b      	strh	r3, [r5, #0]
 80911c6:	e772      	b.n	80910ae <SENSORS_Demo+0x1c2>
			sprintf((char*)&strbuff, "Gyro (Failed):                                      ");
 80911c8:	f246 0560 	movw	r5, #24672	; 0x6060
 80911cc:	4626      	mov	r6, r4
 80911ce:	f6c0 0509 	movt	r5, #2057	; 0x809
 80911d2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80911d4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80911d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80911d8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80911da:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80911dc:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80911de:	e895 0003 	ldmia.w	r5, {r0, r1}
 80911e2:	f846 0b04 	str.w	r0, [r6], #4
 80911e6:	7031      	strb	r1, [r6, #0]
 80911e8:	e734      	b.n	8091054 <SENSORS_Demo+0x168>
			sprintf((char*)&strbuff, "Acc (Failed):                                       ");
 80911ea:	f246 0504 	movw	r5, #24580	; 0x6004
 80911ee:	4626      	mov	r6, r4
 80911f0:	f6c0 0509 	movt	r5, #2057	; 0x809
 80911f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80911f6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80911f8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80911fa:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80911fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80911fe:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8091200:	e895 0003 	ldmia.w	r5, {r0, r1}
 8091204:	f846 0b04 	str.w	r0, [r6], #4
 8091208:	7031      	strb	r1, [r6, #0]
 809120a:	e701      	b.n	8091010 <SENSORS_Demo+0x124>
}
 809120c:	b023      	add	sp, #140	; 0x8c
 809120e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8091212:	bf00      	nop

08091214 <Display_DemoDescription>:
 * @brief  Display main demo messages.
 * @param  None
 * @retval None
 */
static void Display_DemoDescription(void)
{
 8091214:	b530      	push	{r4, r5, lr}
	uint8_t desc[50];

	/* Set LCD Background Layer  */
	BSP_LCD_SelectLayer(LTDC_FOREGROUND_LAYER);
	BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
 8091216:	f24b 3464 	movw	r4, #45924	; 0xb364
{
 809121a:	b08f      	sub	sp, #60	; 0x3c
	BSP_LCD_SelectLayer(LTDC_FOREGROUND_LAYER);
 809121c:	2001      	movs	r0, #1

	BSP_LCD_SetFont(&Font12);
	BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 20, (uint8_t *)"INSA - GEI 2019", CENTER_MODE);

	BSP_LCD_SetFont(&Font16);
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 809121e:	25ff      	movs	r5, #255	; 0xff
	BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
 8091220:	f2c2 0400 	movt	r4, #8192	; 0x2000
	BSP_LCD_SelectLayer(LTDC_FOREGROUND_LAYER);
 8091224:	f7f2 f870 	bl	8083308 <BSP_LCD_SelectLayer>
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8091228:	f6cf 7500 	movt	r5, #65280	; 0xff00
	BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
 809122c:	4620      	mov	r0, r4
 809122e:	f7f2 f8ad 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_SetColorKeying(LTDC_FOREGROUND_LAYER, LCD_COLOR_BLACK);
 8091232:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
 8091236:	2001      	movs	r0, #1
 8091238:	f7f2 f86c 	bl	8083314 <BSP_LCD_SetColorKeying>
	BSP_LCD_SetBackColor(LCD_COLOR_BLACK);
 809123c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8091240:	f7f2 f894 	bl	808336c <BSP_LCD_SetBackColor>
	BSP_LCD_Clear(LCD_COLOR_BLACK);
 8091244:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8091248:	f7f2 f8c0 	bl	80833cc <BSP_LCD_Clear>
	BSP_LCD_SelectLayer(LTDC_ACTIVE_LAYER);
 809124c:	2000      	movs	r0, #0
 809124e:	f7f2 f85b 	bl	8083308 <BSP_LCD_SelectLayer>
	BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
 8091252:	4620      	mov	r0, r4
 8091254:	f7f2 f89a 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 8091258:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 809125c:	f7f2 f886 	bl	808336c <BSP_LCD_SetBackColor>
	BSP_LCD_Clear(LCD_COLOR_WHITE);
 8091260:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8091264:	f7f2 f8b2 	bl	80833cc <BSP_LCD_Clear>
	BSP_LCD_SetTextColor(LCD_COLOR_DARKBLUE);
 8091268:	2080      	movs	r0, #128	; 0x80
 809126a:	f6cf 7000 	movt	r0, #65280	; 0xff00
 809126e:	f7f2 f861 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_DisplayStringAt(0, 10, (uint8_t *)"ARM-ADA Next Gen", CENTER_MODE);
 8091272:	f246 12b4 	movw	r2, #25012	; 0x61b4
 8091276:	2301      	movs	r3, #1
 8091278:	210a      	movs	r1, #10
 809127a:	f6c0 0209 	movt	r2, #2057	; 0x809
 809127e:	2000      	movs	r0, #0
 8091280:	f7f2 f9da 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DisplayStringAt(0, 35, (uint8_t *)"Firmware tests", CENTER_MODE);
 8091284:	f246 12c8 	movw	r2, #25032	; 0x61c8
 8091288:	2301      	movs	r3, #1
 809128a:	2123      	movs	r1, #35	; 0x23
 809128c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8091290:	2000      	movs	r0, #0
 8091292:	f7f2 f9d1 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_DrawBitmap((BSP_LCD_GetXSize() - 80) / 2, 65, (uint8_t *)stlogo);
 8091296:	f7f1 ffd7 	bl	8083248 <BSP_LCD_GetXSize>
 809129a:	f243 2240 	movw	r2, #12864	; 0x3240
 809129e:	3850      	subs	r0, #80	; 0x50
 80912a0:	2141      	movs	r1, #65	; 0x41
 80912a2:	f6c0 0209 	movt	r2, #2057	; 0x809
 80912a6:	0840      	lsrs	r0, r0, #1
 80912a8:	f7f2 fc40 	bl	8083b2c <BSP_LCD_DrawBitmap>
	BSP_LCD_SetFont(&Font12);
 80912ac:	f24b 304c 	movw	r0, #45900	; 0xb34c
 80912b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80912b4:	f7f2 f86a 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 20, (uint8_t *)"INSA - GEI 2019", CENTER_MODE);
 80912b8:	f7f1 ffd4 	bl	8083264 <BSP_LCD_GetYSize>
 80912bc:	f246 12d8 	movw	r2, #25048	; 0x61d8
 80912c0:	f1a0 0114 	sub.w	r1, r0, #20
 80912c4:	2301      	movs	r3, #1
 80912c6:	f6c0 0209 	movt	r2, #2057	; 0x809
 80912ca:	2000      	movs	r0, #0
 80912cc:	b289      	uxth	r1, r1
 80912ce:	f7f2 f9b3 	bl	8083638 <BSP_LCD_DisplayStringAt>
	BSP_LCD_SetFont(&Font16);
 80912d2:	f24b 3054 	movw	r0, #45908	; 0xb354
 80912d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80912da:	f7f2 f857 	bl	808338c <BSP_LCD_SetFont>
	BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 80912de:	4628      	mov	r0, r5
 80912e0:	f7f2 f828 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_FillRect(0, BSP_LCD_GetYSize() / 2 + 15, BSP_LCD_GetXSize(), 60);
 80912e4:	f7f1 ffbe 	bl	8083264 <BSP_LCD_GetYSize>
 80912e8:	4604      	mov	r4, r0
 80912ea:	f7f1 ffad 	bl	8083248 <BSP_LCD_GetXSize>
 80912ee:	233c      	movs	r3, #60	; 0x3c
 80912f0:	0861      	lsrs	r1, r4, #1
	BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
	BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() / 2 + 30, (uint8_t *)"Press A (Red) to start ", CENTER_MODE);
	sprintf((char *)desc, "%s example", BSP_examples[DemoIndex].DemoName);
 80912f2:	f24d 6404 	movw	r4, #54788	; 0xd604
	BSP_LCD_FillRect(0, BSP_LCD_GetYSize() / 2 + 15, BSP_LCD_GetXSize(), 60);
 80912f6:	b282      	uxth	r2, r0
 80912f8:	2000      	movs	r0, #0
 80912fa:	310f      	adds	r1, #15
	sprintf((char *)desc, "%s example", BSP_examples[DemoIndex].DemoName);
 80912fc:	f2c2 0402 	movt	r4, #8194	; 0x2002
	BSP_LCD_FillRect(0, BSP_LCD_GetYSize() / 2 + 15, BSP_LCD_GetXSize(), 60);
 8091300:	b289      	uxth	r1, r1
 8091302:	f7f2 fd05 	bl	8083d10 <BSP_LCD_FillRect>
	BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 8091306:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 809130a:	f7f2 f813 	bl	8083334 <BSP_LCD_SetTextColor>
	BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 809130e:	4628      	mov	r0, r5
 8091310:	f7f2 f82c 	bl	808336c <BSP_LCD_SetBackColor>
	sprintf((char *)desc, "%s example", BSP_examples[DemoIndex].DemoName);
 8091314:	253c      	movs	r5, #60	; 0x3c
	BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() / 2 + 30, (uint8_t *)"Press A (Red) to start ", CENTER_MODE);
 8091316:	f7f1 ffa5 	bl	8083264 <BSP_LCD_GetYSize>
 809131a:	f246 12e8 	movw	r2, #25064	; 0x61e8
 809131e:	0841      	lsrs	r1, r0, #1
 8091320:	2301      	movs	r3, #1
 8091322:	f6c0 0209 	movt	r2, #2057	; 0x809
 8091326:	2000      	movs	r0, #0
 8091328:	311e      	adds	r1, #30
 809132a:	b289      	uxth	r1, r1
 809132c:	f7f2 f984 	bl	8083638 <BSP_LCD_DisplayStringAt>
	sprintf((char *)desc, "%s example", BSP_examples[DemoIndex].DemoName);
 8091330:	f24b 03b4 	movw	r3, #45236	; 0xb0b4
 8091334:	7822      	ldrb	r2, [r4, #0]
 8091336:	f246 2100 	movw	r1, #25088	; 0x6200
 809133a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 809133e:	a801      	add	r0, sp, #4
 8091340:	f6c0 0109 	movt	r1, #2057	; 0x809
 8091344:	fb05 3202 	mla	r2, r5, r2, r3
 8091348:	3204      	adds	r2, #4
 809134a:	f000 fec3 	bl	80920d4 <siprintf>
	BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() / 2 + 45, (uint8_t *)desc, CENTER_MODE);
 809134e:	f7f1 ff89 	bl	8083264 <BSP_LCD_GetYSize>
 8091352:	aa01      	add	r2, sp, #4
 8091354:	0841      	lsrs	r1, r0, #1
 8091356:	2301      	movs	r3, #1
 8091358:	2000      	movs	r0, #0
 809135a:	312d      	adds	r1, #45	; 0x2d
 809135c:	b289      	uxth	r1, r1
 809135e:	f7f2 f96b 	bl	8083638 <BSP_LCD_DisplayStringAt>
}
 8091362:	b00f      	add	sp, #60	; 0x3c
 8091364:	bd30      	pop	{r4, r5, pc}
 8091366:	bf00      	nop

08091368 <CheckForUserInput>:
{
 8091368:	b508      	push	{r3, lr}
	if (BSP_PB_GetState(BUTTON_A) != RESET)
 809136a:	f44f 7084 	mov.w	r0, #264	; 0x108
 809136e:	f7f0 fec7 	bl	8082100 <BSP_PB_GetState>
 8091372:	b900      	cbnz	r0, 8091376 <CheckForUserInput+0xe>
}
 8091374:	bd08      	pop	{r3, pc}
		HAL_Delay(10);
 8091376:	200a      	movs	r0, #10
 8091378:	f7f4 fa20 	bl	80857bc <HAL_Delay>
		while (BSP_PB_GetState(BUTTON_A) != RESET);
 809137c:	f44f 7084 	mov.w	r0, #264	; 0x108
 8091380:	f7f0 febe 	bl	8082100 <BSP_PB_GetState>
 8091384:	2800      	cmp	r0, #0
 8091386:	d1f9      	bne.n	809137c <CheckForUserInput+0x14>
		return 1 ;
 8091388:	2001      	movs	r0, #1
}
 809138a:	bd08      	pop	{r3, pc}

0809138c <TESTS_Run>:

void TESTS_Run(void)
{
 809138c:	f24d 6404 	movw	r4, #54788	; 0xd604
 8091390:	f24b 06b4 	movw	r6, #45236	; 0xb0b4
 8091394:	f24b 3548 	movw	r5, #45896	; 0xb348
 8091398:	f2c2 0402 	movt	r4, #8194	; 0x2002
 809139c:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80913a0:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80913a4:	b500      	push	{lr}
 80913a6:	b083      	sub	sp, #12
	Display_DemoDescription();
 80913a8:	f7ff ff34 	bl	8091214 <Display_DemoDescription>

	/* Wait For User inputs */
	while (1)
	{
		if (BSP_PB_GetState(BUTTON_A) != RESET)
 80913ac:	f44f 7084 	mov.w	r0, #264	; 0x108
 80913b0:	f7f0 fea6 	bl	8082100 <BSP_PB_GetState>
 80913b4:	2800      	cmp	r0, #0
 80913b6:	d0f9      	beq.n	80913ac <TESTS_Run+0x20>
		{
			HAL_Delay(100);
 80913b8:	2064      	movs	r0, #100	; 0x64
 80913ba:	f7f4 f9ff 	bl	80857bc <HAL_Delay>
			while (BSP_PB_GetState(BUTTON_A) != RESET);
 80913be:	f44f 7084 	mov.w	r0, #264	; 0x108
 80913c2:	f7f0 fe9d 	bl	8082100 <BSP_PB_GetState>
 80913c6:	2800      	cmp	r0, #0
 80913c8:	d1f9      	bne.n	80913be <TESTS_Run+0x32>

			BSP_examples[DemoIndex++].DemoFunc();
 80913ca:	7823      	ldrb	r3, [r4, #0]
 80913cc:	9001      	str	r0, [sp, #4]
 80913ce:	ebc3 1203 	rsb	r2, r3, r3, lsl #4
 80913d2:	3301      	adds	r3, #1
 80913d4:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 80913d8:	7023      	strb	r3, [r4, #0]
 80913da:	4790      	blx	r2

			if (DemoIndex >= COUNT_OF_EXAMPLE(BSP_examples))
 80913dc:	7823      	ldrb	r3, [r4, #0]
 80913de:	2b0a      	cmp	r3, #10
 80913e0:	d904      	bls.n	80913ec <TESTS_Run+0x60>
			{
				/* Increment number of loops which be used by EEPROM example */
				NbLoop++;
 80913e2:	782b      	ldrb	r3, [r5, #0]
				DemoIndex = 0;
 80913e4:	9801      	ldr	r0, [sp, #4]
				NbLoop++;
 80913e6:	3301      	adds	r3, #1
				DemoIndex = 0;
 80913e8:	7020      	strb	r0, [r4, #0]
				NbLoop++;
 80913ea:	702b      	strb	r3, [r5, #0]
			}
			Display_DemoDescription();
 80913ec:	f7ff ff12 	bl	8091214 <Display_DemoDescription>
 80913f0:	e7dc      	b.n	80913ac <TESTS_Run+0x20>
 80913f2:	bf00      	nop

080913f4 <Touchscreen_DrawBackground>:
  * @brief  Draw Touchscreen Background
  * @param  state : touch zone state
  * @retval None
  */
static void Touchscreen_DrawBackground (uint8_t state)
{
 80913f4:	b570      	push	{r4, r5, r6, lr}

  switch (state)
 80913f6:	2808      	cmp	r0, #8
 80913f8:	f200 814f 	bhi.w	809169a <Touchscreen_DrawBackground+0x2a6>
 80913fc:	e8df f010 	tbh	[pc, r0, lsl #1]
 8091400:	00d30037 	.word	0x00d30037
 8091404:	014d0100 	.word	0x014d0100
 8091408:	014d0126 	.word	0x014d0126
 809140c:	014d014d 	.word	0x014d014d
 8091410:	0009      	.short	0x0009
      BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
      BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2);
      break;

    case 8:
      BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 8091412:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
      BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(4), CIRCLE_RADIUS);
 8091416:	f64c 46cd 	movw	r6, #52429	; 0xcccd
      BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 809141a:	f7f1 ff8b 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(4), CIRCLE_RADIUS);
 809141e:	f7f1 ff13 	bl	8083248 <BSP_LCD_GetXSize>
 8091422:	4605      	mov	r5, r0
 8091424:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
 8091428:	f7f1 ff1c 	bl	8083264 <BSP_LCD_GetYSize>
 809142c:	00ad      	lsls	r5, r5, #2
 809142e:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091432:	221e      	movs	r2, #30
 8091434:	fba6 3505 	umull	r3, r5, r6, r5
 8091438:	b289      	uxth	r1, r1
 809143a:	f3c5 008f 	ubfx	r0, r5, #2, #16
 809143e:	f7f2 fc99 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 8091442:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8091446:	f7f1 ff75 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(4), CIRCLE_RADIUS - 2);
 809144a:	f7f1 fefd 	bl	8083248 <BSP_LCD_GetXSize>
 809144e:	4604      	mov	r4, r0
 8091450:	f7f1 ff08 	bl	8083264 <BSP_LCD_GetYSize>
 8091454:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091458:	00a4      	lsls	r4, r4, #2
 809145a:	fba6 3004 	umull	r3, r0, r6, r4
 809145e:	221c      	movs	r2, #28
 8091460:	b289      	uxth	r1, r1
 8091462:	f3c0 008f 	ubfx	r0, r0, #2, #16
      break;

  }
}
 8091466:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(4), CIRCLE_RADIUS - 2);
 809146a:	f7f2 bc83 	b.w	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 809146e:	20ff      	movs	r0, #255	; 0xff
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS);
 8091470:	f64c 44cd 	movw	r4, #52429	; 0xcccd
      BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8091474:	f6cf 7000 	movt	r0, #65280	; 0xff00
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS);
 8091478:	f6cc 44cc 	movt	r4, #52428	; 0xcccc
      BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 809147c:	f7f1 ff5a 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS);
 8091480:	f7f1 fee2 	bl	8083248 <BSP_LCD_GetXSize>
 8091484:	4605      	mov	r5, r0
 8091486:	f7f1 feed 	bl	8083264 <BSP_LCD_GetYSize>
 809148a:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 809148e:	fba4 3505 	umull	r3, r5, r4, r5
 8091492:	221e      	movs	r2, #30
 8091494:	b289      	uxth	r1, r1
 8091496:	f3c5 008f 	ubfx	r0, r5, #2, #16
 809149a:	f7f2 fc6b 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_RED);
 809149e:	2000      	movs	r0, #0
 80914a0:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 80914a4:	f7f1 ff46 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS);
 80914a8:	f7f1 fece 	bl	8083248 <BSP_LCD_GetXSize>
 80914ac:	4605      	mov	r5, r0
 80914ae:	f7f1 fed9 	bl	8083264 <BSP_LCD_GetYSize>
 80914b2:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 80914b6:	006d      	lsls	r5, r5, #1
 80914b8:	221e      	movs	r2, #30
 80914ba:	b289      	uxth	r1, r1
 80914bc:	fba4 3005 	umull	r3, r0, r4, r5
 80914c0:	f3c0 008f 	ubfx	r0, r0, #2, #16
 80914c4:	f7f2 fc56 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_YELLOW);
 80914c8:	f06f 00ff 	mvn.w	r0, #255	; 0xff
 80914cc:	f7f1 ff32 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS);
 80914d0:	f7f1 feba 	bl	8083248 <BSP_LCD_GetXSize>
 80914d4:	4605      	mov	r5, r0
 80914d6:	f7f1 fec5 	bl	8083264 <BSP_LCD_GetYSize>
 80914da:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 80914de:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80914e2:	221e      	movs	r2, #30
 80914e4:	b289      	uxth	r1, r1
 80914e6:	fba4 3005 	umull	r3, r0, r4, r5
 80914ea:	f3c0 008f 	ubfx	r0, r0, #2, #16
 80914ee:	f7f2 fc41 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 80914f2:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
 80914f6:	f7f1 ff1d 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS);
 80914fa:	f7f1 fea5 	bl	8083248 <BSP_LCD_GetXSize>
 80914fe:	4605      	mov	r5, r0
 8091500:	f7f1 feb0 	bl	8083264 <BSP_LCD_GetYSize>
 8091504:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091508:	00ad      	lsls	r5, r5, #2
 809150a:	221e      	movs	r2, #30
 809150c:	b289      	uxth	r1, r1
 809150e:	fba4 3005 	umull	r3, r0, r4, r5
 8091512:	f3c0 008f 	ubfx	r0, r0, #2, #16
 8091516:	f7f2 fc2d 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 809151a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 809151e:	f7f1 ff09 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS - 2);
 8091522:	f7f1 fe91 	bl	8083248 <BSP_LCD_GetXSize>
 8091526:	4605      	mov	r5, r0
 8091528:	f7f1 fe9c 	bl	8083264 <BSP_LCD_GetYSize>
 809152c:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091530:	fba4 3505 	umull	r3, r5, r4, r5
 8091534:	221c      	movs	r2, #28
 8091536:	b289      	uxth	r1, r1
 8091538:	f3c5 008f 	ubfx	r0, r5, #2, #16
 809153c:	f7f2 fc1a 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS - 2);
 8091540:	f7f1 fe82 	bl	8083248 <BSP_LCD_GetXSize>
 8091544:	4605      	mov	r5, r0
 8091546:	f7f1 fe8d 	bl	8083264 <BSP_LCD_GetYSize>
 809154a:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 809154e:	006d      	lsls	r5, r5, #1
 8091550:	221c      	movs	r2, #28
 8091552:	b289      	uxth	r1, r1
 8091554:	fba4 3005 	umull	r3, r0, r4, r5
 8091558:	f3c0 008f 	ubfx	r0, r0, #2, #16
 809155c:	f7f2 fc0a 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2);
 8091560:	f7f1 fe72 	bl	8083248 <BSP_LCD_GetXSize>
 8091564:	4605      	mov	r5, r0
 8091566:	f7f1 fe7d 	bl	8083264 <BSP_LCD_GetYSize>
 809156a:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 809156e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8091572:	221c      	movs	r2, #28
 8091574:	b289      	uxth	r1, r1
 8091576:	fba4 3005 	umull	r3, r0, r4, r5
 809157a:	f3c0 008f 	ubfx	r0, r0, #2, #16
 809157e:	f7f2 fbf9 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2);
 8091582:	f7f1 fe61 	bl	8083248 <BSP_LCD_GetXSize>
 8091586:	4605      	mov	r5, r0
 8091588:	f7f1 fe6c 	bl	8083264 <BSP_LCD_GetYSize>
 809158c:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091590:	00ad      	lsls	r5, r5, #2
 8091592:	221c      	movs	r2, #28
 8091594:	b289      	uxth	r1, r1
 8091596:	fba4 3005 	umull	r3, r0, r4, r5
}
 809159a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2);
 809159e:	f3c0 008f 	ubfx	r0, r0, #2, #16
 80915a2:	f7f2 bbe7 	b.w	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 80915a6:	20ff      	movs	r0, #255	; 0xff
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS);
 80915a8:	f64c 45cd 	movw	r5, #52429	; 0xcccd
      BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 80915ac:	f6cf 7000 	movt	r0, #65280	; 0xff00
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS);
 80915b0:	f6cc 45cc 	movt	r5, #52428	; 0xcccc
      BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 80915b4:	f7f1 febe 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS);
 80915b8:	f7f1 fe46 	bl	8083248 <BSP_LCD_GetXSize>
 80915bc:	4604      	mov	r4, r0
 80915be:	f7f1 fe51 	bl	8083264 <BSP_LCD_GetYSize>
 80915c2:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 80915c6:	fba5 3404 	umull	r3, r4, r5, r4
 80915ca:	221e      	movs	r2, #30
 80915cc:	b289      	uxth	r1, r1
 80915ce:	f3c4 008f 	ubfx	r0, r4, #2, #16
 80915d2:	f7f2 fbcf 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 80915d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80915da:	f7f1 feab 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS - 2);
 80915de:	f7f1 fe33 	bl	8083248 <BSP_LCD_GetXSize>
 80915e2:	4604      	mov	r4, r0
 80915e4:	f7f1 fe3e 	bl	8083264 <BSP_LCD_GetYSize>
 80915e8:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 80915ec:	fba5 3404 	umull	r3, r4, r5, r4
 80915f0:	221c      	movs	r2, #28
 80915f2:	b289      	uxth	r1, r1
 80915f4:	f3c4 008f 	ubfx	r0, r4, #2, #16
}
 80915f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS - 2);
 80915fc:	f7f2 bbba 	b.w	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_RED);
 8091600:	2000      	movs	r0, #0
      BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS);
 8091602:	f64c 46cd 	movw	r6, #52429	; 0xcccd
      BSP_LCD_SetTextColor(LCD_COLOR_RED);
 8091606:	f6cf 70ff 	movt	r0, #65535	; 0xffff
      BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS);
 809160a:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
      BSP_LCD_SetTextColor(LCD_COLOR_RED);
 809160e:	f7f1 fe91 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS);
 8091612:	f7f1 fe19 	bl	8083248 <BSP_LCD_GetXSize>
 8091616:	4605      	mov	r5, r0
 8091618:	f7f1 fe24 	bl	8083264 <BSP_LCD_GetYSize>
 809161c:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091620:	006d      	lsls	r5, r5, #1
 8091622:	221e      	movs	r2, #30
 8091624:	b289      	uxth	r1, r1
 8091626:	fba6 3005 	umull	r3, r0, r6, r5
 809162a:	f3c0 008f 	ubfx	r0, r0, #2, #16
 809162e:	f7f2 fba1 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 8091632:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8091636:	f7f1 fe7d 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS - 2);
 809163a:	f7f1 fe05 	bl	8083248 <BSP_LCD_GetXSize>
 809163e:	4604      	mov	r4, r0
 8091640:	f7f1 fe10 	bl	8083264 <BSP_LCD_GetYSize>
 8091644:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091648:	0064      	lsls	r4, r4, #1
 809164a:	e706      	b.n	809145a <Touchscreen_DrawBackground+0x66>
      BSP_LCD_SetTextColor(LCD_COLOR_YELLOW);
 809164c:	f06f 00ff 	mvn.w	r0, #255	; 0xff
      BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS);
 8091650:	f64c 46cd 	movw	r6, #52429	; 0xcccd
      BSP_LCD_SetTextColor(LCD_COLOR_YELLOW);
 8091654:	f7f1 fe6e 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS);
 8091658:	f7f1 fdf6 	bl	8083248 <BSP_LCD_GetXSize>
 809165c:	4605      	mov	r5, r0
 809165e:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
 8091662:	f7f1 fdff 	bl	8083264 <BSP_LCD_GetYSize>
 8091666:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 809166a:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 809166e:	221e      	movs	r2, #30
 8091670:	fba6 3505 	umull	r3, r5, r6, r5
 8091674:	b289      	uxth	r1, r1
 8091676:	f3c5 008f 	ubfx	r0, r5, #2, #16
 809167a:	f7f2 fb7b 	bl	8083d74 <BSP_LCD_FillCircle>
      BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 809167e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8091682:	f7f1 fe57 	bl	8083334 <BSP_LCD_SetTextColor>
      BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2);
 8091686:	f7f1 fddf 	bl	8083248 <BSP_LCD_GetXSize>
 809168a:	4604      	mov	r4, r0
 809168c:	f7f1 fdea 	bl	8083264 <BSP_LCD_GetYSize>
 8091690:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091694:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8091698:	e6df      	b.n	809145a <Touchscreen_DrawBackground+0x66>
}
 809169a:	bd70      	pop	{r4, r5, r6, pc}

0809169c <Touchscreen_demo>:
{
 809169c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 80916a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
{
 80916a4:	b08b      	sub	sp, #44	; 0x2c
  BSP_LCD_Clear(LCD_COLOR_WHITE);
 80916a6:	f7f1 fe91 	bl	80833cc <BSP_LCD_Clear>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 80916aa:	20ff      	movs	r0, #255	; 0xff
 80916ac:	f6cf 7000 	movt	r0, #65280	; 0xff00
 80916b0:	f7f1 fe40 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 80);
 80916b4:	f7f1 fdc8 	bl	8083248 <BSP_LCD_GetXSize>
 80916b8:	2100      	movs	r1, #0
 80916ba:	b282      	uxth	r2, r0
 80916bc:	2350      	movs	r3, #80	; 0x50
 80916be:	4608      	mov	r0, r1
 80916c0:	f7f2 fb26 	bl	8083d10 <BSP_LCD_FillRect>
  BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
 80916c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80916c8:	f7f1 fe34 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
 80916cc:	20ff      	movs	r0, #255	; 0xff
 80916ce:	f6cf 7000 	movt	r0, #65280	; 0xff00
 80916d2:	f7f1 fe4b 	bl	808336c <BSP_LCD_SetBackColor>
  BSP_LCD_SetFont(&Font24);
 80916d6:	f24b 3064 	movw	r0, #45924	; 0xb364
 80916da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80916de:	f7f1 fe55 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 0, (uint8_t *)"Touchscreen", CENTER_MODE);
 80916e2:	2100      	movs	r1, #0
 80916e4:	f246 220c 	movw	r2, #25100	; 0x620c
 80916e8:	2301      	movs	r3, #1
 80916ea:	4608      	mov	r0, r1
 80916ec:	f6c0 0209 	movt	r2, #2057	; 0x809
 80916f0:	f7f1 ffa2 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetFont(&Font12);
 80916f4:	f24b 304c 	movw	r0, #45900	; 0xb34c
 80916f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80916fc:	f7f1 fe46 	bl	808338c <BSP_LCD_SetFont>
  BSP_LCD_DisplayStringAt(0, 30, (uint8_t *)"Please use the Touchscreen to", CENTER_MODE);
 8091700:	f246 2218 	movw	r2, #25112	; 0x6218
 8091704:	2301      	movs	r3, #1
 8091706:	211e      	movs	r1, #30
 8091708:	f6c0 0209 	movt	r2, #2057	; 0x809
 809170c:	2000      	movs	r0, #0
 809170e:	f7f1 ff93 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 45, (uint8_t *)"fill the colored circles according to pressure applied", CENTER_MODE);
 8091712:	f246 2238 	movw	r2, #25144	; 0x6238
 8091716:	2301      	movs	r3, #1
 8091718:	212d      	movs	r1, #45	; 0x2d
 809171a:	f6c0 0209 	movt	r2, #2057	; 0x809
 809171e:	2000      	movs	r0, #0
 8091720:	f7f1 ff8a 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_DisplayStringAt(0, 60, (uint8_t *)"Up to 5 finger touch coordinates are displayed", CENTER_MODE);
 8091724:	f246 2270 	movw	r2, #25200	; 0x6270
 8091728:	2301      	movs	r3, #1
 809172a:	213c      	movs	r1, #60	; 0x3c
 809172c:	f6c0 0209 	movt	r2, #2057	; 0x809
 8091730:	2000      	movs	r0, #0
 8091732:	f7f1 ff81 	bl	8083638 <BSP_LCD_DisplayStringAt>
  BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8091736:	20ff      	movs	r0, #255	; 0xff
 8091738:	f6cf 7000 	movt	r0, #65280	; 0xff00
 809173c:	f7f1 fdfa 	bl	8083334 <BSP_LCD_SetTextColor>
  BSP_LCD_DrawRect(10, 90, BSP_LCD_GetXSize() - 20, BSP_LCD_GetYSize() - 100);
 8091740:	f7f1 fd82 	bl	8083248 <BSP_LCD_GetXSize>
 8091744:	4604      	mov	r4, r0
 8091746:	f7f1 fd8d 	bl	8083264 <BSP_LCD_GetYSize>
 809174a:	f1a0 0364 	sub.w	r3, r0, #100	; 0x64
 809174e:	f1a4 0214 	sub.w	r2, r4, #20
 8091752:	215a      	movs	r1, #90	; 0x5a
 8091754:	b29b      	uxth	r3, r3
 8091756:	200a      	movs	r0, #10
 8091758:	b292      	uxth	r2, r2
 809175a:	f7f1 fec3 	bl	80834e4 <BSP_LCD_DrawRect>
  BSP_LCD_DrawRect(11, 91, BSP_LCD_GetXSize() - 22, BSP_LCD_GetYSize() - 102);
 809175e:	f7f1 fd73 	bl	8083248 <BSP_LCD_GetXSize>
 8091762:	4604      	mov	r4, r0
 8091764:	f7f1 fd7e 	bl	8083264 <BSP_LCD_GetYSize>
 8091768:	f1a0 0366 	sub.w	r3, r0, #102	; 0x66
 809176c:	f1a4 0216 	sub.w	r2, r4, #22
 8091770:	215b      	movs	r1, #91	; 0x5b
 8091772:	b29b      	uxth	r3, r3
 8091774:	200b      	movs	r0, #11
 8091776:	b292      	uxth	r2, r2
 8091778:	f7f1 feb4 	bl	80834e4 <BSP_LCD_DrawRect>
  status = BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize());
 809177c:	f7f1 fd64 	bl	8083248 <BSP_LCD_GetXSize>
 8091780:	4604      	mov	r4, r0
 8091782:	f7f1 fd6f 	bl	8083264 <BSP_LCD_GetYSize>
 8091786:	b281      	uxth	r1, r0
 8091788:	b2a0      	uxth	r0, r4
 809178a:	f7f3 fe6f 	bl	808546c <BSP_TS_Init>
  if (status != TS_OK)
 809178e:	4605      	mov	r5, r0
 8091790:	2800      	cmp	r0, #0
 8091792:	f000 8179 	beq.w	8091a88 <Touchscreen_demo+0x3ec>
    BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 8091796:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 809179a:	f7f1 fde7 	bl	808336c <BSP_LCD_SetBackColor>
    BSP_LCD_SetTextColor(LCD_COLOR_RED);
 809179e:	2000      	movs	r0, #0
 80917a0:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 80917a4:	f7f1 fdc6 	bl	8083334 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 95, (uint8_t *)"ERROR", CENTER_MODE);
 80917a8:	f7f1 fd5c 	bl	8083264 <BSP_LCD_GetYSize>
 80917ac:	f645 6264 	movw	r2, #24164	; 0x5e64
 80917b0:	f1a0 015f 	sub.w	r1, r0, #95	; 0x5f
 80917b4:	2301      	movs	r3, #1
 80917b6:	f6c0 0209 	movt	r2, #2057	; 0x809
 80917ba:	2000      	movs	r0, #0
 80917bc:	b289      	uxth	r1, r1
 80917be:	f7f1 ff3b 	bl	8083638 <BSP_LCD_DisplayStringAt>
    BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize() - 80, (uint8_t *)"Touchscreen cannot be initialized", CENTER_MODE);
 80917c2:	f7f1 fd4f 	bl	8083264 <BSP_LCD_GetYSize>
 80917c6:	f245 7290 	movw	r2, #22416	; 0x5790
 80917ca:	f1a0 0150 	sub.w	r1, r0, #80	; 0x50
 80917ce:	2301      	movs	r3, #1
 80917d0:	f6c0 0209 	movt	r2, #2057	; 0x809
 80917d4:	2000      	movs	r0, #0
 80917d6:	b289      	uxth	r1, r1
 80917d8:	f7f1 ff2e 	bl	8083638 <BSP_LCD_DisplayStringAt>
{
 80917dc:	f04f 0900 	mov.w	r9, #0
      BSP_TS_GetState(&TS_State);
 80917e0:	f24d 6408 	movw	r4, #54792	; 0xd608
        sprintf((char*)text, "Nb touch detected = %d", TS_State.touchDetected);
 80917e4:	f246 27a0 	movw	r7, #25248	; 0x62a0
        sprintf((char*)text, "1[%d,%d]    ", x, y);
 80917e8:	f246 26b8 	movw	r6, #25272	; 0x62b8
{
 80917ec:	f8cd 9004 	str.w	r9, [sp, #4]
      BSP_TS_GetState(&TS_State);
 80917f0:	f2c2 0402 	movt	r4, #8194	; 0x2002
        sprintf((char*)text, "Nb touch detected = %d", TS_State.touchDetected);
 80917f4:	f6c0 0709 	movt	r7, #2057	; 0x809
        sprintf((char*)text, "1[%d,%d]    ", x, y);
 80917f8:	f6c0 0609 	movt	r6, #2057	; 0x809
    if (status == TS_OK)
 80917fc:	b14d      	cbz	r5, 8091812 <Touchscreen_demo+0x176>
    if (CheckForUserInput() > 0)
 80917fe:	f7ff fdb3 	bl	8091368 <CheckForUserInput>
 8091802:	2800      	cmp	r0, #0
 8091804:	f040 813d 	bne.w	8091a82 <Touchscreen_demo+0x3e6>
    HAL_Delay(10);
 8091808:	200a      	movs	r0, #10
 809180a:	f7f3 ffd7 	bl	80857bc <HAL_Delay>
    if (status == TS_OK)
 809180e:	2d00      	cmp	r5, #0
 8091810:	d1f5      	bne.n	80917fe <Touchscreen_demo+0x162>
      BSP_TS_GetState(&TS_State);
 8091812:	f24d 6008 	movw	r0, #54792	; 0xd608
 8091816:	f2c2 0002 	movt	r0, #8194	; 0x2002
 809181a:	f7f3 fe99 	bl	8085550 <BSP_TS_GetState>
      if(TS_State.touchDetected)
 809181e:	7823      	ldrb	r3, [r4, #0]
 8091820:	2b00      	cmp	r3, #0
 8091822:	d0ec      	beq.n	80917fe <Touchscreen_demo+0x162>
        BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 8091824:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        x = TS_State.touchX[0];
 8091828:	f8b4 a002 	ldrh.w	sl, [r4, #2]
        y = TS_State.touchY[0];
 809182c:	f8b4 800c 	ldrh.w	r8, [r4, #12]
        BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
 8091830:	f7f1 fd9c 	bl	808336c <BSP_LCD_SetBackColor>
        BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
 8091834:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8091838:	f7f1 fd7c 	bl	8083334 <BSP_LCD_SetTextColor>
        sprintf((char*)text, "Nb touch detected = %d", TS_State.touchDetected);
 809183c:	7822      	ldrb	r2, [r4, #0]
 809183e:	4639      	mov	r1, r7
 8091840:	a802      	add	r0, sp, #8
 8091842:	f000 fc47 	bl	80920d4 <siprintf>
        BSP_LCD_DisplayStringAt(15, BSP_LCD_GetYSize() - 40, (uint8_t *)&text, LEFT_MODE);
 8091846:	f7f1 fd0d 	bl	8083264 <BSP_LCD_GetYSize>
 809184a:	f1a0 0128 	sub.w	r1, r0, #40	; 0x28
 809184e:	aa02      	add	r2, sp, #8
 8091850:	2303      	movs	r3, #3
 8091852:	b289      	uxth	r1, r1
 8091854:	200f      	movs	r0, #15
 8091856:	f7f1 feef 	bl	8083638 <BSP_LCD_DisplayStringAt>
        sprintf((char*)text, "1[%d,%d]    ", x, y);
 809185a:	4643      	mov	r3, r8
 809185c:	4652      	mov	r2, sl
 809185e:	4631      	mov	r1, r6
 8091860:	a802      	add	r0, sp, #8
 8091862:	f000 fc37 	bl	80920d4 <siprintf>
                                BSP_LCD_GetYSize() - 25,
 8091866:	f7f1 fcfd 	bl	8083264 <BSP_LCD_GetYSize>
        BSP_LCD_DisplayStringAt(15,
 809186a:	f1a0 0119 	sub.w	r1, r0, #25
 809186e:	2303      	movs	r3, #3
 8091870:	aa02      	add	r2, sp, #8
 8091872:	b289      	uxth	r1, r1
 8091874:	200f      	movs	r0, #15
 8091876:	f7f1 fedf 	bl	8083638 <BSP_LCD_DisplayStringAt>
        if (TS_State.touchDetected >= 2)  /* Display 2nd touch detected coordinates if applicable */
 809187a:	7823      	ldrb	r3, [r4, #0]
 809187c:	2b01      	cmp	r3, #1
 809187e:	f240 8106 	bls.w	8091a8e <Touchscreen_demo+0x3f2>
          sprintf((char*)text, "2[%d,%d]    ", TS_State.touchX[1], TS_State.touchY[1]);
 8091882:	f246 21c8 	movw	r1, #25288	; 0x62c8
 8091886:	89e3      	ldrh	r3, [r4, #14]
 8091888:	88a2      	ldrh	r2, [r4, #4]
 809188a:	a802      	add	r0, sp, #8
 809188c:	f6c0 0109 	movt	r1, #2057	; 0x809
 8091890:	f000 fc20 	bl	80920d4 <siprintf>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 1) / 5) + 15,
 8091894:	f7f1 fcd8 	bl	8083248 <BSP_LCD_GetXSize>
 8091898:	4683      	mov	fp, r0
                                BSP_LCD_GetYSize() - 25,
 809189a:	f7f1 fce3 	bl	8083264 <BSP_LCD_GetYSize>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 1) / 5) + 15,
 809189e:	f64c 4ecd 	movw	lr, #52429	; 0xcccd
 80918a2:	f1ab 0c1e 	sub.w	ip, fp, #30
 80918a6:	f1a0 0119 	sub.w	r1, r0, #25
 80918aa:	f6cc 4ecc 	movt	lr, #52428	; 0xcccc
 80918ae:	2303      	movs	r3, #3
 80918b0:	b289      	uxth	r1, r1
 80918b2:	aa02      	add	r2, sp, #8
 80918b4:	fbae c00c 	umull	ip, r0, lr, ip
 80918b8:	0880      	lsrs	r0, r0, #2
 80918ba:	300f      	adds	r0, #15
 80918bc:	b280      	uxth	r0, r0
 80918be:	f7f1 febb 	bl	8083638 <BSP_LCD_DisplayStringAt>
        if (TS_State.touchDetected >= 3)  /* Display 3rd touch detected coordinates if applicable */
 80918c2:	7823      	ldrb	r3, [r4, #0]
 80918c4:	2b02      	cmp	r3, #2
 80918c6:	f240 8115 	bls.w	8091af4 <Touchscreen_demo+0x458>
          sprintf((char*)text, "3[%d,%d]    ", TS_State.touchX[2], TS_State.touchY[2]);
 80918ca:	f246 21e8 	movw	r1, #25320	; 0x62e8
 80918ce:	8a23      	ldrh	r3, [r4, #16]
 80918d0:	88e2      	ldrh	r2, [r4, #6]
 80918d2:	a802      	add	r0, sp, #8
 80918d4:	f6c0 0109 	movt	r1, #2057	; 0x809
 80918d8:	f000 fbfc 	bl	80920d4 <siprintf>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 2) / 5) + 15,
 80918dc:	f7f1 fcb4 	bl	8083248 <BSP_LCD_GetXSize>
 80918e0:	4683      	mov	fp, r0
                                BSP_LCD_GetYSize() - 25,
 80918e2:	f7f1 fcbf 	bl	8083264 <BSP_LCD_GetYSize>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 2) / 5) + 15,
 80918e6:	f64f 7ce2 	movw	ip, #65506	; 0xffe2
 80918ea:	f64c 4ecd 	movw	lr, #52429	; 0xcccd
 80918ee:	f1a0 0119 	sub.w	r1, r0, #25
 80918f2:	f6c7 7cff 	movt	ip, #32767	; 0x7fff
 80918f6:	2303      	movs	r3, #3
 80918f8:	f6cc 4ecc 	movt	lr, #52428	; 0xcccc
 80918fc:	b289      	uxth	r1, r1
 80918fe:	44dc      	add	ip, fp
 8091900:	aa02      	add	r2, sp, #8
 8091902:	ea4f 004c 	mov.w	r0, ip, lsl #1
 8091906:	fbae c000 	umull	ip, r0, lr, r0
 809190a:	0880      	lsrs	r0, r0, #2
 809190c:	300f      	adds	r0, #15
 809190e:	b280      	uxth	r0, r0
 8091910:	f7f1 fe92 	bl	8083638 <BSP_LCD_DisplayStringAt>
        if (TS_State.touchDetected >= 4)  /* Display 4th touch detected coordinates if applicable */
 8091914:	7823      	ldrb	r3, [r4, #0]
 8091916:	2b03      	cmp	r3, #3
 8091918:	f240 80dc 	bls.w	8091ad4 <Touchscreen_demo+0x438>
          sprintf((char*)text, "4[%d,%d]    ", TS_State.touchX[3], TS_State.touchY[3]);
 809191c:	f246 21f8 	movw	r1, #25336	; 0x62f8
 8091920:	8a63      	ldrh	r3, [r4, #18]
 8091922:	8922      	ldrh	r2, [r4, #8]
 8091924:	a802      	add	r0, sp, #8
 8091926:	f6c0 0109 	movt	r1, #2057	; 0x809
 809192a:	f000 fbd3 	bl	80920d4 <siprintf>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 3) / 5) + 15,
 809192e:	f7f1 fc8b 	bl	8083248 <BSP_LCD_GetXSize>
 8091932:	4683      	mov	fp, r0
                                BSP_LCD_GetYSize() - 25,
 8091934:	f7f1 fc96 	bl	8083264 <BSP_LCD_GetYSize>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 3) / 5) + 15,
 8091938:	f64c 4ccd 	movw	ip, #52429	; 0xcccd
 809193c:	eb0b 024b 	add.w	r2, fp, fp, lsl #1
 8091940:	f1a0 0119 	sub.w	r1, r0, #25
 8091944:	f6cc 4ccc 	movt	ip, #52428	; 0xcccc
 8091948:	2303      	movs	r3, #3
 809194a:	f1a2 005a 	sub.w	r0, r2, #90	; 0x5a
 809194e:	b289      	uxth	r1, r1
 8091950:	aa02      	add	r2, sp, #8
 8091952:	fbac c000 	umull	ip, r0, ip, r0
 8091956:	0880      	lsrs	r0, r0, #2
 8091958:	300f      	adds	r0, #15
 809195a:	b280      	uxth	r0, r0
 809195c:	f7f1 fe6c 	bl	8083638 <BSP_LCD_DisplayStringAt>
        if (TS_State.touchDetected >= 5)  /* Display 5th touch detected coordinates if applicable */
 8091960:	7823      	ldrb	r3, [r4, #0]
 8091962:	2b04      	cmp	r3, #4
 8091964:	f240 80a6 	bls.w	8091ab4 <Touchscreen_demo+0x418>
          sprintf((char*)text, "5[%d,%d]    ", TS_State.touchX[4], TS_State.touchY[4]);
 8091968:	f246 3108 	movw	r1, #25352	; 0x6308
 809196c:	8aa3      	ldrh	r3, [r4, #20]
 809196e:	8962      	ldrh	r2, [r4, #10]
 8091970:	a802      	add	r0, sp, #8
 8091972:	f6c0 0109 	movt	r1, #2057	; 0x809
 8091976:	f000 fbad 	bl	80920d4 <siprintf>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 4) / 5) + 15,
 809197a:	f7f1 fc65 	bl	8083248 <BSP_LCD_GetXSize>
 809197e:	4683      	mov	fp, r0
                                BSP_LCD_GetYSize() - 25,
 8091980:	f7f1 fc70 	bl	8083264 <BSP_LCD_GetYSize>
        BSP_LCD_DisplayStringAt((((BSP_LCD_GetXSize() - 30) * 4) / 5) + 15,
 8091984:	f64f 7ce2 	movw	ip, #65506	; 0xffe2
 8091988:	f64c 4ecd 	movw	lr, #52429	; 0xcccd
 809198c:	f1a0 0119 	sub.w	r1, r0, #25
 8091990:	f6c3 7cff 	movt	ip, #16383	; 0x3fff
 8091994:	aa02      	add	r2, sp, #8
 8091996:	f6cc 4ecc 	movt	lr, #52428	; 0xcccc
 809199a:	2303      	movs	r3, #3
 809199c:	44dc      	add	ip, fp
 809199e:	b289      	uxth	r1, r1
 80919a0:	ea4f 008c 	mov.w	r0, ip, lsl #2
 80919a4:	fbae c000 	umull	ip, r0, lr, r0
 80919a8:	0880      	lsrs	r0, r0, #2
 80919aa:	300f      	adds	r0, #15
 80919ac:	b280      	uxth	r0, r0
 80919ae:	f7f1 fe43 	bl	8083638 <BSP_LCD_DisplayStringAt>
        radius = TS_State.touchWeight[0]/3;
 80919b2:	f64a 22ab 	movw	r2, #43691	; 0xaaab
 80919b6:	7da3      	ldrb	r3, [r4, #22]
 80919b8:	f6ca 22aa 	movt	r2, #43690	; 0xaaaa
 80919bc:	fba2 2303 	umull	r2, r3, r2, r3
 80919c0:	ea4f 0b53 	mov.w	fp, r3, lsr #1
        if (radius > CIRCLE_RADIUS)
 80919c4:	f1bb 0f1e 	cmp.w	fp, #30
 80919c8:	d871      	bhi.n	8091aae <Touchscreen_demo+0x412>
          radius = 1;
 80919ca:	f1bb 0f00 	cmp.w	fp, #0
 80919ce:	bf08      	it	eq
 80919d0:	f04f 0b01 	moveq.w	fp, #1
        if ((y > (CIRCLE_YPOS(1) - CIRCLE_RADIUS)) &&
 80919d4:	f7f1 fc46 	bl	8083264 <BSP_LCD_GetYSize>
 80919d8:	3878      	subs	r0, #120	; 0x78
 80919da:	4580      	cmp	r8, r0
 80919dc:	f67f af0f 	bls.w	80917fe <Touchscreen_demo+0x162>
            (y < (CIRCLE_YPOS(1) + CIRCLE_RADIUS)))
 80919e0:	f7f1 fc40 	bl	8083264 <BSP_LCD_GetYSize>
 80919e4:	383c      	subs	r0, #60	; 0x3c
        if ((y > (CIRCLE_YPOS(1) - CIRCLE_RADIUS)) &&
 80919e6:	4580      	cmp	r8, r0
 80919e8:	f4bf af09 	bcs.w	80917fe <Touchscreen_demo+0x162>
          if ((x > (CIRCLE_XPOS(1) - CIRCLE_RADIUS)) &&
 80919ec:	f64c 48cd 	movw	r8, #52429	; 0xcccd
 80919f0:	f7f1 fc2a 	bl	8083248 <BSP_LCD_GetXSize>
 80919f4:	f6cc 48cc 	movt	r8, #52428	; 0xcccc
 80919f8:	fba8 3200 	umull	r3, r2, r8, r0
 80919fc:	0892      	lsrs	r2, r2, #2
 80919fe:	3a1e      	subs	r2, #30
 8091a00:	4592      	cmp	sl, r2
 8091a02:	f200 80ab 	bhi.w	8091b5c <Touchscreen_demo+0x4c0>
          if ((x > (CIRCLE_XPOS(2) - CIRCLE_RADIUS)) &&
 8091a06:	f64c 48cd 	movw	r8, #52429	; 0xcccd
 8091a0a:	f7f1 fc1d 	bl	8083248 <BSP_LCD_GetXSize>
 8091a0e:	0042      	lsls	r2, r0, #1
 8091a10:	f6cc 48cc 	movt	r8, #52428	; 0xcccc
 8091a14:	fba8 3202 	umull	r3, r2, r8, r2
 8091a18:	0892      	lsrs	r2, r2, #2
 8091a1a:	3a1e      	subs	r2, #30
 8091a1c:	4592      	cmp	sl, r2
 8091a1e:	f200 808b 	bhi.w	8091b38 <Touchscreen_demo+0x49c>
          if ((x > (CIRCLE_XPOS(3) - CIRCLE_RADIUS)) &&
 8091a22:	f64c 48cd 	movw	r8, #52429	; 0xcccd
 8091a26:	f7f1 fc0f 	bl	8083248 <BSP_LCD_GetXSize>
 8091a2a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8091a2e:	f6cc 48cc 	movt	r8, #52428	; 0xcccc
 8091a32:	fba8 3200 	umull	r3, r2, r8, r0
 8091a36:	0892      	lsrs	r2, r2, #2
 8091a38:	3a1e      	subs	r2, #30
 8091a3a:	4592      	cmp	sl, r2
 8091a3c:	d86a      	bhi.n	8091b14 <Touchscreen_demo+0x478>
          if ((x > (CIRCLE_XPOS(4) - CIRCLE_RADIUS)) &&
 8091a3e:	f64c 48cd 	movw	r8, #52429	; 0xcccd
 8091a42:	f7f1 fc01 	bl	8083248 <BSP_LCD_GetXSize>
 8091a46:	0082      	lsls	r2, r0, #2
 8091a48:	f6cc 48cc 	movt	r8, #52428	; 0xcccc
 8091a4c:	fba8 3202 	umull	r3, r2, r8, r2
 8091a50:	0892      	lsrs	r2, r2, #2
 8091a52:	3a1e      	subs	r2, #30
 8091a54:	4592      	cmp	sl, r2
 8091a56:	f67f aed2 	bls.w	80917fe <Touchscreen_demo+0x162>
              (x < (CIRCLE_XPOS(4) + CIRCLE_RADIUS)))
 8091a5a:	f7f1 fbf5 	bl	8083248 <BSP_LCD_GetXSize>
 8091a5e:	0082      	lsls	r2, r0, #2
 8091a60:	fba8 3202 	umull	r3, r2, r8, r2
 8091a64:	0892      	lsrs	r2, r2, #2
 8091a66:	321e      	adds	r2, #30
          if ((x > (CIRCLE_XPOS(4) - CIRCLE_RADIUS)) &&
 8091a68:	4592      	cmp	sl, r2
 8091a6a:	f4bf aec8 	bcs.w	80917fe <Touchscreen_demo+0x162>
            if ((radius != radius_previous) || (state != 8))
 8091a6e:	45cb      	cmp	fp, r9
 8091a70:	f040 8085 	bne.w	8091b7e <Touchscreen_demo+0x4e2>
 8091a74:	9b01      	ldr	r3, [sp, #4]
 8091a76:	2b08      	cmp	r3, #8
 8091a78:	f040 8081 	bne.w	8091b7e <Touchscreen_demo+0x4e2>
 8091a7c:	2308      	movs	r3, #8
 8091a7e:	9301      	str	r3, [sp, #4]
 8091a80:	e6bd      	b.n	80917fe <Touchscreen_demo+0x162>
}
 8091a82:	b00b      	add	sp, #44	; 0x2c
 8091a84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Touchscreen_DrawBackground(state);
 8091a88:	f7ff fcb4 	bl	80913f4 <Touchscreen_DrawBackground>
 8091a8c:	e6a6      	b.n	80917dc <Touchscreen_demo+0x140>
          sprintf((char*)text, "              ");
 8091a8e:	f246 23d8 	movw	r3, #25304	; 0x62d8
 8091a92:	f10d 0c08 	add.w	ip, sp, #8
 8091a96:	f6c0 0309 	movt	r3, #2057	; 0x809
 8091a9a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8091a9c:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8091aa0:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 8091aa4:	f82c 3b02 	strh.w	r3, [ip], #2
 8091aa8:	f88c e000 	strb.w	lr, [ip]
 8091aac:	e6f2      	b.n	8091894 <Touchscreen_demo+0x1f8>
          radius = CIRCLE_RADIUS;
 8091aae:	f04f 0b1e 	mov.w	fp, #30
 8091ab2:	e78f      	b.n	80919d4 <Touchscreen_demo+0x338>
          sprintf((char*)text, "              ");
 8091ab4:	f246 23d8 	movw	r3, #25304	; 0x62d8
 8091ab8:	f10d 0c08 	add.w	ip, sp, #8
 8091abc:	f6c0 0309 	movt	r3, #2057	; 0x809
 8091ac0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8091ac2:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8091ac6:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 8091aca:	f82c 3b02 	strh.w	r3, [ip], #2
 8091ace:	f88c e000 	strb.w	lr, [ip]
 8091ad2:	e752      	b.n	809197a <Touchscreen_demo+0x2de>
          sprintf((char*)text, "              ");
 8091ad4:	f246 23d8 	movw	r3, #25304	; 0x62d8
 8091ad8:	f10d 0c08 	add.w	ip, sp, #8
 8091adc:	f6c0 0309 	movt	r3, #2057	; 0x809
 8091ae0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8091ae2:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8091ae6:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 8091aea:	f82c 3b02 	strh.w	r3, [ip], #2
 8091aee:	f88c e000 	strb.w	lr, [ip]
 8091af2:	e71c      	b.n	809192e <Touchscreen_demo+0x292>
          sprintf((char*)text, "              ");
 8091af4:	f246 23d8 	movw	r3, #25304	; 0x62d8
 8091af8:	f10d 0c08 	add.w	ip, sp, #8
 8091afc:	f6c0 0309 	movt	r3, #2057	; 0x809
 8091b00:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8091b02:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8091b06:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 8091b0a:	f82c 3b02 	strh.w	r3, [ip], #2
 8091b0e:	f88c e000 	strb.w	lr, [ip]
 8091b12:	e6e3      	b.n	80918dc <Touchscreen_demo+0x240>
              (x < (CIRCLE_XPOS(3) + CIRCLE_RADIUS)))
 8091b14:	f7f1 fb98 	bl	8083248 <BSP_LCD_GetXSize>
 8091b18:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8091b1c:	fba8 3200 	umull	r3, r2, r8, r0
 8091b20:	0892      	lsrs	r2, r2, #2
 8091b22:	321e      	adds	r2, #30
          if ((x > (CIRCLE_XPOS(3) - CIRCLE_RADIUS)) &&
 8091b24:	4592      	cmp	sl, r2
 8091b26:	d28a      	bcs.n	8091a3e <Touchscreen_demo+0x3a2>
            if ((radius != radius_previous) || (state != 4))
 8091b28:	45cb      	cmp	fp, r9
 8091b2a:	d16d      	bne.n	8091c08 <Touchscreen_demo+0x56c>
 8091b2c:	9b01      	ldr	r3, [sp, #4]
 8091b2e:	2b04      	cmp	r3, #4
 8091b30:	d16a      	bne.n	8091c08 <Touchscreen_demo+0x56c>
 8091b32:	2304      	movs	r3, #4
 8091b34:	9301      	str	r3, [sp, #4]
 8091b36:	e782      	b.n	8091a3e <Touchscreen_demo+0x3a2>
              (x < (CIRCLE_XPOS(2) + CIRCLE_RADIUS)))
 8091b38:	f7f1 fb86 	bl	8083248 <BSP_LCD_GetXSize>
 8091b3c:	0042      	lsls	r2, r0, #1
 8091b3e:	fba8 3202 	umull	r3, r2, r8, r2
 8091b42:	0892      	lsrs	r2, r2, #2
 8091b44:	321e      	adds	r2, #30
          if ((x > (CIRCLE_XPOS(2) - CIRCLE_RADIUS)) &&
 8091b46:	4592      	cmp	sl, r2
 8091b48:	f4bf af6b 	bcs.w	8091a22 <Touchscreen_demo+0x386>
            if ((radius != radius_previous) || (state != 2))
 8091b4c:	45cb      	cmp	fp, r9
 8091b4e:	d17e      	bne.n	8091c4e <Touchscreen_demo+0x5b2>
 8091b50:	9b01      	ldr	r3, [sp, #4]
 8091b52:	2b02      	cmp	r3, #2
 8091b54:	d17b      	bne.n	8091c4e <Touchscreen_demo+0x5b2>
 8091b56:	2302      	movs	r3, #2
 8091b58:	9301      	str	r3, [sp, #4]
 8091b5a:	e762      	b.n	8091a22 <Touchscreen_demo+0x386>
              (x < (CIRCLE_XPOS(1) + CIRCLE_RADIUS)))
 8091b5c:	f7f1 fb74 	bl	8083248 <BSP_LCD_GetXSize>
 8091b60:	fba8 3200 	umull	r3, r2, r8, r0
 8091b64:	0892      	lsrs	r2, r2, #2
 8091b66:	321e      	adds	r2, #30
          if ((x > (CIRCLE_XPOS(1) - CIRCLE_RADIUS)) &&
 8091b68:	4592      	cmp	sl, r2
 8091b6a:	f4bf af4c 	bcs.w	8091a06 <Touchscreen_demo+0x36a>
            if ((radius != radius_previous) || (state != 1))
 8091b6e:	45cb      	cmp	fp, r9
 8091b70:	d128      	bne.n	8091bc4 <Touchscreen_demo+0x528>
 8091b72:	9b01      	ldr	r3, [sp, #4]
 8091b74:	2b01      	cmp	r3, #1
 8091b76:	d125      	bne.n	8091bc4 <Touchscreen_demo+0x528>
 8091b78:	2301      	movs	r3, #1
 8091b7a:	9301      	str	r3, [sp, #4]
 8091b7c:	e743      	b.n	8091a06 <Touchscreen_demo+0x36a>
              if (state != 8) /* Erase previous filled circle */
 8091b7e:	9b01      	ldr	r3, [sp, #4]
 8091b80:	2b08      	cmp	r3, #8
 8091b82:	d002      	beq.n	8091b8a <Touchscreen_demo+0x4ee>
                Touchscreen_DrawBackground(state);
 8091b84:	4618      	mov	r0, r3
 8091b86:	f7ff fc35 	bl	80913f4 <Touchscreen_DrawBackground>
              BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 8091b8a:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
              BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), radius);
 8091b8e:	46d9      	mov	r9, fp
              BSP_LCD_SetTextColor(LCD_COLOR_GREEN);
 8091b90:	f7f1 fbd0 	bl	8083334 <BSP_LCD_SetTextColor>
              BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), radius);
 8091b94:	f7f1 fb58 	bl	8083248 <BSP_LCD_GetXSize>
 8091b98:	4680      	mov	r8, r0
 8091b9a:	f7f1 fb63 	bl	8083264 <BSP_LCD_GetYSize>
 8091b9e:	f64c 4ecd 	movw	lr, #52429	; 0xcccd
 8091ba2:	ea4f 0c88 	mov.w	ip, r8, lsl #2
 8091ba6:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091baa:	f6cc 4ecc 	movt	lr, #52428	; 0xcccc
 8091bae:	465a      	mov	r2, fp
 8091bb0:	b289      	uxth	r1, r1
 8091bb2:	fbae 300c 	umull	r3, r0, lr, ip
              state = 8;
 8091bb6:	2308      	movs	r3, #8
              BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), radius);
 8091bb8:	f3c0 008f 	ubfx	r0, r0, #2, #16
              state = 8;
 8091bbc:	9301      	str	r3, [sp, #4]
              BSP_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), radius);
 8091bbe:	f7f2 f8d9 	bl	8083d74 <BSP_LCD_FillCircle>
 8091bc2:	e61c      	b.n	80917fe <Touchscreen_demo+0x162>
              if (state != 1) /* Erase previous filled circle */
 8091bc4:	9b01      	ldr	r3, [sp, #4]
 8091bc6:	2b01      	cmp	r3, #1
 8091bc8:	d002      	beq.n	8091bd0 <Touchscreen_demo+0x534>
                Touchscreen_DrawBackground(state);
 8091bca:	4618      	mov	r0, r3
 8091bcc:	f7ff fc12 	bl	80913f4 <Touchscreen_DrawBackground>
              BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8091bd0:	20ff      	movs	r0, #255	; 0xff
              BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), radius);
 8091bd2:	46d9      	mov	r9, fp
              BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
 8091bd4:	f6cf 7000 	movt	r0, #65280	; 0xff00
 8091bd8:	f7f1 fbac 	bl	8083334 <BSP_LCD_SetTextColor>
              BSP_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), radius);
 8091bdc:	f7f1 fb34 	bl	8083248 <BSP_LCD_GetXSize>
 8091be0:	4680      	mov	r8, r0
 8091be2:	f7f1 fb3f 	bl	8083264 <BSP_LCD_GetYSize>
 8091be6:	f64c 42cd 	movw	r2, #52429	; 0xcccd
 8091bea:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091bee:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
 8091bf2:	b289      	uxth	r1, r1
 8091bf4:	fba2 3008 	umull	r3, r0, r2, r8
 8091bf8:	465a      	mov	r2, fp
 8091bfa:	f3c0 008f 	ubfx	r0, r0, #2, #16
 8091bfe:	f7f2 f8b9 	bl	8083d74 <BSP_LCD_FillCircle>
              state = 1;
 8091c02:	2301      	movs	r3, #1
 8091c04:	9301      	str	r3, [sp, #4]
 8091c06:	e6fe      	b.n	8091a06 <Touchscreen_demo+0x36a>
              if (state != 4) /* Erase previous filled circle */
 8091c08:	9b01      	ldr	r3, [sp, #4]
 8091c0a:	2b04      	cmp	r3, #4
 8091c0c:	d002      	beq.n	8091c14 <Touchscreen_demo+0x578>
                Touchscreen_DrawBackground(state);
 8091c0e:	4618      	mov	r0, r3
 8091c10:	f7ff fbf0 	bl	80913f4 <Touchscreen_DrawBackground>
              BSP_LCD_SetTextColor(LCD_COLOR_YELLOW);
 8091c14:	f06f 00ff 	mvn.w	r0, #255	; 0xff
              BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), radius);
 8091c18:	46d9      	mov	r9, fp
              BSP_LCD_SetTextColor(LCD_COLOR_YELLOW);
 8091c1a:	f7f1 fb8b 	bl	8083334 <BSP_LCD_SetTextColor>
              BSP_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), radius);
 8091c1e:	f7f1 fb13 	bl	8083248 <BSP_LCD_GetXSize>
 8091c22:	4680      	mov	r8, r0
 8091c24:	f7f1 fb1e 	bl	8083264 <BSP_LCD_GetYSize>
 8091c28:	f64c 42cd 	movw	r2, #52429	; 0xcccd
 8091c2c:	eb08 0848 	add.w	r8, r8, r8, lsl #1
 8091c30:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091c34:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
 8091c38:	b289      	uxth	r1, r1
 8091c3a:	fba2 3008 	umull	r3, r0, r2, r8
 8091c3e:	465a      	mov	r2, fp
 8091c40:	f3c0 008f 	ubfx	r0, r0, #2, #16
 8091c44:	f7f2 f896 	bl	8083d74 <BSP_LCD_FillCircle>
              state = 4;
 8091c48:	2304      	movs	r3, #4
 8091c4a:	9301      	str	r3, [sp, #4]
 8091c4c:	e6f7      	b.n	8091a3e <Touchscreen_demo+0x3a2>
              if (state != 2) /* Erase previous filled circle */
 8091c4e:	9b01      	ldr	r3, [sp, #4]
 8091c50:	2b02      	cmp	r3, #2
 8091c52:	d002      	beq.n	8091c5a <Touchscreen_demo+0x5be>
                Touchscreen_DrawBackground(state);
 8091c54:	4618      	mov	r0, r3
 8091c56:	f7ff fbcd 	bl	80913f4 <Touchscreen_DrawBackground>
              BSP_LCD_SetTextColor(LCD_COLOR_RED);
 8091c5a:	2000      	movs	r0, #0
              BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), radius);
 8091c5c:	46d9      	mov	r9, fp
              BSP_LCD_SetTextColor(LCD_COLOR_RED);
 8091c5e:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 8091c62:	f7f1 fb67 	bl	8083334 <BSP_LCD_SetTextColor>
              BSP_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), radius);
 8091c66:	f7f1 faef 	bl	8083248 <BSP_LCD_GetXSize>
 8091c6a:	4680      	mov	r8, r0
 8091c6c:	f7f1 fafa 	bl	8083264 <BSP_LCD_GetYSize>
 8091c70:	f64c 42cd 	movw	r2, #52429	; 0xcccd
 8091c74:	ea4f 0848 	mov.w	r8, r8, lsl #1
 8091c78:	f1a0 015a 	sub.w	r1, r0, #90	; 0x5a
 8091c7c:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
 8091c80:	b289      	uxth	r1, r1
 8091c82:	fba2 3008 	umull	r3, r0, r2, r8
 8091c86:	465a      	mov	r2, fp
 8091c88:	f3c0 008f 	ubfx	r0, r0, #2, #16
 8091c8c:	f7f2 f872 	bl	8083d74 <BSP_LCD_FillCircle>
              state = 2;
 8091c90:	2302      	movs	r3, #2
 8091c92:	9301      	str	r3, [sp, #4]
 8091c94:	e6c5      	b.n	8091a22 <Touchscreen_demo+0x386>
 8091c96:	bf00      	nop

08091c98 <main>:
 * @param  None
 * @retval None
 */
static void CPU_EnableFPU(void)
{
	SCB->CPACR=(0x3<<20)+(0x3<<22); // Enable full access to CP11 and CP10 FPU
 8091c98:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8091c9c:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
 8091ca0:	f2ce 0300 	movt	r3, #57344	; 0xe000
{
 8091ca4:	b5f0      	push	{r4, r5, r6, r7, lr}
	SCB->CPACR=(0x3<<20)+(0x3<<22); // Enable full access to CP11 and CP10 FPU
 8091ca6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
{
 8091caa:	b093      	sub	sp, #76	; 0x4c
 * @param  None
 * @retval None
 */
static void CPU_EnableFaultHandler(void)
{
	SCB->SHCSR = SCB->SHCSR | (SCB_SHCSR_BUSFAULTENA_Msk + SCB_SHCSR_MEMFAULTENA_Msk + SCB_SHCSR_USGFAULTENA_Msk);
 8091cac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8091cae:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
 8091cb2:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8091cb4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8091cb8:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8091cbc:	2100      	movs	r1, #0
 8091cbe:	f8c3 1250 	str.w	r1, [r3, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8091cc2:	695a      	ldr	r2, [r3, #20]
 8091cc4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8091cc8:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8091cca:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8091cce:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
 8091cd2:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8091cd6:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 8091cda:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8091cde:	461a      	mov	r2, r3
 8091ce0:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8091ce4:	f3c1 06c9 	ubfx	r6, r1, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8091ce8:	f3c1 314e 	ubfx	r1, r1, #13, #15
 8091cec:	07b7      	lsls	r7, r6, #30
 8091cee:	014c      	lsls	r4, r1, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8091cf0:	ea04 050c 	and.w	r5, r4, ip
 8091cf4:	4638      	mov	r0, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8091cf6:	4631      	mov	r1, r6
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8091cf8:	ea45 0300 	orr.w	r3, r5, r0
      } while (ways--);
 8091cfc:	3901      	subs	r1, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8091cfe:	f100 4040 	add.w	r0, r0, #3221225472	; 0xc0000000
 8091d02:	f8c2 3260 	str.w	r3, [r2, #608]	; 0x260
      } while (ways--);
 8091d06:	1c4b      	adds	r3, r1, #1
 8091d08:	d1f6      	bne.n	8091cf8 <main+0x60>
 8091d0a:	3c20      	subs	r4, #32
    } while(sets--);
 8091d0c:	f114 0f20 	cmn.w	r4, #32
 8091d10:	d1ee      	bne.n	8091cf0 <main+0x58>
 8091d12:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8091d16:	6953      	ldr	r3, [r2, #20]
 8091d18:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8091d1c:	6153      	str	r3, [r2, #20]
 8091d1e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8091d22:	f3bf 8f6f 	isb	sy
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8091d26:	2401      	movs	r4, #1
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8091d28:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8091d2c:	f44f 0580 	mov.w	r5, #4194304	; 0x400000
	RCC_OscInitStruct.PLL.PLLM = 25;
 8091d30:	2119      	movs	r1, #25
	RCC_OscInitStruct.PLL.PLLN = 432;
 8091d32:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
	RCC_OscInitStruct.PLL.PLLQ = 9;
 8091d36:	2309      	movs	r3, #9
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8091d38:	9406      	str	r4, [sp, #24]
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8091d3a:	2402      	movs	r4, #2
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8091d3c:	9007      	str	r0, [sp, #28]
	ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8091d3e:	a806      	add	r0, sp, #24
	RCC_OscInitStruct.PLL.PLLN = 432;
 8091d40:	920f      	str	r2, [sp, #60]	; 0x3c
	RCC_OscInitStruct.PLL.PLLQ = 9;
 8091d42:	9311      	str	r3, [sp, #68]	; 0x44
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8091d44:	940c      	str	r4, [sp, #48]	; 0x30
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8091d46:	9410      	str	r4, [sp, #64]	; 0x40
	RCC_OscInitStruct.PLL.PLLM = 25;
 8091d48:	e9cd 510d 	strd	r5, r1, [sp, #52]	; 0x34
	ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8091d4c:	f7f5 fcb6 	bl	80876bc <HAL_RCC_OscConfig>
	if(ret != HAL_OK)
 8091d50:	b100      	cbz	r0, 8091d54 <main+0xbc>
 8091d52:	e7fe      	b.n	8091d52 <main+0xba>
	ret = HAL_PWREx_EnableOverDrive();
 8091d54:	f7f5 f8fa 	bl	8086f4c <HAL_PWREx_EnableOverDrive>
	if(ret != HAL_OK)
 8091d58:	4603      	mov	r3, r0
 8091d5a:	b100      	cbz	r0, 8091d5e <main+0xc6>
 8091d5c:	e7fe      	b.n	8091d5c <main+0xc4>
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8091d5e:	f44f 55a0 	mov.w	r5, #5120	; 0x1400
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8091d62:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8091d66:	260f      	movs	r6, #15
	ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
 8091d68:	2107      	movs	r1, #7
 8091d6a:	a801      	add	r0, sp, #4
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8091d6c:	9402      	str	r4, [sp, #8]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8091d6e:	9303      	str	r3, [sp, #12]
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8091d70:	9601      	str	r6, [sp, #4]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8091d72:	e9cd 5204 	strd	r5, r2, [sp, #16]
	ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
 8091d76:	f7f5 feeb 	bl	8087b50 <HAL_RCC_ClockConfig>
	if(ret != HAL_OK)
 8091d7a:	4605      	mov	r5, r0
 8091d7c:	b100      	cbz	r0, 8091d80 <main+0xe8>
 8091d7e:	e7fe      	b.n	8091d7e <main+0xe6>
	HAL_Init();
 8091d80:	f7f3 fcf0 	bl	8085764 <HAL_Init>
 * @retval None
 */
static void MAIN_SystemInit(void)
{
	/* Init standard IO serial link */
	BSP_STDIO_Init();
 8091d84:	f7f3 fb46 	bl	8085414 <BSP_STDIO_Init>

	/* Init led1 */
	BSP_LED_Init(LED1);
 8091d88:	4628      	mov	r0, r5
 8091d8a:	f7f0 f92d 	bl	8081fe8 <BSP_LED_Init>

	/* Configure the User Button in GPIO Mode */
	BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);
 8091d8e:	4629      	mov	r1, r5
 8091d90:	4620      	mov	r0, r4
 8091d92:	f7f0 f953 	bl	808203c <BSP_PB_Init>

	/* Init External SRAM */
	BSP_SDRAM_Init();
 8091d96:	f7f3 fa9d 	bl	80852d4 <BSP_SDRAM_Init>

	/* Init QSPI */
	BSP_QSPI_Init();
 8091d9a:	f7f2 fed5 	bl	8084b48 <BSP_QSPI_Init>
	BSP_QSPI_EnableMemoryMappedMode();
 8091d9e:	f7f2 fe0f 	bl	80849c0 <BSP_QSPI_EnableMemoryMappedMode>

	/* Init Keys */
	BSP_KEYS_Init();
 8091da2:	f7f1 f9c1 	bl	8083128 <BSP_KEYS_Init>

	/* Init magnetic sensor */
	BSP_MAG_Init();
 8091da6:	f7f2 fb49 	bl	808443c <BSP_MAG_Init>

	/* Init accelerometer and gyroscope sensor */
	BSP_ACC_GYRO_Init();
 8091daa:	f7f0 fbf1 	bl	8082590 <BSP_ACC_GYRO_Init>

	/* Init pressure sensor */
	BSP_PRESSURE_Init();
 8091dae:	f7f2 fc6d 	bl	808468c <BSP_PRESSURE_Init>

	/* Init WIFI */
	//BSP_WIFI_Init();

	/* Init RNG */
	BSP_RNG_InitGenerator();
 8091db2:	f7f2 ff6b 	bl	8084c8c <BSP_RNG_InitGenerator>
	lcd_status = BSP_LCD_Init();
 8091db6:	f7f2 f9cf 	bl	8084158 <BSP_LCD_Init>
	ASSERT(lcd_status != LCD_OK);
 8091dba:	b130      	cbz	r0, 8091dca <main+0x132>
 8091dbc:	f24d 6334 	movw	r3, #54836	; 0xd634
 8091dc0:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8091dc4:	681a      	ldr	r2, [r3, #0]
 8091dc6:	3201      	adds	r2, #1
 8091dc8:	601a      	str	r2, [r3, #0]
	BSP_LCD_LayerRgb565Init(LTDC_FOREGROUND_LAYER, LCD_FRAME_BUFFER_LAYER_FOREGROUND);
 8091dca:	f240 0100 	movw	r1, #0
 8091dce:	2001      	movs	r0, #1
 8091dd0:	f2cc 0100 	movt	r1, #49152	; 0xc000
 8091dd4:	f7f1 fa54 	bl	8083280 <BSP_LCD_LayerRgb565Init>
	BSP_LCD_LayerRgb565Init(LTDC_BACKGROUND_LAYER, LCD_FRAME_BUFFER_LAYER_BACKGROUND);
 8091dd8:	f64f 4100 	movw	r1, #64512	; 0xfc00
 8091ddc:	2000      	movs	r0, #0
 8091dde:	f2cc 0103 	movt	r1, #49155	; 0xc003
 8091de2:	f7f1 fa4d 	bl	8083280 <BSP_LCD_LayerRgb565Init>
	BSP_LCD_ResetScreen();
 8091de6:	f7f1 fb09 	bl	80833fc <BSP_LCD_ResetScreen>
	if (BSP_PB_GetState(BUTTON_X) != RESET)	{
 8091dea:	f44f 7081 	mov.w	r0, #258	; 0x102
 8091dee:	f7f0 f987 	bl	8082100 <BSP_PB_GetState>
 8091df2:	b108      	cbz	r0, 8091df8 <main+0x160>
		TESTS_Run();
 8091df4:	f7ff faca 	bl	809138c <TESTS_Run>
	LEGACY_System();
 8091df8:	f7fa fa1e 	bl	808c238 <LEGACY_System>
 8091dfc:	e7fe      	b.n	8091dfc <main+0x164>
 8091dfe:	bf00      	nop

08091e00 <HAL_GPIO_EXTI_Callback>:
	switch (GPIO_Pin)
 8091e00:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8091e04:	d028      	beq.n	8091e58 <HAL_GPIO_EXTI_Callback+0x58>
 8091e06:	d91d      	bls.n	8091e44 <HAL_GPIO_EXTI_Callback+0x44>
 8091e08:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8091e0c:	4601      	mov	r1, r0
{
 8091e0e:	b510      	push	{r4, lr}
	switch (GPIO_Pin)
 8091e10:	d00a      	beq.n	8091e28 <HAL_GPIO_EXTI_Callback+0x28>
 8091e12:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8091e16:	d106      	bne.n	8091e26 <HAL_GPIO_EXTI_Callback+0x26>
		if (HAL_GPIO_ReadPin(TS_INT_GPIO_PORT, TS_INT_PIN))
 8091e18:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8091e1c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8091e20:	f7f4 fb38 	bl	8086494 <HAL_GPIO_ReadPin>
 8091e24:	bb00      	cbnz	r0, 8091e68 <HAL_GPIO_EXTI_Callback+0x68>
}
 8091e26:	bd10      	pop	{r4, pc}
		if ((HAL_GetTick() - debounce_time) > 50)
 8091e28:	f24d 6440 	movw	r4, #54848	; 0xd640
 8091e2c:	f7f3 fcc0 	bl	80857b0 <HAL_GetTick>
 8091e30:	f2c2 0402 	movt	r4, #8194	; 0x2002
 8091e34:	6823      	ldr	r3, [r4, #0]
 8091e36:	1ac0      	subs	r0, r0, r3
 8091e38:	2832      	cmp	r0, #50	; 0x32
 8091e3a:	d9f4      	bls.n	8091e26 <HAL_GPIO_EXTI_Callback+0x26>
			debounce_time = HAL_GetTick();
 8091e3c:	f7f3 fcb8 	bl	80857b0 <HAL_GetTick>
 8091e40:	6020      	str	r0, [r4, #0]
}
 8091e42:	bd10      	pop	{r4, pc}
	switch (GPIO_Pin)
 8091e44:	2840      	cmp	r0, #64	; 0x40
 8091e46:	d113      	bne.n	8091e70 <HAL_GPIO_EXTI_Callback+0x70>
		counter_mag++;
 8091e48:	f24d 633c 	movw	r3, #54844	; 0xd63c
 8091e4c:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8091e50:	681a      	ldr	r2, [r3, #0]
 8091e52:	3201      	adds	r2, #1
 8091e54:	601a      	str	r2, [r3, #0]
		break;
 8091e56:	4770      	bx	lr
		counter_acc_gyro++;
 8091e58:	f24d 6338 	movw	r3, #54840	; 0xd638
 8091e5c:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8091e60:	681a      	ldr	r2, [r3, #0]
 8091e62:	3201      	adds	r2, #1
 8091e64:	601a      	str	r2, [r3, #0]
 8091e66:	4770      	bx	lr
}
 8091e68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			BSP_TS_ITClear();
 8091e6c:	f7f3 bc68 	b.w	8085740 <BSP_TS_ITClear>
 8091e70:	4770      	bx	lr
 8091e72:	bf00      	nop

08091e74 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8091e74:	f8df d034 	ldr.w	sp, [pc, #52]	; 8091eac <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8091e78:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8091e7a:	e003      	b.n	8091e84 <LoopCopyDataInit>

08091e7c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8091e7c:	4b0c      	ldr	r3, [pc, #48]	; (8091eb0 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8091e7e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8091e80:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8091e82:	3104      	adds	r1, #4

08091e84 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8091e84:	480b      	ldr	r0, [pc, #44]	; (8091eb4 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8091e86:	4b0c      	ldr	r3, [pc, #48]	; (8091eb8 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8091e88:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8091e8a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8091e8c:	d3f6      	bcc.n	8091e7c <CopyDataInit>
  ldr  r2, =_sbss
 8091e8e:	4a0b      	ldr	r2, [pc, #44]	; (8091ebc <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8091e90:	e002      	b.n	8091e98 <LoopFillZerobss>

08091e92 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8091e92:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8091e94:	f842 3b04 	str.w	r3, [r2], #4

08091e98 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8091e98:	4b09      	ldr	r3, [pc, #36]	; (8091ec0 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8091e9a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8091e9c:	d3f9      	bcc.n	8091e92 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8091e9e:	f000 f8af 	bl	8092000 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8091ea2:	f000 f8df 	bl	8092064 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8091ea6:	f7ff fef7 	bl	8091c98 <main>
  bx  lr    
 8091eaa:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8091eac:	20001400 	.word	0x20001400
  ldr  r3, =_sidata
 8091eb0:	08099db8 	.word	0x08099db8
  ldr  r0, =_sdata
 8091eb4:	2000b000 	.word	0x2000b000
  ldr  r3, =_edata
 8091eb8:	2000b3dc 	.word	0x2000b3dc
  ldr  r2, =_sbss
 8091ebc:	2000b3e0 	.word	0x2000b3e0
  ldr  r3, = _ebss
 8091ec0:	2002f4f8 	.word	0x2002f4f8

08091ec4 <SetStack>:
*/
	.section	.text.SetStack
	.type	SetStack, %function
	.global SetStack
SetStack:
	CPSID	i // Disable interrupts
 8091ec4:	b672      	cpsid	i

	//LDR 	R0, =__initial_sp
	MSR		MSP, R0
 8091ec6:	f380 8808 	msr	MSP, r0
	MSR		PSP, R1
 8091eca:	f381 8809 	msr	PSP, r1

	MOV		R0, #0
 8091ece:	f04f 0000 	mov.w	r0, #0
	MSR		CONTROL, R0 // MSP in use, Privileged, Float point registers will not be saved
 8091ed2:	f380 8814 	msr	CONTROL, r0

	ISB		// Flush cache
 8091ed6:	f3bf 8f6f 	isb	sy

	LDR 	R0, =#0xDEADBEEF
 8091eda:	4808      	ldr	r0, [pc, #32]	; (8091efc <SetStack_LoopApplicationStack+0xe>)
	LDR		R1, =#__system_stack_start__
 8091edc:	4908      	ldr	r1, [pc, #32]	; (8091f00 <SetStack_LoopApplicationStack+0x12>)
	LDR		R2, =#__system_stack_end__
 8091ede:	4a09      	ldr	r2, [pc, #36]	; (8091f04 <SetStack_LoopApplicationStack+0x16>)

08091ee0 <SetStack_LoopSystemStack>:

SetStack_LoopSystemStack:
	STR		R0,[R1]
 8091ee0:	6008      	str	r0, [r1, #0]
	ADD		R1,R1,#4
 8091ee2:	f101 0104 	add.w	r1, r1, #4
	CMP		R1,R2
 8091ee6:	4291      	cmp	r1, r2
	BNE		SetStack_LoopSystemStack
 8091ee8:	d1fa      	bne.n	8091ee0 <SetStack_LoopSystemStack>

	LDR		R1, =#__app_stack_start__
 8091eea:	4907      	ldr	r1, [pc, #28]	; (8091f08 <SetStack_LoopApplicationStack+0x1a>)
	LDR		R2, =#__app_stack_end__
 8091eec:	4a07      	ldr	r2, [pc, #28]	; (8091f0c <SetStack_LoopApplicationStack+0x1e>)

08091eee <SetStack_LoopApplicationStack>:
SetStack_LoopApplicationStack:
	STR		R0,[R1]
 8091eee:	6008      	str	r0, [r1, #0]
	ADD		R1,R1,#4
 8091ef0:	f101 0104 	add.w	r1, r1, #4
	CMP		R1,R2
 8091ef4:	4291      	cmp	r1, r2
	BNE		SetStack_LoopApplicationStack
 8091ef6:	d1fa      	bne.n	8091eee <SetStack_LoopApplicationStack>

	CPSIE	i // Enable back interrupts
 8091ef8:	b662      	cpsie	i
	BX		LR
 8091efa:	4770      	bx	lr
	LDR 	R0, =#0xDEADBEEF
 8091efc:	deadbeef 	.word	0xdeadbeef
	LDR		R1, =#__system_stack_start__
 8091f00:	20001000 	.word	0x20001000
	LDR		R2, =#__system_stack_end__
 8091f04:	20001400 	.word	0x20001400
	LDR		R1, =#__app_stack_start__
 8091f08:	20000000 	.word	0x20000000
	LDR		R2, =#__app_stack_end__
 8091f0c:	20001000 	.word	0x20001000

08091f10 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8091f10:	e7fe      	b.n	8091f10 <ADC_IRQHandler>
	...

08091f14 <HAL_MspInit>:
/**
  * @brief  Initializes the Global MSP.
  * @retval None
  */
void HAL_MspInit(void)
{
 8091f14:	b500      	push	{lr}
 8091f16:	b085      	sub	sp, #20
	RNG_HandleTypeDef RNG_Handle;

	RNG_Handle.State = HAL_RNG_STATE_READY;
 8091f18:	2301      	movs	r3, #1
	HAL_RNG_MspInit(&RNG_Handle);
 8091f1a:	a801      	add	r0, sp, #4
	RNG_Handle.State = HAL_RNG_STATE_READY;
 8091f1c:	f88d 300d 	strb.w	r3, [sp, #13]
	HAL_RNG_MspInit(&RNG_Handle);
 8091f20:	f7f2 fed0 	bl	8084cc4 <HAL_RNG_MspInit>
}
 8091f24:	b005      	add	sp, #20
 8091f26:	f85d fb04 	ldr.w	pc, [sp], #4
 8091f2a:	bf00      	nop

08091f2c <NMI_Handler>:
 * @param  None
 * @retval None
 */
void NMI_Handler(void)
{
	asm ("MOV		R0, #0\n\t"
 8091f2c:	f04f 0000 	mov.w	r0, #0
 8091f30:	4669      	mov	r1, sp
 8091f32:	f7f9 bf5d 	b.w	808bdf0 <PANIC_ReadStack>
 8091f36:	e7fe      	b.n	8091f36 <NMI_Handler+0xa>

08091f38 <HardFault_Handler>:
 * @param  None
 * @retval None
 */
void HardFault_Handler(void)
{
	asm ("MOV		R0, #1\n\t"
 8091f38:	f04f 0001 	mov.w	r0, #1
 8091f3c:	4669      	mov	r1, sp
 8091f3e:	f7f9 bf57 	b.w	808bdf0 <PANIC_ReadStack>
 8091f42:	e7fe      	b.n	8091f42 <HardFault_Handler+0xa>

08091f44 <MemManage_Handler>:
 * @param  None
 * @retval None
 */
void MemManage_Handler(void)
{
	asm ("MOV		R0, #2\n\t"
 8091f44:	f04f 0002 	mov.w	r0, #2
 8091f48:	4669      	mov	r1, sp
 8091f4a:	f7f9 bf51 	b.w	808bdf0 <PANIC_ReadStack>
 8091f4e:	e7fe      	b.n	8091f4e <MemManage_Handler+0xa>

08091f50 <BusFault_Handler>:
 * @param  None
 * @retval None
 */
void BusFault_Handler(void)
{
	asm ("MOV		R0, #3\n\t"
 8091f50:	f04f 0003 	mov.w	r0, #3
 8091f54:	4669      	mov	r1, sp
 8091f56:	f7f9 bf4b 	b.w	808bdf0 <PANIC_ReadStack>
 8091f5a:	e7fe      	b.n	8091f5a <BusFault_Handler+0xa>

08091f5c <UsageFault_Handler>:
 * @param  None
 * @retval None
 */
void UsageFault_Handler(void)
{
	asm ("MOV		R0, #4\n\t"
 8091f5c:	f04f 0004 	mov.w	r0, #4
 8091f60:	4669      	mov	r1, sp
 8091f62:	f7f9 bf45 	b.w	808bdf0 <PANIC_ReadStack>
 8091f66:	e7fe      	b.n	8091f66 <UsageFault_Handler+0xa>

08091f68 <DebugMon_Handler>:
 * @param  None
 * @retval None
 */
void DebugMon_Handler(void)
{
}
 8091f68:	4770      	bx	lr
 8091f6a:	bf00      	nop

08091f6c <SysTick_Handler>:
 * @param  None
 * @retval None
 */
void SysTick_Handler(void)
{
	HAL_IncTick();
 8091f6c:	f7f3 bc12 	b.w	8085794 <HAL_IncTick>

08091f70 <EXTI0_IRQHandler>:
 * @param  None
 * @retval None
 */
void EXTI0_IRQHandler(void)
{
	HAL_GPIO_EXTI_IRQHandler(WAKEUP_BUTTON_PIN);
 8091f70:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8091f74:	f7f4 ba98 	b.w	80864a8 <HAL_GPIO_EXTI_IRQHandler>

08091f78 <EXTI2_IRQHandler>:
 * @param  None
 * @retval None
 */
void EXTI2_IRQHandler(void)
{
	HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
 8091f78:	2004      	movs	r0, #4
 8091f7a:	f7f4 ba95 	b.w	80864a8 <HAL_GPIO_EXTI_IRQHandler>
 8091f7e:	bf00      	nop

08091f80 <EXTI9_5_IRQHandler>:
 * @retval None
 */
void EXTI9_5_IRQHandler(void)
{
	/* Interrupt handler shared between ACC GYRo DRDY and MAG DRDY interrupt */
	if (__HAL_GPIO_EXTI_GET_IT(ACC_GYRO_DRDY_PIN ) != RESET)
 8091f80:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8091f84:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8091f88:	695b      	ldr	r3, [r3, #20]
 8091f8a:	05db      	lsls	r3, r3, #23
 8091f8c:	d402      	bmi.n	8091f94 <EXTI9_5_IRQHandler+0x14>
	{
		HAL_GPIO_EXTI_IRQHandler(ACC_GYRO_DRDY_PIN );   /* SD detect event or touch screen interrupt */
	}
	else
	{     /* User button event or Touch screen interrupt */
		HAL_GPIO_EXTI_IRQHandler(MAG_DRDY_PIN);
 8091f8e:	2040      	movs	r0, #64	; 0x40
 8091f90:	f7f4 ba8a 	b.w	80864a8 <HAL_GPIO_EXTI_IRQHandler>
		HAL_GPIO_EXTI_IRQHandler(ACC_GYRO_DRDY_PIN );   /* SD detect event or touch screen interrupt */
 8091f94:	f44f 7080 	mov.w	r0, #256	; 0x100
 8091f98:	f7f4 ba86 	b.w	80864a8 <HAL_GPIO_EXTI_IRQHandler>

08091f9c <EXTI15_10_IRQHandler>:
 * @retval None
 */
void EXTI15_10_IRQHandler(void)
{
	/* Interrupt handler shared between SD_DETECT pin, USER_KEY button and touch screen interrupt */
	if (__HAL_GPIO_EXTI_GET_IT(KEY_BUTTON_PIN) == RESET)
 8091f9c:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8091fa0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8091fa4:	695b      	ldr	r3, [r3, #20]
 8091fa6:	051b      	lsls	r3, r3, #20
 8091fa8:	d503      	bpl.n	8091fb2 <EXTI15_10_IRQHandler+0x16>
	{
		HAL_GPIO_EXTI_IRQHandler(SD_DETECT_PIN | TS_INT_PIN | AUDIO_IN_INT_GPIO_PIN);   /* SD detect event or touch screen interrupt */
	}
	else
	{     /* User button event or Touch screen interrupt */
		HAL_GPIO_EXTI_IRQHandler(KEY_BUTTON_PIN);
 8091faa:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8091fae:	f7f4 ba7b 	b.w	80864a8 <HAL_GPIO_EXTI_IRQHandler>
		HAL_GPIO_EXTI_IRQHandler(SD_DETECT_PIN | TS_INT_PIN | AUDIO_IN_INT_GPIO_PIN);   /* SD detect event or touch screen interrupt */
 8091fb2:	f44f 4020 	mov.w	r0, #40960	; 0xa000
 8091fb6:	f7f4 ba77 	b.w	80864a8 <HAL_GPIO_EXTI_IRQHandler>
 8091fba:	bf00      	nop

08091fbc <DMA2_Stream7_IRQHandler>:
 * @param None
 * @retval None
 */
void AUDIO_IN_SAIx_DMAx_IRQHandler(void)
{
	HAL_DMA_IRQHandler(haudio_in_sai.hdmarx);
 8091fbc:	f24b 43a8 	movw	r3, #46248	; 0xb4a8
 8091fc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8091fc4:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8091fc6:	f7f3 bdfd 	b.w	8085bc4 <HAL_DMA_IRQHandler>
 8091fca:	bf00      	nop

08091fcc <DMA2_Stream0_IRQHandler>:
 * @brief  Handles SDRAM DMA transfer interrupt request.
 * @retval None
 */
void BSP_SDRAM_DMA_IRQHandler(void)
{
	HAL_DMA_IRQHandler(sdramHandle.hdma);
 8091fcc:	f64d 03c4 	movw	r3, #55492	; 0xd8c4
 8091fd0:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8091fd4:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8091fd6:	f7f3 bdf5 	b.w	8085bc4 <HAL_DMA_IRQHandler>
 8091fda:	bf00      	nop

08091fdc <DMA2_Stream1_IRQHandler>:
 * @brief  DMA interrupt handler.
 * @param  None
 * @retval None
 */
void DMA2_Stream1_IRQHandler(void)
{
 8091fdc:	e7fe      	b.n	8091fdc <DMA2_Stream1_IRQHandler>
 8091fde:	bf00      	nop

08091fe0 <DMA2_Stream4_IRQHandler>:
 * @param  None
 * @retval None
 */
void AUDIO_OUT_SAIx_DMAx_IRQHandler(void)
{
	HAL_DMA_IRQHandler(haudio_out_sai.hdmatx);
 8091fe0:	f24b 532c 	movw	r3, #46380	; 0xb52c
 8091fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8091fe8:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8091fea:	f7f3 bdeb 	b.w	8085bc4 <HAL_DMA_IRQHandler>
 8091fee:	bf00      	nop

08091ff0 <DCMI_IRQHandler>:
 * @brief  DCMI interrupt handler.
 * @param  None
 * @retval None
 */
void DCMI_IRQHandler(void)
{
 8091ff0:	e7fe      	b.n	8091ff0 <DCMI_IRQHandler>
 8091ff2:	bf00      	nop

08091ff4 <DMA2D_IRQHandler>:
 * @param  None
 * @retval None
 */
void DMA2D_IRQHandler(void)
{
	BSP_LCD_DMA2D_IRQHandler();
 8091ff4:	f7f2 b916 	b.w	8084224 <BSP_LCD_DMA2D_IRQHandler>

08091ff8 <USART1_IRQHandler>:
 * @param  None
 * @retval None
 */
void USART1_IRQHandler(void)
{
	BSP_STDIO_IRQHandler();
 8091ff8:	f7f3 b9d4 	b.w	80853a4 <BSP_STDIO_IRQHandler>

08091ffc <USART6_IRQHandler>:
 * @param  None
 * @retval None
 */
void USART6_IRQHandler(void)
{
	BSP_WIFI_IRQHandler();
 8091ffc:	f7f3 bbac 	b.w	8085758 <BSP_WIFI_IRQHandler>

08092000 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8092000:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8092004:	f44f 5360 	mov.w	r3, #14336	; 0x3800

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8092008:	f64f 71ff 	movw	r1, #65535	; 0xffff
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 809200c:	f2ce 0200 	movt	r2, #57344	; 0xe000
  RCC->CR |= (uint32_t)0x00000001;
 8092010:	f2c4 0302 	movt	r3, #16386	; 0x4002
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8092014:	f6cf 61f6 	movt	r1, #65270	; 0xfef6
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8092018:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
 809201c:	f440 0070 	orr.w	r0, r0, #15728640	; 0xf00000
{
 8092020:	b470      	push	{r4, r5, r6}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8092022:	f8c2 0088 	str.w	r0, [r2, #136]	; 0x88
  RCC->CFGR = 0x00000000;
 8092026:	2400      	movs	r4, #0
  RCC->CR |= (uint32_t)0x00000001;
 8092028:	6818      	ldr	r0, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 809202a:	f243 0510 	movw	r5, #12304	; 0x3010

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 809202e:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
  RCC->CR |= (uint32_t)0x00000001;
 8092032:	f040 0001 	orr.w	r0, r0, #1
  RCC->PLLCFGR = 0x24003010;
 8092036:	f2c2 4500 	movt	r5, #9216	; 0x2400
  RCC->CR |= (uint32_t)0x00000001;
 809203a:	6018      	str	r0, [r3, #0]
  RCC->CFGR = 0x00000000;
 809203c:	609c      	str	r4, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 809203e:	6818      	ldr	r0, [r3, #0]
 8092040:	4001      	ands	r1, r0
 8092042:	6019      	str	r1, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 8092044:	605d      	str	r5, [r3, #4]
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8092046:	6819      	ldr	r1, [r3, #0]
 8092048:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 809204c:	6019      	str	r1, [r3, #0]
  RCC->CIR = 0x00000000;
 809204e:	60dc      	str	r4, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8092050:	6096      	str	r6, [r2, #8]
#endif
}
 8092052:	bc70      	pop	{r4, r5, r6}
 8092054:	4770      	bx	lr
 8092056:	bf00      	nop

08092058 <__errno>:
 8092058:	4b01      	ldr	r3, [pc, #4]	; (8092060 <__errno+0x8>)
 809205a:	6818      	ldr	r0, [r3, #0]
 809205c:	4770      	bx	lr
 809205e:	bf00      	nop
 8092060:	2000b378 	.word	0x2000b378

08092064 <__libc_init_array>:
 8092064:	b570      	push	{r4, r5, r6, lr}
 8092066:	4e0d      	ldr	r6, [pc, #52]	; (809209c <__libc_init_array+0x38>)
 8092068:	4c0d      	ldr	r4, [pc, #52]	; (80920a0 <__libc_init_array+0x3c>)
 809206a:	1ba4      	subs	r4, r4, r6
 809206c:	10a4      	asrs	r4, r4, #2
 809206e:	2500      	movs	r5, #0
 8092070:	42a5      	cmp	r5, r4
 8092072:	d109      	bne.n	8092088 <__libc_init_array+0x24>
 8092074:	4e0b      	ldr	r6, [pc, #44]	; (80920a4 <__libc_init_array+0x40>)
 8092076:	4c0c      	ldr	r4, [pc, #48]	; (80920a8 <__libc_init_array+0x44>)
 8092078:	f000 fc28 	bl	80928cc <_init>
 809207c:	1ba4      	subs	r4, r4, r6
 809207e:	10a4      	asrs	r4, r4, #2
 8092080:	2500      	movs	r5, #0
 8092082:	42a5      	cmp	r5, r4
 8092084:	d105      	bne.n	8092092 <__libc_init_array+0x2e>
 8092086:	bd70      	pop	{r4, r5, r6, pc}
 8092088:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 809208c:	4798      	blx	r3
 809208e:	3501      	adds	r5, #1
 8092090:	e7ee      	b.n	8092070 <__libc_init_array+0xc>
 8092092:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8092096:	4798      	blx	r3
 8092098:	3501      	adds	r5, #1
 809209a:	e7f2      	b.n	8092082 <__libc_init_array+0x1e>
 809209c:	08099db0 	.word	0x08099db0
 80920a0:	08099db0 	.word	0x08099db0
 80920a4:	08099db0 	.word	0x08099db0
 80920a8:	08099db4 	.word	0x08099db4

080920ac <memcpy>:
 80920ac:	b510      	push	{r4, lr}
 80920ae:	1e43      	subs	r3, r0, #1
 80920b0:	440a      	add	r2, r1
 80920b2:	4291      	cmp	r1, r2
 80920b4:	d100      	bne.n	80920b8 <memcpy+0xc>
 80920b6:	bd10      	pop	{r4, pc}
 80920b8:	f811 4b01 	ldrb.w	r4, [r1], #1
 80920bc:	f803 4f01 	strb.w	r4, [r3, #1]!
 80920c0:	e7f7      	b.n	80920b2 <memcpy+0x6>

080920c2 <memset>:
 80920c2:	4402      	add	r2, r0
 80920c4:	4603      	mov	r3, r0
 80920c6:	4293      	cmp	r3, r2
 80920c8:	d100      	bne.n	80920cc <memset+0xa>
 80920ca:	4770      	bx	lr
 80920cc:	f803 1b01 	strb.w	r1, [r3], #1
 80920d0:	e7f9      	b.n	80920c6 <memset+0x4>
	...

080920d4 <siprintf>:
 80920d4:	b40e      	push	{r1, r2, r3}
 80920d6:	b500      	push	{lr}
 80920d8:	b09c      	sub	sp, #112	; 0x70
 80920da:	ab1d      	add	r3, sp, #116	; 0x74
 80920dc:	9002      	str	r0, [sp, #8]
 80920de:	9006      	str	r0, [sp, #24]
 80920e0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80920e4:	4809      	ldr	r0, [pc, #36]	; (809210c <siprintf+0x38>)
 80920e6:	9107      	str	r1, [sp, #28]
 80920e8:	9104      	str	r1, [sp, #16]
 80920ea:	4909      	ldr	r1, [pc, #36]	; (8092110 <siprintf+0x3c>)
 80920ec:	f853 2b04 	ldr.w	r2, [r3], #4
 80920f0:	9105      	str	r1, [sp, #20]
 80920f2:	6800      	ldr	r0, [r0, #0]
 80920f4:	9301      	str	r3, [sp, #4]
 80920f6:	a902      	add	r1, sp, #8
 80920f8:	f000 f90e 	bl	8092318 <_svfiprintf_r>
 80920fc:	9b02      	ldr	r3, [sp, #8]
 80920fe:	2200      	movs	r2, #0
 8092100:	701a      	strb	r2, [r3, #0]
 8092102:	b01c      	add	sp, #112	; 0x70
 8092104:	f85d eb04 	ldr.w	lr, [sp], #4
 8092108:	b003      	add	sp, #12
 809210a:	4770      	bx	lr
 809210c:	2000b378 	.word	0x2000b378
 8092110:	ffff0208 	.word	0xffff0208

08092114 <_free_r>:
 8092114:	b538      	push	{r3, r4, r5, lr}
 8092116:	4605      	mov	r5, r0
 8092118:	2900      	cmp	r1, #0
 809211a:	d045      	beq.n	80921a8 <_free_r+0x94>
 809211c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8092120:	1f0c      	subs	r4, r1, #4
 8092122:	2b00      	cmp	r3, #0
 8092124:	bfb8      	it	lt
 8092126:	18e4      	addlt	r4, r4, r3
 8092128:	f000 fb9f 	bl	809286a <__malloc_lock>
 809212c:	4a1f      	ldr	r2, [pc, #124]	; (80921ac <_free_r+0x98>)
 809212e:	6813      	ldr	r3, [r2, #0]
 8092130:	4610      	mov	r0, r2
 8092132:	b933      	cbnz	r3, 8092142 <_free_r+0x2e>
 8092134:	6063      	str	r3, [r4, #4]
 8092136:	6014      	str	r4, [r2, #0]
 8092138:	4628      	mov	r0, r5
 809213a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 809213e:	f000 bb95 	b.w	809286c <__malloc_unlock>
 8092142:	42a3      	cmp	r3, r4
 8092144:	d90c      	bls.n	8092160 <_free_r+0x4c>
 8092146:	6821      	ldr	r1, [r4, #0]
 8092148:	1862      	adds	r2, r4, r1
 809214a:	4293      	cmp	r3, r2
 809214c:	bf04      	itt	eq
 809214e:	681a      	ldreq	r2, [r3, #0]
 8092150:	685b      	ldreq	r3, [r3, #4]
 8092152:	6063      	str	r3, [r4, #4]
 8092154:	bf04      	itt	eq
 8092156:	1852      	addeq	r2, r2, r1
 8092158:	6022      	streq	r2, [r4, #0]
 809215a:	6004      	str	r4, [r0, #0]
 809215c:	e7ec      	b.n	8092138 <_free_r+0x24>
 809215e:	4613      	mov	r3, r2
 8092160:	685a      	ldr	r2, [r3, #4]
 8092162:	b10a      	cbz	r2, 8092168 <_free_r+0x54>
 8092164:	42a2      	cmp	r2, r4
 8092166:	d9fa      	bls.n	809215e <_free_r+0x4a>
 8092168:	6819      	ldr	r1, [r3, #0]
 809216a:	1858      	adds	r0, r3, r1
 809216c:	42a0      	cmp	r0, r4
 809216e:	d10b      	bne.n	8092188 <_free_r+0x74>
 8092170:	6820      	ldr	r0, [r4, #0]
 8092172:	4401      	add	r1, r0
 8092174:	1858      	adds	r0, r3, r1
 8092176:	4282      	cmp	r2, r0
 8092178:	6019      	str	r1, [r3, #0]
 809217a:	d1dd      	bne.n	8092138 <_free_r+0x24>
 809217c:	6810      	ldr	r0, [r2, #0]
 809217e:	6852      	ldr	r2, [r2, #4]
 8092180:	605a      	str	r2, [r3, #4]
 8092182:	4401      	add	r1, r0
 8092184:	6019      	str	r1, [r3, #0]
 8092186:	e7d7      	b.n	8092138 <_free_r+0x24>
 8092188:	d902      	bls.n	8092190 <_free_r+0x7c>
 809218a:	230c      	movs	r3, #12
 809218c:	602b      	str	r3, [r5, #0]
 809218e:	e7d3      	b.n	8092138 <_free_r+0x24>
 8092190:	6820      	ldr	r0, [r4, #0]
 8092192:	1821      	adds	r1, r4, r0
 8092194:	428a      	cmp	r2, r1
 8092196:	bf04      	itt	eq
 8092198:	6811      	ldreq	r1, [r2, #0]
 809219a:	6852      	ldreq	r2, [r2, #4]
 809219c:	6062      	str	r2, [r4, #4]
 809219e:	bf04      	itt	eq
 80921a0:	1809      	addeq	r1, r1, r0
 80921a2:	6021      	streq	r1, [r4, #0]
 80921a4:	605c      	str	r4, [r3, #4]
 80921a6:	e7c7      	b.n	8092138 <_free_r+0x24>
 80921a8:	bd38      	pop	{r3, r4, r5, pc}
 80921aa:	bf00      	nop
 80921ac:	2002d644 	.word	0x2002d644

080921b0 <_malloc_r>:
 80921b0:	b570      	push	{r4, r5, r6, lr}
 80921b2:	1ccd      	adds	r5, r1, #3
 80921b4:	f025 0503 	bic.w	r5, r5, #3
 80921b8:	3508      	adds	r5, #8
 80921ba:	2d0c      	cmp	r5, #12
 80921bc:	bf38      	it	cc
 80921be:	250c      	movcc	r5, #12
 80921c0:	2d00      	cmp	r5, #0
 80921c2:	4606      	mov	r6, r0
 80921c4:	db01      	blt.n	80921ca <_malloc_r+0x1a>
 80921c6:	42a9      	cmp	r1, r5
 80921c8:	d903      	bls.n	80921d2 <_malloc_r+0x22>
 80921ca:	230c      	movs	r3, #12
 80921cc:	6033      	str	r3, [r6, #0]
 80921ce:	2000      	movs	r0, #0
 80921d0:	bd70      	pop	{r4, r5, r6, pc}
 80921d2:	f000 fb4a 	bl	809286a <__malloc_lock>
 80921d6:	4a21      	ldr	r2, [pc, #132]	; (809225c <_malloc_r+0xac>)
 80921d8:	6814      	ldr	r4, [r2, #0]
 80921da:	4621      	mov	r1, r4
 80921dc:	b991      	cbnz	r1, 8092204 <_malloc_r+0x54>
 80921de:	4c20      	ldr	r4, [pc, #128]	; (8092260 <_malloc_r+0xb0>)
 80921e0:	6823      	ldr	r3, [r4, #0]
 80921e2:	b91b      	cbnz	r3, 80921ec <_malloc_r+0x3c>
 80921e4:	4630      	mov	r0, r6
 80921e6:	f000 fb17 	bl	8092818 <_sbrk_r>
 80921ea:	6020      	str	r0, [r4, #0]
 80921ec:	4629      	mov	r1, r5
 80921ee:	4630      	mov	r0, r6
 80921f0:	f000 fb12 	bl	8092818 <_sbrk_r>
 80921f4:	1c43      	adds	r3, r0, #1
 80921f6:	d124      	bne.n	8092242 <_malloc_r+0x92>
 80921f8:	230c      	movs	r3, #12
 80921fa:	6033      	str	r3, [r6, #0]
 80921fc:	4630      	mov	r0, r6
 80921fe:	f000 fb35 	bl	809286c <__malloc_unlock>
 8092202:	e7e4      	b.n	80921ce <_malloc_r+0x1e>
 8092204:	680b      	ldr	r3, [r1, #0]
 8092206:	1b5b      	subs	r3, r3, r5
 8092208:	d418      	bmi.n	809223c <_malloc_r+0x8c>
 809220a:	2b0b      	cmp	r3, #11
 809220c:	d90f      	bls.n	809222e <_malloc_r+0x7e>
 809220e:	600b      	str	r3, [r1, #0]
 8092210:	50cd      	str	r5, [r1, r3]
 8092212:	18cc      	adds	r4, r1, r3
 8092214:	4630      	mov	r0, r6
 8092216:	f000 fb29 	bl	809286c <__malloc_unlock>
 809221a:	f104 000b 	add.w	r0, r4, #11
 809221e:	1d23      	adds	r3, r4, #4
 8092220:	f020 0007 	bic.w	r0, r0, #7
 8092224:	1ac3      	subs	r3, r0, r3
 8092226:	d0d3      	beq.n	80921d0 <_malloc_r+0x20>
 8092228:	425a      	negs	r2, r3
 809222a:	50e2      	str	r2, [r4, r3]
 809222c:	e7d0      	b.n	80921d0 <_malloc_r+0x20>
 809222e:	428c      	cmp	r4, r1
 8092230:	684b      	ldr	r3, [r1, #4]
 8092232:	bf16      	itet	ne
 8092234:	6063      	strne	r3, [r4, #4]
 8092236:	6013      	streq	r3, [r2, #0]
 8092238:	460c      	movne	r4, r1
 809223a:	e7eb      	b.n	8092214 <_malloc_r+0x64>
 809223c:	460c      	mov	r4, r1
 809223e:	6849      	ldr	r1, [r1, #4]
 8092240:	e7cc      	b.n	80921dc <_malloc_r+0x2c>
 8092242:	1cc4      	adds	r4, r0, #3
 8092244:	f024 0403 	bic.w	r4, r4, #3
 8092248:	42a0      	cmp	r0, r4
 809224a:	d005      	beq.n	8092258 <_malloc_r+0xa8>
 809224c:	1a21      	subs	r1, r4, r0
 809224e:	4630      	mov	r0, r6
 8092250:	f000 fae2 	bl	8092818 <_sbrk_r>
 8092254:	3001      	adds	r0, #1
 8092256:	d0cf      	beq.n	80921f8 <_malloc_r+0x48>
 8092258:	6025      	str	r5, [r4, #0]
 809225a:	e7db      	b.n	8092214 <_malloc_r+0x64>
 809225c:	2002d644 	.word	0x2002d644
 8092260:	2002d648 	.word	0x2002d648

08092264 <__ssputs_r>:
 8092264:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8092268:	688e      	ldr	r6, [r1, #8]
 809226a:	429e      	cmp	r6, r3
 809226c:	4682      	mov	sl, r0
 809226e:	460c      	mov	r4, r1
 8092270:	4690      	mov	r8, r2
 8092272:	4699      	mov	r9, r3
 8092274:	d837      	bhi.n	80922e6 <__ssputs_r+0x82>
 8092276:	898a      	ldrh	r2, [r1, #12]
 8092278:	f412 6f90 	tst.w	r2, #1152	; 0x480
 809227c:	d031      	beq.n	80922e2 <__ssputs_r+0x7e>
 809227e:	6825      	ldr	r5, [r4, #0]
 8092280:	6909      	ldr	r1, [r1, #16]
 8092282:	1a6f      	subs	r7, r5, r1
 8092284:	6965      	ldr	r5, [r4, #20]
 8092286:	2302      	movs	r3, #2
 8092288:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 809228c:	fb95 f5f3 	sdiv	r5, r5, r3
 8092290:	f109 0301 	add.w	r3, r9, #1
 8092294:	443b      	add	r3, r7
 8092296:	429d      	cmp	r5, r3
 8092298:	bf38      	it	cc
 809229a:	461d      	movcc	r5, r3
 809229c:	0553      	lsls	r3, r2, #21
 809229e:	d530      	bpl.n	8092302 <__ssputs_r+0x9e>
 80922a0:	4629      	mov	r1, r5
 80922a2:	f7ff ff85 	bl	80921b0 <_malloc_r>
 80922a6:	4606      	mov	r6, r0
 80922a8:	b950      	cbnz	r0, 80922c0 <__ssputs_r+0x5c>
 80922aa:	230c      	movs	r3, #12
 80922ac:	f8ca 3000 	str.w	r3, [sl]
 80922b0:	89a3      	ldrh	r3, [r4, #12]
 80922b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80922b6:	81a3      	strh	r3, [r4, #12]
 80922b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80922bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80922c0:	463a      	mov	r2, r7
 80922c2:	6921      	ldr	r1, [r4, #16]
 80922c4:	f7ff fef2 	bl	80920ac <memcpy>
 80922c8:	89a3      	ldrh	r3, [r4, #12]
 80922ca:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80922ce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80922d2:	81a3      	strh	r3, [r4, #12]
 80922d4:	6126      	str	r6, [r4, #16]
 80922d6:	6165      	str	r5, [r4, #20]
 80922d8:	443e      	add	r6, r7
 80922da:	1bed      	subs	r5, r5, r7
 80922dc:	6026      	str	r6, [r4, #0]
 80922de:	60a5      	str	r5, [r4, #8]
 80922e0:	464e      	mov	r6, r9
 80922e2:	454e      	cmp	r6, r9
 80922e4:	d900      	bls.n	80922e8 <__ssputs_r+0x84>
 80922e6:	464e      	mov	r6, r9
 80922e8:	4632      	mov	r2, r6
 80922ea:	4641      	mov	r1, r8
 80922ec:	6820      	ldr	r0, [r4, #0]
 80922ee:	f000 faa3 	bl	8092838 <memmove>
 80922f2:	68a3      	ldr	r3, [r4, #8]
 80922f4:	1b9b      	subs	r3, r3, r6
 80922f6:	60a3      	str	r3, [r4, #8]
 80922f8:	6823      	ldr	r3, [r4, #0]
 80922fa:	441e      	add	r6, r3
 80922fc:	6026      	str	r6, [r4, #0]
 80922fe:	2000      	movs	r0, #0
 8092300:	e7dc      	b.n	80922bc <__ssputs_r+0x58>
 8092302:	462a      	mov	r2, r5
 8092304:	f000 fab3 	bl	809286e <_realloc_r>
 8092308:	4606      	mov	r6, r0
 809230a:	2800      	cmp	r0, #0
 809230c:	d1e2      	bne.n	80922d4 <__ssputs_r+0x70>
 809230e:	6921      	ldr	r1, [r4, #16]
 8092310:	4650      	mov	r0, sl
 8092312:	f7ff feff 	bl	8092114 <_free_r>
 8092316:	e7c8      	b.n	80922aa <__ssputs_r+0x46>

08092318 <_svfiprintf_r>:
 8092318:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 809231c:	461d      	mov	r5, r3
 809231e:	898b      	ldrh	r3, [r1, #12]
 8092320:	061f      	lsls	r7, r3, #24
 8092322:	b09d      	sub	sp, #116	; 0x74
 8092324:	4680      	mov	r8, r0
 8092326:	460c      	mov	r4, r1
 8092328:	4616      	mov	r6, r2
 809232a:	d50f      	bpl.n	809234c <_svfiprintf_r+0x34>
 809232c:	690b      	ldr	r3, [r1, #16]
 809232e:	b96b      	cbnz	r3, 809234c <_svfiprintf_r+0x34>
 8092330:	2140      	movs	r1, #64	; 0x40
 8092332:	f7ff ff3d 	bl	80921b0 <_malloc_r>
 8092336:	6020      	str	r0, [r4, #0]
 8092338:	6120      	str	r0, [r4, #16]
 809233a:	b928      	cbnz	r0, 8092348 <_svfiprintf_r+0x30>
 809233c:	230c      	movs	r3, #12
 809233e:	f8c8 3000 	str.w	r3, [r8]
 8092342:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8092346:	e0c8      	b.n	80924da <_svfiprintf_r+0x1c2>
 8092348:	2340      	movs	r3, #64	; 0x40
 809234a:	6163      	str	r3, [r4, #20]
 809234c:	2300      	movs	r3, #0
 809234e:	9309      	str	r3, [sp, #36]	; 0x24
 8092350:	2320      	movs	r3, #32
 8092352:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8092356:	2330      	movs	r3, #48	; 0x30
 8092358:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 809235c:	9503      	str	r5, [sp, #12]
 809235e:	f04f 0b01 	mov.w	fp, #1
 8092362:	4637      	mov	r7, r6
 8092364:	463d      	mov	r5, r7
 8092366:	f815 3b01 	ldrb.w	r3, [r5], #1
 809236a:	b10b      	cbz	r3, 8092370 <_svfiprintf_r+0x58>
 809236c:	2b25      	cmp	r3, #37	; 0x25
 809236e:	d13e      	bne.n	80923ee <_svfiprintf_r+0xd6>
 8092370:	ebb7 0a06 	subs.w	sl, r7, r6
 8092374:	d00b      	beq.n	809238e <_svfiprintf_r+0x76>
 8092376:	4653      	mov	r3, sl
 8092378:	4632      	mov	r2, r6
 809237a:	4621      	mov	r1, r4
 809237c:	4640      	mov	r0, r8
 809237e:	f7ff ff71 	bl	8092264 <__ssputs_r>
 8092382:	3001      	adds	r0, #1
 8092384:	f000 80a4 	beq.w	80924d0 <_svfiprintf_r+0x1b8>
 8092388:	9b09      	ldr	r3, [sp, #36]	; 0x24
 809238a:	4453      	add	r3, sl
 809238c:	9309      	str	r3, [sp, #36]	; 0x24
 809238e:	783b      	ldrb	r3, [r7, #0]
 8092390:	2b00      	cmp	r3, #0
 8092392:	f000 809d 	beq.w	80924d0 <_svfiprintf_r+0x1b8>
 8092396:	2300      	movs	r3, #0
 8092398:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 809239c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80923a0:	9304      	str	r3, [sp, #16]
 80923a2:	9307      	str	r3, [sp, #28]
 80923a4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80923a8:	931a      	str	r3, [sp, #104]	; 0x68
 80923aa:	462f      	mov	r7, r5
 80923ac:	2205      	movs	r2, #5
 80923ae:	f817 1b01 	ldrb.w	r1, [r7], #1
 80923b2:	4850      	ldr	r0, [pc, #320]	; (80924f4 <_svfiprintf_r+0x1dc>)
 80923b4:	f7ed fe4c 	bl	8080050 <memchr>
 80923b8:	9b04      	ldr	r3, [sp, #16]
 80923ba:	b9d0      	cbnz	r0, 80923f2 <_svfiprintf_r+0xda>
 80923bc:	06d9      	lsls	r1, r3, #27
 80923be:	bf44      	itt	mi
 80923c0:	2220      	movmi	r2, #32
 80923c2:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80923c6:	071a      	lsls	r2, r3, #28
 80923c8:	bf44      	itt	mi
 80923ca:	222b      	movmi	r2, #43	; 0x2b
 80923cc:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80923d0:	782a      	ldrb	r2, [r5, #0]
 80923d2:	2a2a      	cmp	r2, #42	; 0x2a
 80923d4:	d015      	beq.n	8092402 <_svfiprintf_r+0xea>
 80923d6:	9a07      	ldr	r2, [sp, #28]
 80923d8:	462f      	mov	r7, r5
 80923da:	2000      	movs	r0, #0
 80923dc:	250a      	movs	r5, #10
 80923de:	4639      	mov	r1, r7
 80923e0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80923e4:	3b30      	subs	r3, #48	; 0x30
 80923e6:	2b09      	cmp	r3, #9
 80923e8:	d94d      	bls.n	8092486 <_svfiprintf_r+0x16e>
 80923ea:	b1b8      	cbz	r0, 809241c <_svfiprintf_r+0x104>
 80923ec:	e00f      	b.n	809240e <_svfiprintf_r+0xf6>
 80923ee:	462f      	mov	r7, r5
 80923f0:	e7b8      	b.n	8092364 <_svfiprintf_r+0x4c>
 80923f2:	4a40      	ldr	r2, [pc, #256]	; (80924f4 <_svfiprintf_r+0x1dc>)
 80923f4:	1a80      	subs	r0, r0, r2
 80923f6:	fa0b f000 	lsl.w	r0, fp, r0
 80923fa:	4318      	orrs	r0, r3
 80923fc:	9004      	str	r0, [sp, #16]
 80923fe:	463d      	mov	r5, r7
 8092400:	e7d3      	b.n	80923aa <_svfiprintf_r+0x92>
 8092402:	9a03      	ldr	r2, [sp, #12]
 8092404:	1d11      	adds	r1, r2, #4
 8092406:	6812      	ldr	r2, [r2, #0]
 8092408:	9103      	str	r1, [sp, #12]
 809240a:	2a00      	cmp	r2, #0
 809240c:	db01      	blt.n	8092412 <_svfiprintf_r+0xfa>
 809240e:	9207      	str	r2, [sp, #28]
 8092410:	e004      	b.n	809241c <_svfiprintf_r+0x104>
 8092412:	4252      	negs	r2, r2
 8092414:	f043 0302 	orr.w	r3, r3, #2
 8092418:	9207      	str	r2, [sp, #28]
 809241a:	9304      	str	r3, [sp, #16]
 809241c:	783b      	ldrb	r3, [r7, #0]
 809241e:	2b2e      	cmp	r3, #46	; 0x2e
 8092420:	d10c      	bne.n	809243c <_svfiprintf_r+0x124>
 8092422:	787b      	ldrb	r3, [r7, #1]
 8092424:	2b2a      	cmp	r3, #42	; 0x2a
 8092426:	d133      	bne.n	8092490 <_svfiprintf_r+0x178>
 8092428:	9b03      	ldr	r3, [sp, #12]
 809242a:	1d1a      	adds	r2, r3, #4
 809242c:	681b      	ldr	r3, [r3, #0]
 809242e:	9203      	str	r2, [sp, #12]
 8092430:	2b00      	cmp	r3, #0
 8092432:	bfb8      	it	lt
 8092434:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8092438:	3702      	adds	r7, #2
 809243a:	9305      	str	r3, [sp, #20]
 809243c:	4d2e      	ldr	r5, [pc, #184]	; (80924f8 <_svfiprintf_r+0x1e0>)
 809243e:	7839      	ldrb	r1, [r7, #0]
 8092440:	2203      	movs	r2, #3
 8092442:	4628      	mov	r0, r5
 8092444:	f7ed fe04 	bl	8080050 <memchr>
 8092448:	b138      	cbz	r0, 809245a <_svfiprintf_r+0x142>
 809244a:	2340      	movs	r3, #64	; 0x40
 809244c:	1b40      	subs	r0, r0, r5
 809244e:	fa03 f000 	lsl.w	r0, r3, r0
 8092452:	9b04      	ldr	r3, [sp, #16]
 8092454:	4303      	orrs	r3, r0
 8092456:	3701      	adds	r7, #1
 8092458:	9304      	str	r3, [sp, #16]
 809245a:	7839      	ldrb	r1, [r7, #0]
 809245c:	4827      	ldr	r0, [pc, #156]	; (80924fc <_svfiprintf_r+0x1e4>)
 809245e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8092462:	2206      	movs	r2, #6
 8092464:	1c7e      	adds	r6, r7, #1
 8092466:	f7ed fdf3 	bl	8080050 <memchr>
 809246a:	2800      	cmp	r0, #0
 809246c:	d038      	beq.n	80924e0 <_svfiprintf_r+0x1c8>
 809246e:	4b24      	ldr	r3, [pc, #144]	; (8092500 <_svfiprintf_r+0x1e8>)
 8092470:	bb13      	cbnz	r3, 80924b8 <_svfiprintf_r+0x1a0>
 8092472:	9b03      	ldr	r3, [sp, #12]
 8092474:	3307      	adds	r3, #7
 8092476:	f023 0307 	bic.w	r3, r3, #7
 809247a:	3308      	adds	r3, #8
 809247c:	9303      	str	r3, [sp, #12]
 809247e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8092480:	444b      	add	r3, r9
 8092482:	9309      	str	r3, [sp, #36]	; 0x24
 8092484:	e76d      	b.n	8092362 <_svfiprintf_r+0x4a>
 8092486:	fb05 3202 	mla	r2, r5, r2, r3
 809248a:	2001      	movs	r0, #1
 809248c:	460f      	mov	r7, r1
 809248e:	e7a6      	b.n	80923de <_svfiprintf_r+0xc6>
 8092490:	2300      	movs	r3, #0
 8092492:	3701      	adds	r7, #1
 8092494:	9305      	str	r3, [sp, #20]
 8092496:	4619      	mov	r1, r3
 8092498:	250a      	movs	r5, #10
 809249a:	4638      	mov	r0, r7
 809249c:	f810 2b01 	ldrb.w	r2, [r0], #1
 80924a0:	3a30      	subs	r2, #48	; 0x30
 80924a2:	2a09      	cmp	r2, #9
 80924a4:	d903      	bls.n	80924ae <_svfiprintf_r+0x196>
 80924a6:	2b00      	cmp	r3, #0
 80924a8:	d0c8      	beq.n	809243c <_svfiprintf_r+0x124>
 80924aa:	9105      	str	r1, [sp, #20]
 80924ac:	e7c6      	b.n	809243c <_svfiprintf_r+0x124>
 80924ae:	fb05 2101 	mla	r1, r5, r1, r2
 80924b2:	2301      	movs	r3, #1
 80924b4:	4607      	mov	r7, r0
 80924b6:	e7f0      	b.n	809249a <_svfiprintf_r+0x182>
 80924b8:	ab03      	add	r3, sp, #12
 80924ba:	9300      	str	r3, [sp, #0]
 80924bc:	4622      	mov	r2, r4
 80924be:	4b11      	ldr	r3, [pc, #68]	; (8092504 <_svfiprintf_r+0x1ec>)
 80924c0:	a904      	add	r1, sp, #16
 80924c2:	4640      	mov	r0, r8
 80924c4:	f3af 8000 	nop.w
 80924c8:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 80924cc:	4681      	mov	r9, r0
 80924ce:	d1d6      	bne.n	809247e <_svfiprintf_r+0x166>
 80924d0:	89a3      	ldrh	r3, [r4, #12]
 80924d2:	065b      	lsls	r3, r3, #25
 80924d4:	f53f af35 	bmi.w	8092342 <_svfiprintf_r+0x2a>
 80924d8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80924da:	b01d      	add	sp, #116	; 0x74
 80924dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80924e0:	ab03      	add	r3, sp, #12
 80924e2:	9300      	str	r3, [sp, #0]
 80924e4:	4622      	mov	r2, r4
 80924e6:	4b07      	ldr	r3, [pc, #28]	; (8092504 <_svfiprintf_r+0x1ec>)
 80924e8:	a904      	add	r1, sp, #16
 80924ea:	4640      	mov	r0, r8
 80924ec:	f000 f882 	bl	80925f4 <_printf_i>
 80924f0:	e7ea      	b.n	80924c8 <_svfiprintf_r+0x1b0>
 80924f2:	bf00      	nop
 80924f4:	08099d14 	.word	0x08099d14
 80924f8:	08099d1a 	.word	0x08099d1a
 80924fc:	08099d1e 	.word	0x08099d1e
 8092500:	00000000 	.word	0x00000000
 8092504:	08092265 	.word	0x08092265

08092508 <_printf_common>:
 8092508:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 809250c:	4691      	mov	r9, r2
 809250e:	461f      	mov	r7, r3
 8092510:	688a      	ldr	r2, [r1, #8]
 8092512:	690b      	ldr	r3, [r1, #16]
 8092514:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8092518:	4293      	cmp	r3, r2
 809251a:	bfb8      	it	lt
 809251c:	4613      	movlt	r3, r2
 809251e:	f8c9 3000 	str.w	r3, [r9]
 8092522:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8092526:	4606      	mov	r6, r0
 8092528:	460c      	mov	r4, r1
 809252a:	b112      	cbz	r2, 8092532 <_printf_common+0x2a>
 809252c:	3301      	adds	r3, #1
 809252e:	f8c9 3000 	str.w	r3, [r9]
 8092532:	6823      	ldr	r3, [r4, #0]
 8092534:	0699      	lsls	r1, r3, #26
 8092536:	bf42      	ittt	mi
 8092538:	f8d9 3000 	ldrmi.w	r3, [r9]
 809253c:	3302      	addmi	r3, #2
 809253e:	f8c9 3000 	strmi.w	r3, [r9]
 8092542:	6825      	ldr	r5, [r4, #0]
 8092544:	f015 0506 	ands.w	r5, r5, #6
 8092548:	d107      	bne.n	809255a <_printf_common+0x52>
 809254a:	f104 0a19 	add.w	sl, r4, #25
 809254e:	68e3      	ldr	r3, [r4, #12]
 8092550:	f8d9 2000 	ldr.w	r2, [r9]
 8092554:	1a9b      	subs	r3, r3, r2
 8092556:	42ab      	cmp	r3, r5
 8092558:	dc28      	bgt.n	80925ac <_printf_common+0xa4>
 809255a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 809255e:	6822      	ldr	r2, [r4, #0]
 8092560:	3300      	adds	r3, #0
 8092562:	bf18      	it	ne
 8092564:	2301      	movne	r3, #1
 8092566:	0692      	lsls	r2, r2, #26
 8092568:	d42d      	bmi.n	80925c6 <_printf_common+0xbe>
 809256a:	f104 0243 	add.w	r2, r4, #67	; 0x43
 809256e:	4639      	mov	r1, r7
 8092570:	4630      	mov	r0, r6
 8092572:	47c0      	blx	r8
 8092574:	3001      	adds	r0, #1
 8092576:	d020      	beq.n	80925ba <_printf_common+0xb2>
 8092578:	6823      	ldr	r3, [r4, #0]
 809257a:	68e5      	ldr	r5, [r4, #12]
 809257c:	f8d9 2000 	ldr.w	r2, [r9]
 8092580:	f003 0306 	and.w	r3, r3, #6
 8092584:	2b04      	cmp	r3, #4
 8092586:	bf08      	it	eq
 8092588:	1aad      	subeq	r5, r5, r2
 809258a:	68a3      	ldr	r3, [r4, #8]
 809258c:	6922      	ldr	r2, [r4, #16]
 809258e:	bf0c      	ite	eq
 8092590:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8092594:	2500      	movne	r5, #0
 8092596:	4293      	cmp	r3, r2
 8092598:	bfc4      	itt	gt
 809259a:	1a9b      	subgt	r3, r3, r2
 809259c:	18ed      	addgt	r5, r5, r3
 809259e:	f04f 0900 	mov.w	r9, #0
 80925a2:	341a      	adds	r4, #26
 80925a4:	454d      	cmp	r5, r9
 80925a6:	d11a      	bne.n	80925de <_printf_common+0xd6>
 80925a8:	2000      	movs	r0, #0
 80925aa:	e008      	b.n	80925be <_printf_common+0xb6>
 80925ac:	2301      	movs	r3, #1
 80925ae:	4652      	mov	r2, sl
 80925b0:	4639      	mov	r1, r7
 80925b2:	4630      	mov	r0, r6
 80925b4:	47c0      	blx	r8
 80925b6:	3001      	adds	r0, #1
 80925b8:	d103      	bne.n	80925c2 <_printf_common+0xba>
 80925ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80925be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80925c2:	3501      	adds	r5, #1
 80925c4:	e7c3      	b.n	809254e <_printf_common+0x46>
 80925c6:	18e1      	adds	r1, r4, r3
 80925c8:	1c5a      	adds	r2, r3, #1
 80925ca:	2030      	movs	r0, #48	; 0x30
 80925cc:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 80925d0:	4422      	add	r2, r4
 80925d2:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80925d6:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80925da:	3302      	adds	r3, #2
 80925dc:	e7c5      	b.n	809256a <_printf_common+0x62>
 80925de:	2301      	movs	r3, #1
 80925e0:	4622      	mov	r2, r4
 80925e2:	4639      	mov	r1, r7
 80925e4:	4630      	mov	r0, r6
 80925e6:	47c0      	blx	r8
 80925e8:	3001      	adds	r0, #1
 80925ea:	d0e6      	beq.n	80925ba <_printf_common+0xb2>
 80925ec:	f109 0901 	add.w	r9, r9, #1
 80925f0:	e7d8      	b.n	80925a4 <_printf_common+0x9c>
	...

080925f4 <_printf_i>:
 80925f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80925f8:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 80925fc:	460c      	mov	r4, r1
 80925fe:	7e09      	ldrb	r1, [r1, #24]
 8092600:	b085      	sub	sp, #20
 8092602:	296e      	cmp	r1, #110	; 0x6e
 8092604:	4617      	mov	r7, r2
 8092606:	4606      	mov	r6, r0
 8092608:	4698      	mov	r8, r3
 809260a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 809260c:	f000 80b3 	beq.w	8092776 <_printf_i+0x182>
 8092610:	d822      	bhi.n	8092658 <_printf_i+0x64>
 8092612:	2963      	cmp	r1, #99	; 0x63
 8092614:	d036      	beq.n	8092684 <_printf_i+0x90>
 8092616:	d80a      	bhi.n	809262e <_printf_i+0x3a>
 8092618:	2900      	cmp	r1, #0
 809261a:	f000 80b9 	beq.w	8092790 <_printf_i+0x19c>
 809261e:	2958      	cmp	r1, #88	; 0x58
 8092620:	f000 8083 	beq.w	809272a <_printf_i+0x136>
 8092624:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8092628:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 809262c:	e032      	b.n	8092694 <_printf_i+0xa0>
 809262e:	2964      	cmp	r1, #100	; 0x64
 8092630:	d001      	beq.n	8092636 <_printf_i+0x42>
 8092632:	2969      	cmp	r1, #105	; 0x69
 8092634:	d1f6      	bne.n	8092624 <_printf_i+0x30>
 8092636:	6820      	ldr	r0, [r4, #0]
 8092638:	6813      	ldr	r3, [r2, #0]
 809263a:	0605      	lsls	r5, r0, #24
 809263c:	f103 0104 	add.w	r1, r3, #4
 8092640:	d52a      	bpl.n	8092698 <_printf_i+0xa4>
 8092642:	681b      	ldr	r3, [r3, #0]
 8092644:	6011      	str	r1, [r2, #0]
 8092646:	2b00      	cmp	r3, #0
 8092648:	da03      	bge.n	8092652 <_printf_i+0x5e>
 809264a:	222d      	movs	r2, #45	; 0x2d
 809264c:	425b      	negs	r3, r3
 809264e:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8092652:	486f      	ldr	r0, [pc, #444]	; (8092810 <_printf_i+0x21c>)
 8092654:	220a      	movs	r2, #10
 8092656:	e039      	b.n	80926cc <_printf_i+0xd8>
 8092658:	2973      	cmp	r1, #115	; 0x73
 809265a:	f000 809d 	beq.w	8092798 <_printf_i+0x1a4>
 809265e:	d808      	bhi.n	8092672 <_printf_i+0x7e>
 8092660:	296f      	cmp	r1, #111	; 0x6f
 8092662:	d020      	beq.n	80926a6 <_printf_i+0xb2>
 8092664:	2970      	cmp	r1, #112	; 0x70
 8092666:	d1dd      	bne.n	8092624 <_printf_i+0x30>
 8092668:	6823      	ldr	r3, [r4, #0]
 809266a:	f043 0320 	orr.w	r3, r3, #32
 809266e:	6023      	str	r3, [r4, #0]
 8092670:	e003      	b.n	809267a <_printf_i+0x86>
 8092672:	2975      	cmp	r1, #117	; 0x75
 8092674:	d017      	beq.n	80926a6 <_printf_i+0xb2>
 8092676:	2978      	cmp	r1, #120	; 0x78
 8092678:	d1d4      	bne.n	8092624 <_printf_i+0x30>
 809267a:	2378      	movs	r3, #120	; 0x78
 809267c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8092680:	4864      	ldr	r0, [pc, #400]	; (8092814 <_printf_i+0x220>)
 8092682:	e055      	b.n	8092730 <_printf_i+0x13c>
 8092684:	6813      	ldr	r3, [r2, #0]
 8092686:	1d19      	adds	r1, r3, #4
 8092688:	681b      	ldr	r3, [r3, #0]
 809268a:	6011      	str	r1, [r2, #0]
 809268c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8092690:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8092694:	2301      	movs	r3, #1
 8092696:	e08c      	b.n	80927b2 <_printf_i+0x1be>
 8092698:	681b      	ldr	r3, [r3, #0]
 809269a:	6011      	str	r1, [r2, #0]
 809269c:	f010 0f40 	tst.w	r0, #64	; 0x40
 80926a0:	bf18      	it	ne
 80926a2:	b21b      	sxthne	r3, r3
 80926a4:	e7cf      	b.n	8092646 <_printf_i+0x52>
 80926a6:	6813      	ldr	r3, [r2, #0]
 80926a8:	6825      	ldr	r5, [r4, #0]
 80926aa:	1d18      	adds	r0, r3, #4
 80926ac:	6010      	str	r0, [r2, #0]
 80926ae:	0628      	lsls	r0, r5, #24
 80926b0:	d501      	bpl.n	80926b6 <_printf_i+0xc2>
 80926b2:	681b      	ldr	r3, [r3, #0]
 80926b4:	e002      	b.n	80926bc <_printf_i+0xc8>
 80926b6:	0668      	lsls	r0, r5, #25
 80926b8:	d5fb      	bpl.n	80926b2 <_printf_i+0xbe>
 80926ba:	881b      	ldrh	r3, [r3, #0]
 80926bc:	4854      	ldr	r0, [pc, #336]	; (8092810 <_printf_i+0x21c>)
 80926be:	296f      	cmp	r1, #111	; 0x6f
 80926c0:	bf14      	ite	ne
 80926c2:	220a      	movne	r2, #10
 80926c4:	2208      	moveq	r2, #8
 80926c6:	2100      	movs	r1, #0
 80926c8:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80926cc:	6865      	ldr	r5, [r4, #4]
 80926ce:	60a5      	str	r5, [r4, #8]
 80926d0:	2d00      	cmp	r5, #0
 80926d2:	f2c0 8095 	blt.w	8092800 <_printf_i+0x20c>
 80926d6:	6821      	ldr	r1, [r4, #0]
 80926d8:	f021 0104 	bic.w	r1, r1, #4
 80926dc:	6021      	str	r1, [r4, #0]
 80926de:	2b00      	cmp	r3, #0
 80926e0:	d13d      	bne.n	809275e <_printf_i+0x16a>
 80926e2:	2d00      	cmp	r5, #0
 80926e4:	f040 808e 	bne.w	8092804 <_printf_i+0x210>
 80926e8:	4665      	mov	r5, ip
 80926ea:	2a08      	cmp	r2, #8
 80926ec:	d10b      	bne.n	8092706 <_printf_i+0x112>
 80926ee:	6823      	ldr	r3, [r4, #0]
 80926f0:	07db      	lsls	r3, r3, #31
 80926f2:	d508      	bpl.n	8092706 <_printf_i+0x112>
 80926f4:	6923      	ldr	r3, [r4, #16]
 80926f6:	6862      	ldr	r2, [r4, #4]
 80926f8:	429a      	cmp	r2, r3
 80926fa:	bfde      	ittt	le
 80926fc:	2330      	movle	r3, #48	; 0x30
 80926fe:	f805 3c01 	strble.w	r3, [r5, #-1]
 8092702:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 8092706:	ebac 0305 	sub.w	r3, ip, r5
 809270a:	6123      	str	r3, [r4, #16]
 809270c:	f8cd 8000 	str.w	r8, [sp]
 8092710:	463b      	mov	r3, r7
 8092712:	aa03      	add	r2, sp, #12
 8092714:	4621      	mov	r1, r4
 8092716:	4630      	mov	r0, r6
 8092718:	f7ff fef6 	bl	8092508 <_printf_common>
 809271c:	3001      	adds	r0, #1
 809271e:	d14d      	bne.n	80927bc <_printf_i+0x1c8>
 8092720:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8092724:	b005      	add	sp, #20
 8092726:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 809272a:	4839      	ldr	r0, [pc, #228]	; (8092810 <_printf_i+0x21c>)
 809272c:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 8092730:	6813      	ldr	r3, [r2, #0]
 8092732:	6821      	ldr	r1, [r4, #0]
 8092734:	1d1d      	adds	r5, r3, #4
 8092736:	681b      	ldr	r3, [r3, #0]
 8092738:	6015      	str	r5, [r2, #0]
 809273a:	060a      	lsls	r2, r1, #24
 809273c:	d50b      	bpl.n	8092756 <_printf_i+0x162>
 809273e:	07ca      	lsls	r2, r1, #31
 8092740:	bf44      	itt	mi
 8092742:	f041 0120 	orrmi.w	r1, r1, #32
 8092746:	6021      	strmi	r1, [r4, #0]
 8092748:	b91b      	cbnz	r3, 8092752 <_printf_i+0x15e>
 809274a:	6822      	ldr	r2, [r4, #0]
 809274c:	f022 0220 	bic.w	r2, r2, #32
 8092750:	6022      	str	r2, [r4, #0]
 8092752:	2210      	movs	r2, #16
 8092754:	e7b7      	b.n	80926c6 <_printf_i+0xd2>
 8092756:	064d      	lsls	r5, r1, #25
 8092758:	bf48      	it	mi
 809275a:	b29b      	uxthmi	r3, r3
 809275c:	e7ef      	b.n	809273e <_printf_i+0x14a>
 809275e:	4665      	mov	r5, ip
 8092760:	fbb3 f1f2 	udiv	r1, r3, r2
 8092764:	fb02 3311 	mls	r3, r2, r1, r3
 8092768:	5cc3      	ldrb	r3, [r0, r3]
 809276a:	f805 3d01 	strb.w	r3, [r5, #-1]!
 809276e:	460b      	mov	r3, r1
 8092770:	2900      	cmp	r1, #0
 8092772:	d1f5      	bne.n	8092760 <_printf_i+0x16c>
 8092774:	e7b9      	b.n	80926ea <_printf_i+0xf6>
 8092776:	6813      	ldr	r3, [r2, #0]
 8092778:	6825      	ldr	r5, [r4, #0]
 809277a:	6961      	ldr	r1, [r4, #20]
 809277c:	1d18      	adds	r0, r3, #4
 809277e:	6010      	str	r0, [r2, #0]
 8092780:	0628      	lsls	r0, r5, #24
 8092782:	681b      	ldr	r3, [r3, #0]
 8092784:	d501      	bpl.n	809278a <_printf_i+0x196>
 8092786:	6019      	str	r1, [r3, #0]
 8092788:	e002      	b.n	8092790 <_printf_i+0x19c>
 809278a:	066a      	lsls	r2, r5, #25
 809278c:	d5fb      	bpl.n	8092786 <_printf_i+0x192>
 809278e:	8019      	strh	r1, [r3, #0]
 8092790:	2300      	movs	r3, #0
 8092792:	6123      	str	r3, [r4, #16]
 8092794:	4665      	mov	r5, ip
 8092796:	e7b9      	b.n	809270c <_printf_i+0x118>
 8092798:	6813      	ldr	r3, [r2, #0]
 809279a:	1d19      	adds	r1, r3, #4
 809279c:	6011      	str	r1, [r2, #0]
 809279e:	681d      	ldr	r5, [r3, #0]
 80927a0:	6862      	ldr	r2, [r4, #4]
 80927a2:	2100      	movs	r1, #0
 80927a4:	4628      	mov	r0, r5
 80927a6:	f7ed fc53 	bl	8080050 <memchr>
 80927aa:	b108      	cbz	r0, 80927b0 <_printf_i+0x1bc>
 80927ac:	1b40      	subs	r0, r0, r5
 80927ae:	6060      	str	r0, [r4, #4]
 80927b0:	6863      	ldr	r3, [r4, #4]
 80927b2:	6123      	str	r3, [r4, #16]
 80927b4:	2300      	movs	r3, #0
 80927b6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80927ba:	e7a7      	b.n	809270c <_printf_i+0x118>
 80927bc:	6923      	ldr	r3, [r4, #16]
 80927be:	462a      	mov	r2, r5
 80927c0:	4639      	mov	r1, r7
 80927c2:	4630      	mov	r0, r6
 80927c4:	47c0      	blx	r8
 80927c6:	3001      	adds	r0, #1
 80927c8:	d0aa      	beq.n	8092720 <_printf_i+0x12c>
 80927ca:	6823      	ldr	r3, [r4, #0]
 80927cc:	079b      	lsls	r3, r3, #30
 80927ce:	d413      	bmi.n	80927f8 <_printf_i+0x204>
 80927d0:	68e0      	ldr	r0, [r4, #12]
 80927d2:	9b03      	ldr	r3, [sp, #12]
 80927d4:	4298      	cmp	r0, r3
 80927d6:	bfb8      	it	lt
 80927d8:	4618      	movlt	r0, r3
 80927da:	e7a3      	b.n	8092724 <_printf_i+0x130>
 80927dc:	2301      	movs	r3, #1
 80927de:	464a      	mov	r2, r9
 80927e0:	4639      	mov	r1, r7
 80927e2:	4630      	mov	r0, r6
 80927e4:	47c0      	blx	r8
 80927e6:	3001      	adds	r0, #1
 80927e8:	d09a      	beq.n	8092720 <_printf_i+0x12c>
 80927ea:	3501      	adds	r5, #1
 80927ec:	68e3      	ldr	r3, [r4, #12]
 80927ee:	9a03      	ldr	r2, [sp, #12]
 80927f0:	1a9b      	subs	r3, r3, r2
 80927f2:	42ab      	cmp	r3, r5
 80927f4:	dcf2      	bgt.n	80927dc <_printf_i+0x1e8>
 80927f6:	e7eb      	b.n	80927d0 <_printf_i+0x1dc>
 80927f8:	2500      	movs	r5, #0
 80927fa:	f104 0919 	add.w	r9, r4, #25
 80927fe:	e7f5      	b.n	80927ec <_printf_i+0x1f8>
 8092800:	2b00      	cmp	r3, #0
 8092802:	d1ac      	bne.n	809275e <_printf_i+0x16a>
 8092804:	7803      	ldrb	r3, [r0, #0]
 8092806:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 809280a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 809280e:	e76c      	b.n	80926ea <_printf_i+0xf6>
 8092810:	08099d25 	.word	0x08099d25
 8092814:	08099d36 	.word	0x08099d36

08092818 <_sbrk_r>:
 8092818:	b538      	push	{r3, r4, r5, lr}
 809281a:	4c06      	ldr	r4, [pc, #24]	; (8092834 <_sbrk_r+0x1c>)
 809281c:	2300      	movs	r3, #0
 809281e:	4605      	mov	r5, r0
 8092820:	4608      	mov	r0, r1
 8092822:	6023      	str	r3, [r4, #0]
 8092824:	f7f9 fbda 	bl	808bfdc <_sbrk>
 8092828:	1c43      	adds	r3, r0, #1
 809282a:	d102      	bne.n	8092832 <_sbrk_r+0x1a>
 809282c:	6823      	ldr	r3, [r4, #0]
 809282e:	b103      	cbz	r3, 8092832 <_sbrk_r+0x1a>
 8092830:	602b      	str	r3, [r5, #0]
 8092832:	bd38      	pop	{r3, r4, r5, pc}
 8092834:	2002f4f4 	.word	0x2002f4f4

08092838 <memmove>:
 8092838:	4288      	cmp	r0, r1
 809283a:	b510      	push	{r4, lr}
 809283c:	eb01 0302 	add.w	r3, r1, r2
 8092840:	d807      	bhi.n	8092852 <memmove+0x1a>
 8092842:	1e42      	subs	r2, r0, #1
 8092844:	4299      	cmp	r1, r3
 8092846:	d00a      	beq.n	809285e <memmove+0x26>
 8092848:	f811 4b01 	ldrb.w	r4, [r1], #1
 809284c:	f802 4f01 	strb.w	r4, [r2, #1]!
 8092850:	e7f8      	b.n	8092844 <memmove+0xc>
 8092852:	4283      	cmp	r3, r0
 8092854:	d9f5      	bls.n	8092842 <memmove+0xa>
 8092856:	1881      	adds	r1, r0, r2
 8092858:	1ad2      	subs	r2, r2, r3
 809285a:	42d3      	cmn	r3, r2
 809285c:	d100      	bne.n	8092860 <memmove+0x28>
 809285e:	bd10      	pop	{r4, pc}
 8092860:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8092864:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8092868:	e7f7      	b.n	809285a <memmove+0x22>

0809286a <__malloc_lock>:
 809286a:	4770      	bx	lr

0809286c <__malloc_unlock>:
 809286c:	4770      	bx	lr

0809286e <_realloc_r>:
 809286e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8092870:	4607      	mov	r7, r0
 8092872:	4614      	mov	r4, r2
 8092874:	460e      	mov	r6, r1
 8092876:	b921      	cbnz	r1, 8092882 <_realloc_r+0x14>
 8092878:	4611      	mov	r1, r2
 809287a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 809287e:	f7ff bc97 	b.w	80921b0 <_malloc_r>
 8092882:	b922      	cbnz	r2, 809288e <_realloc_r+0x20>
 8092884:	f7ff fc46 	bl	8092114 <_free_r>
 8092888:	4625      	mov	r5, r4
 809288a:	4628      	mov	r0, r5
 809288c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 809288e:	f000 f814 	bl	80928ba <_malloc_usable_size_r>
 8092892:	42a0      	cmp	r0, r4
 8092894:	d20f      	bcs.n	80928b6 <_realloc_r+0x48>
 8092896:	4621      	mov	r1, r4
 8092898:	4638      	mov	r0, r7
 809289a:	f7ff fc89 	bl	80921b0 <_malloc_r>
 809289e:	4605      	mov	r5, r0
 80928a0:	2800      	cmp	r0, #0
 80928a2:	d0f2      	beq.n	809288a <_realloc_r+0x1c>
 80928a4:	4631      	mov	r1, r6
 80928a6:	4622      	mov	r2, r4
 80928a8:	f7ff fc00 	bl	80920ac <memcpy>
 80928ac:	4631      	mov	r1, r6
 80928ae:	4638      	mov	r0, r7
 80928b0:	f7ff fc30 	bl	8092114 <_free_r>
 80928b4:	e7e9      	b.n	809288a <_realloc_r+0x1c>
 80928b6:	4635      	mov	r5, r6
 80928b8:	e7e7      	b.n	809288a <_realloc_r+0x1c>

080928ba <_malloc_usable_size_r>:
 80928ba:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80928be:	1f18      	subs	r0, r3, #4
 80928c0:	2b00      	cmp	r3, #0
 80928c2:	bfbc      	itt	lt
 80928c4:	580b      	ldrlt	r3, [r1, r0]
 80928c6:	18c0      	addlt	r0, r0, r3
 80928c8:	4770      	bx	lr
	...

080928cc <_init>:
 80928cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80928ce:	bf00      	nop
 80928d0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80928d2:	bc08      	pop	{r3}
 80928d4:	469e      	mov	lr, r3
 80928d6:	4770      	bx	lr

080928d8 <_fini>:
 80928d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80928da:	bf00      	nop
 80928dc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80928de:	bc08      	pop	{r3}
 80928e0:	469e      	mov	lr, r3
 80928e2:	4770      	bx	lr
